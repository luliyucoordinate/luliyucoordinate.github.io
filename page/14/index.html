<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 14 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/14/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="coordinate" rel="home"> coordinate </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-04-15-cpp2.0新特性3"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/15/2017-04-15-cpp2.0新特性3/">cpp2.0新特性(3)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/15/2017-04-15-cpp2.0新特性3/" class="article-date">
	  <time datetime="2017-04-14T16:00:00.000Z" itemprop="datePublished">四月 15, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h1><p>Rvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary copying and enable perfect forwarding.When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a separate allocation ,thus enabling move semantics<br>Lvalue:可以出现operator=左侧<br>Rvalue:只能出现operator=右侧<br>做以下测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello "</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">s1 + s2 = s2; <span class="comment">//竟然通过了编译</span></span><br><span class="line"><span class="built_in">string</span>() = <span class="string">"world"</span>;<span class="comment">//竟然可以对temp object赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 + s2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>这个是标准库设计上的不合理，temp object是一个Rvalue<br>C++ with its user-defined types has introduced some subtleties regarding modifiability and assignability that cause this definition to be incorrect</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x = foo();</span><br><span class="line"><span class="keyword">int</span> *p = &amp;foo(); <span class="comment">//ERROR 表达式必须为左值</span></span><br><span class="line">foo() = <span class="number">7</span>; <span class="comment">//ERROR 表达式必须是可修改的左值</span></span><br></pre></td></tr></table></figure>
<p>函数的返回值是一个Rvalue，对Rvalue取reference是不可以的</p>
<h2 id="Unperfect-Forwarding"><a href="#Unperfect-Forwarding" class="headerlink" title="Unperfect Forwarding"></a>Unperfect Forwarding</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"process"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"process(int&amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"forward(int &amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	process(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">process(a);<span class="comment">//process(int&amp;):0</span></span><br><span class="line">process(<span class="number">1</span>);<span class="comment">//process(int&amp;&amp;):1</span></span><br><span class="line">process(move(a));<span class="comment">//process(int&amp;&amp;):0</span></span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//forward(int&amp;&amp;):2,process(int&amp;):2</span></span><br><span class="line"><span class="comment">//rvalue经过forward()传给另一个函数却变为lvalue</span></span><br><span class="line"><span class="comment">//原因在于传递的过程中它变成了一个named object</span></span><br><span class="line">forward(move(a));<span class="comment">//forward(int&amp;&amp;):0,process(int&amp;):0</span></span><br><span class="line"><span class="comment">//rvalue经过forward()传给另一个函数却变为rvalue</span></span><br></pre></td></tr></table></figure>
<h2 id="Perfect-Forwarding"><a href="#Perfect-Forwarding" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h2><p>Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function.The nature of the argument(modifiable,const ,lvalue or rvalue) is preserved in this forwarding process.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionB(<span class="built_in">std</span>::forward&lt;T1&gt;(t1),</span><br><span class="line">				<span class="built_in">std</span>::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="String-Literal"><a href="#String-Literal" class="headerlink" title="String Literal"></a>String Literal</h1><h2 id="Raw-String-Literal"><a href="#Raw-String-Literal" class="headerlink" title="Raw String Literal"></a>Raw String Literal</h2><p>例如一个用来表示两个反斜杠和一个n的寻常字面常量可定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“\\\\n”</span><br></pre></td></tr></table></figure>
<p>也可以定义为raw string literal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R”(\\n)”</span><br></pre></td></tr></table></figure>
<p>如果要在raw string内写出)”，可以使用定义符。因此，一个raw string的完整语法是R”delim()delim”,其中delim是字符序列，最多16个基本字符，不包含反斜线、空格和小括号。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R”nc(a\</span><br><span class="line">    b\nc()”</span><br><span class="line">)nc”</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“a\\\n    b\\nc()\”\n    ”</span><br></pre></td></tr></table></figure>
<h2 id="Encoded-String-Literal"><a href="#Encoded-String-Literal" class="headerlink" title="Encoded String Literal"></a>Encoded String Literal</h2><p>u8定义一个UTF-8编码。<br>u定义一个string lteral，带着char16_t的字符<br>U定义一个string lteral，带着char32_t的字符<br>L定义一个wide string lteral，带着wchar_t的字符</p>
<h1 id="New-Fundamental-Data-Type"><a href="#New-Fundamental-Data-Type" class="headerlink" title="New Fundamental Data Type"></a>New Fundamental Data Type</h1><p>char16_t 和 char32_t<br>long long 和unsigned long long<br>std::nullptr_t</p>
<h1 id="Scoped-Enumerration"><a href="#Scoped-Enumerration" class="headerlink" title="Scoped Enumerration"></a>Scoped Enumerration</h1><p>一般情况下，在花括号中声明一个name（包括变量名，函数名），这个name的可见性会被限制在花括号的作用域内。对于在C++98风格的enum中声明的enum成员却不是这样。这些enum成员的name属于的作用域是enum所在作用域，这意味着在这个作用域中，不能拥有相同的name:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;;   <span class="comment">//black，white，red</span></span><br><span class="line">                                    <span class="comment">//和Color在同一个作用域</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误！white在这个</span></span><br><span class="line">                                    <span class="comment">//作用域已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>所以事实上，这些enum成员name泄露到enum所在的作用域中去了，这导致官方对于这种enum给出了一个官方术语：unscoped。新的C++11中有一个与此相对应的版本：scoped enum，不会像这样让name泄露：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">//black，white red</span></span><br><span class="line">                                        <span class="comment">//在Color作用域中</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                     <span class="comment">//好的，没其他white</span></span><br><span class="line">Color c = white;                        <span class="comment">//错误！在这个作用域中没有</span></span><br><span class="line">                                        <span class="comment">//一个叫“white”的enum成员</span></span><br><span class="line">Color c = Color::white;                 <span class="comment">//对的</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                  <span class="comment">//也是对的（而且和Item 5的建议一样）</span></span><br></pre></td></tr></table></figure>
<p>再举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Salutation</span> :</span> <span class="keyword">char</span> &#123; mr, ms co&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以明显定义底层类型（本例是char）并因此获得一个保证大小（如果你这里省略了char，则默认是int）。</p>
<h1 id="Member-Template"><a href="#Member-Template" class="headerlink" title="Member Template "></a>Member Template </h1><p>Member template的一个特殊形式时template构造函数。这个函数通常被提供用于“对象被复制时给予隐式类型转换”的能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//copy constructor with inmplicit type conversion</span></span><br><span class="line"><span class="comment">//-ddoes not supperss implicit copy constructor</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">	MyClass ( <span class="keyword">const</span> MyClass&lt;U&gt;&amp; x);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;<span class="keyword">double</span>&gt; xd;</span><br><span class="line">	MyClass&lt;<span class="keyword">double</span>&gt; xd2(xd);</span><br><span class="line">	MyClass&lt;<span class="keyword">int</span>&gt; xi(xd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里xd2与xd类型完全相同，因此其初始化是通过被隐式生成的copy构造函数完成。xi的类型与xd不同，因此其初始化是通过template构造函数完成的。</p>
<h1 id="Explicit-Initialization-for-Fundamental-Type"><a href="#Explicit-Initialization-for-Fundamental-Type" class="headerlink" title="Explicit Initialization for Fundamental Type"></a>Explicit Initialization for Fundamental Type</h1><p>如果你使用一个明确的构造函数，但不给实参这样的语法，基础类型会被设定初值为0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1;<span class="comment">//undefined value</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="keyword">int</span>();<span class="comment">//initialized with zero</span></span><br><span class="line"><span class="keyword">int</span> i3&#123;&#125;;<span class="comment">//initialized with zero</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; p;<span class="comment">//initialize p.first and p.second with zero</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-14-cpp2.0新特性2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/14/2017-04-14-cpp2.0新特性2/">cpp2.0新特性(2)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/14/2017-04-14-cpp2.0新特性2/" class="article-date">
	  <time datetime="2017-04-13T16:00:00.000Z" itemprop="datePublished">四月 14, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>Declval converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.<br>Decltype allows the compiler to infer the return type of a function based on an arbitrary expression and makes perfect forwarding more generic.In past versions,for two arbitrary T1 and T2,there was no way to deduce the type of an expression used these two types.The decltype feature allows you to state, for example, an expression that has template arguments,such as sum&lt;T1,T2&gt;() has the type T1+T2.<br>By using the new decltype keyword,you can let the complier find out the type of an expression.This is the realization of the often requested typeof feature.However,the existing typeof implementations were inconsistent and incomplete,so C++11 introduced a new keyword.For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br></pre></td></tr></table></figure>
<p>One application of decltype is to <strong>declare return types</strong>.Another is to use it <strong>in metaprogramming</strong> or to <strong>pass the type of a lambda</strong>.</p>
<h2 id="Used-to-declare-return-types"><a href="#Used-to-declare-return-types" class="headerlink" title="Used to declare return types"></a>Used to declare return types</h2><p>Sometimes,the return type of a function depends on an expression processed with the arguments.However,something like</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y)add(T1 x,T2 y);</span><br></pre></td></tr></table></figure>
<p>was not possible before C++11,because the return expression uses objects not introduced or in scope yet.But with C++11,you can alternatively declare the return type of a function behind the parameter list: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x,T2 y)-&gt;decltype(x+y);</span><br></pre></td></tr></table></figure>
<p>This uses the same syntax as for lambdas to declare return types.</p>
<h2 id="In-metaprogramming"><a href="#In-metaprogramming" class="headerlink" title="In metaprogramming"></a>In metaprogramming</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_decltype</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt;::value_type elem;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt; coll;</span><br><span class="line">	<span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line"></span><br><span class="line">	typedef typename decltype(obj)::iterator iType;</span><br><span class="line">	<span class="comment">//typedef typename T::iterator iType;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">decltype</span>(obj) anotherObj(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pass-the-type-of-a-lambda"><a href="#Pass-the-type-of-a-lambda" class="headerlink" title="Pass the type of a lambda"></a>Pass the type of a lambda</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp =[](<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.lastname()&lt;p2.lastname()||</span><br><span class="line">			(p1.lastname() == p2.lastname()&amp;&amp;</span><br><span class="line">			p1.lastname() &lt; p2.lastname());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>
<p>对于lambda，我们手上往往只有object，没有type。这是可以使用decltype<br>Because you need the type of the lambda for the declaration of the set,decltype must be used ,which yields the type of a lambda object,such as cmp.Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion passed ,and by rule lambdas have no default constructor and no assignment operator.So,for a sorting criterion,a class defining the function objects might still be more intuitive.</p>
<h1 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h1><p>C++11 introduced lambdas,allowing the definition of inline functionality,which can used as a parameter or a local object.Lambdas change the way the C++ standard library is used.<br>A lambda is a definition of functionality that can be defined inside statements and expressions.Thus,you can use a lambdas as an inline function.The minimal lambda function has no parameters and simply does something;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>You can call it directly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>or pass it to objects to get called:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Auto l = []&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">l();</span><br></pre></td></tr></table></figure>
<p>you can specify a capture to access data of outer scope that is not passed as an argument:<br>[=]means that the outer scope is passed to the lambda by value.<br>[&amp;]means that the outer scope is passed to the lambda by reference.<br>Ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">41</span>;</span><br><span class="line"><span class="keyword">auto</span> q = [x,&amp;y] &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>[=,&amp;y]to pass y by reference and all other objects by value.<br>Objects are passed by value,but inside the function object defined by the lambda,you have write access to the passed value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;<span class="comment">//如果没有写mutable，这个还有效吗?</span></span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>the type of a lambda is an anonymous function object(or functor)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		++id;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br></pre></td></tr></table></figure>
<h2 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass by value"></a>pass by value</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:<span class="number">0</span></span><br><span class="line">id:<span class="number">1</span></span><br><span class="line">id:<span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h2 id="pass-by-reference"><a href="#pass-by-reference" class="headerlink" title="pass by reference"></a>pass by reference</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:<span class="number">42</span></span><br><span class="line">id:<span class="number">43</span></span><br><span class="line">id:<span class="number">44</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<h2 id="No-mutable"><a href="#No-mutable" class="headerlink" title="No mutable"></a>No mutable</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    ++id;<span class="comment">//ERROR</span></span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：<br>ERROR increment of read-only variable ‘id’</p>
<h2 id="可以申明变量，可以返回变量"><a href="#可以申明变量，可以返回变量" class="headerlink" title="可以申明变量，可以返回变量"></a>可以申明变量，可以返回变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="再看Variadic-Template"><a href="#再看Variadic-Template" class="headerlink" title="再看Variadic Template"></a>再看Variadic Template</h1><h2 id="重写printf"><a href="#重写printf" class="headerlink" title="重写printf()"></a>重写printf()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,T value,Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">'%'</span> &amp;&amp; *(++s) != <span class="string">'%'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">			<span class="built_in">printf</span>(++s, args...);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"extra arguments provided to printf"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">'%'</span>&amp;&amp;*(++s) != <span class="string">'%'</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invaild format string: missing arguments"</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现max接受任意个数"><a href="#实现max接受任意个数" class="headerlink" title="实现max接受任意个数"></a>实现max接受任意个数</h2><p>若参数type都一样，就无需调用variadic templates,使用initializer_list<t>就足够了。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator,</span><br><span class="line">		<span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__max_element(_ForwardIterator __first,</span><br><span class="line">				_ForwardIterator __last,</span><br><span class="line">				_Compare _comp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(__first == __last) <span class="keyword">return</span> __first;</span><br><span class="line">	_ForwardIterator __result = __first;</span><br><span class="line">	<span class="keyword">while</span>(++__first != __last)</span><br><span class="line">		<span class="keyword">if</span>(__comp(__result, __first))</span><br><span class="line">			__result = __first;</span><br><span class="line">	<span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">max_element(_ForwardIterator __first,</span><br><span class="line">			_ForwardIterator __last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __max_element(__first,__last,</span><br><span class="line">						__iter_less_iter());</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _Tp</span><br><span class="line">max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *max_element(_l.begin(),__l.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> _Iter_less_iter </span><br><span class="line">__iter_less_iter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _Iter_less_iter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Iter_less_iter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1,<span class="keyword">typename</span> _Iterator2&gt;</span><br><span class="line">	<span class="keyword">bool</span> </span><br><span class="line">	<span class="keyword">operator</span>()(_Iterator1 __it1,_Iterator2 __it2) <span class="keyword">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *__it1 &lt; *__it2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="若参数type不同的话，使用variadic-templates"><a href="#若参数type不同的话，使用variadic-templates" class="headerlink" title="若参数type不同的话，使用variadic templates"></a>若参数type不同的话，使用variadic templates</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(n, mymax(args...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理first和last元素"><a href="#处理first和last元素" class="headerlink" title="处理first和last元素"></a>处理first和last元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">	PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;::print(os,t);</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> IDX,<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os,<span class="keyword">const</span> tuple &lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + <span class="number">1</span>==MAX?<span class="string">""</span>:<span class="string">","</span>);</span><br><span class="line">		PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;MAX, MAX, Args...&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; make_tuple(<span class="number">7.5</span>, <span class="built_in">string</span>(<span class="string">"hello"</span>),<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7.5</span>,hello,<span class="number">0000000101111001</span>,<span class="number">42</span>]</span><br></pre></td></tr></table></figure>
<h2 id="递归继承recursive-inheritance"><a href="#递归继承recursive-inheritance" class="headerlink" title="递归继承recursive inheritance"></a>递归继承recursive inheritance</h2><p>参看<a href="http://www.coordinate.wang/cpp/2017/04/13/cpp2.0%E6%96%B0%E7%89%B9%E6%80%A71.html#variadic-templates" target="_blank" rel="noopener">第一讲</a><br>但是里面有一行在这里就要变为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head;&#125; </span><br><span class="line"><span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;<span class="comment">//至此这就完美了</span></span><br></pre></td></tr></table></figure>
<h2 id="递归复合recursive-composition"><a href="#递归复合recursive-composition" class="headerlink" title="递归复合recursive composition"></a>递归复合recursive composition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;<span class="comment">//结束边界</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span> &lt;Head, Tail...&gt;</span></span><br><span class="line"><span class="class">	:</span><span class="keyword">private</span> tuple &lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> tuple &lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail)</span><br><span class="line">		:m_head(v), m_tail(vtail...) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tail; &#125;</span><br><span class="line"><span class="keyword">protected</span>:]</span><br><span class="line">    inherited m_tail;</span><br><span class="line">	Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-13-cpp2.0新特性1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/13/2017-04-13-cpp2.0新特性1/">cpp2.0新特性(1)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/13/2017-04-13-cpp2.0新特性1/" class="article-date">
	  <time datetime="2017-04-12T16:00:00.000Z" itemprop="datePublished">四月 13, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="新增加的头文件"><a href="#新增加的头文件" class="headerlink" title="新增加的头文件"></a>新增加的头文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理最后情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; first, <span class="keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//递归调用recursive</span></span><br><span class="line">	print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…就是所谓的pack<br>用于template parameters ，就是template parameters pack<br>用于function parameter types，就是function parameters types pack<br>用于function parameters ，就是function parameters pack<br>sizeof…(args) yields the number of arguments</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;<span class="comment">//结束边界</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span> &lt;Head, Tail...&gt;</span></span><br><span class="line"><span class="class">	:</span><span class="keyword">private</span> tuple &lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> tuple &lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail)</span><br><span class="line">		:m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" class="img-fluid"><br></a></p>
<h1 id="Spaces-in-template-expressions"><a href="#Spaces-in-template-expressions" class="headerlink" title="Spaces in template expressions"></a>Spaces in template expressions</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt;;<span class="comment">//ok in each c++ version</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">//ok in c++ 11</span></span><br></pre></td></tr></table></figure>
<h1 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a>nullptr and std::nullptr_t</h1><p>C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value.This new feature especially helps to avoid mistakes that occurred when a null ointer was interpreted as an integral value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="literal">NULL</span>)</span></span>;<span class="comment">//valls f(int) if NULL is 0,ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">//call f(void*)</span></span><br><span class="line"><span class="literal">nullptr</span> is a <span class="keyword">new</span> keywords</span><br></pre></td></tr></table></figure>
<h1 id="Automatic-type-deduction-with-auto"><a href="#Automatic-type-deduction-with-auto" class="headerlink" title="Automatic type deduction with auto "></a>Automatic type deduction with auto </h1><p>With c++11,you can declare a variable or an object without specifying its specific type by using auto.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = f();</span><br></pre></td></tr></table></figure>
<p>using auto is especially useful where the type is a pretty long and/or complicated expression.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin(); <span class="comment">//pos has type vector&lt;string&gt;::iterator</span></span><br></pre></td></tr></table></figure>
<h1 id="Uniform-initialization"><a href="#Uniform-initialization" class="headerlink" title="Uniform initialization"></a>Uniform initialization</h1><p>Before c++11,programmers,especially novices,could easily become confused by the question of how to initialize a variable or an object.Initialization could happen parentheses, braces,and/or assignment opretators.<br>For this reason ,c++11  introduces the concept of uniform initialization ,which means that for any initialization ,you can use one common syntax.This syntax uses braces, so the following is possible now;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> values[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123; <span class="number">4.0</span>,<span class="number">3.0</span> &#125;;<span class="comment">//背后有个array&lt;double,2&gt;</span></span><br></pre></td></tr></table></figure>
<p>编译器看到{1,2…}便做出一个initializer_list<t>，它关联至一个array&lt;T,n&gt;。调用函数时该array内的元素可被编译器逐一分解传给函数。但若函数参数是个initializer_list<t>，调用者却不能给予数个T参数然后以为他们会被自动转为一个initializer_list<t>传入。</t></t></t></p>
<h1 id="Initializer-lists"><a href="#Initializer-lists" class="headerlink" title="Initializer lists"></a>Initializer lists</h1><p>An initializer list forces so-called value initialization ,which means that even local variables of fundamental data types,which usually have an undefined initial value,are initialized by zero</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">//i has undefined value</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j is initialized by 0</span></span><br><span class="line"><span class="keyword">int</span> *p;<span class="comment">//i has undefined value</span></span><br><span class="line"><span class="keyword">int</span> *q&#123;&#125;;<span class="comment">//q is initialized by nullptr</span></span><br></pre></td></tr></table></figure>
<p>Note,however,that narrowing initializations –those that reduce precision or where the supplied value gets modified – are not possible with braces.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;<span class="comment">//x1 to 5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2 to 5</span></span><br><span class="line"><span class="keyword">int</span> x3&#123;<span class="number">5.3</span>&#125;;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> x4 = &#123;<span class="number">5.3</span>&#125;;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>To support  the concept of initializer lists for user-defined types,c++11 provides the class template std::initializer_list&lt;&gt; .It can be used to support initializations by a list of values or in any place where you want to process just a list of values.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p = vals.begin(); p != vals.end(); ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);<span class="comment">//与前面不同的是这里面的类型必须相同</span></span><br></pre></td></tr></table></figure>
<p>when there are constructors for both a specific number of arguments and an initializer list, the version with the initializer list is preferred.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	P(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"fjdsjf"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	P(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; initlist)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : initlist)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>, <span class="number">5</span>)</span></span>; <span class="comment">//P(int,int)</span></span><br><span class="line">P q&#123; <span class="number">77</span>,<span class="number">5</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br><span class="line">P r&#123; <span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br><span class="line">P s = &#123; <span class="number">77</span>,<span class="number">5</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br></pre></td></tr></table></figure>
<p>Without the constructor for the initializer list, the constructor taking two ints would be called to initialize q and s,while the initialization of r would be invalid.<br>Initializer_list objects are automatically constructed as if an array of elements of type T was allocated ,with each of the elements in the list being copy-initialized to its corresponding element in the array,using  any necessary non-narrowing implicit conversions.<br>The initializer_list object refers to the element of this array without containing them:copying an initializer_list object produces another object referring to the same underlying elements, not to new copies of them (reference semantics).<br>The lifetime of this temporary array is the same as the initializer_list object.</p>
<h1 id="Explicit-for-ctors-taking-more-than-one-argument"><a href="#Explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="Explicit for ctors taking more than one argument"></a>Explicit for ctors taking more than one argument</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	P(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">P y = (<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//error</span></span><br><span class="line">P z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">P v = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//ok</span></span><br><span class="line">P w = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>关于上面()这样做的错误原因，我后来想了一下，（）内取得是“，”运算符的结果，将这个结果初始化y，但是没有单个参数的构造函数，所以出现了“初始化: 无法从“int”转换为“P”，此时如果将第一个构造函数改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>编译果然通过了，结果和预想的一样</p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" class="img-fluid"><br></a></p>
<h1 id="Range-based-for-statement"><a href="#Range-based-for-statement" class="headerlink" title="Range-based for statement"></a>Range-based for statement</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (decl : coll)</span><br><span class="line">&#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>No explicit type conversions are possible when elements are initialized as decl inside the for loop.Thus ,the following does not compile:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> C&amp; elem : vs) <span class="comment">//ERROR,no conversion from string to C defined </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default ,=delete"></a>=default ,=delete</h1><p>如果你自行定义了一个ctor，那么编译器就不会再给你一个default ctor。<br>如果你强行加上=default，就可以重新获得并使用default ctor。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Zoo(<span class="keyword">int</span> i1,<span class="keyword">int</span> i2) : d1(i1),d2(i2);</span><br><span class="line">	Zoo(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;<span class="comment">//表示我不使用这个构造函数，default ctor也不会使用</span></span><br><span class="line"><span class="comment">// Zoo(const Zoo&amp;) = default;//ERROR,’Zoo(const Zoo&amp;)’cannot be overload</span></span><br><span class="line"><span class="comment">//对于copy assignment也是类似 的</span></span><br><span class="line">	Zoo(Zoo&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//表示使用编译器给我的默认构造函数</span></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~Zoo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>=default用于big-5之外没有意义，编译会报错<br>=delete可以用在任何函数上<br>default ctor和dtor主要是给编译器放置如唤起base classed以及non-static members的ctors和dtors，这个在effective c++中有所提及。<br>对于何种类需要自己写big-3呢？<br>如果这个类内部有pointer member的话，大多数情况下是需要自己写的，如果没有pointer member的话，基本可以使用default。</p>
<h1 id="Alias-template-template-typedef"><a href="#Alias-template-template-typedef" class="headerlink" title="Alias template(template typedef)"></a>Alias template(template typedef)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>the term</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, MyAlloc&lt;<span class="keyword">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>
<p>It is not possible to partially or explicitly specialize an alias template.<br>难道只是为了少敲几个代码吗？<br>看这个例子：<br>//函数功能：可以传入不同容器进行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">		c.insert(c.end(), T());</span><br><span class="line">	output_static_data(*(c.begin()));</span><br><span class="line">	Container&lt;T&gt; c1(c);</span><br><span class="line">	Container&lt;T&gt; c2(<span class="built_in">std</span>::move(c));</span><br><span class="line">	c1.swap(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是container里面的类型也是不定的所以就用到了以下方法：<br>template template parameter</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">XCLs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	XCLs()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">			c.insert(c.end(), T());</span><br><span class="line">		output_static_data(T());</span><br><span class="line">		Container&lt;T&gt; c1(c);</span><br><span class="line">		Container&lt;T&gt; c2(<span class="built_in">std</span>::move(c));</span><br><span class="line">		c1.swap(c2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">XCLs&lt;MyString,<span class="built_in">vector</span>&gt; c1;</span><br></pre></td></tr></table></figure>
<p>但是这里报错了<br>ERROR type/value mismatch at argument 2 in template parameter list for ‘template&lt;class T,template <class>class Container&gt; class XCLs’<br>原因在于</class></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span>: <span class="keyword">protected</span> _Vector_base&lt;_Tp,_Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>虽然第二个参数有默认值但是<br>Alias template are never deduced by template argument deduction when deducing a template template parameter<br>最终的解决法，这样使用这个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">vector</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">//上面的东西是不可以写在函数内的</span></span><br><span class="line">XCLs&lt;MyString,Vec&gt; c1;</span><br></pre></td></tr></table></figure>
<h1 id="Type-alias-similar-to-typedef"><a href="#Type-alias-similar-to-typedef" class="headerlink" title="Type alias(similar to typedef)"></a>Type alias(similar to typedef)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>There is no difference between a type alias declaration and typedef declaration.This declaration many appear in block scope,class scope or namespace scope.</p>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void foo() noexcept(true);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>Declares that foo() won’t throw.If an exception is not handled locally inside foo()-thus,if foo() throws – the program is terminated ,calling std::terminate(),which by default calls std::abort().<br>由于noexcept不需要stack unwinding ，程序员从今开始可以表现“绝不抛出”而不需要额外开销。c++11开始不再鼓励使用异常明细。<br>You can even specify a condition undef which a function throws no exception.For example,for any type Type,the alobal swap() usually is defined as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void swap(Type &amp;x, Type&amp; y) noexcept(noexcept(x.wap(y)))</span><br><span class="line">&#123;</span><br><span class="line">	x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here,inside noexception(…),you can specify a Boolean condition under which no thrown :Specifying noexcept without condition is a short form of specifying  noexcept(true).<br>You need to inform C++(specifivally std::vector)that your move constructor and destructor does not throw.Then the move constructor will be called when the vector frows.If the constructor is not noexcept,std::vector can’t use it,since then it can’t ensure the exception guarantees demanded by the standard.<br>Growable containers(会发生memory reallocation) 只有两种:vector 和 deque</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyString(MyString &amp;&amp;str)<span class="keyword">noexcept</span></span><br><span class="line">		: _data(str._data), _len(str._len) &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//ERROR 'virtual void Derived::vfunc(in)' marked override,but does not override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span> override </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">final</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">//ERROR cannot derive from 'final' base 'Base' in derived type 'Derived'</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//ERROR overriding final function</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-12-other issues"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-other issues/">other issues</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-other issues/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>当将元素加入容器中，容器必须分配更多的内存以足够保存这些元素，于是他们向他的模板参数allocator发出申请，该模板参数往往被另一个名为 allocator_type。甚至将chars添加到string class也是如此，因为string也算是一个正规的STL容器。每个元素类型为T的容器的Allocator模板默认为allocator<t>。其接口只有大约20个public申明，包括嵌套的typedefs和成员函数。最重要的两个成员函数是：</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Void <span class="title">deallocate</span><span class="params">(T* p, size_type n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>N指的是客户申请的元素个数，不是指空间总量。这些空间是通过调用::operator new获得，但何时需要并无具体指定。  </p>
<p>最容易满足需求的做法就是每当容器需要内存就调用operator new，每当容器释放内存就调用operator delete。这种做法比起分配大块内存并缓存然后小块小块的使用当然较慢，优势则是可以在极大范围的硬件和操作系统有效运作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::new_allocator</span><br></pre></td></tr></table></figure>
<p>实现出简洁的operator new 和operator delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator</span><br></pre></td></tr></table></figure>
<p>实现上例唯一不同的是，它使用c函数std::malloc和std::free  </p>
<p>另外一种做法就是使用智能型allocator，将分配所得的内存加以缓存。这种额外机制可以数种形式呈现：可以是个bitmap index，用以索引至一个以2的指数倍成长的篮子。也可以是个相较之下比较简易的fixed-size pooling cache这里所说的cache被程序内的所有容器共享，而operators new和operator delete不经常<br>被调用，这可带来速度上的优势。使用这个技巧的allocators包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::bitmap_allocator</span><br></pre></td></tr></table></figure>
<p>一个高效能的allocator，使用bit-map追踪被使用和未使用的内存块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::pool_allocator</span><br><span class="line">__gnu_cxx::__mt_alloc</span><br></pre></td></tr></table></figure>
<p>Class allocator 只拥有typedef,constructor,和rebind等成员。它继承自一个high-speed extension allocators。也因此，所有分配器和归还都取决于该base class，而这个base class也许是终端用户无法碰触和操控的。很难挑选出某个分配策略说他可以提供最大共同利益而不至于令某些行为过度优势。事实上，就算要挑选何种典型动作以测量速度，都是一种困难。<br>GNU C++提供三项综合测试用以C++allocators之间的速度比较：<br>Insertion进过多次iterations后各种STL容器将拥有某个极大量。分别测试sequence和associative容器。多线程环境中的insertion and erasure 。这个测试展示allocator归还内存，测量线程之间对内存的竞争。A threaded producer/consumer model分别测试sequence和associative容器。</p>
<p>另外两个智能allocator：<br><strong>gnu_cxx::debug_allocator<br>这个是一个外覆器(wrapper)，可包含于任何allocator之上。他把客户的申请量添加一些，然后由allocator回应，并以那个一小块额外内存放置size信息。一旦deallocate()收到一个pointer，就会检查size并以assert()保证吻合。  
</strong>gnu_cxx::array_allocator<br>允许分配一个已知固定大小的内存块，内存来自std::array objects。用上这个allocator，大小固定的容器就无需在调用::operator new 和::operator delete。这就允许我们使用STL abstractions而无需再运行期添加额外开销。甚至在program startup情况下也可使用。注意他是静态的，所以他不需要调用delete。</p>
<h2 id="Array-allocator"><a href="#Array-allocator" class="headerlink" title="Array allocator"></a>Array allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array内的第二个参数表示array的大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Array = <span class="built_in">std</span>::tr1::<span class="built_in">array</span>&lt;_Tp,<span class="number">1</span>&gt;&gt;</span><br><span class="line">class array_allocator:<span class="keyword">public</span> array_allocator_base&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Array array_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	array_type* _M_array;</span><br><span class="line">	size_type _M_used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	array_allocator(array_type* __array = <span class="literal">NULL</span>)<span class="keyword">throw</span>()</span><br><span class="line">		:_M_array(__array), _M_used(size_type())&#123;&#125;</span><br><span class="line">		...</span><br><span class="line">	pointer</span><br><span class="line">	allocate(size_type __n,<span class="keyword">const</span> <span class="keyword">void</span>* =<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_M_array == <span class="number">0</span>|| _M_used + __n&gt;_M_array &gt; size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		pointer __ret = _M_array-&gt;begin() + _M_used();</span><br><span class="line">		_M_used += __n;</span><br><span class="line">		<span class="keyword">return</span> __ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">debug_allocator</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">debug_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	size_type _M_extra;<span class="comment">//额外的空间，记录整个区块的大小</span></span><br><span class="line">	_Alloc _M_allocator;</span><br><span class="line">	</span><br><span class="line">	size_type _S_extra()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">size_t</span> __obj_size = <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">sizeof</span>(size_type) + __obj_size - <span class="number">1</span>)/__obj_size;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	debug_allocator(<span class="keyword">const</span> _Alloc&amp; __a)</span><br><span class="line">		:_M_allocator(__a), _M_extra(_S_extra())&#123;&#125;</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pointer __res = _M_allocator.allocate(__n + __m_extra);</span><br><span class="line">		size_type *__ps = <span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__res);</span><br><span class="line">		*__ps = __n;</span><br><span class="line">		<span class="keyword">return</span> __res + _M_extra;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::__throw_runtine_error;</span><br><span class="line">		<span class="keyword">if</span>(__p)</span><br><span class="line">		&#123;</span><br><span class="line">			pointer __real_p = __p + _m_extra;</span><br><span class="line">			<span class="keyword">if</span>(*<span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__real_p) != __n)</span><br><span class="line">				__throw_runtime_error</span><br><span class="line">					(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">			_M_allocator.deallocate(__ + _M_extra);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			__throw_runtime_error</span><br><span class="line">				(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bitmap-allocator"><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a>bitmap_allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitmap_allocator</span>:</span><span class="keyword">private</span> free_list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__n &gt; <span class="keyword">this</span>-&gt;max_size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,<span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_allocate_single_object();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> size_type __b = __n * <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;pointer&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__p !=<span class="number">0</span>,<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,tue))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;_M_delaoocate_single_object(__p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				::<span class="keyword">operator</span> <span class="keyword">delete</span>(_p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vector的元素排列将以super block size为依据，新进者若大于最末者，便直接delete新进者，否则delete最末者后再insert新进者，若没有到达64则insert到适当位置。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-12-loki&#39;s allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-loki's allocator/">loki::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-loki's allocator/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pData_: <span class="keyword">unsigned</span> <span class="keyword">char</span>*</span><br><span class="line">firstAvailableBlock_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//第一个可用的编号</span></span><br><span class="line">blocksAvailable_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//剩余可用的数目</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Init(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	pData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[blockSize * blocks];</span><br><span class="line">	Reset(blockSize, blocks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Reset(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	firstAvailableBlock_ = <span class="number">0</span>;</span><br><span class="line">	blocksAvailable_ = blocks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* p = pData_;</span><br><span class="line">	<span class="keyword">for</span>(; i!=blocks; p+=blockSize)</span><br><span class="line">		*p =++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Release()</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">delete</span>[] pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Allocate(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!blocksAvailable_) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* pResult = </span><br><span class="line">		pData_ + (firstAvailableBlock_ * blockSize);</span><br><span class="line">	firstAvailableBlock_ = *pResult;</span><br><span class="line">	--blocksAvailable_;</span><br><span class="line">	<span class="keyword">return</span> pResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Deallocate(<span class="keyword">void</span>* p,<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * toRelease = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">	*toRelease = firstAvailableBlock_;</span><br><span class="line">	firstAvailableBlock_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(</span><br><span class="line">						(toRelease - pData_)/blockSize);</span><br><span class="line">	++blocksAvailable_;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="FixedAllocator"><a href="#FixedAllocator" class="headerlink" title="FixedAllocator"></a>FixedAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunks_:<span class="built_in">vector</span>&lt;Chunk&gt;</span><br><span class="line">allocChunk_: Chunk*</span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *FixedAllocator::Allocate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(allocChunk == <span class="number">0</span> || allocChunk_-&gt;blocksAvailable_ == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunks::iterator i = chunks_.begin();</span><br><span class="line">		<span class="keyword">for</span>(;; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == chunks_.end())</span><br><span class="line">			&#123;</span><br><span class="line">				chunks_.push_back(Chunk());</span><br><span class="line">				Chunk&amp; newChunk = chunks_.back();</span><br><span class="line">				newChunk.Init(blockSize_, numBlocks_);</span><br><span class="line">				allocChunk_ = &amp;newChunk;<span class="comment">//指向上次给出去的chunk</span></span><br><span class="line">				deallocChunk_ = &amp;chunks_.front();<span class="comment">//指向上一次的回收</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i-&gt;blocksAvailable_&gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				allocChunk_ = &amp;*i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> allocChunk_-&gt;Allocate(blockSize_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Deallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_ = VicinityFind(p);</span><br><span class="line">	DoDealllocate(p);</span><br><span class="line">&#125;</span><br><span class="line">FixedAllocator::Chunk* FixedAllocator::VicinityFind(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> chunkLength = numBlocks_ * blockSize_;</span><br><span class="line">	</span><br><span class="line">	Chunk* lo = deallocChunk_;</span><br><span class="line">	Chunk* hi = deallocChunk_ + <span class="number">1</span>;</span><br><span class="line">	Chunk* loBound = &amp;chunks_.front();</span><br><span class="line">	Chunk* hiBound = &amp;chunks_.back() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(lo)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= lo-&gt;pData_ &amp;&amp; p&lt; lo-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> lo;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(lo == loBound) lo = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> --lo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= hi-&gt;pData_&amp;&amp; p &lt;hi-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> hi;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>( ++ hi == hiBound) hi = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::DoDeallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_-&gt;Deallocate(p, blockSize_);</span><br><span class="line"><span class="comment">//是否等于开始的登记值</span></span><br><span class="line">	<span class="keyword">if</span>(deallocChunk_-&gt;blocksAvailable == numBlocks)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunk&amp; lastChunk == chunks_.back();</span><br><span class="line"><span class="comment">//这里的做法与vc SBH defer类似</span></span><br><span class="line"><span class="comment">//__sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原</span></span><br><span class="line"><span class="comment">//本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer </span></span><br><span class="line"><span class="comment">//group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer </span></span><br><span class="line"><span class="comment">//group取出block完成分配，Defer指针会被取消(设为NULL);</span></span><br><span class="line"><span class="comment">//__sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(&amp;lastChunk == deallocChunk_)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(chunks_.size() &gt;<span class="number">1</span> &amp;&amp;</span><br><span class="line">				deallocChunk_[<span class="number">-1</span>].blocksAvailable_ == numBlocks)</span><br><span class="line">			&#123;</span><br><span class="line">				lastChunk.Release();</span><br><span class="line">				chunks_.pop_back();</span><br><span class="line">				allocChunk_ = deallocChunk_ = &amp;chunks_.front();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lastChunk.blocksAvailable == numBlocks)</span><br><span class="line">		&#123;</span><br><span class="line">			lastChunk.Release();</span><br><span class="line">			chunks_.pop_back();</span><br><span class="line">			allocChunk_ = deallocChunk_;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(*deallocChunk_, lastChunk);</span><br><span class="line">			allocChunk_ = &amp;chunks_.back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SmallObjAllocator"><a href="#SmallObjAllocator" class="headerlink" title="SmallObjAllocator"></a>SmallObjAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool_: <span class="built_in">vector</span>&lt;FixedAllocator&gt;</span><br><span class="line">pLastAlloc: FixedAllocator</span><br><span class="line">pLastDealloc: FixedAllocator</span><br><span class="line">chunkSize: <span class="keyword">size_t</span></span><br><span class="line">maxObjectSize: <span class="keyword">size_t</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-11-malloc and free"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/11/2017-04-11-malloc and free/">malloc/free</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/11/2017-04-11-malloc and free/" class="article-date">
	  <time datetime="2017-04-10T16:00:00.000Z" itemprop="datePublished">四月 11, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SBH-small-block-heap"><a href="#SBH-small-block-heap" class="headerlink" title="SBH(small block heap)"></a>SBH(small block heap)</h1><h2 id="heap-init-和-sbh-heap-init"><a href="#heap-init-和-sbh-heap-init" class="headerlink" title="_heap_init() 和__sbh_heap_init()"></a>_heap_init() 和__sbh_heap_init()</h2><p>CRT为自己建立一个__crtheap，然后从中配置SBH所需的headers，regions作为管理用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _cdecl_heap_init(<span class="keyword">int</span> mtflag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(( _crtheap = HeapCreate( mtflag?<span class="number">0</span>: HEAP_NO_SERIALIZE,</span><br><span class="line">					BYTES_PER_PAGE, <span class="number">0</span> )) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( __sbh_heap_init() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HeapDestory(_crtheap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nNoMansLandSize 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderPrev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *szFilename;<span class="comment">//指向的文件名ioinit.c</span></span><br><span class="line">	<span class="keyword">int</span> nLine;<span class="comment">//上面文件的第几行,81行</span></span><br><span class="line">	<span class="keyword">size_t</span> nDataSize;<span class="comment">//客户要的内存大小</span></span><br><span class="line">	<span class="keyword">int</span> nBlockUse;<span class="comment">//memory block</span></span><br><span class="line">	<span class="keyword">long</span> IRequest;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> gap[nNoMansLandSize];</span><br><span class="line">	<span class="comment">/*followed by:</span></span><br><span class="line"><span class="comment">	*unsigned char data[nDataSize];</span></span><br><span class="line"><span class="comment">	*unsigned char anothergap[nNoMansLandSize];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;_CrtMemBlockHeader;</span><br></pre></td></tr></table></figure>
<p>至此我们终于知道了，在debug模式下，分配的内存块中多出来的部分</p>
<h2 id="关于第一块内存的分配"><a href="#关于第一块内存的分配" class="headerlink" title="关于第一块内存的分配"></a>关于第一块内存的分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRegion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> indGroupUse;<span class="comment">//0xffffffff，用于分割</span></span><br><span class="line">	<span class="keyword">char</span> cntRegionSize[<span class="number">64</span>];</span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];</span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span> <span class="title">grpHeadList</span>[32];</span></span><br><span class="line">&#125;REGION, *PREGION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cntEntries; <span class="comment">//记录分配次数，每分配一次加一，回收减一</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span> <span class="title">listHead</span>[64];</span></span><br><span class="line">&#125;GROUP, *PGROUP;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;LISTHEAD, *PLISTHEAD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sizeFront;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;ENTRY, *PENTRY;</span><br></pre></td></tr></table></figure>
<h2 id="归还操作系统"><a href="#归还操作系统" class="headerlink" title="归还操作系统"></a>归还操作系统</h2><p><strong>sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer group取出block完成分配，Defer指针会被取消(设为NULL);  
</strong>sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl__sbh_heap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(! (__sbh_pHeaderList = HeapAlloc(crtheap,<span class="number">0</span>,<span class="number">16</span>*<span class="keyword">sizeof</span>(HEADER)))</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	__sbh_pHeaderScan = __sbh_pHeaderList;</span><br><span class="line">	__sbh_pHeaderDefer = <span class="literal">NULL</span>;</span><br><span class="line">	__sbh_cntHeaderList = <span class="number">0</span>;</span><br><span class="line">	__sbh_sizeHeaderList = <span class="number">16</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-10-std_allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/10/2017-04-10-std_allocator/">std::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/10/2017-04-10-std_allocator/" class="article-date">
	  <time datetime="2017-04-09T16:00:00.000Z" itemprop="datePublished">四月 10, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在vc6的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在bc5中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在G2.9中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计，但是它内部并没有使用，而是使用的std::alloc。<br>在4.9版中叫__pool_alloc，但是这两个都不是标准分配器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: __n is permitted to be 0.  The C++ standard says nothing</span></span><br><span class="line"> <span class="comment">// about what the return value is when __n == 0.</span></span><br><span class="line">pointer</span><br><span class="line">allocate(size_type __n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect(__n &gt; <span class="keyword">this</span>-&gt;max_size(), <span class="literal">false</span>))</span><br><span class="line">		<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp*&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__n * <span class="keyword">sizeof</span>(_Tp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __p is not permitted to be a null pointer.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">deallocate(pointer __p, size_type)</span><br><span class="line">&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>alloc的设计<br>申请32bytes，由于pool为空，所以成功所求32<em>20</em>2+RoundUp(0(目前的申请总量)&gt;&gt;4) =1280，从中切出一个，另外的19个给list#3，剩余640备用。每次分配前都是先看原先的是否有剩余pool，从pool切给出来的数量永远在1~20之间，pool余量不足够的时候，先将pool余量给相应的list#，然后索取相应的内存。当内存不够时，往右边找一块给他。如果就近找不到的话，就会失败。但是这样的话，还有很多的空内存未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二级分配器</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __ALIGN = <span class="number">8</span> &#125;;<span class="comment">//定义常量,小区快的下限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __MAX_BYTES = <span class="number">128</span> &#125;;<span class="comment">//上限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __NFREELISTS = __MAX_BYTES/ __ALIGN &#125;;<span class="comment">//freelist的长度</span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> ((bytes) + _ALIGN<span class="number">-1</span>) &amp; ~(_ALIGN - <span class="number">1</span>));</span><br><span class="line"> 	&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">union</span> obj</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="keyword">union</span> obj* free_list_link;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">static</span> obj *<span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line"> 	<span class="comment">//计算list#</span></span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN<span class="number">-1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;<span class="comment">//指向pool头</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;<span class="comment">//指向pool尾</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		obj* result;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)<span class="comment">//改用第一级</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"> 		result = *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(result == <span class="number">0</span>_</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line"> 			<span class="keyword">return</span> r;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		*my_free_list = result-&gt;free_list_link;</span><br><span class="line"> 		<span class="keyword">return</span> (result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//回收的时候，把要回收的部分插入二级链表的头</span></span><br><span class="line"> 	<span class="comment">//函数内部没有做p指针的检查，如果这个p指针不是这个系统的，</span></span><br><span class="line"> 	<span class="comment">//如果他不是8的倍数的话，回收后再分配时会出问题，原来分配给list#1，</span></span><br><span class="line"> 	<span class="comment">//可能现在到了list#2</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span> deallocate(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		obj* q = (obj*)p;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			malloc_alloc::deallocate(p,n);</span><br><span class="line"> 			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list +FREELIST_INDEX(n);</span><br><span class="line"> 		q-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 		*my_free_list = q;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span>* reallocate(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz);<span class="comment">//略</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">char</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"> chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">char</span> *result;</span><br><span class="line"> 	<span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line"> 	<span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">if</span>( bytes_left &gt;= total_bytes)<span class="comment">//pool能否满足20个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span>( bytes_left &gt;= size)<span class="comment">//pool能否满足1个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		nobjs = bytes_left /size;</span><br><span class="line"> 		total_bytes = size * nobjs;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 	<span class="comment">//空pool或者为碎片</span></span><br><span class="line"> 		<span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"> 		<span class="comment">//将碎片挂接</span></span><br><span class="line"> 		<span class="keyword">if</span>( bytes_left &gt; <span class="number">0</span>)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line"> 			((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 			*my_free_list = (obj*)start_free;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//分配内存</span></span><br><span class="line"> 		start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"> 		<span class="keyword">if</span>( <span class="number">0</span> == start_free)<span class="comment">//分配失败的话，从freelist中找</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">int</span> i;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"><span class="comment">//try to make do with what we have.that can’t hurt.</span></span><br><span class="line"><span class="comment">//we do not try smaller requests,since that tends</span></span><br><span class="line"><span class="comment">//to result in disaster on muti-process machines.</span></span><br><span class="line"> 			<span class="keyword">for</span>( i = size; i &lt;= __MAX_BYTES; i+= __ALIGN)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line"> 				p = *my_free_list;</span><br><span class="line"> 				<span class="keyword">if</span>( <span class="number">0</span> != p)</span><br><span class="line"> 				&#123;</span><br><span class="line"> 					*my_free_list = p-&gt;free_list_link;</span><br><span class="line"> 					start_free = (<span class="keyword">char</span> *)p;</span><br><span class="line"> 					end_free = start_free + i;</span><br><span class="line"> 					<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			<span class="comment">//表示memory已经‘没有’了</span></span><br><span class="line"> 			end_free = <span class="number">0</span>;</span><br><span class="line"> 			start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		heap_size += bytes_to_get;</span><br><span class="line"> 		end_free = start_free + bytes_to_get;</span><br><span class="line"> 		<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">void</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)<span class="comment">//n已经是8的倍数</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">int</span> nobjs = <span class="number">20</span>;<span class="comment">//预设20个</span></span><br><span class="line"> 	<span class="keyword">char</span> *chunk = chunk_alloc(n, nobjs);</span><br><span class="line"> 	obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 	obj* result;</span><br><span class="line"> 	obj* current_obj;</span><br><span class="line"> 	obj* next_obj;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">if</span>( <span class="number">1</span>== nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"> 	my_free_list = free_list_link;</span><br><span class="line"> 	result = (obj*)chunk;</span><br><span class="line"> 	*my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line"> 	<span class="comment">//在chunk内建立freelist</span></span><br><span class="line"> 	<span class="keyword">for</span>( i = <span class="number">1</span>; ; ++i)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		current_obj = next_obj;</span><br><span class="line"> 		next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line"> 		<span class="keyword">if</span>( nobjs<span class="number">-1</span> == i)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = next_obj;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> (result);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:heap_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[_NFREELISTS]</span><br><span class="line">= &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; alloc;</span><br></pre></td></tr></table></figure>
<p>deallocate完全没有free，设计上的缺陷，没有变量记录freelist的起始位置</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-09-内存管理primitives"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/09/2017-04-09-内存管理primitives/">内存管理 primitives</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/09/2017-04-09-内存管理primitives/" class="article-date">
	  <time datetime="2017-04-08T16:00:00.000Z" itemprop="datePublished">四月 9, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSR_VER</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是static，可以通过全名调用，2.9ver</span></span><br><span class="line"><span class="keyword">void</span> *p4 = alloc::allocate(<span class="number">512</span>);</span><br><span class="line">alloc::deallocate(p4, <span class="number">512</span>);</span><br><span class="line"><span class="comment">//4.9ver 以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p5 = __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">9</span>);</span><br><span class="line">__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;.deallocate((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="New-expression"><a href="#New-expression" class="headerlink" title="New expression"></a>New expression</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//只有编译器可以这样调用ctor</span></span><br><span class="line"><span class="comment">//想要直接调用ctor，可以运用placement new；</span></span><br><span class="line"><span class="comment">//new(p)Complex(1,2);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::nothrow <span class="keyword">_t</span>&amp;)</span> _<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//nothrow struct is used as a function parameter to operator new to </span></span></span><br><span class="line"><span class="function"><span class="comment">//indicate that the function should return a null pointer to report</span></span></span><br><span class="line"><span class="function"><span class="comment">//an allocation failure ,rather than throw an exception</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">	    <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">	    &#123;       <span class="comment">// report no memory</span></span><br><span class="line">	            _THROW_NCEE(_XSTD bad_alloc, );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> expression</span><br><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line">pc-&gt;~Complex();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span>_<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Array-new-array-delete"><a href="#Array-new-array-delete" class="headerlink" title="Array new,array delete"></a>Array new,array delete</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex *pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//唤起3次ctor</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] pca;<span class="comment">//唤起3次dtor</span></span><br><span class="line"><span class="comment">//一下做法会造成内存泄漏，string的内部有指针</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> psa;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" class="img-fluid"><br></a></p>
<p>61h为cookie，用来记录空间的大小，最后一个字节用来记录内存是在使用，还是未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo *p = <span class="keyword">new</span> Demo[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" class="img-fluid"><br></a></p>
<p>第一个p指向的地址是00481c30，第二个p指向的地址是00481c34，如果写成delete p;的话，那么会从第一个p开始而不是第二个，就会出问题，多出一个3，这个3表示调用几次析构。如果Demo没有nontrivial dtor ,就不会记录3，也就是说，和上面的int类似，可以不加[]。<br>关于内存空间，必须要调节16的倍数，所以增加了pad这个东西。</p>
<h1 id="Placement-new"><a href="#Placement-new" class="headerlink" title="Placement new"></a>Placement new</h1><p>Placement new 允许我们将object建立于 allocated memory中没有所谓的placement delete，因为placement new根本没有分配memory亦或称呼placement new 对应的operator delete为placement delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>];</span><br><span class="line">Complex *pc = <span class="keyword">new</span>(buf)Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//等同于调用构造函数</span></span><br><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));<span class="comment">//没有做任何事</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> ,<span class="keyword">void</span> *loc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> loc; &#125;</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>
<p>关于placement new，或指为new(p)，或指为::operator new(size, void*)</p>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="重载-operator-new-operator-delete"><a href="#重载-operator-new-operator-delete" class="headerlink" title="重载::operator new/::operator delete"></a>重载::operator new/::operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myAlloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAlloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete"><a href="#重载operator-new-operator-delete" class="headerlink" title="重载operator new/operator delete"></a>重载operator new/operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete-1"><a href="#重载operator-new-operator-delete-1" class="headerlink" title="重载operator new[]/operator delete[]"></a>重载operator new[]/operator delete[]</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo[n];</span><br><span class="line">...</span><br><span class="line">Delete[] p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new()/delete()"></a>重载new()/delete()</h2><p>我们重载class member operator new(),前提是每一个版本的声明都必须是独特的参数列，其中第一个参数必须是size_t，其余参数以new所指定的placement arguments为初值.出现new()小括号内的便是所谓的placement argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo *pf = <span class="keyword">new</span> (<span class="number">300</span>,<span class="string">'c'</span>) Foo;<span class="comment">//第一个参数表所示Foo的大小</span></span><br><span class="line"><span class="comment">//一般重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="comment">//placement new()的标准写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> *start)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> start; &#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。他只能这样被调用，主要用来clean未完成创建的object所占的memory。即使operator delete() 未能一一对应operator new() ,编译器也不会报错，这样做的意思是放弃处理ctor发出的异常。  </p>
<p>Basic_string使用new(extra)<br>平时使用的string就是typdef  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Rep</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>( --ref == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> Rep* <span class="title">create</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep*</span><br><span class="line">basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">create(<span class="keyword">size_t</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">	extra = frob_size(extra + <span class="number">1</span>);</span><br><span class="line">	Rep *p = <span class="keyword">new</span>(extra) Rep;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> *<span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep::</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> s,<span class="keyword">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Allocator::allocate(s + extra * <span class="keyword">sizeof</span>();<span class="comment">//placement new的重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;class charT, class traits, class Allocator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">opreraotr <span class="keyword">delete</span>(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	Allocator::deallocate(ptr...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">1</span></span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">class Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Screen(<span class="keyword">int</span> x) :i(x) &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> get() &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Screen *next;</span><br><span class="line">	<span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Screen *Screen::freeSore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	Screen *p;<span class="comment">//这种设计多用了一个指针</span></span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = screenChunk *size;</span><br><span class="line">		freeStore = p = <span class="keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="keyword">new</span> <span class="keyword">char</span> [chunk]);</span><br><span class="line"><span class="comment">//将一大块分割后，用链表穿起来</span></span><br><span class="line">		<span class="keyword">for</span>(; p!= &amp;freeStore[screenChunk<span class="number">-1</span>]; ++p)</span><br><span class="line">			p-&gt;next = p +<span class="number">1</span>;</span><br><span class="line">		p-&gt;next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p,<span class="keyword">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将delete object插回</span></span><br><span class="line">	(<span class="keyword">static_cast</span> &lt;Screen*&gt;(p))-&gt;next = freeStore;</span><br><span class="line">	freeStore = <span class="keyword">static_cast</span>&lt;Screen*&gt;(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">2</span></span><br><span class="line">class Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	struct AirplaneRep</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> miles;</span><br><span class="line">		<span class="keyword">char</span> type;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		AirplaneRep rep;</span><br><span class="line">		Airplane *next;<span class="comment">//嵌入式指针，相对于前面的来说非常不错</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长</span></span><br><span class="line"><span class="comment">//度是AirplaneRep型态。</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数</span></span><br><span class="line"><span class="comment">//据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> getMiles() &#123; <span class="keyword">return</span> rep.miles;&#125;</span><br><span class="line">	<span class="keyword">char</span> getType() &#123; <span class="keyword">return</span> rep.type; &#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="built_in">set</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> m, <span class="keyword">char</span> t)</span><br><span class="line">	&#123;</span><br><span class="line">		rep.miles = m;</span><br><span class="line">		rep.type = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> *opertor <span class="keyword">new</span>(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="comment">//注意这里static，编译器默认也是static，原因在于，要在对象创建时调用，</span></span><br><span class="line"><span class="comment">//如果不是static，对象创建时，可能这个东西还在创建的过程中</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BLOCK_SIZE;	<span class="keyword">static</span> Airplane *headOfFreeList;</span><br><span class="line">&#125;;</span><br><span class="line">Airplane *Airplane::headOfFreeList;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Airplane::BLOCK_SIZE=<span class="number">512</span>;</span><br><span class="line"><span class="keyword">void</span> *Airplane::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当继承发生时</span></span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line">	Airplane *p = headOfFreeList;</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">		headOfFreeList = p-&gt;next;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Airplane *newBlock = <span class="keyword">static_cast</span>&lt;Airplane*&gt;</span><br><span class="line">		(::<span class="keyword">operator</span> <span class="keyword">new</span>(BLOCK_SIZE * <span class="keyword">sizeof</span>(Airplane));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;BLOCK_SIZE - <span class="number">1</span>;++i)</span><br><span class="line">			newBlock[i].next = &amp;newBlock[i+<span class="number">1</span>];</span><br><span class="line">		newBlock[BLOCK_SIZE<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">		p = newBlock;</span><br><span class="line">		headOfFreeList = &amp;newBlock[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Airplane::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(deadObject == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="keyword">operator</span> <span class="keyword">delete</span>(deadObject);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Airplane *carcass = <span class="keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);</span><br><span class="line">	carcass-&gt;next = headOfFreeList;</span><br><span class="line">	headOfFreeList = carcass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static-allocator"><a href="#static-allocator" class="headerlink" title="static allocator"></a>static allocator</h1><p>不同的class重写一遍几乎相同member operator new和member operator delete时，应该有方法将他们统一在一起，是他可以重用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">obj</span>* <span class="title">next</span>;</span><span class="comment">//与linux里的链表做法一样</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	obj* freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> CHUNK = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> *allocator::allocate(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	obj *p;</span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = CHUNK *size;</span><br><span class="line">		freeStore = p = (obj*)<span class="built_in">malloc</span>(chunk);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; (CHUNK<span class="number">-1</span>); +i)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = (obj*)((<span class="keyword">char</span>*)p+size);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	((obj*)p)-&gt;next = freeStore;</span><br><span class="line">	freeStore = (obj*)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Foo可以这样写了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pHead, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    &#123; <span class="keyword">return</span> myAlloc.deallocate(pHead, size); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做就方便了很多</p>
<h1 id="Macro-for-static-allocator"><a href="#Macro-for-static-allocator" class="headerlink" title="Macro for static allocator"></a>Macro for static allocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\表示续行符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_POOL_ALLOC()\</span></span><br><span class="line"><span class="keyword">public</span>:\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123; myAlloc.deallocate(p, <span class="number">0</span>); &#125;\</span><br><span class="line"><span class="keyword">protected</span>:\</span><br><span class="line">	<span class="keyword">static</span> allocator myAlloc;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name)\</span></span><br><span class="line">allocator class_name::myAlloc;</span><br></pre></td></tr></table></figure>
<p>原来的变成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DECLARE_POOL_ALLOC()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">long</span> L;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(<span class="keyword">long</span> l) : L(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">IMPLEMENT_POOL_ALLOC(Foo)</span><br></pre></td></tr></table></figure>
<h1 id="New-handler"><a href="#New-handler" class="headerlink" title="New handler"></a>New handler</h1><p>当operator new 没有能力分配申请的memory，会抛出异常std::bad_alloc execption以仍然可以让编译器new(nothrow) Foo;<br>抛出异常之前会调用一个可由client指定的handler，以下是new handler的形式和设定方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>设计良好的new handler只有俩个选择：<br>让更多的memory可用 调用abort()和exit()</p>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h1><p>It is not only for ctor and assignments,but also apllies to operator new/new[],operator delete/delete[] and their overloads</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo() = <span class="keyword">default</span>;<span class="comment">//表示使用默认版本，如果没有的话使用编译器合成版</span></span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示不使用这个函数 </span></span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">	~Foo()=defalut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-08-cast"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/08/2017-04-08-cast/">static_cast,dynamic_cast,reinterpret_cast和const_cast</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/08/2017-04-08-cast/" class="article-date">
	  <time datetime="2017-04-07T16:00:00.000Z" itemprop="datePublished">四月 8, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。<br>同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。</p>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p>用法：static_cast \&lt;typeid> (expression)<br>说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。<br>用途：  </p>
<ol>
<li>用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。</li>
<li>用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。</li>
<li>可以把空指针转换成目标类型的空指针(null pointer)。</li>
<li>把任何类型的表达式转换成void类型。<br>注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。</li>
</ol>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>用法：dynamic_cast\&lt;typeid> (expression)<br>说明：该运算符把expression转换成typeid类型的对象。typeid必须是类的指针、类的引用或者void*。如果typeid是类的指针类型，那么expression也必须是指针，如果typeid是一个引用，那么expression也必须是一个引用。一般情况下，dynamic_cast用于具有多态性的类(即有虚函数的类)的类型转换。  </p>
<p>dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。先看RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换,例如从派生类指针转换成基类指针。而这种转换其实并不需要dynamic_cast参与。也就是说,dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的。</p>
<p>用途：主要用于类层次之间的up-casting和down-casting，还可以用于类之间的交叉转换。在进行down-casting时，dynamic_cast具有类型检查的功能，比static_cast更安全。检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转 换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。<br>注意：dynamic_cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>用法：reinterpret_cast \&lt;typeid>(expression)<br>说明：转换一个指针为其他类型的指针，也允许将一个指针转换为整数类型，反之亦然。这个操作符能够在非相关的类型之间进行转换。操作结果只是简单的从一个指针到<br>别的指针的值的二进制拷贝，在类型之间指向的内容不做任何类型的检查和转换。这是一个强制转换。使用时有很大的风险，慎用之。<br>注意：reinterpret _cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>用法：const_cast\&lt;typeid>(expression)<br>说明：这个类型操纵传递对象的const属性，或者是设置或者是移除。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class C&#123;…&#125;</span><br><span class="line"><span class="keyword">const</span> C* a = <span class="keyword">new</span> C;</span><br><span class="line">C* b = <span class="keyword">const_cast</span>&lt;C*&gt;(a);</span><br></pre></td></tr></table></figure>
<p>如果将上面的const_cast转换成其他任何其他的转换，编译都不能通过，出错的信心大致如下：</p>
<p>“…cannot convert from ‘const class C <em>‘ to ‘class C </em>‘”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _base;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _derived;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _derived &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Base b1;</span><br><span class="line">     Derived d1;</span><br><span class="line">     <span class="keyword">int</span> aInt = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">long</span> aLong = <span class="number">11</span>;</span><br><span class="line">     <span class="keyword">float</span> aFloat = <span class="number">11.11f</span>;</span><br><span class="line">     <span class="keyword">double</span> aDouble = <span class="number">12.12</span>;</span><br><span class="line">     Derived* pd = <span class="keyword">static_cast</span>&lt;Derived*&gt;(&amp;b1);     <span class="comment">// down-casting  不安全</span></span><br><span class="line">     Base* pb = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;d1);       <span class="comment">// up-casting   安全</span></span><br><span class="line">     Derived&amp; d = <span class="keyword">static_cast</span>&lt;Derived&amp;&gt;(b1);  <span class="comment">// down-casting   不安全</span></span><br><span class="line">     Base&amp; b = <span class="keyword">static_cast</span>&lt;Base&amp;&gt;(d1);   <span class="comment">// up-casting    安全</span></span><br><span class="line"></span><br><span class="line">     aInt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(aFloat);        <span class="comment">// 基本数据类型转换</span></span><br><span class="line">     <span class="keyword">void</span>* sth = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;aDouble);    <span class="comment">// 将double指针类型转换成void指针类型</span></span><br><span class="line">     <span class="keyword">double</span>* bDouble = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(sth);<span class="comment">// 将void指针类型转换成double指针类型</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; *bDouble &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     Base* pb1 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(&amp;d1);</span><br><span class="line">     <span class="comment">//Derived* pd1 = dynamic_cast&lt;Derived*&gt;(&amp;b1); // 编译时有warning，运行时出错</span></span><br><span class="line">     <span class="keyword">int</span> bInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(pb1);     <span class="comment">// 将地址或指针转换成整数</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; bInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base*&gt;(bInt);   <span class="comment">// 将整数转换成地址或指针</span></span><br><span class="line">     <span class="keyword">int</span>* cInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;aFloat);<span class="comment">// 这个转换的结果会出乎意料</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)*cInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">const</span> Base* bBase = <span class="keyword">new</span> Base();</span><br><span class="line">     Base* cBase = <span class="keyword">const_cast</span>&lt;Base*&gt;(bBase);</span><br><span class="line">     <span class="comment">//Base* dBase = dynamic_cast&lt;Base*&gt;(bBase);  // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* eBase = static_cast&lt;Base*&gt;(bBase);      // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* fBase = reinterpret_cast&lt;Base*&gt;(bBase);    // 不能通过编译</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-06-分配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/06/2017-04-06-分配器/">分配器 allocators</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/06/2017-04-06-分配器/" class="article-date">
	  <time datetime="2017-04-05T16:00:00.000Z" itemprop="datePublished">四月 6, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span>:<span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>:<span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">deque</span>:<span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		typenaem _Alloc = <span class="built_in">std</span>::allocator&lt;_Key&gt;&gt;</span><br><span class="line">class <span class="built_in">set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		<span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">map</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Value&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_set</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Key&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_map</span></span><br></pre></td></tr></table></figure>
<p>一般写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc1;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>);</span><br><span class="line">alloc1.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>特殊写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__pool_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__mt_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br></pre></td></tr></table></figure>
<p>不建议用分配器，应该用容器，new malloc</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分配器/">分配器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/15/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/iTimeTraveler" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/20/2017-12-20-YOLOv2代码分析（四）/">YOLOv2代码分析（四）</a></h6>
              <span>十二月 20, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/19/2017-12-19-YOLOv2代码分析（三）/">YOLOv2代码分析（三）</a></h6>
              <span>十二月 19, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/17/2017-12-17-YOLOv2代码分析（二）/">YOLOv2代码分析（二）</a></h6>
              <span>十二月 17, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/16/2017-12-16-YOLOv2代码分析（一）/">YOLOv2代码分析（一）</a></h6>
              <span>十二月 16, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/15/2017-12-15-目标检测中的IOU计算问题/">目标检测中的IOU计算问题</a></h6>
              <span>十二月 15, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/13/2017-12-13-tf.identity的作用/">tf.identity的作用</a></h6>
              <span>十二月 13, 2017</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/1080ti/">1080ti</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aggregate/">Aggregate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dell/">Dell</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eassy/">Eassy</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eval/">Eval</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Execute/">Execute</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExecuteGlobal/">ExecuteGlobal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fibonacci/">Fibonacci</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOU/">IOU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kolakoski/">Kolakoski</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MNIST/">MNIST</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PIL/">PIL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POD/">POD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YOLO/">YOLO</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/">acm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/advance/">advance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/array/">array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp/">asp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto&</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto&&</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binding/">binding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c#</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cin/">cin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/constexpr/">constexpr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a><span class="tag-list-count">90</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp标准库/">cpp标准库</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp第二版/">cpp第二版</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cuda/">cuda</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cudnn/">cudnn</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/darknet/">darknet</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dd/">dd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/">default</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/downcasting/">downcasting</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/error/">error</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/estimator/">estimator</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/forward/">forward</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/">game</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glvalue/">glvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hook/">hook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/identity/">identity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/">lambda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvalue/">lvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mismatch/">mismatch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/move/">move</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/namehiding/">namehiding</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/">next</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/">notes</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/office/">office</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oj/">oj</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/">opencv</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overload/">overload</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/override/">override</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/piecewise-construct/">piecewise_construct</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/">pip</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipe/">pipe</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/process/">process</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prvalue/">prvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytesseract/">pytesseract</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quit/">quit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/re/">re</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requests/">requests</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rvalue/">rvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/">signal</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql注入/">sql注入</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tensorflow/">tensorflow</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threading/">threading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie树/">trie树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uninstall/">uninstall</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unordered-multimap/">unordered_multimap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upcasting/">upcasting</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vbs/">vbs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/">vector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vfptr/">vfptr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wait/">wait</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlvalue/">xlvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人工智能/">人工智能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/仿函数/">仿函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/决策树算法/">决策树算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分配器/">分配器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原理/">原理</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反斜杠/">反斜杠</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文字符串/">回文字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多态/">多态</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典树/">字典树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/引用折叠/">引用折叠</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排列组合/">排列组合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/木马/">木马</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式识别/">模式识别</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞/">漏洞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/病毒/">病毒</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试/">笔试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓冲区溢出/">缓冲区溢出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪吃蛇/">贪吃蛇</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心算法/">贪心算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/迭代器/">迭代器</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/适配器/">适配器</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.83px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.67px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.67px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.83px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.83px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.67px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.67px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 12.5px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.83px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.5px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.5px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.67px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.83px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.83px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 12.5px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.67px;">error</a> <a href="/tags/estimator/" style="font-size: 11.67px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.67px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.83px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.5px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 19.17px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.5px;">numpy</a> <a href="/tags/office/" style="font-size: 10.83px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.17px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.83px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.83px;">overload</a> <a href="/tags/override/" style="font-size: 10.83px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.83px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 18.33px;">python</a> <a href="/tags/qt/" style="font-size: 13.33px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.67px;">re</a> <a href="/tags/requests/" style="font-size: 10.83px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.83px;">signal</a> <a href="/tags/sql/" style="font-size: 10.83px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.67px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.83px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.83px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.5px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.83px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/笔试/" style="font-size: 11.67px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.83px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.83px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.5px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
