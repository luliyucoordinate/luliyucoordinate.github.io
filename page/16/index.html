<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 16 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/16/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-04-11-malloc and free"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/11/2017-04-11-malloc and free/">malloc/free</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/11/2017-04-11-malloc and free/" class="article-date">
	  <time datetime="2017-04-10T16:00:00.000Z" itemprop="datePublished">四月 11, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SBH-small-block-heap"><a href="#SBH-small-block-heap" class="headerlink" title="SBH(small block heap)"></a>SBH(small block heap)</h1><h2 id="heap-init-和-sbh-heap-init"><a href="#heap-init-和-sbh-heap-init" class="headerlink" title="_heap_init() 和__sbh_heap_init()"></a>_heap_init() 和__sbh_heap_init()</h2><p>CRT为自己建立一个__crtheap，然后从中配置SBH所需的headers，regions作为管理用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _cdecl_heap_init(<span class="keyword">int</span> mtflag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(( _crtheap = HeapCreate( mtflag?<span class="number">0</span>: HEAP_NO_SERIALIZE,</span><br><span class="line">					BYTES_PER_PAGE, <span class="number">0</span> )) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( __sbh_heap_init() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HeapDestory(_crtheap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nNoMansLandSize 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderPrev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *szFilename;<span class="comment">//指向的文件名ioinit.c</span></span><br><span class="line">	<span class="keyword">int</span> nLine;<span class="comment">//上面文件的第几行,81行</span></span><br><span class="line">	<span class="keyword">size_t</span> nDataSize;<span class="comment">//客户要的内存大小</span></span><br><span class="line">	<span class="keyword">int</span> nBlockUse;<span class="comment">//memory block</span></span><br><span class="line">	<span class="keyword">long</span> IRequest;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> gap[nNoMansLandSize];</span><br><span class="line">	<span class="comment">/*followed by:</span></span><br><span class="line"><span class="comment">	*unsigned char data[nDataSize];</span></span><br><span class="line"><span class="comment">	*unsigned char anothergap[nNoMansLandSize];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;_CrtMemBlockHeader;</span><br></pre></td></tr></table></figure>
<p>至此我们终于知道了，在debug模式下，分配的内存块中多出来的部分</p>
<h2 id="关于第一块内存的分配"><a href="#关于第一块内存的分配" class="headerlink" title="关于第一块内存的分配"></a>关于第一块内存的分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRegion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> indGroupUse;<span class="comment">//0xffffffff，用于分割</span></span><br><span class="line">	<span class="keyword">char</span> cntRegionSize[<span class="number">64</span>];</span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];</span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span> <span class="title">grpHeadList</span>[32];</span></span><br><span class="line">&#125;REGION, *PREGION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cntEntries; <span class="comment">//记录分配次数，每分配一次加一，回收减一</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span> <span class="title">listHead</span>[64];</span></span><br><span class="line">&#125;GROUP, *PGROUP;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;LISTHEAD, *PLISTHEAD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sizeFront;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;ENTRY, *PENTRY;</span><br></pre></td></tr></table></figure>
<h2 id="归还操作系统"><a href="#归还操作系统" class="headerlink" title="归还操作系统"></a>归还操作系统</h2><p><strong>sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer group取出block完成分配，Defer指针会被取消(设为NULL);  
</strong>sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl__sbh_heap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(! (__sbh_pHeaderList = HeapAlloc(crtheap,<span class="number">0</span>,<span class="number">16</span>*<span class="keyword">sizeof</span>(HEADER)))</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	__sbh_pHeaderScan = __sbh_pHeaderList;</span><br><span class="line">	__sbh_pHeaderDefer = <span class="literal">NULL</span>;</span><br><span class="line">	__sbh_cntHeaderList = <span class="number">0</span>;</span><br><span class="line">	__sbh_sizeHeaderList = <span class="number">16</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-10-std_allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/10/2017-04-10-std_allocator/">std::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/10/2017-04-10-std_allocator/" class="article-date">
	  <time datetime="2017-04-09T16:00:00.000Z" itemprop="datePublished">四月 10, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在vc6的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在bc5中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在G2.9中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计，但是它内部并没有使用，而是使用的std::alloc。<br>在4.9版中叫__pool_alloc，但是这两个都不是标准分配器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: __n is permitted to be 0.  The C++ standard says nothing</span></span><br><span class="line"> <span class="comment">// about what the return value is when __n == 0.</span></span><br><span class="line">pointer</span><br><span class="line">allocate(size_type __n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect(__n &gt; <span class="keyword">this</span>-&gt;max_size(), <span class="literal">false</span>))</span><br><span class="line">		<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp*&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__n * <span class="keyword">sizeof</span>(_Tp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __p is not permitted to be a null pointer.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">deallocate(pointer __p, size_type)</span><br><span class="line">&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>alloc的设计<br>申请32bytes，由于pool为空，所以成功所求32<em>20</em>2+RoundUp(0(目前的申请总量)&gt;&gt;4) =1280，从中切出一个，另外的19个给list#3，剩余640备用。每次分配前都是先看原先的是否有剩余pool，从pool切给出来的数量永远在1~20之间，pool余量不足够的时候，先将pool余量给相应的list#，然后索取相应的内存。当内存不够时，往右边找一块给他。如果就近找不到的话，就会失败。但是这样的话，还有很多的空内存未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二级分配器</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __ALIGN = <span class="number">8</span> &#125;;<span class="comment">//定义常量,小区快的下限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __MAX_BYTES = <span class="number">128</span> &#125;;<span class="comment">//上限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __NFREELISTS = __MAX_BYTES/ __ALIGN &#125;;<span class="comment">//freelist的长度</span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> ((bytes) + _ALIGN<span class="number">-1</span>) &amp; ~(_ALIGN - <span class="number">1</span>));</span><br><span class="line"> 	&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">union</span> obj</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="keyword">union</span> obj* free_list_link;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">static</span> obj *<span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line"> 	<span class="comment">//计算list#</span></span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN<span class="number">-1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;<span class="comment">//指向pool头</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;<span class="comment">//指向pool尾</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		obj* result;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)<span class="comment">//改用第一级</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"> 		result = *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(result == <span class="number">0</span>_</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line"> 			<span class="keyword">return</span> r;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		*my_free_list = result-&gt;free_list_link;</span><br><span class="line"> 		<span class="keyword">return</span> (result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//回收的时候，把要回收的部分插入二级链表的头</span></span><br><span class="line"> 	<span class="comment">//函数内部没有做p指针的检查，如果这个p指针不是这个系统的，</span></span><br><span class="line"> 	<span class="comment">//如果他不是8的倍数的话，回收后再分配时会出问题，原来分配给list#1，</span></span><br><span class="line"> 	<span class="comment">//可能现在到了list#2</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span> deallocate(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		obj* q = (obj*)p;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			malloc_alloc::deallocate(p,n);</span><br><span class="line"> 			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list +FREELIST_INDEX(n);</span><br><span class="line"> 		q-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 		*my_free_list = q;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span>* reallocate(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz);<span class="comment">//略</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">char</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"> chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">char</span> *result;</span><br><span class="line"> 	<span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line"> 	<span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">if</span>( bytes_left &gt;= total_bytes)<span class="comment">//pool能否满足20个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span>( bytes_left &gt;= size)<span class="comment">//pool能否满足1个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		nobjs = bytes_left /size;</span><br><span class="line"> 		total_bytes = size * nobjs;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 	<span class="comment">//空pool或者为碎片</span></span><br><span class="line"> 		<span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"> 		<span class="comment">//将碎片挂接</span></span><br><span class="line"> 		<span class="keyword">if</span>( bytes_left &gt; <span class="number">0</span>)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line"> 			((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 			*my_free_list = (obj*)start_free;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//分配内存</span></span><br><span class="line"> 		start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"> 		<span class="keyword">if</span>( <span class="number">0</span> == start_free)<span class="comment">//分配失败的话，从freelist中找</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">int</span> i;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"><span class="comment">//try to make do with what we have.that can’t hurt.</span></span><br><span class="line"><span class="comment">//we do not try smaller requests,since that tends</span></span><br><span class="line"><span class="comment">//to result in disaster on muti-process machines.</span></span><br><span class="line"> 			<span class="keyword">for</span>( i = size; i &lt;= __MAX_BYTES; i+= __ALIGN)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line"> 				p = *my_free_list;</span><br><span class="line"> 				<span class="keyword">if</span>( <span class="number">0</span> != p)</span><br><span class="line"> 				&#123;</span><br><span class="line"> 					*my_free_list = p-&gt;free_list_link;</span><br><span class="line"> 					start_free = (<span class="keyword">char</span> *)p;</span><br><span class="line"> 					end_free = start_free + i;</span><br><span class="line"> 					<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			<span class="comment">//表示memory已经‘没有’了</span></span><br><span class="line"> 			end_free = <span class="number">0</span>;</span><br><span class="line"> 			start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		heap_size += bytes_to_get;</span><br><span class="line"> 		end_free = start_free + bytes_to_get;</span><br><span class="line"> 		<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">void</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)<span class="comment">//n已经是8的倍数</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">int</span> nobjs = <span class="number">20</span>;<span class="comment">//预设20个</span></span><br><span class="line"> 	<span class="keyword">char</span> *chunk = chunk_alloc(n, nobjs);</span><br><span class="line"> 	obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 	obj* result;</span><br><span class="line"> 	obj* current_obj;</span><br><span class="line"> 	obj* next_obj;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">if</span>( <span class="number">1</span>== nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"> 	my_free_list = free_list_link;</span><br><span class="line"> 	result = (obj*)chunk;</span><br><span class="line"> 	*my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line"> 	<span class="comment">//在chunk内建立freelist</span></span><br><span class="line"> 	<span class="keyword">for</span>( i = <span class="number">1</span>; ; ++i)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		current_obj = next_obj;</span><br><span class="line"> 		next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line"> 		<span class="keyword">if</span>( nobjs<span class="number">-1</span> == i)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = next_obj;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> (result);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:heap_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[_NFREELISTS]</span><br><span class="line">= &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; alloc;</span><br></pre></td></tr></table></figure>
<p>deallocate完全没有free，设计上的缺陷，没有变量记录freelist的起始位置</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-09-内存管理primitives"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/09/2017-04-09-内存管理primitives/">内存管理 primitives</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/09/2017-04-09-内存管理primitives/" class="article-date">
	  <time datetime="2017-04-08T16:00:00.000Z" itemprop="datePublished">四月 9, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSR_VER</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是static，可以通过全名调用，2.9ver</span></span><br><span class="line"><span class="keyword">void</span> *p4 = alloc::allocate(<span class="number">512</span>);</span><br><span class="line">alloc::deallocate(p4, <span class="number">512</span>);</span><br><span class="line"><span class="comment">//4.9ver 以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p5 = __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">9</span>);</span><br><span class="line">__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;.deallocate((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="New-expression"><a href="#New-expression" class="headerlink" title="New expression"></a>New expression</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//只有编译器可以这样调用ctor</span></span><br><span class="line"><span class="comment">//想要直接调用ctor，可以运用placement new；</span></span><br><span class="line"><span class="comment">//new(p)Complex(1,2);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::nothrow <span class="keyword">_t</span>&amp;)</span> _<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//nothrow struct is used as a function parameter to operator new to </span></span></span><br><span class="line"><span class="function"><span class="comment">//indicate that the function should return a null pointer to report</span></span></span><br><span class="line"><span class="function"><span class="comment">//an allocation failure ,rather than throw an exception</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">	    <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">	    &#123;       <span class="comment">// report no memory</span></span><br><span class="line">	            _THROW_NCEE(_XSTD bad_alloc, );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> expression</span><br><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line">pc-&gt;~Complex();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span>_<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Array-new-array-delete"><a href="#Array-new-array-delete" class="headerlink" title="Array new,array delete"></a>Array new,array delete</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex *pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//唤起3次ctor</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] pca;<span class="comment">//唤起3次dtor</span></span><br><span class="line"><span class="comment">//一下做法会造成内存泄漏，string的内部有指针</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> psa;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" class="img-fluid"><br></a></p>
<p>61h为cookie，用来记录空间的大小，最后一个字节用来记录内存是在使用，还是未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo *p = <span class="keyword">new</span> Demo[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" class="img-fluid"><br></a></p>
<p>第一个p指向的地址是00481c30，第二个p指向的地址是00481c34，如果写成delete p;的话，那么会从第一个p开始而不是第二个，就会出问题，多出一个3，这个3表示调用几次析构。如果Demo没有nontrivial dtor ,就不会记录3，也就是说，和上面的int类似，可以不加[]。<br>关于内存空间，必须要调节16的倍数，所以增加了pad这个东西。</p>
<h1 id="Placement-new"><a href="#Placement-new" class="headerlink" title="Placement new"></a>Placement new</h1><p>Placement new 允许我们将object建立于 allocated memory中没有所谓的placement delete，因为placement new根本没有分配memory亦或称呼placement new 对应的operator delete为placement delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>];</span><br><span class="line">Complex *pc = <span class="keyword">new</span>(buf)Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//等同于调用构造函数</span></span><br><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));<span class="comment">//没有做任何事</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> ,<span class="keyword">void</span> *loc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> loc; &#125;</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>
<p>关于placement new，或指为new(p)，或指为::operator new(size, void*)</p>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="重载-operator-new-operator-delete"><a href="#重载-operator-new-operator-delete" class="headerlink" title="重载::operator new/::operator delete"></a>重载::operator new/::operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myAlloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAlloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete"><a href="#重载operator-new-operator-delete" class="headerlink" title="重载operator new/operator delete"></a>重载operator new/operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete-1"><a href="#重载operator-new-operator-delete-1" class="headerlink" title="重载operator new[]/operator delete[]"></a>重载operator new[]/operator delete[]</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo[n];</span><br><span class="line">...</span><br><span class="line">Delete[] p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new()/delete()"></a>重载new()/delete()</h2><p>我们重载class member operator new(),前提是每一个版本的声明都必须是独特的参数列，其中第一个参数必须是size_t，其余参数以new所指定的placement arguments为初值.出现new()小括号内的便是所谓的placement argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo *pf = <span class="keyword">new</span> (<span class="number">300</span>,<span class="string">'c'</span>) Foo;<span class="comment">//第一个参数表所示Foo的大小</span></span><br><span class="line"><span class="comment">//一般重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="comment">//placement new()的标准写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> *start)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> start; &#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。他只能这样被调用，主要用来clean未完成创建的object所占的memory。即使operator delete() 未能一一对应operator new() ,编译器也不会报错，这样做的意思是放弃处理ctor发出的异常。  </p>
<p>Basic_string使用new(extra)<br>平时使用的string就是typdef  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Rep</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>( --ref == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> Rep* <span class="title">create</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep*</span><br><span class="line">basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">create(<span class="keyword">size_t</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">	extra = frob_size(extra + <span class="number">1</span>);</span><br><span class="line">	Rep *p = <span class="keyword">new</span>(extra) Rep;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> *<span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep::</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> s,<span class="keyword">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Allocator::allocate(s + extra * <span class="keyword">sizeof</span>();<span class="comment">//placement new的重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;class charT, class traits, class Allocator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">opreraotr <span class="keyword">delete</span>(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	Allocator::deallocate(ptr...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">1</span></span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">class Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Screen(<span class="keyword">int</span> x) :i(x) &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> get() &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Screen *next;</span><br><span class="line">	<span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Screen *Screen::freeSore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	Screen *p;<span class="comment">//这种设计多用了一个指针</span></span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = screenChunk *size;</span><br><span class="line">		freeStore = p = <span class="keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="keyword">new</span> <span class="keyword">char</span> [chunk]);</span><br><span class="line"><span class="comment">//将一大块分割后，用链表穿起来</span></span><br><span class="line">		<span class="keyword">for</span>(; p!= &amp;freeStore[screenChunk<span class="number">-1</span>]; ++p)</span><br><span class="line">			p-&gt;next = p +<span class="number">1</span>;</span><br><span class="line">		p-&gt;next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p,<span class="keyword">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将delete object插回</span></span><br><span class="line">	(<span class="keyword">static_cast</span> &lt;Screen*&gt;(p))-&gt;next = freeStore;</span><br><span class="line">	freeStore = <span class="keyword">static_cast</span>&lt;Screen*&gt;(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">2</span></span><br><span class="line">class Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	struct AirplaneRep</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> miles;</span><br><span class="line">		<span class="keyword">char</span> type;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		AirplaneRep rep;</span><br><span class="line">		Airplane *next;<span class="comment">//嵌入式指针，相对于前面的来说非常不错</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长</span></span><br><span class="line"><span class="comment">//度是AirplaneRep型态。</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数</span></span><br><span class="line"><span class="comment">//据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> getMiles() &#123; <span class="keyword">return</span> rep.miles;&#125;</span><br><span class="line">	<span class="keyword">char</span> getType() &#123; <span class="keyword">return</span> rep.type; &#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="built_in">set</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> m, <span class="keyword">char</span> t)</span><br><span class="line">	&#123;</span><br><span class="line">		rep.miles = m;</span><br><span class="line">		rep.type = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> *opertor <span class="keyword">new</span>(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="comment">//注意这里static，编译器默认也是static，原因在于，要在对象创建时调用，</span></span><br><span class="line"><span class="comment">//如果不是static，对象创建时，可能这个东西还在创建的过程中</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BLOCK_SIZE;	<span class="keyword">static</span> Airplane *headOfFreeList;</span><br><span class="line">&#125;;</span><br><span class="line">Airplane *Airplane::headOfFreeList;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Airplane::BLOCK_SIZE=<span class="number">512</span>;</span><br><span class="line"><span class="keyword">void</span> *Airplane::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当继承发生时</span></span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line">	Airplane *p = headOfFreeList;</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">		headOfFreeList = p-&gt;next;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Airplane *newBlock = <span class="keyword">static_cast</span>&lt;Airplane*&gt;</span><br><span class="line">		(::<span class="keyword">operator</span> <span class="keyword">new</span>(BLOCK_SIZE * <span class="keyword">sizeof</span>(Airplane));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;BLOCK_SIZE - <span class="number">1</span>;++i)</span><br><span class="line">			newBlock[i].next = &amp;newBlock[i+<span class="number">1</span>];</span><br><span class="line">		newBlock[BLOCK_SIZE<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">		p = newBlock;</span><br><span class="line">		headOfFreeList = &amp;newBlock[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Airplane::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(deadObject == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="keyword">operator</span> <span class="keyword">delete</span>(deadObject);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Airplane *carcass = <span class="keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);</span><br><span class="line">	carcass-&gt;next = headOfFreeList;</span><br><span class="line">	headOfFreeList = carcass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static-allocator"><a href="#static-allocator" class="headerlink" title="static allocator"></a>static allocator</h1><p>不同的class重写一遍几乎相同member operator new和member operator delete时，应该有方法将他们统一在一起，是他可以重用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">obj</span>* <span class="title">next</span>;</span><span class="comment">//与linux里的链表做法一样</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	obj* freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> CHUNK = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> *allocator::allocate(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	obj *p;</span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = CHUNK *size;</span><br><span class="line">		freeStore = p = (obj*)<span class="built_in">malloc</span>(chunk);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; (CHUNK<span class="number">-1</span>); +i)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = (obj*)((<span class="keyword">char</span>*)p+size);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	((obj*)p)-&gt;next = freeStore;</span><br><span class="line">	freeStore = (obj*)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Foo可以这样写了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pHead, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    &#123; <span class="keyword">return</span> myAlloc.deallocate(pHead, size); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做就方便了很多</p>
<h1 id="Macro-for-static-allocator"><a href="#Macro-for-static-allocator" class="headerlink" title="Macro for static allocator"></a>Macro for static allocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\表示续行符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_POOL_ALLOC()\</span></span><br><span class="line"><span class="keyword">public</span>:\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123; myAlloc.deallocate(p, <span class="number">0</span>); &#125;\</span><br><span class="line"><span class="keyword">protected</span>:\</span><br><span class="line">	<span class="keyword">static</span> allocator myAlloc;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name)\</span></span><br><span class="line">allocator class_name::myAlloc;</span><br></pre></td></tr></table></figure>
<p>原来的变成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DECLARE_POOL_ALLOC()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">long</span> L;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(<span class="keyword">long</span> l) : L(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">IMPLEMENT_POOL_ALLOC(Foo)</span><br></pre></td></tr></table></figure>
<h1 id="New-handler"><a href="#New-handler" class="headerlink" title="New handler"></a>New handler</h1><p>当operator new 没有能力分配申请的memory，会抛出异常std::bad_alloc execption以仍然可以让编译器new(nothrow) Foo;<br>抛出异常之前会调用一个可由client指定的handler，以下是new handler的形式和设定方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>设计良好的new handler只有俩个选择：<br>让更多的memory可用 调用abort()和exit()</p>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h1><p>It is not only for ctor and assignments,but also apllies to operator new/new[],operator delete/delete[] and their overloads</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo() = <span class="keyword">default</span>;<span class="comment">//表示使用默认版本，如果没有的话使用编译器合成版</span></span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示不使用这个函数 </span></span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">	~Foo()=defalut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-08-cast"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/08/2017-04-08-cast/">static_cast,dynamic_cast,reinterpret_cast和const_cast</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/08/2017-04-08-cast/" class="article-date">
	  <time datetime="2017-04-07T16:00:00.000Z" itemprop="datePublished">四月 8, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。<br>同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。</p>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p>用法：static_cast \&lt;typeid> (expression)<br>说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。<br>用途：  </p>
<ol>
<li>用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。</li>
<li>用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。</li>
<li>可以把空指针转换成目标类型的空指针(null pointer)。</li>
<li>把任何类型的表达式转换成void类型。<br>注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。</li>
</ol>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>用法：dynamic_cast\&lt;typeid> (expression)<br>说明：该运算符把expression转换成typeid类型的对象。typeid必须是类的指针、类的引用或者void*。如果typeid是类的指针类型，那么expression也必须是指针，如果typeid是一个引用，那么expression也必须是一个引用。一般情况下，dynamic_cast用于具有多态性的类(即有虚函数的类)的类型转换。  </p>
<p>dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。先看RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换,例如从派生类指针转换成基类指针。而这种转换其实并不需要dynamic_cast参与。也就是说,dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的。</p>
<p>用途：主要用于类层次之间的up-casting和down-casting，还可以用于类之间的交叉转换。在进行down-casting时，dynamic_cast具有类型检查的功能，比static_cast更安全。检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转 换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。<br>注意：dynamic_cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>用法：reinterpret_cast \&lt;typeid>(expression)<br>说明：转换一个指针为其他类型的指针，也允许将一个指针转换为整数类型，反之亦然。这个操作符能够在非相关的类型之间进行转换。操作结果只是简单的从一个指针到<br>别的指针的值的二进制拷贝，在类型之间指向的内容不做任何类型的检查和转换。这是一个强制转换。使用时有很大的风险，慎用之。<br>注意：reinterpret _cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>用法：const_cast\&lt;typeid>(expression)<br>说明：这个类型操纵传递对象的const属性，或者是设置或者是移除。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class C&#123;…&#125;</span><br><span class="line"><span class="keyword">const</span> C* a = <span class="keyword">new</span> C;</span><br><span class="line">C* b = <span class="keyword">const_cast</span>&lt;C*&gt;(a);</span><br></pre></td></tr></table></figure>
<p>如果将上面的const_cast转换成其他任何其他的转换，编译都不能通过，出错的信心大致如下：</p>
<p>“…cannot convert from ‘const class C <em>‘ to ‘class C </em>‘”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _base;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _derived;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _derived &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Base b1;</span><br><span class="line">     Derived d1;</span><br><span class="line">     <span class="keyword">int</span> aInt = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">long</span> aLong = <span class="number">11</span>;</span><br><span class="line">     <span class="keyword">float</span> aFloat = <span class="number">11.11f</span>;</span><br><span class="line">     <span class="keyword">double</span> aDouble = <span class="number">12.12</span>;</span><br><span class="line">     Derived* pd = <span class="keyword">static_cast</span>&lt;Derived*&gt;(&amp;b1);     <span class="comment">// down-casting  不安全</span></span><br><span class="line">     Base* pb = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;d1);       <span class="comment">// up-casting   安全</span></span><br><span class="line">     Derived&amp; d = <span class="keyword">static_cast</span>&lt;Derived&amp;&gt;(b1);  <span class="comment">// down-casting   不安全</span></span><br><span class="line">     Base&amp; b = <span class="keyword">static_cast</span>&lt;Base&amp;&gt;(d1);   <span class="comment">// up-casting    安全</span></span><br><span class="line"></span><br><span class="line">     aInt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(aFloat);        <span class="comment">// 基本数据类型转换</span></span><br><span class="line">     <span class="keyword">void</span>* sth = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;aDouble);    <span class="comment">// 将double指针类型转换成void指针类型</span></span><br><span class="line">     <span class="keyword">double</span>* bDouble = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(sth);<span class="comment">// 将void指针类型转换成double指针类型</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; *bDouble &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     Base* pb1 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(&amp;d1);</span><br><span class="line">     <span class="comment">//Derived* pd1 = dynamic_cast&lt;Derived*&gt;(&amp;b1); // 编译时有warning，运行时出错</span></span><br><span class="line">     <span class="keyword">int</span> bInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(pb1);     <span class="comment">// 将地址或指针转换成整数</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; bInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base*&gt;(bInt);   <span class="comment">// 将整数转换成地址或指针</span></span><br><span class="line">     <span class="keyword">int</span>* cInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;aFloat);<span class="comment">// 这个转换的结果会出乎意料</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)*cInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">const</span> Base* bBase = <span class="keyword">new</span> Base();</span><br><span class="line">     Base* cBase = <span class="keyword">const_cast</span>&lt;Base*&gt;(bBase);</span><br><span class="line">     <span class="comment">//Base* dBase = dynamic_cast&lt;Base*&gt;(bBase);  // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* eBase = static_cast&lt;Base*&gt;(bBase);      // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* fBase = reinterpret_cast&lt;Base*&gt;(bBase);    // 不能通过编译</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-06-分配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/06/2017-04-06-分配器/">分配器 allocators</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/06/2017-04-06-分配器/" class="article-date">
	  <time datetime="2017-04-05T16:00:00.000Z" itemprop="datePublished">四月 6, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span>:<span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>:<span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">deque</span>:<span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		typenaem _Alloc = <span class="built_in">std</span>::allocator&lt;_Key&gt;&gt;</span><br><span class="line">class <span class="built_in">set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		<span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">map</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Value&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_set</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Key&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_map</span></span><br></pre></td></tr></table></figure>
<p>一般写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc1;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>);</span><br><span class="line">alloc1.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>特殊写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__pool_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__mt_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br></pre></td></tr></table></figure>
<p>不建议用分配器，应该用容器，new malloc</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分配器/">分配器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-04-适配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/04/2017-04-04-适配器/">适配器 adapters</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/04/2017-04-04-适配器/" class="article-date">
	  <time datetime="2017-04-03T16:00:00.000Z" itemprop="datePublished">四月 4, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="容器的适配器：stack，queue"><a href="#容器的适配器：stack，queue" class="headerlink" title="容器的适配器：stack，queue"></a>容器的适配器：stack，queue</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">//底层容器deque</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数适配器binder2nd"><a href="#函数适配器binder2nd" class="headerlink" title="函数适配器binder2nd"></a>函数适配器binder2nd</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">binder2nd</span>&lt;Operation&gt; <span class="title">bind2nd</span> (<span class="title">const</span> <span class="title">Operation</span>&amp; <span class="title">op</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//辅助函数，让user更方便的使用binder2nd</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line"><span class="comment">//typename 原因在于不知道后面的类型，所以要告诉编译器他是一个typename</span></span><br><span class="line">	<span class="keyword">return</span> binder2nd&lt;Operation&gt;(op, arg2_type(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">bind2nd</span> :</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">									<span class="keyword">typename</span> Operation::result_type&gt;</span><br><span class="line"><span class="comment">//注意这里的继承，如果这个functor还可以被别人使用的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Operation op;<span class="comment">//内部成员</span></span><br><span class="line">	<span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	binder2nd(<span class="keyword">const</span> Operation&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type)</span><br><span class="line">	: op(x), value(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Operation::result_type</span><br><span class="line">	<span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> op(x, value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数适配器not1"><a href="#函数适配器not1" class="headerlink" title="函数适配器not1"></a>函数适配器not1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">unary_negate</span>&lt;Predicate&gt;<span class="title">not1</span>(<span class="title">const</span> <span class="title">Predicate</span>&amp; <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unary_negate</span></span></span><br><span class="line"><span class="class">:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Predicate pred;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//explicit关键字的作用就是防止类构造函数的隐式自动转换</span></span><br><span class="line">	explicit unary_negate(const Predicate&amp; x) : pred(x) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> !pred(x); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="新型适配器bind"><a href="#新型适配器bind" class="headerlink" title="新型适配器bind"></a>新型适配器bind</h2><p>Since c++11  </p>
<p><functional>bind —–&gt;<functional>binder1st  </functional></functional></p>
<p><functional>bind —–&gt;<functional>binder2nd  </functional></functional></p>
<p><functional>bind —–&gt;<functional>bind1st  </functional></functional></p>
<p><functional>bind —–&gt;<functional>bind2nd</functional></functional></p>
<p>可以绑定</p>
<ol>
<li>functions </li>
<li>functions objects </li>
<li>member functions ，_1必须是某个object的地址</li>
<li>data members，_1必须是某个object的地址</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::bind</span></span></span><br><span class="line"><span class="comment">// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> a,b;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...占位符</span></span><br><span class="line">  <span class="comment">// binding functions:</span></span><br><span class="line">  <span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,_1,<span class="number">2</span>);               <span class="comment">// returns x/2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind (my_divide,_2,_1);            <span class="comment">// returns y/x</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt; (my_divide,_1,_2);     <span class="comment">// returns int(x/y)</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// binding members:</span></span><br><span class="line">  <span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind (&amp;MyPair::multiply,_1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/适配器/">适配器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-03-仿函数"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/03/2017-04-03-仿函数/">仿函数 functors</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/03/2017-04-03-仿函数/" class="article-date">
	  <time datetime="2017-04-02T16:00:00.000Z" itemprop="datePublished">四月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="仿函数functors"><a href="#仿函数functors" class="headerlink" title="仿函数functors"></a>仿函数functors</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算数类arithmetic</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span>:</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span>:</span> <span class="keyword">public</span> binary_function&lt; T, T,T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//逻辑运算类logical</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function &lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//相对关系类relational</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T , T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Stl的仿函数都是继承一个类<br>自己写的话也要这样做，才可以融入stl</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//一个操作数，如对一个东西取非</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Stl规定每个adaptable function都应该挑选适当的继承。这种继承没有任何的坏处，他的空间没有变大。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/仿函数/">仿函数</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-02-迭代器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/02/2017-04-02-迭代器/">迭代器 iterators</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/02/2017-04-02-迭代器/" class="article-date">
	  <time datetime="2017-04-01T16:00:00.000Z" itemprop="datePublished">四月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="迭代器的种类"><a href="#迭代器的种类" class="headerlink" title="迭代器的种类"></a>迭代器的种类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forword_iterator_tag</span> :</span><span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" class="img-fluid"><br></a></p>
<h1 id="迭代器对算法的影响"><a href="#迭代器对算法的影响" class="headerlink" title="迭代器对算法的影响"></a>迭代器对算法的影响</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIteartor&gt;:</span>:difference_type</span><br><span class="line">__distance(InputIterator first, InputIterator last,</span><br><span class="line">			input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(fisrt != last)</span><br><span class="line">	&#123;</span><br><span class="line">		++first; ++n; <span class="comment">///数据量一大的话,这样效率会很低.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;RandomAccessIterator&gt;:</span>:difference_type</span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">			random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">distance(InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> </span><br><span class="line"><span class="comment">//取出迭代器的分类</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;;:iterator_category category;</span><br><span class="line">	<span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里虽然只写了两种，但是由于前面图例的继承关系,所以是可以的</p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" class="img-fluid"><br></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">temlplate&lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">destory</span>(<span class="title">FI</span> <span class="title">first</span>, <span class="title">FI</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__destory(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">destory</span>(<span class="title">T</span>* <span class="title">pointer</span>)</span></span><br><span class="line"><span class="class">&#123;</span> pointer-&gt;~T(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Itr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Itr&gt;:</span>:value_type*</span><br><span class="line">value_type(<span class="keyword">const</span> Itr&amp;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span></span><br><span class="line">	&lt;<span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::valur_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">char</span> *)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(wchar *,wchar *)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class">__<span class="title">destory_aux</span>(<span class="title">FI</span>, <span class="title">FI</span>,__<span class="title">true_type</span>)&#123;</span>&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class">__<span class="title">destory__aux</span>(<span class="title">FI</span> <span class="title">first</span>,<span class="title">FI</span> <span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>(; first &lt;last; ++first)</span><br><span class="line">		destory(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destory</span>(<span class="title">FI</span> <span class="title">first</span>, <span class="title">FI</span> <span class="title">last</span>, <span class="title">T</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> </span><br><span class="line">	__type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">	__destory_aux(first,last, trivial_destructor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法源码中对于迭代器的分类的暗示，没有强制要求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">distance (InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">	<span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">RandomAccessIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(first != last)</span><br><span class="line">	&#123;</span><br><span class="line">		__introsort_loop(first, last, value_type(first), __lg(last-first) * <span class="number">2</span>);</span><br><span class="line">		__final_insertion_sort(first, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于reverse-iterator，rbegin-，rend"><a href="#关于reverse-iterator，rbegin-，rend" class="headerlink" title="关于reverse iterator，rbegin()，rend"></a>关于reverse iterator，rbegin()，rend</h1><p><a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" class="img-fluid"><br></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse_iterator</span><br><span class="line">rbegin()</span><br><span class="line">&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//用了iterator adapter</span></span><br><span class="line">reverse_iterator</span><br><span class="line">rend()</span><br><span class="line">&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-01-算法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/01/2017-04-01-算法/">算法 algorithms</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/01/2017-04-01-算法/" class="article-date">
	  <time datetime="2017-03-31T16:00:00.000Z" itemprop="datePublished">四月 1, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Algorithm 看不见containers，所以他需要的一切信息都必须从iterators取得，而iterators必须回答algorithm的所有问题，才能搭配这个algorithm的所有操作，可以看最前面的一个图。从语言层面看，algorithm是一个function template</p>
<h1 id="算法accumulate"><a href="#算法accumulate" class="headerlink" title="算法accumulate"></a>算法accumulate</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span> (<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">T</span> <span class="title">init</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>( ; first != last; ++first)</span><br><span class="line"><span class="comment">//将元素累加至初值init身上</span></span><br><span class="line">		init = init + *first;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line">通常算法有两个版本，另一个允许增加函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">T</span> <span class="title">init</span>,</span></span><br><span class="line"><span class="class">				<span class="title">BinaryOperation</span> <span class="title">binary</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>( ; first != last; ++first)</span><br><span class="line"><span class="comment">//将元素累加至初值init身上</span></span><br><span class="line">		init = binary_op(init, *first);</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法for-each"><a href="#算法for-each" class="headerlink" title="算法for_each"></a>算法for_each</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">for_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">					<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">					<span class="title">Function</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>( ; first != last ; ++first)</span><br><span class="line">		f(*first);</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">range-based <span class="keyword">for</span> statement</span><br><span class="line">since c++<span class="number">11</span></span><br><span class="line"><span class="keyword">for</span>( decl : coll )</span><br><span class="line">&#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法replace，replace-if，replace-copy"><a href="#算法replace，replace-if，replace-copy" class="headerlink" title="算法replace，replace_if，replace_copy"></a>算法replace，replace_if，replace_copy</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">关于算法的命名规则</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>( ;first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span>(*first == old_value)</span><br><span class="line">			*first = new_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">replace_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">								<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">								<span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">								<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>,</span></span><br><span class="line"><span class="class">								<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">//等于<span class="title">old_value</span>的都以<span class="title">new_value</span>放入新的存储空间</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>(; fisrt != last; ++first, ++result)</span><br><span class="line">		*result = *first == old_value? new_value:*first;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Predicate</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace_if</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">predicate</span> <span class="title">pred</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last ; ++first)</span><br><span class="line">		<span class="keyword">if</span>(pred(*first))</span><br><span class="line">			*first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法count，count-if"><a href="#算法count，count-if" class="headerlink" title="算法count，count_if"></a>算法count，count_if</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">count(InputIterator first, InputIterator last,</span><br><span class="line">		<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span>(*first == value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">count_if( InputIterator first, InputIterator last,</span><br><span class="line">			Predicate pred)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>( ; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span>(pred(*first))</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器不带成员函数count"><a href="#容器不带成员函数count" class="headerlink" title="容器不带成员函数count()"></a>容器不带成员函数count()</h2><p>array，vector，list，forward_list，deque</p>
<h2 id="容器带有成员函数"><a href="#容器带有成员函数" class="headerlink" title="容器带有成员函数"></a>容器带有成员函数</h2><p>set/mutiset<br>map/mutimap<br>unordered_set/unordered_mutiset<br>unordered_map/unordered_mutimap</p>
<h1 id="算法find，find-if"><a href="#算法find，find-if" class="headerlink" title="算法find，find_if"></a>算法find，find_if</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">					<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">					<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">while</span>(first != last &amp;&amp; *first != value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Precidate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">					<span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">					<span class="title">Predicate</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">while</span>( first != last &amp;&amp; !pred(*first))</span><br><span class="line">	&#123;</span><br><span class="line">		++first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器不带成员函数find"><a href="#容器不带成员函数find" class="headerlink" title="容器不带成员函数find()"></a>容器不带成员函数find()</h2><p>array，vector，list，forward_list，deque</p>
<h2 id="容器带有成员函数-1"><a href="#容器带有成员函数-1" class="headerlink" title="容器带有成员函数"></a>容器带有成员函数</h2><p>set/mutiset<br>map/mutimap<br>unordered_set/unordered_mutiset<br>unordered_map/unordered_mutimap</p>
<h1 id="算法sort"><a href="#算法sort" class="headerlink" title="算法sort"></a>算法sort</h1><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) </span><br><span class="line">  &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Size</span> __<span class="title">lg</span>(<span class="title">Size</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    Size k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) ++k;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) </span><br><span class="line">	  &#123;</span><br><span class="line">		    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) </span><br><span class="line">		    &#123;</span><br><span class="line">			      partial_sort(__first, __last, __last);</span><br><span class="line">			      <span class="keyword">return</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">		    --__depth_limit;</span><br><span class="line">		    _RandomAccessIter __cut =</span><br><span class="line">		      __unguarded_partition(__first, __last,</span><br><span class="line">		                            _Tp(__median(*__first,</span><br><span class="line">		                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">		                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">		    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">		    __last = __cut;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断元素规模是否大于阀值<strong>stl_threshold，</strong>stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。若元素规模大于<strong>stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。若没有超过递归调用深度，则调用函数</strong>unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。<br>__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">Tp</span> __<span class="title">pivot</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">	        ++__first;</span><br><span class="line">	    --__last;</span><br><span class="line">	    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">	        --__last;</span><br><span class="line">	    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">	        <span class="keyword">return</span> __first;</span><br><span class="line">	    iter_swap(__first, __last);</span><br><span class="line">	    ++__first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。 </p>
<p>容器不带成员函数sort()<br>array，vector，deque</p>
<p>以下四个默认排好了<br>set/mutiset<br>map/mutimap<br>unordered_set/unordered_mutiset<br>unordered_map/unordered_mutimap</p>
<p>容器带有成员函数<br>list，forward_list</p>
<h2 id="算法binary-search"><a href="#算法binary-search" class="headerlink" title="算法binary_search"></a>算法binary_search</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="keyword">if</span> value exits in sorted sequence</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>( <span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">					<span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">					<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	first = <span class="built_in">std</span>::lower_bound(first, last, val);</span><br><span class="line"><span class="comment">//获得的iterator所指的位置，既非end，目标val也不是小于首元素</span></span><br><span class="line">	<span class="keyword">return</span> (first != last &amp;&amp; !(val &lt;*first));</span><br><span class="line">&#125;</span><br><span class="line">在lower_bound之前做一次!(val &lt;*first)会更好</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> </span></span><br><span class="line"><span class="class"><span class="title">lower_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">			<span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">			<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ForwardIterator it;</span><br><span class="line">	iterator_traits&lt;ForwardIterator&gt;::difference_type count,step;</span><br><span class="line">	count = distance(first, last);</span><br><span class="line">	<span class="keyword">while</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		it = first;step = count /<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(*it &lt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			first = ++it;</span><br><span class="line">			count -= step +<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count = step;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于lower_bound表示的是一个排好的序列里，相同的value的最低点，而upper_bound<br>则相反。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-03-31-容器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/03/31/2017-03-31-容器/">容器 containers</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/03/31/2017-03-31-容器/" class="article-date">
	  <time datetime="2017-03-30T16:00:00.000Z" itemprop="datePublished">三月 31, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="stl-六大部件"><a href="#stl-六大部件" class="headerlink" title="stl 六大部件"></a>stl 六大部件</h1><p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jdem29sj20j80dl7cf.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jdem29sj20j80dl7cf.jpg" class="img-fluid"><br></a></p>
<h1 id="容器containers"><a href="#容器containers" class="headerlink" title="容器containers"></a>容器containers</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">前闭后开区间</span><br><span class="line">Begin指向第一个元素，end指向最后一个元素的下一个元素</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">...</span><br><span class="line">Container&lt;T&gt;::iterator ite = c.begin();</span><br><span class="line"><span class="keyword">for</span>(; ite != c.end(); ite++)</span><br><span class="line">...</span><br><span class="line">Ranged-based <span class="keyword">for</span> statement c++<span class="number">11</span></span><br><span class="line">And <span class="keyword">auto</span> keyword</span><br><span class="line"><span class="keyword">for</span>( decl : coll) </span><br><span class="line">&#123; statement &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> elem : vec )</span><br><span class="line">&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; elem : vec )</span><br><span class="line">&#123; elem *= <span class="number">3</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jg3srgsj20py0cik4d.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jg3srgsj20py0cik4d.jpg" class="img-fluid"><br></a></p>
<p>Associative containers 使用红黑树Unordered containers 哈希表separate chaining,注意对于vector 和list，forword list用其自带的排序，而对于deque使用全局的排序queue和stack内部使用了deque，而且他们的内部都不会提供iterator</p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe7jg42m1zj20fi0ayq3d.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe7jg42m1zj20fi0ayq3d.jpg" class="img-fluid"><br></a></p>
<p>在c++11中，slist名为forward_list，hash_set，hash_map名为unordered_set，unordered_man，hash_mutiset，hash_mutimap名为unordered_mutiset，unordered_multimap</p>
<h2 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">是一个环形双向链表</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	self &amp;<span class="keyword">operator</span>++() <span class="comment">//prefix</span></span><br><span class="line">	&#123; node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">//postfix</span></span><br><span class="line">&#123; self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果iterator不是一个类的话，那他的内部就不可以使用typedef，例如指针，指针不是一个类，但指针是一种退化的iterator。所以传给算法的时候，有可能是一个指针而不是迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">algorithm (T first, T last)</span><br><span class="line">&#123;</span><br><span class="line">	T::iterator_category;</span><br><span class="line">	T::pointer;</span><br><span class="line">	T::reference;</span><br><span class="line">	T::value_type;</span><br><span class="line">	T::difference_type;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候就引入了traits萃取机</p>
<h2 id="Taits-特性"><a href="#Taits-特性" class="headerlink" title="Taits 特性"></a>Taits 特性</h2><p>Iterator traits用以分离class iterators和non-class iterators,这个traits机器不许有分辨iterator是一个class iterator T或是一个native pointer to T</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_tarits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//to pointer</span></span><br><span class="line">Partial specialization 偏特化</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;<span class="comment">//这里是T不是const T</span></span><br><span class="line"><span class="comment">//如果是const 那他就不能被赋值，那就没有用了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//于是但需要知道value type，这样写</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,...&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_taits&lt;T&gt;::value_type v1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器vector</h2><p>如果空间不够的话，需要向操作系统寻求两倍大的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type*	iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp;	reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span>		size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;<span class="comment">//实际大小</span></span><br><span class="line">	iterator end_of_storage;<span class="comment">//理论大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> size_type( end() - begin()); &#125;<span class="comment">//这样确定size永远不会改变</span></span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> size_type( end_of_storge - begin()); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> beign() == end(); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector’s iterator</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type *iterator;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用的是指针萃取机</p>
<h2 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> _Tp			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp*		pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type*	iterator;</span><br><span class="line">	</span><br><span class="line">	value_type _M_instance[_Nm ? _Nm : <span class="number">1</span> ];</span><br><span class="line">	</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> iterator(&amp; _M_instance[<span class="number">0</span>]; &#125;</span><br><span class="line">	</span><br><span class="line">	iterator end()</span><br><span class="line">	&#123; <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有构造和析构<br>使用必须指定大小，因为她不可扩充</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myArray;</span><br><span class="line"><span class="keyword">auto</span> ite = myArray.begin();</span><br><span class="line">ite += <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ite;</span><br></pre></td></tr></table></figure>
<p>使用的是指针萃取机</p>
<h2 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器deque</h2><p>双向开口的空间</p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jktznx7j20qr0gn18c.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jktznx7j20qr0gn18c.jpg" class="img-fluid"><br></a></p>
<p>每个vector里面是一个指针，内存不够的话，分配一个buf，让指针指向buf</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span>? <span class="keyword">size_t</span>(<span class="number">512</span> /sz) :<span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;class T, class Alloc = alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;<span class="comment">//如果是0使用默认设置，如果不是，使用上面的算式</span></span><br><span class="line">class <span class="built_in">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSize&gt; iteartor;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> pointer *map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	map_pointer <span class="built_in">map</span>;</span><br><span class="line">	size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iterator begin() &#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	iterator end() &#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	size_type size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>’s iterator</span><br><span class="line"><span class="keyword">template</span> &lt;class T, class Ref, class Ptr, <span class="keyword">size_t</span> BufSiz&gt;</span><br><span class="line">struct __deque_iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;<span class="comment">//注意这里random</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line">	</span><br><span class="line">	T* cur;</span><br><span class="line">	T* first;</span><br><span class="line">	T* last;</span><br><span class="line">	map_pointer node;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Deque是如何模拟连续空间的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>[](size_type n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> start[difference_type(n)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator tmp = finish;</span><br><span class="line">	--tmp;</span><br><span class="line">	<span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> finish - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> finish == start;</span><br><span class="line">&#125;</span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer opertor-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">difference_type</span><br><span class="line"><span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">	(cur - first) + (x.last - x.cur );</span><br><span class="line">&#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	++cur;</span><br><span class="line">	<span class="keyword">if</span>(cur == last)</span><br><span class="line">	&#123;	</span><br><span class="line">		set_node(node + <span class="number">1</span>);</span><br><span class="line">		cur = first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur == last)</span><br><span class="line">	&#123;	</span><br><span class="line">		set_node(node - <span class="number">1</span>);</span><br><span class="line">		cur = last;</span><br><span class="line">	&#125;</span><br><span class="line">	--cur;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node = new_node;</span><br><span class="line">	first = *new_node;</span><br><span class="line">	last = first + difference_type(buffer_size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器queue，stack"><a href="#容器queue，stack" class="headerlink" title="容器queue，stack"></a>容器queue，stack</h2><p>就是变相的deque，deque是双进双出，stack先进后出，queue先进先出<br>Stack和queue都可以选择list或queue</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;&gt; c;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; c;<span class="comment">//默认是deque</span></span><br></pre></td></tr></table></figure>
<p>Stack或queue都不允许遍历，所以也就不提供iterator<br>Stack可以选择vector作为底部结构，但是queue不可以<br>Stack与queue都不可以使用set或map作为底部支撑</p>
<h2 id="容器rb-tree"><a href="#容器rb-tree" class="headerlink" title="容器rb_tree"></a>容器rb_tree</h2><p>红黑数是平衡二叉树中的常用的一种<br>平衡二叉树的特征：配列规则有利search和insert，并保持适度平衡。我们不应使用rb_tree的iterators改变元素值。变成层面并未阻绝此事。因为rb_tree即将为set和map服务，而map允许元素的data被改变，只有元素的key才是不可被改编的。Rb_tree提供两种insertion操作：insert_unique和insert_equal。前者表示节点的key一定是整个tree中独一无二的，后者便是节点的key可重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, //<span class="title">key</span>的类型</span></span><br><span class="line"><span class="class">		  <span class="title">class</span> <span class="title">Value</span>,//<span class="title">value</span>是<span class="title">data</span>和<span class="title">key</span>一起，这里指<span class="title">value</span>的类型</span></span><br><span class="line"><span class="class">		  <span class="title">class</span> <span class="title">KeyOfValue</span>, //<span class="title">key</span>要怎么取出</span></span><br><span class="line"><span class="class">		  <span class="title">class</span> <span class="title">Compare</span>, //<span class="title">key</span>怎么比大小</span></span><br><span class="line"><span class="class">		  <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node *link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	size_type node_count;</span><br><span class="line">	link_type header;</span><br><span class="line">	Compare key_compare;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rb_tree&lt;<span class="keyword">int</span>, <span class="comment">//key的类型</span></span><br><span class="line">		<span class="keyword">int</span>, <span class="comment">//value的类型</span></span><br><span class="line">		identity&lt;<span class="keyword">int</span>&gt;, <span class="comment">//注意这个gc下的，但是可以自己写</span></span><br><span class="line">		less&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">		alloc&gt;</span><br><span class="line">myTree;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">identity</span>:</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	tyepdef Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意没有必要这样做，只是为了更加了解内部原理</p>
<h2 id="容器set、mutiset"><a href="#容器set、mutiset" class="headerlink" title="容器set、mutiset"></a>容器set、mutiset</h2><p>以rb_tree为底层结构，因此有元素自动排序特性。排序的依据是key，而set/mutiset元素的value和key合一：value就是key<br>Set/mutiset提供遍历操作及iterators<br>我们无法使用set/mutiset的iterators改变元素值。Set/mutiset的iterator是其底部的re_tree的const iterator，就是为了禁止user对其赋值。Set元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。Mutiset元素的key可以重复，因此insert用的是rb_tree的insert_equal</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;	<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Key value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">	<span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </span><br><span class="line">					identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type ::const_iterator iterator;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="容器map，mutimap"><a href="#容器map，mutimap" class="headerlink" title="容器map，mutimap"></a>容器map，mutimap</h2><p>Map/mutimap以rb_tree为底层结构，因此有元素自动排序的特性，排序的依据是key<br>Set/mutiset提供遍历操作及iterators<br>我们无法使用map/mutimap的iterators改变元素的key但可以改变data。因此map/mutimap内部自动将user指定的keytype设为const，如此便能禁止user对元素的key赋值。map元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。mutimap元素的key可以重复，因此insert用的是rb_tree的insert_equal</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;	<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> T data_type;</span><br><span class="line">	<span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;<span class="comment">//注意这里将data和key合成为value</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">						select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在mutimap中不可以用[]做insert，必需使用insert<br>在map中可以<br>Allow for easy lookup with the subscript(@c[])operator.Returns data associated with the key specified subscript.If the key does not exit, a pair with that key is created using default values, which is then returned.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mapped_type&amp;</span><br><span class="line"><span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">	iterator __i = lower_bound(__k);</span><br><span class="line">	<span class="keyword">if</span>(__i == end() || key_comp()(__k, (*__i).first))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpluscplus &gt;= 201103L</span></span><br><span class="line">	__i = M_t....</span><br><span class="line">#<span class="keyword">else</span> </span><br><span class="line">	__i = insert(__i, value_type(__k, mapped_type()));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> (*__i).second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lower_bound是二分查找，在sorted[first, last)中查找元素value，找到返回一个iterator指向其中的第一个元素。如果没有这样的元素存在，他就会传回最适合按插这个key的iterator。<br>但是可以从源代码中看出，使用[]后速度变慢了，调用了lower_bound</p>
<h2 id="容器hashtable"><a href="#容器hashtable" class="headerlink" title="容器hashtable"></a>容器hashtable</h2><p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jku891ij20od090mxf.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jku891ij20od090mxf.jpg" class="img-fluid"><br></a></p>
<p>如果多个元素放在同一个位置就会发生碰撞，但是如果采用移动位置的方式就会降低效率，最后的方法是，每一个节点做一个链表，把碰撞的元素放入链表中，也就是separate chaining。但是这样做的话，可能会出现单一链表过长，所以就出现了buckets。<br>如果按插的元素个数大于buckets个数，于是rehashing，所有的元素要重新按插，这是一件花时间的事情。buckets的数目是按照素数来的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFcn</span>,//<span class="title">HashFcn</span>计算<span class="title">hashcode</span></span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>,//<span class="title">ExtractKey</span>取出<span class="title">key</span>的方法</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hashtable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">	<span class="built_in">vector</span>&lt;node*, Alloc&gt; buckets;</span><br><span class="line">	size_type num_elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buckets.size(); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">			<span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hashtable_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">	node *cur;<span class="comment">//指向节点</span></span><br><span class="line">	hashtable *ht;<span class="comment">//指向buckets，这样做和前面的deque做法类似</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__hashtable_node *next;<span class="comment">//这个是gc的版本，在vc下面时双向链表</span></span><br><span class="line">	Value val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">hashtable&lt;<span class="keyword">const</span> <span class="keyword">char</span> *,</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *,</span><br><span class="line">			hash&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;,</span><br><span class="line">			identity&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;,</span><br><span class="line">			eqstr,</span><br><span class="line">			alloc&gt;</span><br><span class="line">ht(<span class="number">50</span>, hash&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(), eqstr());</span><br><span class="line">ht.insert_unique(<span class="string">"fjds"</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eqstr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strcmp</span>(s1,s2) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">//注意strcmp有三种返回值-1，0，1，C/C++函数，比较两个字符串，</span></span><br><span class="line"><span class="comment">//设这两个字符串为str1，str2，若str1==str2，则返回零；若</span></span><br><span class="line"><span class="comment">//str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span> &gt; <span class="title">struct</span> <span class="title">hash</span> &#123;</span>&#125;;<span class="comment">//泛化</span></span><br><span class="line">_STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt;//特化</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">char</span> x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>..数值型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __stl_hash_string(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; *s; ++s)</span><br><span class="line">		h = h*<span class="number">5</span> + *s;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">size_t</span>(h);</span><br><span class="line">&#125;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char *&gt;//特化</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">const</span> <span class="keyword">char</span> *s ) <span class="keyword">const</span> &#123; <span class="keyword">return</span> __stl_hash_string(s); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>..字符串型但是不是c++的string<br>Hash_function的目的就是希望根据元素值算出一个hash code，使得元素经hash code映射后可以得到一个唯一值放入hashtable中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	size_type n = bkt_num_key(key);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">size_type</span><br><span class="line">bkt_num_key(<span class="keyword">const</span> key_type&amp; key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> bkt_num_key(key, buckets.size());</span><br><span class="line">&#125;</span><br><span class="line">size_type</span><br><span class="line">bkt_num(<span class="keyword">const</span> value_type &amp;obj) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> bkt_num_key(get_key(obj));</span><br><span class="line">&#125;;</span><br><span class="line">size_type</span><br><span class="line">bkt_num_key(<span class="keyword">const</span> key_type &amp;key, <span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> hash(key)%n;</span><br><span class="line">&#125;		 </span><br><span class="line">size_type</span><br><span class="line">bkt_num(<span class="keyword">const</span> value_type&amp; obj, <span class="keyword">size_t</span> n)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> bkt_num_key(get_key(obj) n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Before c++11<br>Hash_set<br>Hash_mutiset<br>Hash_map<br>Hash_mutimap  </p>
<p>Since c++11<br>Unordered_set<br>Unordered_multiset<br>Unordered_map<br>Unordered_multimap</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/17/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/10/2018-02-10-python实现2048/">Python实现2048</a></h6>
              <span>二月 10, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/09/2018-02-09-图片转字符画/">图片转化为字符画</a></h6>
              <span>二月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/">c++中空字符串解释为True的困惑</a></h6>
              <span>二月 5, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/26/2018-01-26-python字符串令牌解析/">python字符串令牌解析</a></h6>
              <span>一月 26, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/15/2018-01-15-RefineDet论文笔记/">RefineDet论文笔记</a></h6>
              <span>一月 15, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/09/2018-01-09-has-no-attribute-items问题/">AttributeError &#39;dict&#39; object has no attribute &#39;items&#39; 问题</a></h6>
              <span>一月 9, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.71px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.57px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
