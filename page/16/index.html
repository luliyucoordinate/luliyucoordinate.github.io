<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 16 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/16/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-04-29-STL容器7Map和Mutimap"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/29/2017-04-29-STL容器7Map和Mutimap/">STL容器（7）Map和Mutimap</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/29/2017-04-29-STL容器7Map和Mutimap/" class="article-date">
	  <time datetime="2017-04-28T16:00:00.000Z" itemprop="datePublished">四月 29, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义于头文件 <map></map></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;Key&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure>
<p>std::map是一个有序关联容器，包含具有唯一键的键值对。键使用比较函数Compare比较来进行排序。搜索，删除和插入操作具有对数复杂性。map通常实现为红黑树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;Key&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multimap</span>;</span></span><br></pre></td></tr></table></figure>
<p>multimap是一个关联容器，它包含一个有序的键值对列表。键值按照Compare比较函数来排序。搜索、插入和删除操作具有对数的复杂性。<br> 相等的键值对在比较中的排序是保持插入时的顺序。 (C++11 起)</p>
<h2 id="Map和Multimap的能力"><a href="#Map和Multimap的能力" class="headerlink" title="Map和Multimap的能力"></a>Map和Multimap的能力</h2><p>Map和multimap后根据元素的key自动对元素排序。这么一来，根据已知的key查找某个元素时就能够有很好的效率，而根据已知value查找元素时，效率就会很糟糕。map和multimap身上有一个重要的限制：你不可以直接改变元素的key，因为这会破坏正确顺序。要修改元素的key，必须先移除该key的元素，然后插入key/value的元素。</p>
<h2 id="Map和Multimap的操作函数"><a href="#Map和Multimap的操作函数" class="headerlink" title="Map和Multimap的操作函数"></a>Map和Multimap的操作函数</h2><p>成员函数find用来查找第一个“拥有某key”的元素，并返回一个迭代器指向该位置。如果没有这样的元素，就返回容器的end。你不能以find查找拥有某特定value的元素。你可以使用下面的方法查找value：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::iterator pos;</span><br><span class="line"><span class="keyword">for</span>(pos = coll.begin(); pos != coll.end(); ++pos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos-&gt;second == value)</span><br><span class="line">	&#123;</span><br><span class="line">		do_something();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用find_if:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = find_if(coll.begin(),coll.end(),</span><br><span class="line">					[](<span class="keyword">const</span> pair&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;&amp; elem)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> elem.second == value;</span><br><span class="line">					&#125;);</span><br></pre></td></tr></table></figure>
<p>Map和multimap只支持“所有容器都提供的基本赋值操作”，赋值动作的两端容器必须拥有相同类型，尽管“比较准则”本身可能不同，但其类型必须相同。如果准则不同，准则本身也会随着容器被赋值或交换。但只要注意的是，元素比较函数只能用于类型相同的容器身上，换言之，两个容器的key、value、排序准则都必须相同的类型。<br>如果你一定要修改元素的key，只有一条路：以一个“value相同”的新元素替换掉旧元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyLib &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line">    <span class="keyword">inline</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">replace_key</span> <span class="params">(Cont&amp; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">typename</span> Cont::key_type&amp; old_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">typename</span> Cont::key_type&amp; new_key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typename</span> Cont::iterator pos;</span><br><span class="line">        pos = c.find(old_key);</span><br><span class="line">        <span class="keyword">if</span> (pos != c.end()) &#123;</span><br><span class="line">            <span class="comment">// insert new element with value of old element</span></span><br><span class="line">            c.insert(<span class="keyword">typename</span> Cont::value_type(new_key,</span><br><span class="line">                                               pos-&gt;second));</span><br><span class="line">            <span class="comment">// remove old element</span></span><br><span class="line">            c.erase(pos);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是map提供一个非常方便的手法，然你改变元素的key。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert new element with value of old element</span></span><br><span class="line">coll[<span class="string">"new_key"</span>] = coll[<span class="string">"old_key"</span>];</span><br><span class="line"><span class="comment">//remove old key</span></span><br><span class="line">coll.erase(<span class="string">"old_key"</span>);</span><br></pre></td></tr></table></figure>
<p>有三种方法可以将value传入map或multimap</p>
<ol>
<li>运用value_type</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line">coll.insert(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::value_type(<span class="string">"ot"</span>,<span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.insert(<span class="keyword">decltype</span>(coll)::value_type(<span class="string">"oit"</span>,<span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<ol>
<li>运用pair&lt;&gt;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line">coll.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt;(<span class="string">"ot"</span>,<span class="number">12</span>));</span><br><span class="line">coll.insert(<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt;(<span class="string">"ot"</span>,<span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<ol>
<li>运用make_pair，这是C++11前最方便的做法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line">coll.insert(<span class="built_in">std</span>::make_pair (<span class="string">"ot"</span>,<span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<p>查看是否插入成功，可以使用和set和multiset相同的方法，也就是coll.insert().second。<br>使用emplace函数与insert的区别在于：<br>The element is constructed in-place by calling allocator_traits::construct with args forwarded.<br>A similar member function exists, insert, which either copies or moves existing objects into the container.<br>移除元素时，当心发生意外情况。移除迭代器所指对象时，有一个很大的危险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end(); ++pos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos-&gt;second == value)</span><br><span class="line">	&#123;</span><br><span class="line">		coll.earse(pos);<span class="comment">//RUNTIME ERROR</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对pos所指元素erase，会使pos不再成为coll的一个有效迭代器。所以后面++pos，这样做是不合理的。<br>C++11后的做法很简单，earse总是返回一个迭代器所指元素其后继元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos-&gt;second == value)</span><br><span class="line">	&#123;</span><br><span class="line">		coll.earse(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	++pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在C++11之前的做法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos-&gt;second == value)</span><br><span class="line">	&#123;</span><br><span class="line">		coll.earse(pos++);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	++pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关联式数组的优点是你可以通过更方便的接口对map安插新元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll[<span class="string">"fdsa"</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>对于coll[“fdsa”]的处理：<br>如果存在key为“fdsa”的元素，上式会返回元素的reference。如果没有任何元素的key是“fdsa”，便为map插入一个新元素，令其key为“fdsa”，value以default构造函数完成，并返回一个reference指向新元素。<br>但是上面的这种做法是会存在缺点的，你很容易想到如果这样做的话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; coll[<span class="string">"fdsaa"</span>];</span><br></pre></td></tr></table></figure>
<p>这和我预先的做法就有出入，它的结果是输出0。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-28-STL容器6Set和Multiset"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/28/2017-04-28-STL容器6Set和Multiset/">STL容器（6）Set和Multiset</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/28/2017-04-28-STL容器6Set和Multiset/" class="article-date">
	  <time datetime="2017-04-27T16:00:00.000Z" itemprop="datePublished">四月 28, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Set和Multiset"><a href="#Set和Multiset" class="headerlink" title="Set和Multiset"></a>Set和Multiset</h1><p>定义于头文件 <set></set></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;Key&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure>
<p>std::set是一个关联容器，是一个有序的集合，集合中包含不可重复的、类型为Key的元素。排序通过使用类型为Compare的比较函数比较来实现。搜索，删除和插入操作具有对数时间复杂度。set通常实现为红黑树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;Key&gt;,</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiset</span>;</span></span><br></pre></td></tr></table></figure>
<p>multiset 是一个关联容器，它包含一些有序的Key类型的对象。与set不同的是，它允许多个带有相同值的键存在。排序通过使用键比较函数比较来实现。搜索，插入和删除操作具有对数的复杂性.<br>在比较中相等的元素，顺序为插入时的顺序，且不会改变。 (C++11 起)</p>
<h2 id="Set和Multiset的能力"><a href="#Set和Multiset的能力" class="headerlink" title="Set和Multiset的能力"></a>Set和Multiset的能力</h2><p>自动排序会造成set和multiset的一个重要限制：你不能直接改变元素值，因为这样会打乱原本正确的顺序。<br>因此，要改变元素值，必须先删除旧元素，在插入新元素。一下接口反映这种行为：<br>Set和multiset不提供任何操作函数可以直接访问元素。<br>从迭代器的角度看，元素只是一个常量。</p>
<h2 id="Set和Multiset的操作函数"><a href="#Set和Multiset的操作函数" class="headerlink" title="Set和Multiset的操作函数"></a>Set和Multiset的操作函数</h2><p>排序准则也被用来检查元素的相等性。采用默认排序准则时，两元素的相等性检查如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(elem1 &lt; elem2)||（elem2 &lt; elem1))</span><br></pre></td></tr></table></figure>
<p>这种做法有三种好处：  </p>
<ol>
<li>只需传递一个实参作为排序准则</li>
<li>不必针对元素类型提供operator==</li>
<li>可以对“相等性”有相反的定义。<br>元素比较只适用于类型相同的容器。换而言之，元素和排序准则则必须有相同的类型，否则编译器会报错。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">float</span>&gt; c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">float</span>,<span class="built_in">std</span>::greater&lt;<span class="keyword">float</span>&gt;&gt; c2;</span><br><span class="line"><span class="keyword">if</span>(c == c2)<span class="comment">//ERROR different  types</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>lower_bound和upper_bound分别返回第一个和最后一个“元素可安插点”。换而言之，lower_bound返回第一个“大于等于实参值”的元素位置，upper_bound返回第一个“大于实参值”的位置。equal_range则是将lower_bound和upper_bound的返回值做成一个pair返回，所以他返回的是“与实参值相等”的元素所形成的区间。<br>和所有关联式容器类似，这里迭代器是双向迭代器。所以，对于那些“只能接受随机访问迭代器”的STL算法。<br>更重要的是，从迭代器的角度看，所有元素都被视为常量。这使得你无法对set或multiset调用更易性算法。例如你不能对它们调用remove，因为remove算法实际上是以其实参值覆盖被移除的元素。<br>注意，用于安插元素的函数：insert和emplace，其返回值不尽相同：<br>返回类型之所以不相同，原因是：multiset允许元素重复而set不允许。因此，如果将某元素安插至set内，而该set内含同值元素，安插失败。所以set的返回类型是以pair组织起来的两个值：  </p>
<ol>
<li>pair结构中的second成员表示安插是否成功。</li>
<li>pair结构中first成员表示新元素的位置，或现存的同元素位置。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-26-STL容器5forward_list"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/26/2017-04-26-STL容器5forward_list/">STL容器（5）forward_list</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/26/2017-04-26-STL容器5forward_list/" class="article-date">
	  <time datetime="2017-04-25T16:00:00.000Z" itemprop="datePublished">四月 26, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Forward-list"><a href="#Forward-list" class="headerlink" title="Forward list"></a>Forward list</h1><p>定义于头文件 &lt;forward_list&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;T&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">forward_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>单向列表是一个容器，支持在其任何地方快速插入和删除元素，不支持快速的随机访问。它被实现为单向链表，和C中它的实现相比，基本上不会有任何开销。当不需要双向迭代的时候，与std::list相比，该容器具有更高的空间利用率。</p>
<h2 id="Forward-list的能力"><a href="#Forward-list的能力" class="headerlink" title="Forward list的能力"></a>Forward list的能力</h2><p>相较于list，forward list有以下约束：  </p>
<ol>
<li>forward list只提供前向迭代器，而不是双向迭代器。因此它不支持反向迭代器，这意味着reverse_iterator不再提供。</li>
<li>forward list不提供size函数。</li>
<li>forward list没有这项最末元素的锚点。基于这个原因，forward list不提供back、push_back和pop_back函数</li>
<li>对于所有“令元素被安插或删除与forward list的某特定位置上”的成员函数，forward list提供特殊版本。原因是你必须传递第一个被处理元素的前一个位置，因为你必须在哪里指定一个新的后继元素，然而由于froward list不允许回头，因此对于这些成员函数，你必须传递迁移元素位置。</li>
</ol>
<h2 id="Forward-list的操作"><a href="#Forward-list的操作" class="headerlink" title="Forward list的操作"></a>Forward list的操作</h2><p>Forward list不提供size，原因是他不存储元素的数量，亦无法在常量时间内算出它。此外也为了凸显size是一个费时操作，所以不提供它。如果你必须计算元素个数，可以使用distance 函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"l.size()"</span> &lt;&lt; <span class="built_in">std</span>::distance(l.begin(), l.end()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>forward list只提供了front函数用于元素访问。<br>注意，面对forward list提供的所有安插、安放、抹除成员函数，你会有个疑问：他们需要获取一个元素位置，而你打算在这个位置上安插元素或删除元素。但这就必需改动前导元素，因为必须更改前导元素的pointer。但是对于forward list你无法回头，因此成员函数的行为就会和list不同。所有以after为结尾的函数，会将新元素安插于给定元素之后。<br>当你使用成员函数，并使用begin_before，一个典型的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fwlist = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">fwlist.insert_after(fwlist.before_begin(),</span><br><span class="line">					&#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>要注意的是，调用after成员函数并传入end或cend函数将导致不明确的行为，因为如果要在forward list的尾端附加一个新元素，你必须传入终端元素的位置：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwlist.insert_after(fwlist.end(),<span class="number">1</span>);<span class="comment">// RUNTIME ERROR</span></span><br></pre></td></tr></table></figure>
<p>再插入元素时，要注意的是由于使用的是一个单向链表，所以你只可以不断的向前，但是当你尝试找出某个元素，准备在那安插或删除元素时，“找到的当下”代表“已经超出了”，因为，想要在这个位置安插或删除元素，你必须改写给出的前一元素。<br>这里又有这样几种做法，一是可以通过记录前一位置，不断++操作，另一种是使用next函数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> posBefore = <span class="built_in">list</span>.before_begin();</span><br><span class="line"><span class="keyword">for</span>(; next(posBefore) != <span class="built_in">list</span>.end(); ++posBefore)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( *next(posBefore) != <span class="built_in">list</span>.end9); ++posBefore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*next(posBefore) %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里我们要理解一个概念。begin指向的是第一个元素的位置，而before_begin指向的是第一个元素的前面位置，也就是真正意义上的首节点。<br>你也可以自己定义算法，找出“拥有特定值”或“满足某特定条件”的元素的前一位置。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> InputIterator</span><br><span class="line">find_before (InputIterator first, InputIterator last, <span class="keyword">const</span> Tp&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first==last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InputIterator <span class="title">next</span><span class="params">(first)</span></span>;</span><br><span class="line">    ++next;</span><br><span class="line">    <span class="keyword">while</span> (next!=last &amp;&amp; !(*next==val)) &#123;</span><br><span class="line">        ++next;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="keyword">inline</span> InputIterator</span><br><span class="line">find_before_if (InputIterator first, InputIterator last, Pred pred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first==last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InputIterator <span class="title">next</span><span class="params">(first)</span></span>;</span><br><span class="line">    ++next;</span><br><span class="line">    <span class="keyword">while</span> (next!=last &amp;&amp; !pred(*next)) &#123;</span><br><span class="line">        ++next;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，结合操作的来源端和目的端可以相同。因此你可以在同一个forward list中splice operation。但是要注意的是，调用splice_after 并传入end会导致不明确的行为  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fwlist.splice_after(fwlist.end(),</span><br><span class="line">					fwlist,</span><br><span class="line">					fwlist.begin());<span class="comment">//RUNTIME ERROR</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-25-STL容器4list"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/25/2017-04-25-STL容器4list/">STL容器（4）list</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/25/2017-04-25-STL容器4list/" class="article-date">
	  <time datetime="2017-04-24T16:00:00.000Z" itemprop="datePublished">四月 25, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>定义于头文件 <list></list></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;T&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>;</span></span><br></pre></td></tr></table></figure>
<p>列表是一个容器，它支持任何位置的元素快速插入和删除，不支持快速的随机访问。它被实现为双向的链表。与std::forward_list相比，它提供双向迭代的能力，但具有更低的空间效率。</p>
<h2 id="List的能力"><a href="#List的能力" class="headerlink" title="List的能力"></a>List的能力</h2><p>List在几个方面与array、vector或deque不同：  </p>
<ol>
<li>list不支持随机访问。</li>
<li>任何位置上的元素的安插和删除都非常快，始终都是常量时间内完成，实际内部只进行一些pointer操作。</li>
<li>安插和删除元素不会造成其他元素的各个pointer、reference和iterator失效。</li>
<li>list的异常处理，要么操作成功，要么什么都不会发生</li>
</ol>
<p>list提供的成员函数反映出它和array、vector以及deque不同：    </p>
<ol>
<li>list提供front、push_front和pop_front、back、push_back和pop_back等。</li>
<li>由于不支持随机访问迭代器，list不提供subscript操作，也不提供at</li>
<li>list并没有提供容量、空间重新分配函数。</li>
<li>list提供不少特殊成员函数。</li>
</ol>
<h2 id="List的操作"><a href="#List的操作" class="headerlink" title="List的操作"></a>List的操作</h2><p>为了移除元素list特别配备了remove算法的特别版本。这些成员函数比remove算法的速度快，因为它内部都是pointer操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Elem&gt; coll;</span><br><span class="line">coll.remove(val);</span><br></pre></td></tr></table></figure>
<p>你可以使用remove_if并定义出元素的移除准则。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coll.remove_if([](<span class="keyword">int</span> i)&#123;</span><br><span class="line">					<span class="keyword">return</span> i%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">			&#125;);</span><br></pre></td></tr></table></figure>
<p>Linked list的最大一个好处是不论在任何位置，元素的安插和移除都只需要常量时间。</p>
<h2 id="List的运用实例"><a href="#List的运用实例" class="headerlink" title="List的运用实例"></a>List的运用实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLists</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; l1, <span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list1: "</span>;</span><br><span class="line">    copy (l1.cbegin(), l1.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"list2: "</span>;</span><br><span class="line">    copy (l2.cbegin(), l2.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create two empty lists</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1, list2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill both lists with elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        list1.push_back(i);</span><br><span class="line">        list2.push_front(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printLists(list1, list2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert all elements of list1 before the first element with value 3 of list2</span></span><br><span class="line">    <span class="comment">// - find() returns an iterator to the first element with value 3</span></span><br><span class="line">    list2.splice(find(list2.begin(),list2.end(),  <span class="comment">// destination position</span></span><br><span class="line">                      <span class="number">3</span>),</span><br><span class="line">                 list1);                          <span class="comment">// source list</span></span><br><span class="line">    printLists(list1, list2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move first element of list2 to the end</span></span><br><span class="line">    list2.splice(list2.end(),        <span class="comment">// destination position</span></span><br><span class="line">                 list2,              <span class="comment">// source list</span></span><br><span class="line">                 list2.begin());     <span class="comment">// source position</span></span><br><span class="line">    printLists(list1, list2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort second list, assign to list1 and remove duplicates</span></span><br><span class="line">    list2.sort();</span><br><span class="line">    list1 = list2;</span><br><span class="line">    list2.unique();</span><br><span class="line">    printLists(list1, list2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge both sorted lists into the first list</span></span><br><span class="line">    list1.merge(list2);</span><br><span class="line">    printLists(list1, list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list1: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">list2: <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">list1:</span><br><span class="line">list2: <span class="number">5</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">list1:</span><br><span class="line">list2: <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">list1: <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">list2: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">list1: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">list2:</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-24-STL容器3deque"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/24/2017-04-24-STL容器3deque/">STL容器（3）deque</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/24/2017-04-24-STL容器3deque/" class="article-date">
	  <time datetime="2017-04-23T16:00:00.000Z" itemprop="datePublished">四月 24, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h1><p>定义于头文件 <deque></deque></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;T&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="Deque的能力"><a href="#Deque的能力" class="headerlink" title="Deque的能力"></a>Deque的能力</h2><p>Deque与vector相比，功能上的差异如下：  </p>
<ol>
<li>两端都可以快速插入和删除元素，而vector只可以后端。</li>
<li>返回元素时deque内部结构会多一个间接过程，所有元素访问和迭代器的动作会慢一些。</li>
<li>迭代器需要在不同的区块间跳转，所以必须是一个smart pointer</li>
<li>在内存区块有限制的系统中，deque可以包含更多元素。</li>
<li>安插和删除元素都将导致指向deque元素的pointer、reference和iterator实效。不过deque的内存分配优于vector，因为其内部结构显示，deque不必在内存充分配时复制所有元素。</li>
<li>deque会释放不再使用的内存区块。deque的内存大小是可以缩减的。</li>
</ol>
<p>以下情形最好使用deque：  </p>
<ol>
<li>你需要在两端安插或移除元素。</li>
<li>无需指向容器内的元素。</li>
<li>要求不再使用的元素必须释放。</li>
</ol>
<h2 id="Deque的操作函数"><a href="#Deque的操作函数" class="headerlink" title="Deque的操作函数"></a>Deque的操作函数</h2><p>Deque的各项操作只有两点和vector不同：</p>
<ol>
<li>deque不提供容量操作（capacity和reserve）</li>
<li>deque提供函数完成头部元素的安插和删除</li>
</ol>
<h2 id="Deque运用实例"><a href="#Deque运用实例" class="headerlink" title="Deque运用实例"></a>Deque运用实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create empty deque of strings</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert several elements</span></span><br><span class="line">    coll.assign (<span class="number">3</span>, <span class="built_in">string</span>(<span class="string">"string"</span>));</span><br><span class="line">    coll.push_back (<span class="string">"last string"</span>);</span><br><span class="line">    coll.push_front (<span class="string">"first string"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print elements separated by newlines</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">"\n"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove first and last element</span></span><br><span class="line">    coll.pop_front();</span><br><span class="line">    coll.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert "another" into every element but the first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">1</span>; i&lt;coll.size(); ++i) &#123;</span><br><span class="line">        coll[i] = <span class="string">"another "</span> + coll[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change size to four elements</span></span><br><span class="line">    coll.resize (<span class="number">4</span>, <span class="string">"resized string"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print elements separated by newlines</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">"\n"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first <span class="built_in">string</span></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line">last <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line">another <span class="built_in">string</span></span><br><span class="line">another <span class="built_in">string</span> </span><br><span class="line">resized <span class="built_in">string</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-23-STL容器2vector"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/23/2017-04-23-STL容器2vector/">STL容器（2）vector</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/23/2017-04-23-STL容器2vector/" class="article-date">
	  <time datetime="2017-04-22T16:00:00.000Z" itemprop="datePublished">四月 23, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>定义于头文件\&lt;vector></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;T&gt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="Vector的能力"><a href="#Vector的能力" class="headerlink" title="Vector的能力"></a>Vector的能力</h2><p>Vector支持随机访问，因此只要知道位置，就可以在常亮时间内访问任意元素。vector提供随机访问迭代器，所以适用于任意STL算法。capacity函数返回vector实际容纳量，如果超过这个量，vector必须重新分配内部内存。一旦内存重新分配，vector元素相关的所有reference、pointer和iterator都会失效，内存重新分配很耗时间。<br>你可以使用reserve函数保存适当容量，避免重新分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">80</span>);<span class="comment">//reserve mempry for 80 elements</span></span><br></pre></td></tr></table></figure>
<p>vector不能使用reserve缩减容量，调用reverse所给的实参如果小于当前vector的容量，不会引发任何效果。，既然vector的容量不会缩减，我们就可以知道，及时删除元素，其reference、pointer和iterator也会继续有效，继续指向动作发生前的位置。然而安插动作可能会使reference、pointer和iterator实效，因为会使vector重排。<br>C++11引入一个新的函数shrink_to_fit：这个函数不具有强制力的要求，可以缩减容量以符合当前的元素个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.shrink_to_fit();<span class="comment">//注意不具有强制性</span></span><br></pre></td></tr></table></figure>
<p>在c++11之前有一个小技巧实现这个功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrinkCapacity</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; tmp(v);</span><br><span class="line">	v.swap(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你甚至可以像这样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;(v).swap(v);</span><br></pre></td></tr></table></figure>
<p>但是要注意的是，这些做法都会使reference、pointer和iterator换了只想对象。</p>
<h2 id="Vector的操作"><a href="#Vector的操作" class="headerlink" title="Vector的操作"></a>Vector的操作</h2><p>元素访问<br>at 访问指定的元素，同时进行越界检查<br>operator[] 访问指定的元素<br>front 访问第一个元素<br>back 访问最后一个元素<br>data 返回指向内存中数组第一个元素的指针<br>当pop_back调用时，确保容器不为空是程序员的责任。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Elem&gt;coll;</span><br><span class="line"><span class="keyword">if</span>(!coll.empty())</span><br><span class="line">&#123;</span><br><span class="line">	coll.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于效能，以下几种情况你可以预期安插动作和移除动作会快一些：  </p>
<ol>
<li>在容器的尾部安插或移除元素</li>
<li>容器的容量一开始就很大</li>
<li>安插多个元素调用一次肯定是最快的  </li>
</ol>
<p>Vector并能没有提供任何函数可以直接移除“与某个值相等”的所有元素。但是可以通过以下做法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Elem&gt; coll;</span><br><span class="line">coll.erase(remove(coll.begin(),coll.end(),</span><br><span class="line">					val),</span><br><span class="line">			coll.end());</span><br></pre></td></tr></table></figure>
<p>如果只要一出第一个元素，可以这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Elem&gt; coll;</span><br><span class="line">pos = find(coll.begin(),coll.end(),</span><br><span class="line">			val);</span><br><span class="line"><span class="keyword">if</span>(pos != coll.end())</span><br><span class="line">&#123;</span><br><span class="line">	coll.erase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将vector当做C-Style-Array使用"><a href="#将vector当做C-Style-Array使用" class="headerlink" title="将vector当做C-Style Array使用"></a>将vector当做C-Style Array使用</h2><p>reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。<br>resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">v.resize(<span class="number">41</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;v[<span class="number">0</span>],<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;v[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>初次接触这两个接口也许会混淆，其实接口的命名就是对功能的绝佳描述，resize就是重新分配大小，reserve就是预留一定的空间。这两个接口即存在差别，也有共同点。下面就它们的细节进行分析。<br>为实现resize的语义，resize接口做了两个保证：<br>一是保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的。<br>二是保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。<br>reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。<br>resize和reserve接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。</p>
<h2 id="Class-vector"><a href="#Class-vector" class="headerlink" title="Class vector"></a>Class vector<bool></bool></h2><p>vector<bool>特化版的内部只是用1bit存放元素，空间节省8倍。C++的最小可定址值是以byte为单位的，所以reference和iterator做特殊处理<br>vector<bool>无法满足其他vector的所有规定，例如vector<bool>::reference并不是一个lvalue，vector<bool>::iterator也不是一个随机访问迭代器，而且它的操作速度会比一般的vector慢因为他是bit操作。<br>flip函数用来取补数（complement）。注意，你可以对vector内的所有bit或单一bit调用filp，后者很值得注意，因为你也许会以为subscript操作符返回bool在对此基础类型调用filp是不可能的。然而vector<bool>运用了一个名为proxy的技巧：面对一个vector<bool>，subscript操作符的返回类型实际上是个辅助类，一旦你要求返回值为bool，便会触发一个自动类型转换函数。<br>所有用于元素访问的函数，返回的都是reference类型。所以可以这么写：</bool></bool></bool></bool></bool></bool></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.front().filp();</span><br><span class="line">c[<span class="number">5</span>] = c.back();</span><br></pre></td></tr></table></figure>
<p>只有vector<bool>的non-const容器才会用到内部的proxy类型reference。而用来处理那些const成员函数，返回类型都是const reference，那就是bool。</bool></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-22-STL容器1array"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/22/2017-04-22-STL容器1array/">STL容器（1）array</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/22/2017-04-22-STL容器1array/" class="article-date">
	  <time datetime="2017-04-21T16:00:00.000Z" itemprop="datePublished">四月 22, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>为了使用array，首先必须加头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该类型被定义为一个class template，在命名空间std中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是Array并不支持分配器，也就是说不允许指定自己的allocator</p>
<h2 id="Array的能力"><a href="#Array的能力" class="headerlink" title="Array的能力"></a>Array的能力</h2><p>Array会把元素复制到其内的static C-style array中。这些元素总是拥有一个明确次序。Array允许随机访问，你可以在常量时间内访问任何元素。Array的迭代器属于随机访问迭代器，所以你可以使用任意的STL算法。<br>关于初始化，class array有一些独特的语法。注意，array是唯一一个“无任何东西被指定为初值时，会被与初始化”的容器。这意味着对于基础类型，初值可能不明确，而不是0。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; x;elements of x have undefined value</span><br></pre></td></tr></table></figure>
<p>这里要提一些什么是明确的初始化，对于明确的初始化，基础类型会被设定初值为0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1;<span class="comment">//undefined value</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="keyword">int</span>();<span class="comment">//initialized with zero</span></span><br><span class="line"><span class="keyword">int</span> i3&#123;&#125;;<span class="comment">//initialized with zero</span></span><br></pre></td></tr></table></figure>
<p>array满足聚合体要求，因此可以使用处置列来设定array，聚合体（aggregate）是一个class或array，不带用户提供的构造函数，也没有private和protected的nostatic的数据成员，也没有base class ，也没有virtual函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果初值列内的元素个数多余array的大小，这样的表达式就不对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; c1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//ERROR too many values</span></span><br></pre></td></tr></table></figure>
<p>由于没有提供初值列而写的构造函数和assignment操作符，因此“在array声明期间完成初始化”是使用初值列的唯一途径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; a(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//ERROR </span></span><br><span class="line"><span class="built_in">std</span>::vecotr&lt;<span class="keyword">int</span>&gt; v(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>swap拥有线性复杂度并有以下的影响：iterator和reference不会随着元素的置换而改变所指向的元素。所以置换后，iterator和reference指向那个原本容器，但指向不同元素。</p>
<h2 id="Array的操作"><a href="#Array的操作" class="headerlink" title="Array的操作"></a>Array的操作</h2><p>如果使用操作符=和swap()，两个array必须具备相同的类型，意思是两者的元素类型和大小必须相同。<br>想要访问array内的所有元素，必须使用range-based for循环，或者特定的操作符或迭代器。通常只有使用at()会执行范围检查。如果超出范围，at()会抛出一个out_of_range异常，其它函数不会做检查。对于一个空的array调用operator[]、front和back会导致不明确的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;Elem,0&gt; c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.front();<span class="comment">//RUNTIME ERROR</span></span><br></pre></td></tr></table></figure>
<h2 id="将array当做C-Style-Array"><a href="#将array当做C-Style-Array" class="headerlink" title="将array当做C-Style Array"></a>将array当做C-Style Array</h2><p>如果想要访问array的元素，你不一定使用表达式&amp;a[0]，因为成员函数data()也具备相同用途：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,41&gt; a;</span><br><span class="line"><span class="built_in">strcpy</span>(a.data(),<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>，a.data());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>，&amp;a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>但是你必须确保array的大小足够容纳复制进来的数据，而且如果你把其中的内容当做一个C-string来看，你必须放置一个’\0’元素于尾端。<br>注意，绝对不要用迭代器表现“第一元素的地址”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a.begin());<span class="comment">//ERROR</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a.data());<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<h2 id="Tuple接口"><a href="#Tuple接口" class="headerlink" title="Tuple接口"></a>Tuple接口</h2><p>Array提供tuple接口。因此可以使用tuple_size&lt;&gt;::value去的元素个数，用tuple_element&lt;&gt;::type取得某个特定元素类型，用get取得某个特定元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,5&gt; FiveStrings;</span><br><span class="line">FiveStrings a = &#123; <span class="string">"hello"</span>,<span class="string">"how"</span>,<span class="string">"are"</span>,<span class="string">"you"</span>,<span class="string">"hehe"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::tuple_size&lt;FiveStrings&gt;::value <span class="comment">//5</span></span><br><span class="line"><span class="built_in">std</span>::tuple_element&lt;<span class="number">1</span>,FiveStrings&gt;::type <span class="comment">//std::string</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(a) <span class="comment">//std::string("how")</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-20-标准模板库2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/20/2017-04-20-标准模板库2/">标准模板库(2)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/20/2017-04-20-标准模板库2/" class="article-date">
	  <time datetime="2017-04-19T16:00:00.000Z" itemprop="datePublished">四月 20, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="更易型算法-Manipulating-Algorithm"><a href="#更易型算法-Manipulating-Algorithm" class="headerlink" title="更易型算法(Manipulating Algorithm)"></a>更易型算法(Manipulating Algorithm)</h1><p>现实中存在某些限制和某些需要避开的事物，其中许多和元素/容器的改动相伴相生。有些算法会改变目标的区间。</p>
<h2 id="移除-Removing-元素"><a href="#移除-Removing-元素" class="headerlink" title="移除(Removing)元素"></a>移除(Removing)元素</h2><p>分析这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 6 to 1 and 1 to 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        coll.push_front(i);</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pre:  "</span>;</span><br><span class="line">    copy (coll.cbegin(), coll.cend(),         <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));   <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// remove all elements with value 3</span></span><br><span class="line">    remove (coll.begin(), coll.end(),         <span class="comment">// range</span></span><br><span class="line">            <span class="number">3</span>);                               <span class="comment">// value</span></span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"post: "</span>;</span><br><span class="line">    copy (coll.cbegin(), coll.cend(),         <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));   <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个程序的结果和我们预想的不一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre:  <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">post: <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>remove并没有改变集合中的元素数量。cend返回的是当初那个终点，size()返回的还是当初那个大小。<br>事实上，这个算法返回一个新终点。你可以利用这个新终点获得新区间。改进版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 6 to 1 and 1 to 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        coll.push_front(i);</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements with value 3</span></span><br><span class="line">    <span class="comment">// - retain new end</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator end = remove (coll.begin(), coll.end(),</span><br><span class="line">                                      <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print resulting elements of the collection</span></span><br><span class="line">    copy (coll.begin(), end,</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print number of removed elements</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"number of removed elements: "</span></span><br><span class="line">         &lt;&lt; distance(end,coll.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove "removed" elements</span></span><br><span class="line">    coll.erase (end, coll.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements of the modified collection</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果真想把那些删除的元素斩草除根，erase正适用于此目的。<br>为什么算法不自己调用erase呢？这正是STL为了获取弹性付出的代价。通过“以迭代器为接口”，STL将数据结构和算法分离出来。任何“以迭代器访问容器”的算法，都不得通过迭代器调用容器类所提供的任何成员函数。<br>算法的操作对象不一定是“容器内的全部元素”所形成的区间，而可以使那些元素的子集。<br>注意，通常并无必要删除那些“已被删除”的元素。以逻辑终点取代容器的实际终点，通常就足以应对现实情况。</p>
<h2 id="更易Associative-关联式-和Unordered-无序-容器"><a href="#更易Associative-关联式-和Unordered-无序-容器" class="headerlink" title="更易Associative(关联式)和Unordered(无序)容器"></a>更易Associative(关联式)和Unordered(无序)容器</h2><p>更易型算法(指那些会移除，重排，修改元素的算法)若用于关联式容器或无序容器，会出问题。如果更易型算法用于关联式和无序容器身上，会改变某位置上的值，进而破会容器本身对次序的维护。<br>关联式容器和无序容器的所有迭代器均被申明为指向常量的value或key，如果你更动关联式容器或无序容器的元素会导致编译出错。</p>
<h2 id="算法VS成员函数"><a href="#算法VS成员函数" class="headerlink" title="算法VS成员函数"></a>算法VS成员函数</h2><p>如果高效能是你的首要目标，你应该总是优先选用成员函数。</p>
<h1 id="以函数作为算法的实参"><a href="#以函数作为算法的实参" class="headerlink" title="以函数作为算法的实参"></a>以函数作为算法的实参</h1><p>有些算法可以接受用户自定义的辅助函数，提高弹性和能力。</p>
<h2 id="判断式-Predicate"><a href="#判断式-Predicate" class="headerlink" title="判断式(Predicate)"></a>判断式(Predicate)</h2><p>Predicate是一种特殊的辅助函数。所谓的predicate，它会返回布尔值。<br>单参数判断式(Unary Predicate)会检查唯一实参的某项特性。<br>双参判断式(Binary Predicate)<br>Binary Predicate的典型用途是，比较两个实参的特定属性。</p>
<h1 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h1><p>可以定义对象，用于描述函数行为，并将这些对象以“inline实参”形式给算法作为predicate。</p>
<h1 id="函数对象-Function-Object"><a href="#函数对象-Function-Object" class="headerlink" title="函数对象(Function Object)"></a>函数对象(Function Object)</h1><h2 id="定义一个函数对象"><a href="#定义一个函数对象" class="headerlink" title="定义一个函数对象"></a>定义一个函数对象</h2><p>函数对象是一种带状态的函数。事实上，在同一时间点，相同类型的两个不同的函数对象所表述的相同机能，可具备不同状态。这是寻常函数中不可能的。另一个好处是，你可以在运行期初始化他们—当然必须在他们被调用之前。<br>每个函数对象有其自己的类型。寻常函数，唯有在其signature不同时，才算类型不同。而函数对象即使signature相同，也可以有不同的类型。<br>函数对象通常比寻常函数速度快。由于更多细节在编译器就已确定，所以通常可能进行更好的优化。</p>
<h2 id="预定义的函数对象"><a href="#预定义的函数对象" class="headerlink" title="预定义的函数对象"></a>预定义的函数对象</h2><p>C++标准库内含若干预定义的函数对象，含盖了许多基础运算。一个典型的例子是作为基础排序的函数对象。operator &lt; 默认排序准则是调用less&lt;&gt;，所以，如果你声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<p>会被扩展为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser&lt;<span class="keyword">int</span>,less&lt;<span class="keyword">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>
<h2 id="binder"><a href="#binder" class="headerlink" title="binder"></a>binder</h2><p>你可以使用特殊的函数适配器，所谓的binder，将于定义的函数对象和其他数值结合为一体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: due to the sorting criterion greater&lt;&gt;() elements have reverse order:</span></span><br><span class="line">    PRINT_ELEMENTS(coll1,<span class="string">"initialized: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transform all elements into coll2 by multiplying them with 10</span></span><br><span class="line">    transform (coll1.cbegin(),coll1.cend(),      <span class="comment">// source</span></span><br><span class="line">               back_inserter(coll2),             <span class="comment">// destination</span></span><br><span class="line">               bind(multiplies&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));   <span class="comment">// operation</span></span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"transformed: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace value equal to 70 with 42</span></span><br><span class="line">    replace_if (coll2.begin(),coll2.end(),       <span class="comment">// range</span></span><br><span class="line">                bind(equal_to&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">70</span>),     <span class="comment">// replace criterion</span></span><br><span class="line">                <span class="number">42</span>);                             <span class="comment">// new value</span></span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"replaced:    "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements with values between 50 and 80</span></span><br><span class="line">    coll2.erase(remove_if(coll2.begin(),coll2.end(),</span><br><span class="line">                          bind(logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">                               bind(greater_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">50</span>),</span><br><span class="line">                               bind(less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">80</span>))),</span><br><span class="line">                coll2.end());</span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"removed:     "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(multiplies&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>变定义一个函数对象，将传入的第一个实参乘以10。<br>最后一例用的是binder的组合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">     bind(greater_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">50</span>),</span><br><span class="line">     bind(less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<p>表现出的是个unary predicate，拥有参数x，操作意义是x&gt;=50&amp;&amp;x&lt;=80。</p>
<h1 id="STL内部的错误和异常"><a href="#STL内部的错误和异常" class="headerlink" title="STL内部的错误和异常"></a>STL内部的错误和异常</h1><h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h2><p>C++标准库指出，对于STL的任何运用，如果违反规则，将导致不明确的行为。通常会导致不明确的内存访问，这肯能导致难缠的副作用。具体地说，使用STL，必须满足以下条件：<br>迭代器必须合法有效。例如你必须在使用他们之前先将他们初始化。<br>迭代器如果指向past-the-end位置，它并不指向任何对象。因此不能对他调用operator*和operator-&gt;。<br>区间(range)必须合法：<br>用以“指出某个区间”的前后迭代器必须指向同一个容器。<br>从第一个迭代器出发必须可以到达第二个迭代器位置。<br>如果涉及的区间不止一个，第二区间及后继各区间必须拥有“至少和第一区间一样多的”元素。<br>腹泻操作中的“标的区间”必须拥有足够多的元素，否则必须采用insert iterator<br>以下例子展示若干可能发生的错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll1;    <span class="comment">// empty collection</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;    <span class="comment">// empty collection</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - beginning is behind the end of the range</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = coll1.begin();</span><br><span class="line">    reverse (++pos, coll1.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 1 to 9 into coll1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll1.push_back (i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - overwriting nonexisting elements</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),  <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - collections mistaken</span></span><br><span class="line">    <span class="comment">// - cbegin() and cend() refer to different collections</span></span><br><span class="line">    copy (coll1.cbegin(), coll2.cend(),  <span class="comment">// source</span></span><br><span class="line">          coll1.end());                  <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-19-标准模板库1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/19/2017-04-19-标准模板库1/">标准模板库(1)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/19/2017-04-19-标准模板库1/" class="article-date">
	  <time datetime="2017-04-18T16:00:00.000Z" itemprop="datePublished">四月 19, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h1><p>序列式容器(Sequence container):array,vector,deque,list and forward_list<br>关联式容器(Associative container):set,multiset,map and multimap<br>无序容器:(Unordered(associative)container):unordered_set,unordered_multiset,unordered_map,unordered_multimap</p>
<h2 id="序列式容器-Sequence-container"><a href="#序列式容器-Sequence-container" class="headerlink" title="序列式容器(Sequence container)"></a>序列式容器(Sequence container)</h2><p>自c++11开始，c++标准库提供另一个list容器：forward list。forward list是一个单向链表。<br>因此，forward list原则上就是一个受限的list，你无法查找某个元素然后删除它，或是在他的前面安插另一个元素。因此，为了删除某个元素，你必须位于其前一个元素的位置上，因为正是那个元素，才决定一个新的后继元素。也因此，forward list对此提供了一个特殊的成员函数erase_after()<br>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create forward-list container for some prime numbers</span></span><br><span class="line">    forward_list&lt;<span class="keyword">long</span>&gt; coll = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span> &#125;;</span><br><span class="line">    <span class="comment">// resize two times</span></span><br><span class="line">    <span class="comment">// - note: poor performance</span></span><br><span class="line">    coll.resize(<span class="number">9</span>);</span><br><span class="line">    coll.resize(<span class="number">10</span>,<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// print all elements:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : coll) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联式数组-Associative-Array"><a href="#关联式数组-Associative-Array" class="headerlink" title="关联式数组(Associative Array)"></a>关联式数组(Associative Array)</h2><p>不论map或unordered map，都是key/value pair形成的集合，每个元素都带着独一无二的key。这样的集合也可以被视为一个关联式数组，也就是“索引并非整数”的array。也因此，刚才说的两个容器，都可以使用[]操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// type of the container:</span></span><br><span class="line">    <span class="comment">// - unordered_map: elements are key/value pairs</span></span><br><span class="line">    <span class="comment">// - string: keys have type string</span></span><br><span class="line">    <span class="comment">// - float: values have type float</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert some elements into the collection</span></span><br><span class="line">    <span class="comment">// - using the syntax of an associative array</span></span><br><span class="line">    coll[<span class="string">"VAT1"</span>] = <span class="number">0.16</span>;</span><br><span class="line">    coll[<span class="string">"VAT2"</span>] = <span class="number">0.07</span>;</span><br><span class="line">    coll[<span class="string">"Pi"</span>] = <span class="number">3.1415</span>;</span><br><span class="line">    coll[<span class="string">"an arbitrary number"</span>] = <span class="number">4983.223</span>;</span><br><span class="line">    coll[<span class="string">"Null"</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change value</span></span><br><span class="line">    coll[<span class="string">"VAT1"</span>] += <span class="number">0.03</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print difference of VAT values</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"VAT difference: "</span> &lt;&lt; coll[<span class="string">"VAT1"</span>] - coll[<span class="string">"VAT2"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自C++11开始，你也可以使用at()访问元素的value，只要传给他key就行。这种情况下如果容器内找不到给定的key，会导致out_of_range异常:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.at(<span class="string">"VAT1"</span>) = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure>
<p>使用map与使用unordered_map的差异在于，元素在unordered_map的次序有各种可能，但元素在map内一定是排序过的。但由于unordered_map的操作属于“amortized constant”复杂度，map提供的是“对数复杂度”，所以通常宁可使用unordered_map而放弃map，除非你需要排序。<br>容器适配器(Container Adapter)<br>Stack 名字足以说明。Stack容器对元素采取的是LIFO(后进先出)管理策略。<br>Queue 对元素采取FIFO(先进先出)管理策略。也就是说，他就是一个寻常的缓冲区(buffer)。<br>Priority queue 其内的元素拥有各种优先权。所谓的优先权是基于程序员提供的排序准则(默认为操作符&lt;)而定义。<br>迭代器(Iterator)<br>任何容器都定义两种迭代器类型：  </p>
<ol>
<li>container::iterator以“读/写”模式遍历元素。</li>
<li>container::const_iterator以“只读”模式遍历元素。</li>
</ol>
<p>我们可以使用关键字auto代替迭代器的精确类型。因此我们直接以begin初始化迭代器，就可以使用auto声明其类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin(); pos != coll.end(); ++pos)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>采用这种写法，万一容器类型发生变化，程序整体仍能保持较佳的健壮性。然而其缺点是，迭代器丧失常量性，可能引发“计划外的赋值”风险。因为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = coll.begin();</span><br></pre></td></tr></table></figure>
<p>会使pos是一个非常量迭代器，因为begin()返回的是个类型为cont::iterator的对象。为确保仍可使用常量迭代器，自C++11起容器提供cbegin和cend，他们放回一个cont::const_iterator的对象。</p>
<h1 id="算法-Algorithm"><a href="#算法-Algorithm" class="headerlink" title="算法(Algorithm)"></a>算法(Algorithm)</h1><h2 id="区间-Range"><a href="#区间-Range" class="headerlink" title="区间(Range)"></a>区间(Range)</h2><p>所有算法处理的都是半开区间(half-open range)—包括其实元素的位置但并不包括末尾元素的位置。<br>半开区间的有点主要是单纯，可免除对空集做特殊处理。当然，金无足赤，世上没有完美的设计。<br>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 20 to 40</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>; i&lt;=<span class="number">40</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find position of element with value 3</span></span><br><span class="line">    <span class="comment">// - there is none, so pos3 gets coll.end()</span></span><br><span class="line">    <span class="keyword">auto</span> pos3 = find (coll.begin(), coll.end(),    <span class="comment">// range</span></span><br><span class="line">                      <span class="number">3</span>);                          <span class="comment">// value</span></span><br><span class="line">       <span class="comment">// reverse the order of elements between found element and the end</span></span><br><span class="line">    <span class="comment">// - because pos3 is coll.end() it reverses an empty range</span></span><br><span class="line">    reverse (pos3, coll.end());</span><br><span class="line">    <span class="comment">// find positions of values 25 and 35</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator pos25, pos35;</span><br><span class="line">    pos25 = find (coll.begin(), coll.end(),  <span class="comment">// range</span></span><br><span class="line">                  <span class="number">25</span>);                       <span class="comment">// value</span></span><br><span class="line">    pos35 = find (coll.begin(), coll.end(),  <span class="comment">// range</span></span><br><span class="line">                  <span class="number">35</span>);                       <span class="comment">// value</span></span><br><span class="line">    <span class="comment">// print the maximum of the corresponding range</span></span><br><span class="line">    <span class="comment">// - note: including pos25 but excluding pos35</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max: "</span> &lt;&lt; *max_element (pos25, pos35) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// process the elements including the last position</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max: "</span> &lt;&lt; *max_element (pos25, ++pos35) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找元素3的任务失败后，find()返回区间的结束位置并赋值给pos3。所以reverse()的结果就是相当于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(coll.end(), coll.end());</span><br></pre></td></tr></table></figure>
<h2 id="处理多重区间-Multiple-Ranges"><a href="#处理多重区间-Multiple-Ranges" class="headerlink" title="处理多重区间(Multiple Ranges)"></a>处理多重区间(Multiple Ranges)</h2><p>有数个算法可以同时处理多重区间。通常你必须设定第一区间的起点和终点，至于其他区间，只需设定起点即可，终点通常可由第一区间的元素数量推导出来。例如，equal从头开始比较coll1和coll2的所有元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( equal(coll1.begin(), coll1,end(),</span><br><span class="line">			coll.begin())&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，coll2之中参与比较的元素数量，间接取决于coll1内的数量。<br>这使得我们获得一个重要的心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二区间所拥有的元素个数至少和第一区间内的元素个数相同。<br>注意下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;   coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - overwrites nonexisting elements in the destination</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                 <span class="comment">// destination</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要避免上面的错误，你可以确定目标区间内有足够的元素空间，或是采用insert iterator。<br>为了是目标区间足够大，你可以一开始给他一个正确的大小，也可以显示的变更他的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;   coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize destination to have enough room for the overwriting algorithm</span></span><br><span class="line">    coll2.resize (coll1.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements from first into second collection</span></span><br><span class="line">    <span class="comment">// - overwrites existing elements in destination</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                 <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create third collection with enough room</span></span><br><span class="line">    <span class="comment">// - initial size is passed as parameter</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll3(coll1.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements from first into third collection</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll3.begin());                 <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这两种做法都会产生新元素并赋初值。这些元素由default构造函数初始化，没有任何实参。你可以传递额外的实参给构造函数和resize()，这样就可以按你的意思将新元素初始化。</p>
<h1 id="迭代器之适配器-Iterator-Adapter"><a href="#迭代器之适配器-Iterator-Adapter" class="headerlink" title="迭代器之适配器(Iterator Adapter)"></a>迭代器之适配器(Iterator Adapter)</h1><p>C++11标准库提供了数个预定义的特殊迭代器，亦即所谓迭代器适配器(iterator adapter)。</p>
<h2 id="Insert-Iterator-安插型迭代器"><a href="#Insert-Iterator-安插型迭代器" class="headerlink" title="Insert Iterator(安插型迭代器)"></a>Insert Iterator(安插型迭代器)</h2><p>它可以使算法以安插方式而非覆写方式运作。使用它可以解决算法的“目标空间不足”问题。她会促使目标区间的大小按需求成长。<br>Insert iterator内部将接口做了新的定义：<br>如果你将某个元素赋值，会引发“对其所属集合的按插动作”。至于插入位置是在容器的最前或最后，或某特定位置上，要视三种不同的insert iterator而定。<br>单步前行不会构成任何动静。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the elements of coll1 into coll2 by appending them</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          back_inserter(coll2));           <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the elements of coll1 into coll3 by inserting them at the front</span></span><br><span class="line">    <span class="comment">// - reverses the order of the elements</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll3;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          front_inserter(coll3));          <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements of coll1 into coll4</span></span><br><span class="line">    <span class="comment">// - only inserter that works for associative collections</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; coll4;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          inserter(coll4,coll4.begin()));  <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子运用了三个预定义的insert iterator<br>Back inserter其内部调用push_back()，在容器末尾插入元素。<br>Front inserter其内部调用push_front()，将元素安插于容器最前端。<br>General inserter这种一般性的inserter，简称inserter，它的作用是在“初始化时接受第二实参”所指位置的前方插入元素。其内部调用成员函数insert()，因此这是唯一可用于关联式容器身上的一种预定义inserter。</p>
<h2 id="Stream-Iterator-串流迭代器"><a href="#Stream-Iterator-串流迭代器" class="headerlink" title="Stream Iterator(串流迭代器)"></a>Stream Iterator(串流迭代器)</h2><p>Stream Iterator被用来读写stream。他们提供了必要的抽象性，使得来自键盘的输入像是个集合，你能够从中读取内容。同样道理，你也可以把一个算法输出结果重新导向到某个文件或屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read all words from the standard input</span></span><br><span class="line">    <span class="comment">// - source: all strings until end-of-file (or error)</span></span><br><span class="line">    <span class="comment">// - destination: coll (inserting)</span></span><br><span class="line">    copy (istream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cin</span>),    <span class="comment">// start of source</span></span><br><span class="line">          istream_iterator&lt;<span class="built_in">string</span>&gt;(),       <span class="comment">// end of source</span></span><br><span class="line">          back_inserter(coll));             <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort elements</span></span><br><span class="line">    sort (coll.begin(), coll.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements without duplicates</span></span><br><span class="line">    <span class="comment">// - source: coll</span></span><br><span class="line">    <span class="comment">// - destination: standard output (with newline between elements)</span></span><br><span class="line">    unique_copy (coll.cbegin(), coll.cend(),           <span class="comment">// source</span></span><br><span class="line">                 ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">"\n"</span>)); <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>istream_iterator<string>(cin)会产生一个可从“标准输入串流cin”读取数据的stream iterator。其中的template实参string表示这个stream iterator专门读取这个类型的元素。这些元素通过一般的operator &gt;&gt; 被读取出来。</string></p>
<h2 id="Reverse-Iterator-反向迭代器"><a href="#Reverse-Iterator-反向迭代器" class="headerlink" title="Reverse Iterator(反向迭代器)"></a>Reverse Iterator(反向迭代器)</h2><p>Reverse iterator会造成算法逆向操作。所有提供双向迭代器或随机访问迭代器的容器都可以通过他们的成员函数rbegin和rend产生一个反向迭代器。自C++11开始还提供一组对应成员函数crbegin和crend，它们会返回只读反向迭代器。<br>Forward_list和所有无序容器都没有提供回向迭代接口，即rbegin和rend等等。原因是那些容器内部实现只是使用singly linked list传奇所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 1 to 9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all element in reverse order</span></span><br><span class="line">    copy (coll.crbegin(), coll.crend(),      <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));  <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用reverse iterator，所有算法便可以不需特殊处理就以相反方向操作容器，这自然是美事一桩。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-18-理解C++语言的声明语法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/18/2017-04-18-理解C++语言的声明语法/">理解C/C++语言的声明语法-声明子</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/18/2017-04-18-理解C++语言的声明语法/" class="article-date">
	  <time datetime="2017-04-17T16:00:00.000Z" itemprop="datePublished">四月 18, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.cnblogs.com/dreamliner/archive/2009/06/10/1500827.html" target="_blank" rel="noopener">dreamliner</a>的blog</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>一些声明可能难以理解，特别是如果声明几个不同类型的名字或者那些指向函数指针的函数。例如在§10.1.1/171中，我们看到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p, q;</span><br></pre></td></tr></table></figure>
<p>定义p为一个“整型指针”类型的对象，q为一个整型对象。在§10.1.2/173中，我们看到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>声明get_analysis_ptr为一个函数，不带任何参数，它返回一个指针，它指向一个函数，它带有一个const vector&lt;Student_info&gt;&amp;参数，返回double。你可以通过重写以清楚的表达这些声明的含义，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> q;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义analysis_fp为一个函数，它带一个const vector&lt;Student_info&gt;&amp;参// 数，返回一个double类型。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*analysis_fp)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;)</span></span>;</span><br><span class="line"><span class="function">analysis_fp <span class="title">get_analysis_ptr</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>不幸的是，这种策略不会帮助你阅读其它程序员代码中令人迷惑的声明。<br>一般，一个声明大致如下<br>声明语句：声明说明符[声明子[初始化器]] [,声明子[初始化器]]…;<br>它为每一个声明子声明一个名字。这些名字始于声明开始的地方终于声明作用域结束的地方。一些声明同时也是定义。名字可以声明多次，但是仅能定义一次。如果一个声明分配了存储空间或者定义了类或函数体，那么它也是一个定义。<br>C++继承了C的声明语法。理解声明的关键是认识到每个声明包含两个部分：一系列声明说明符，它们一起说明一个类型和其它正在声明的特性，紧跟着是零个或多个声明子（每个声明子都可选的有一个关联的初始化器）。根据说明符和声明子的形式，每个声明子都为名字赋予一个类型。<br>理解声明的第一步是定位说明符和声明子的边界。这很容易：所有的说明符都是关键字或者类型名，因此说明符终止于第一个不是以上类型之一的符号。<br>例如，在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> * <span class="keyword">const</span> * cp;</span><br></pre></td></tr></table></figure>
<p>很容易找到边界：double是一个类型，左括号后面既不是关键字也不是类型名。因此，声明—说明符只是double，声明子为声明的其它部分，不包含分号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>另一个例子，考虑§10.1.2/173中的声明：<br>第一个既不是关键字也不是类型名的符号是<em>，因此说明符是const char，唯一的声明子</em> const <em> const </em> cp。</p>
<h2 id="说明符（Specifiers）"><a href="#说明符（Specifiers）" class="headerlink" title="说明符（Specifiers）"></a>说明符（Specifiers）</h2><p>我们可以将声明—说明符分成三个部分：类型说明符，存储类说明符，和其它说明符：<br>声明说明符：{类型说明符|存储类说明符|其它声明说明符}<br>然而，这种划分仅仅有助于理解，因为声明本身不存在对应的划分：声明—说明符可以以任何次序出现。<br>类型说明符决定了声明的类型。我们在§A.2/299中讨论内置类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type-specifier: char | wchar_t | bool | short | int | long | signed</span><br><span class="line">unsigned | float | double | void | type-name | const | volatile</span><br><span class="line">type-name: class-name | enum-name | typedef-name</span><br></pre></td></tr></table></figure>
<p>const说明符指出这种类型的对象不可以修改，volatile通知编译器变量可能以非语言定义的形式改变，应该避免优化。<br>注意const既可以出现在说明符部分，这样修改类型，也可以出现在声明子部分，说明一个const指针。这没有任何歧义，因为声明子部分的const总是跟着一个*。<br>存储类说明符决定变量的位置和生命周期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storage-class-specifiers: register | static | extern | mutable</span><br></pre></td></tr></table></figure>
<p>register说明符建议编译器通过将此对象放到寄存器中以优化性能。<br>一般，局部变量在退出声明它们的块（block）时即被销毁；静态变量的值在作用域的入口和出口间会被保存起来。<br>extern说明符表明当前的声明不是一个定义，隐含着在其它地方存在相应的定义。<br>mutable存储类仅用于类的数据成员，并且允许修改这些数据成员即使它们是常量对象的成员。<br>其它声明说明符定义了与类型无关的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other-decl-specifier: friend | inline | virtual | typedef</span><br></pre></td></tr></table></figure>
<p>friend说明符(§12.3.2/216 and §13.4.2/246)改写保护。<br>内联说明符用于函数定义，提示编译器如果可能内联下面的代码。当展开调用时，函数定义必须出现在那个作用域，因此将内联函数体放到声明函数的头文件中通常是一个好主意。<br>virtual说明符(§13.2.1/234)仅用于成员函数，表示这个函数是动态绑定的。<br>typedef说明符(§3.2.2/43)定义类型的同义词。</p>
<h2 id="声明子（Declarators）"><a href="#声明子（Declarators）" class="headerlink" title="声明子（Declarators）"></a>声明子（Declarators）</h2><p>一个声明为每个声明子都声明一个实体（entity）,同时为那个实体给出一个名字，并且隐含的给出存储类，类型，和由说明符给出的其它特性。说明符和声明子一起决定了名字是否是一个对象，数组，指针，引用或函数。例如，声明x为一个整型指针，f为一个函数返回一个整型。正是声明子*x和f()使类型x和f产生区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int *x, f();</span><br><span class="line">declarator: [ * [ const ] | &amp; ]... direct-declarator</span><br><span class="line">direct-declarator: declarator-id | ( declarator ) |</span><br><span class="line">direct-declarator ( parameter-declaration-list ) |</span><br><span class="line">direct-declarator [ constant-expression ]</span><br><span class="line">A declarator-id is an identifier, possibly qualified:</span><br><span class="line">declarator-id: [ nested-name-specifier ] identifier</span><br><span class="line">nested-name-specifier: &#123; class-or-namespace-name ::&#125;...</span><br></pre></td></tr></table></figure>
<p>如果声明子是一个仅包含一个declarator-id的直接-声明子，那么这说明这个标识符具有decl-specifiers隐含的属性，而没有进一步的修饰。例如，在下面的声明中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure>
<p>声明子是n，这是一个只包含direct-declarator的declarator-id，因此根据含义，n的类型为整型。<br>如果声明子为其它形式，那么你可以按照下面的方法确定标识符的类型：首先，假设T为decl-specifiers隐含的类型，忽略friend或static等非类型属性，同时假设D为声明子。然后重复下面的步骤直到推导出D为一个declarator-id，此时T正是你所寻找的类型：  </p>
<ol>
<li>如果D形如(D1)，那么用D1替换D。</li>
<li>如果D形如<em> D1 或 </em> const D1，那么根据是否有const，用“指针，它指向T”或者“常量指针，它指向T”替换T，然后用D1替换D。</li>
<li>如果D形如D1(参数-声明-列表)，那么用参数由参数-声明-列表定义的、“返回T的函数”替换T，然后用D1替换D。</li>
<li>如果D形如D1[常量-表达式]，那么用元素个数由常量-表达式给出的“T数组”替换T，然后然后用D1替换D。</li>
<li>最后，如果声明子形如&amp;D，那么用“T引用”替换T，然后用D1替换D。<br>作为一个示例，考虑下面的声明</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先，T和D分别为int和<em>f()，因此D形如</em>D1，其中D1为f()。<br>你可能认为D可以形如D1() 或者 <em>D1。然而，如果D形如D1()，那么D1将不得不为</em>f，D1将是一个direct-declarator（因为本节开始处的语法注1规定只有direct-declarator前面是()）。但是如果我们看看direct-declarator的定义注2，很明显它不能包含<em>。因此，D只能是</em>f()，它形如*D1，其中D为f()。<br>既然我们已经确定D1为f()，那么我们知道必须用“指针，它指向T”替换T，即“指针，指向整型”，同时用f()替换D。<br>至此我们还没有解析D为declarator-id，因此我们必须重复该过程。此时，D1只能是f，因此我们用“返回T的函数”替换T，它是一个“返回整型指针不带参数的函数”，然后用f替换D。<br>此时，D为declarator-id，因此推导结束。我们已经确定声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明f的类型为“不带参数返回整型指针的函数”。另一个例子，声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p, q;</span><br></pre></td></tr></table></figure>
<p>具有两个声明子，<em>p和q。对于每个声明子，T都是int。对于第一个声明子，D是</em>p，因此T变成“指针，它指向整型，”而D为p。声明p类型为“指针，它指向整型”。<br>我们单独分析第二个声明子，T还是int，D是q。很明显声明q为整型。<br>最后，让我们分析§10.1.2/173中那个奇怪的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>分析过程可以分为下面五个步骤  </p>
<ol>
<li>T: double    D: (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;)</li>
<li>T: 返回double带有 const vector&lt;Student_info&gt;&amp; 参数的函数    D: (*get_analysis_ptr())</li>
<li>T: function returning double… (如前所示)    D: *get_analysis_ptr()</li>
<li>T: 指针，它指向一个返回double…的函数    D: get_analysis_ptr()</li>
<li>T: 一个函数，返回一个函数指针，它指向一个返回double…的函数   D: get_analysis_ptr<br>get_analysis_ptr是一个函数，它返回一个函数指针，它指向一个返回double，带有const vector&lt;Student_info&gt;&amp;参数的函数。我们将如何展开const vector&lt;Student_info&gt;&amp;作为一个练习。幸运的是，很少有函数声明如此令人迷惑；它们中的大多数看起来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declarator: declarator-id ( parameter-declaration-list )</span><br></pre></td></tr></table></figure>
<p>到目前为止，常见情况中最难的是返回函数指针的函数。<br>注1：这里将allows翻译为规定而不是允许。因为如果翻译为允许，言外之意是()后面还可以是其它东西，但是在五条语法中找不到这种东西。语法指的是direct-declarator ( parameter-declaration-list )<br>注2：“declarator: [ * [ const ] | &amp; ]… direct-declarator”</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/17/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/09/2018-04-09-目标检测中的mAP计算/">目标检测中的mAP计算</a></h6>
              <span>四月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/07/2018-04-07-Iterative-Visual-Reasoning-Beyond-Convolutions论文笔记/">Iterative Visual Reasoning Beyond Convolutions论文笔记</a></h6>
              <span>四月 7, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/04/2018-04-04-最简单的K-means++算法原理和实践教程/">最简单的K-means++算法原理和实践教程</a></h6>
              <span>四月 4, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/02/2018-04-02-最简单的K-means算法原理和实践教程/">最简单的K-means算法原理和实践教程</a></h6>
              <span>四月 2, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/03/31/2018-03-31-为什么希尔排序表现出来的速度比归并排序快呢？/">为什么希尔排序表现出来的速度比归并排序快呢？</a></h6>
              <span>三月 31, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/03/26/2018-03-26-YOLOv3论文笔记/">YOLOv3论文笔记</a></h6>
              <span>三月 26, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">78</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means++</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/Li-Fei-Fei/" style="font-size: 10px;">Li Fei Fei</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/Pickle/" style="font-size: 10px;">Pickle</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 11.43px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/descriptor/" style="font-size: 10px;">descriptor</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/mAP/" style="font-size: 10px;">mAP</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/merge/" style="font-size: 10px;">merge</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10.71px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/super/" style="font-size: 10.71px;">super</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/时间复杂度/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 14.29px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://www.wangningcheng.com'>梦影无痕</a></li>
        
          <li class='link'><a href='https://blanboom.org'>Blanboom</a></li>
        
      </ul>
  </div>



  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
