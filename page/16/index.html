<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 16 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/16/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-04-12-loki&#39;s allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-loki's allocator/">loki::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-loki's allocator/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pData_: <span class="keyword">unsigned</span> <span class="keyword">char</span>*</span><br><span class="line">firstAvailableBlock_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//第一个可用的编号</span></span><br><span class="line">blocksAvailable_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//剩余可用的数目</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Init(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	pData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[blockSize * blocks];</span><br><span class="line">	Reset(blockSize, blocks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Reset(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	firstAvailableBlock_ = <span class="number">0</span>;</span><br><span class="line">	blocksAvailable_ = blocks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* p = pData_;</span><br><span class="line">	<span class="keyword">for</span>(; i!=blocks; p+=blockSize)</span><br><span class="line">		*p =++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Release()</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">delete</span>[] pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Allocate(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!blocksAvailable_) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* pResult = </span><br><span class="line">		pData_ + (firstAvailableBlock_ * blockSize);</span><br><span class="line">	firstAvailableBlock_ = *pResult;</span><br><span class="line">	--blocksAvailable_;</span><br><span class="line">	<span class="keyword">return</span> pResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Deallocate(<span class="keyword">void</span>* p,<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * toRelease = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">	*toRelease = firstAvailableBlock_;</span><br><span class="line">	firstAvailableBlock_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(</span><br><span class="line">						(toRelease - pData_)/blockSize);</span><br><span class="line">	++blocksAvailable_;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="FixedAllocator"><a href="#FixedAllocator" class="headerlink" title="FixedAllocator"></a>FixedAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunks_:<span class="built_in">vector</span>&lt;Chunk&gt;</span><br><span class="line">allocChunk_: Chunk*</span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *FixedAllocator::Allocate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(allocChunk == <span class="number">0</span> || allocChunk_-&gt;blocksAvailable_ == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunks::iterator i = chunks_.begin();</span><br><span class="line">		<span class="keyword">for</span>(;; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == chunks_.end())</span><br><span class="line">			&#123;</span><br><span class="line">				chunks_.push_back(Chunk());</span><br><span class="line">				Chunk&amp; newChunk = chunks_.back();</span><br><span class="line">				newChunk.Init(blockSize_, numBlocks_);</span><br><span class="line">				allocChunk_ = &amp;newChunk;<span class="comment">//指向上次给出去的chunk</span></span><br><span class="line">				deallocChunk_ = &amp;chunks_.front();<span class="comment">//指向上一次的回收</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i-&gt;blocksAvailable_&gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				allocChunk_ = &amp;*i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> allocChunk_-&gt;Allocate(blockSize_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Deallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_ = VicinityFind(p);</span><br><span class="line">	DoDealllocate(p);</span><br><span class="line">&#125;</span><br><span class="line">FixedAllocator::Chunk* FixedAllocator::VicinityFind(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> chunkLength = numBlocks_ * blockSize_;</span><br><span class="line">	</span><br><span class="line">	Chunk* lo = deallocChunk_;</span><br><span class="line">	Chunk* hi = deallocChunk_ + <span class="number">1</span>;</span><br><span class="line">	Chunk* loBound = &amp;chunks_.front();</span><br><span class="line">	Chunk* hiBound = &amp;chunks_.back() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(lo)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= lo-&gt;pData_ &amp;&amp; p&lt; lo-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> lo;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(lo == loBound) lo = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> --lo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= hi-&gt;pData_&amp;&amp; p &lt;hi-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> hi;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>( ++ hi == hiBound) hi = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::DoDeallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_-&gt;Deallocate(p, blockSize_);</span><br><span class="line"><span class="comment">//是否等于开始的登记值</span></span><br><span class="line">	<span class="keyword">if</span>(deallocChunk_-&gt;blocksAvailable == numBlocks)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunk&amp; lastChunk == chunks_.back();</span><br><span class="line"><span class="comment">//这里的做法与vc SBH defer类似</span></span><br><span class="line"><span class="comment">//__sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原</span></span><br><span class="line"><span class="comment">//本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer </span></span><br><span class="line"><span class="comment">//group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer </span></span><br><span class="line"><span class="comment">//group取出block完成分配，Defer指针会被取消(设为NULL);</span></span><br><span class="line"><span class="comment">//__sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(&amp;lastChunk == deallocChunk_)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(chunks_.size() &gt;<span class="number">1</span> &amp;&amp;</span><br><span class="line">				deallocChunk_[<span class="number">-1</span>].blocksAvailable_ == numBlocks)</span><br><span class="line">			&#123;</span><br><span class="line">				lastChunk.Release();</span><br><span class="line">				chunks_.pop_back();</span><br><span class="line">				allocChunk_ = deallocChunk_ = &amp;chunks_.front();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lastChunk.blocksAvailable == numBlocks)</span><br><span class="line">		&#123;</span><br><span class="line">			lastChunk.Release();</span><br><span class="line">			chunks_.pop_back();</span><br><span class="line">			allocChunk_ = deallocChunk_;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(*deallocChunk_, lastChunk);</span><br><span class="line">			allocChunk_ = &amp;chunks_.back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SmallObjAllocator"><a href="#SmallObjAllocator" class="headerlink" title="SmallObjAllocator"></a>SmallObjAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool_: <span class="built_in">vector</span>&lt;FixedAllocator&gt;</span><br><span class="line">pLastAlloc: FixedAllocator</span><br><span class="line">pLastDealloc: FixedAllocator</span><br><span class="line">chunkSize: <span class="keyword">size_t</span></span><br><span class="line">maxObjectSize: <span class="keyword">size_t</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-12-other issues"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-other issues/">other issues</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-other issues/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>当将元素加入容器中，容器必须分配更多的内存以足够保存这些元素，于是他们向他的模板参数allocator发出申请，该模板参数往往被另一个名为 allocator_type。甚至将chars添加到string class也是如此，因为string也算是一个正规的STL容器。每个元素类型为T的容器的Allocator模板默认为allocator<t>。其接口只有大约20个public申明，包括嵌套的typedefs和成员函数。最重要的两个成员函数是：</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Void <span class="title">deallocate</span><span class="params">(T* p, size_type n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>N指的是客户申请的元素个数，不是指空间总量。这些空间是通过调用::operator new获得，但何时需要并无具体指定。  </p>
<p>最容易满足需求的做法就是每当容器需要内存就调用operator new，每当容器释放内存就调用operator delete。这种做法比起分配大块内存并缓存然后小块小块的使用当然较慢，优势则是可以在极大范围的硬件和操作系统有效运作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::new_allocator</span><br></pre></td></tr></table></figure>
<p>实现出简洁的operator new 和operator delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator</span><br></pre></td></tr></table></figure>
<p>实现上例唯一不同的是，它使用c函数std::malloc和std::free  </p>
<p>另外一种做法就是使用智能型allocator，将分配所得的内存加以缓存。这种额外机制可以数种形式呈现：可以是个bitmap index，用以索引至一个以2的指数倍成长的篮子。也可以是个相较之下比较简易的fixed-size pooling cache这里所说的cache被程序内的所有容器共享，而operators new和operator delete不经常<br>被调用，这可带来速度上的优势。使用这个技巧的allocators包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::bitmap_allocator</span><br></pre></td></tr></table></figure>
<p>一个高效能的allocator，使用bit-map追踪被使用和未使用的内存块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::pool_allocator</span><br><span class="line">__gnu_cxx::__mt_alloc</span><br></pre></td></tr></table></figure>
<p>Class allocator 只拥有typedef,constructor,和rebind等成员。它继承自一个high-speed extension allocators。也因此，所有分配器和归还都取决于该base class，而这个base class也许是终端用户无法碰触和操控的。很难挑选出某个分配策略说他可以提供最大共同利益而不至于令某些行为过度优势。事实上，就算要挑选何种典型动作以测量速度，都是一种困难。<br>GNU C++提供三项综合测试用以C++allocators之间的速度比较：<br>Insertion进过多次iterations后各种STL容器将拥有某个极大量。分别测试sequence和associative容器。多线程环境中的insertion and erasure 。这个测试展示allocator归还内存，测量线程之间对内存的竞争。A threaded producer/consumer model分别测试sequence和associative容器。</p>
<p>另外两个智能allocator：<br><strong>gnu_cxx::debug_allocator<br>这个是一个外覆器(wrapper)，可包含于任何allocator之上。他把客户的申请量添加一些，然后由allocator回应，并以那个一小块额外内存放置size信息。一旦deallocate()收到一个pointer，就会检查size并以assert()保证吻合。  
</strong>gnu_cxx::array_allocator<br>允许分配一个已知固定大小的内存块，内存来自std::array objects。用上这个allocator，大小固定的容器就无需在调用::operator new 和::operator delete。这就允许我们使用STL abstractions而无需再运行期添加额外开销。甚至在program startup情况下也可使用。注意他是静态的，所以他不需要调用delete。</p>
<h2 id="Array-allocator"><a href="#Array-allocator" class="headerlink" title="Array allocator"></a>Array allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array内的第二个参数表示array的大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Array = <span class="built_in">std</span>::tr1::<span class="built_in">array</span>&lt;_Tp,<span class="number">1</span>&gt;&gt;</span><br><span class="line">class array_allocator:<span class="keyword">public</span> array_allocator_base&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Array array_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	array_type* _M_array;</span><br><span class="line">	size_type _M_used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	array_allocator(array_type* __array = <span class="literal">NULL</span>)<span class="keyword">throw</span>()</span><br><span class="line">		:_M_array(__array), _M_used(size_type())&#123;&#125;</span><br><span class="line">		...</span><br><span class="line">	pointer</span><br><span class="line">	allocate(size_type __n,<span class="keyword">const</span> <span class="keyword">void</span>* =<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_M_array == <span class="number">0</span>|| _M_used + __n&gt;_M_array &gt; size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		pointer __ret = _M_array-&gt;begin() + _M_used();</span><br><span class="line">		_M_used += __n;</span><br><span class="line">		<span class="keyword">return</span> __ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">debug_allocator</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">debug_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	size_type _M_extra;<span class="comment">//额外的空间，记录整个区块的大小</span></span><br><span class="line">	_Alloc _M_allocator;</span><br><span class="line">	</span><br><span class="line">	size_type _S_extra()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">size_t</span> __obj_size = <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">sizeof</span>(size_type) + __obj_size - <span class="number">1</span>)/__obj_size;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	debug_allocator(<span class="keyword">const</span> _Alloc&amp; __a)</span><br><span class="line">		:_M_allocator(__a), _M_extra(_S_extra())&#123;&#125;</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pointer __res = _M_allocator.allocate(__n + __m_extra);</span><br><span class="line">		size_type *__ps = <span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__res);</span><br><span class="line">		*__ps = __n;</span><br><span class="line">		<span class="keyword">return</span> __res + _M_extra;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::__throw_runtine_error;</span><br><span class="line">		<span class="keyword">if</span>(__p)</span><br><span class="line">		&#123;</span><br><span class="line">			pointer __real_p = __p + _m_extra;</span><br><span class="line">			<span class="keyword">if</span>(*<span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__real_p) != __n)</span><br><span class="line">				__throw_runtime_error</span><br><span class="line">					(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">			_M_allocator.deallocate(__ + _M_extra);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			__throw_runtime_error</span><br><span class="line">				(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bitmap-allocator"><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a>bitmap_allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitmap_allocator</span>:</span><span class="keyword">private</span> free_list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__n &gt; <span class="keyword">this</span>-&gt;max_size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,<span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_allocate_single_object();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> size_type __b = __n * <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;pointer&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__p !=<span class="number">0</span>,<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,tue))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;_M_delaoocate_single_object(__p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				::<span class="keyword">operator</span> <span class="keyword">delete</span>(_p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vector的元素排列将以super block size为依据，新进者若大于最末者，便直接delete新进者，否则delete最末者后再insert新进者，若没有到达64则insert到适当位置。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-11-malloc and free"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/11/2017-04-11-malloc and free/">malloc/free</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/11/2017-04-11-malloc and free/" class="article-date">
	  <time datetime="2017-04-10T16:00:00.000Z" itemprop="datePublished">四月 11, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SBH-small-block-heap"><a href="#SBH-small-block-heap" class="headerlink" title="SBH(small block heap)"></a>SBH(small block heap)</h1><h2 id="heap-init-和-sbh-heap-init"><a href="#heap-init-和-sbh-heap-init" class="headerlink" title="_heap_init() 和__sbh_heap_init()"></a>_heap_init() 和__sbh_heap_init()</h2><p>CRT为自己建立一个__crtheap，然后从中配置SBH所需的headers，regions作为管理用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _cdecl_heap_init(<span class="keyword">int</span> mtflag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(( _crtheap = HeapCreate( mtflag?<span class="number">0</span>: HEAP_NO_SERIALIZE,</span><br><span class="line">					BYTES_PER_PAGE, <span class="number">0</span> )) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( __sbh_heap_init() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HeapDestory(_crtheap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nNoMansLandSize 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> *<span class="title">pBlockHeaderPrev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *szFilename;<span class="comment">//指向的文件名ioinit.c</span></span><br><span class="line">	<span class="keyword">int</span> nLine;<span class="comment">//上面文件的第几行,81行</span></span><br><span class="line">	<span class="keyword">size_t</span> nDataSize;<span class="comment">//客户要的内存大小</span></span><br><span class="line">	<span class="keyword">int</span> nBlockUse;<span class="comment">//memory block</span></span><br><span class="line">	<span class="keyword">long</span> IRequest;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> gap[nNoMansLandSize];</span><br><span class="line">	<span class="comment">/*followed by:</span></span><br><span class="line"><span class="comment">	*unsigned char data[nDataSize];</span></span><br><span class="line"><span class="comment">	*unsigned char anothergap[nNoMansLandSize];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;_CrtMemBlockHeader;</span><br></pre></td></tr></table></figure>
<p>至此我们终于知道了，在debug模式下，分配的内存块中多出来的部分</p>
<h2 id="关于第一块内存的分配"><a href="#关于第一块内存的分配" class="headerlink" title="关于第一块内存的分配"></a>关于第一块内存的分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRegion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> indGroupUse;<span class="comment">//0xffffffff，用于分割</span></span><br><span class="line">	<span class="keyword">char</span> cntRegionSize[<span class="number">64</span>];</span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];</span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span> <span class="title">grpHeadList</span>[32];</span></span><br><span class="line">&#125;REGION, *PREGION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cntEntries; <span class="comment">//记录分配次数，每分配一次加一，回收减一</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span> <span class="title">listHead</span>[64];</span></span><br><span class="line">&#125;GROUP, *PGROUP;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;LISTHEAD, *PLISTHEAD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sizeFront;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryNext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> *<span class="title">pEntryPrev</span>;</span></span><br><span class="line">&#125;ENTRY, *PENTRY;</span><br></pre></td></tr></table></figure>
<h2 id="归还操作系统"><a href="#归还操作系统" class="headerlink" title="归还操作系统"></a>归还操作系统</h2><p><strong>sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer group取出block完成分配，Defer指针会被取消(设为NULL);  
</strong>sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl__sbh_heap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(! (__sbh_pHeaderList = HeapAlloc(crtheap,<span class="number">0</span>,<span class="number">16</span>*<span class="keyword">sizeof</span>(HEADER)))</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	__sbh_pHeaderScan = __sbh_pHeaderList;</span><br><span class="line">	__sbh_pHeaderDefer = <span class="literal">NULL</span>;</span><br><span class="line">	__sbh_cntHeaderList = <span class="number">0</span>;</span><br><span class="line">	__sbh_sizeHeaderList = <span class="number">16</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-10-std_allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/10/2017-04-10-std_allocator/">std::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/10/2017-04-10-std_allocator/" class="article-date">
	  <time datetime="2017-04-09T16:00:00.000Z" itemprop="datePublished">四月 10, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在vc6的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在bc5中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。<br>在G2.9中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计，但是它内部并没有使用，而是使用的std::alloc。<br>在4.9版中叫__pool_alloc，但是这两个都不是标准分配器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: __n is permitted to be 0.  The C++ standard says nothing</span></span><br><span class="line"> <span class="comment">// about what the return value is when __n == 0.</span></span><br><span class="line">pointer</span><br><span class="line">allocate(size_type __n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect(__n &gt; <span class="keyword">this</span>-&gt;max_size(), <span class="literal">false</span>))</span><br><span class="line">		<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp*&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__n * <span class="keyword">sizeof</span>(_Tp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __p is not permitted to be a null pointer.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">deallocate(pointer __p, size_type)</span><br><span class="line">&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>alloc的设计<br>申请32bytes，由于pool为空，所以成功所求32<em>20</em>2+RoundUp(0(目前的申请总量)&gt;&gt;4) =1280，从中切出一个，另外的19个给list#3，剩余640备用。每次分配前都是先看原先的是否有剩余pool，从pool切给出来的数量永远在1~20之间，pool余量不足够的时候，先将pool余量给相应的list#，然后索取相应的内存。当内存不够时，往右边找一块给他。如果就近找不到的话，就会失败。但是这样的话，还有很多的空内存未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二级分配器</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __ALIGN = <span class="number">8</span> &#125;;<span class="comment">//定义常量,小区快的下限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __MAX_BYTES = <span class="number">128</span> &#125;;<span class="comment">//上限</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; __NFREELISTS = __MAX_BYTES/ __ALIGN &#125;;<span class="comment">//freelist的长度</span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> ((bytes) + _ALIGN<span class="number">-1</span>) &amp; ~(_ALIGN - <span class="number">1</span>));</span><br><span class="line"> 	&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">union</span> obj</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="keyword">union</span> obj* free_list_link;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">static</span> obj *<span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line"> 	<span class="comment">//计算list#</span></span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN<span class="number">-1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;<span class="comment">//指向pool头</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;<span class="comment">//指向pool尾</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"> 	</span>&#123;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		obj* result;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)<span class="comment">//改用第一级</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"> 		result = *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(result == <span class="number">0</span>_</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line"> 			<span class="keyword">return</span> r;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		*my_free_list = result-&gt;free_list_link;</span><br><span class="line"> 		<span class="keyword">return</span> (result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//回收的时候，把要回收的部分插入二级链表的头</span></span><br><span class="line"> 	<span class="comment">//函数内部没有做p指针的检查，如果这个p指针不是这个系统的，</span></span><br><span class="line"> 	<span class="comment">//如果他不是8的倍数的话，回收后再分配时会出问题，原来分配给list#1，</span></span><br><span class="line"> 	<span class="comment">//可能现在到了list#2</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span> deallocate(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		obj* q = (obj*)p;</span><br><span class="line"> 		obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 		<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			malloc_alloc::deallocate(p,n);</span><br><span class="line"> 			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		my_free_list = free_list +FREELIST_INDEX(n);</span><br><span class="line"> 		q-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 		*my_free_list = q;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">void</span>* reallocate(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz);<span class="comment">//略</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">char</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"> chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">char</span> *result;</span><br><span class="line"> 	<span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line"> 	<span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">if</span>( bytes_left &gt;= total_bytes)<span class="comment">//pool能否满足20个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span>( bytes_left &gt;= size)<span class="comment">//pool能否满足1个</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		nobjs = bytes_left /size;</span><br><span class="line"> 		total_bytes = size * nobjs;</span><br><span class="line"> 		result = start_free;</span><br><span class="line"> 		start_free += total_bytes;</span><br><span class="line"> 		<span class="keyword">return</span>(result);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 	<span class="comment">//空pool或者为碎片</span></span><br><span class="line"> 		<span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"> 		<span class="comment">//将碎片挂接</span></span><br><span class="line"> 		<span class="keyword">if</span>( bytes_left &gt; <span class="number">0</span>)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line"> 			((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line"> 			*my_free_list = (obj*)start_free;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//分配内存</span></span><br><span class="line"> 		start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"> 		<span class="keyword">if</span>( <span class="number">0</span> == start_free)<span class="comment">//分配失败的话，从freelist中找</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">int</span> i;</span><br><span class="line"> 			obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"><span class="comment">//try to make do with what we have.that can’t hurt.</span></span><br><span class="line"><span class="comment">//we do not try smaller requests,since that tends</span></span><br><span class="line"><span class="comment">//to result in disaster on muti-process machines.</span></span><br><span class="line"> 			<span class="keyword">for</span>( i = size; i &lt;= __MAX_BYTES; i+= __ALIGN)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line"> 				p = *my_free_list;</span><br><span class="line"> 				<span class="keyword">if</span>( <span class="number">0</span> != p)</span><br><span class="line"> 				&#123;</span><br><span class="line"> 					*my_free_list = p-&gt;free_list_link;</span><br><span class="line"> 					start_free = (<span class="keyword">char</span> *)p;</span><br><span class="line"> 					end_free = start_free + i;</span><br><span class="line"> 					<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			<span class="comment">//表示memory已经‘没有’了</span></span><br><span class="line"> 			end_free = <span class="number">0</span>;</span><br><span class="line"> 			start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		heap_size += bytes_to_get;</span><br><span class="line"> 		end_free = start_free + bytes_to_get;</span><br><span class="line"> 		<span class="keyword">return</span> (chunk_alloc(size, nobjs));</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"> <span class="keyword">void</span> *</span><br><span class="line"> __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)<span class="comment">//n已经是8的倍数</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">int</span> nobjs = <span class="number">20</span>;<span class="comment">//预设20个</span></span><br><span class="line"> 	<span class="keyword">char</span> *chunk = chunk_alloc(n, nobjs);</span><br><span class="line"> 	obj* <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line"> 	obj* result;</span><br><span class="line"> 	obj* current_obj;</span><br><span class="line"> 	obj* next_obj;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">if</span>( <span class="number">1</span>== nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"> 	my_free_list = free_list_link;</span><br><span class="line"> 	result = (obj*)chunk;</span><br><span class="line"> 	*my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line"> 	<span class="comment">//在chunk内建立freelist</span></span><br><span class="line"> 	<span class="keyword">for</span>( i = <span class="number">1</span>; ; ++i)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		current_obj = next_obj;</span><br><span class="line"> 		next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line"> 		<span class="keyword">if</span>( nobjs<span class="number">-1</span> == i)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			current_obj-&gt;free_list_link = next_obj;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> (result);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;;:heap_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[_NFREELISTS]</span><br><span class="line">= &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt; alloc;</span><br></pre></td></tr></table></figure>
<p>deallocate完全没有free，设计上的缺陷，没有变量记录freelist的起始位置</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-09-内存管理primitives"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/09/2017-04-09-内存管理primitives/">内存管理 primitives</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/09/2017-04-09-内存管理primitives/" class="article-date">
	  <time datetime="2017-04-08T16:00:00.000Z" itemprop="datePublished">四月 9, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSR_VER</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">int</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">//以下两个函数都是static，可以通过全名调用，2.9ver</span></span><br><span class="line"><span class="keyword">void</span> *p4 = alloc::allocate(<span class="number">512</span>);</span><br><span class="line">alloc::deallocate(p4, <span class="number">512</span>);</span><br><span class="line"><span class="comment">//4.9ver 以下两个函数都是non-static，一定要通过object调用</span></span><br><span class="line"><span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p5 = __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">9</span>);</span><br><span class="line">__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;.deallocate((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="New-expression"><a href="#New-expression" class="headerlink" title="New expression"></a>New expression</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//只有编译器可以这样调用ctor</span></span><br><span class="line"><span class="comment">//想要直接调用ctor，可以运用placement new；</span></span><br><span class="line"><span class="comment">//new(p)Complex(1,2);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::nothrow <span class="keyword">_t</span>&amp;)</span> _<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//nothrow struct is used as a function parameter to operator new to </span></span></span><br><span class="line"><span class="function"><span class="comment">//indicate that the function should return a null pointer to report</span></span></span><br><span class="line"><span class="function"><span class="comment">//an allocation failure ,rather than throw an exception</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">	    <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">	    &#123;       <span class="comment">// report no memory</span></span><br><span class="line">	            _THROW_NCEE(_XSTD bad_alloc, );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> expression</span><br><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line">pc-&gt;~Complex();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span>_<span class="title">THROW0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Array-new-array-delete"><a href="#Array-new-array-delete" class="headerlink" title="Array new,array delete"></a>Array new,array delete</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex *pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//唤起3次ctor</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] pca;<span class="comment">//唤起3次dtor</span></span><br><span class="line"><span class="comment">//一下做法会造成内存泄漏，string的内部有指针</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> psa;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1feijde9fnuj20860hxdmk.jpg" class="img-fluid"><br></a></p>
<p>61h为cookie，用来记录空间的大小，最后一个字节用来记录内存是在使用，还是未使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo *p = <span class="keyword">new</span> Demo[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1feijdeoxfpj20830hjgrh.jpg" class="img-fluid"><br></a></p>
<p>第一个p指向的地址是00481c30，第二个p指向的地址是00481c34，如果写成delete p;的话，那么会从第一个p开始而不是第二个，就会出问题，多出一个3，这个3表示调用几次析构。如果Demo没有nontrivial dtor ,就不会记录3，也就是说，和上面的int类似，可以不加[]。<br>关于内存空间，必须要调节16的倍数，所以增加了pad这个东西。</p>
<h1 id="Placement-new"><a href="#Placement-new" class="headerlink" title="Placement new"></a>Placement new</h1><p>Placement new 允许我们将object建立于 allocated memory中没有所谓的placement delete，因为placement new根本没有分配memory亦或称呼placement new 对应的operator delete为placement delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>];</span><br><span class="line">Complex *pc = <span class="keyword">new</span>(buf)Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//等同于调用构造函数</span></span><br><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));<span class="comment">//没有做任何事</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> ,<span class="keyword">void</span> *loc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> loc; &#125;</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>
<p>关于placement new，或指为new(p)，或指为::operator new(size, void*)</p>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="重载-operator-new-operator-delete"><a href="#重载-operator-new-operator-delete" class="headerlink" title="重载::operator new/::operator delete"></a>重载::operator new/::operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myAlloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAlloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">size_t</span> size) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">size_t</span> size) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete"><a href="#重载operator-new-operator-delete" class="headerlink" title="重载operator new/operator delete"></a>重载operator new/operator delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载operator-new-operator-delete-1"><a href="#重载operator-new-operator-delete-1" class="headerlink" title="重载operator new[]/operator delete[]"></a>重载operator new[]/operator delete[]</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = <span class="keyword">new</span> Foo[n];</span><br><span class="line">...</span><br><span class="line">Delete[] p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new()/delete()"></a>重载new()/delete()</h2><p>我们重载class member operator new(),前提是每一个版本的声明都必须是独特的参数列，其中第一个参数必须是size_t，其余参数以new所指定的placement arguments为初值.出现new()小括号内的便是所谓的placement argument</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo *pf = <span class="keyword">new</span> (<span class="number">300</span>,<span class="string">'c'</span>) Foo;<span class="comment">//第一个参数表所示Foo的大小</span></span><br><span class="line"><span class="comment">//一般重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">malloc</span>(size); &#125;</span><br><span class="line"><span class="comment">//placement new()的标准写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> *start)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> start; &#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。他只能这样被调用，主要用来clean未完成创建的object所占的memory。即使operator delete() 未能一一对应operator new() ,编译器也不会报错，这样做的意思是放弃处理ctor发出的异常。  </p>
<p>Basic_string使用new(extra)<br>平时使用的string就是typdef  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Rep</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>( --ref == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> Rep* <span class="title">create</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep*</span><br><span class="line">basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">create(<span class="keyword">size_t</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">	extra = frob_size(extra + <span class="number">1</span>);</span><br><span class="line">	Rep *p = <span class="keyword">new</span>(extra) Rep;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span>, <span class="title">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> *<span class="title">basic_string</span>&lt;charT, traits, Allocator&gt;:</span>:Rep::</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> s,<span class="keyword">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Allocator::allocate(s + extra * <span class="keyword">sizeof</span>();<span class="comment">//placement new的重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;class charT, class traits, class Allocator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> basic_string&lt;charT, traits, Allocator&gt;::Rep::</span><br><span class="line">opreraotr <span class="keyword">delete</span>(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	Allocator::deallocate(ptr...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">1</span></span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">class Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Screen(<span class="keyword">int</span> x) :i(x) &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> get() &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Screen *next;</span><br><span class="line">	<span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Screen *Screen::freeSore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	Screen *p;<span class="comment">//这种设计多用了一个指针</span></span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = screenChunk *size;</span><br><span class="line">		freeStore = p = <span class="keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="keyword">new</span> <span class="keyword">char</span> [chunk]);</span><br><span class="line"><span class="comment">//将一大块分割后，用链表穿起来</span></span><br><span class="line">		<span class="keyword">for</span>(; p!= &amp;freeStore[screenChunk<span class="number">-1</span>]; ++p)</span><br><span class="line">			p-&gt;next = p +<span class="number">1</span>;</span><br><span class="line">		p-&gt;next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p,<span class="keyword">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将delete object插回</span></span><br><span class="line">	(<span class="keyword">static_cast</span> &lt;Screen*&gt;(p))-&gt;next = freeStore;</span><br><span class="line">	freeStore = <span class="keyword">static_cast</span>&lt;Screen*&gt;(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Pre-class allocator，<span class="number">2</span></span><br><span class="line">class Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	struct AirplaneRep</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> miles;</span><br><span class="line">		<span class="keyword">char</span> type;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		AirplaneRep rep;</span><br><span class="line">		Airplane *next;<span class="comment">//嵌入式指针，相对于前面的来说非常不错</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长</span></span><br><span class="line"><span class="comment">//度是AirplaneRep型态。</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数</span></span><br><span class="line"><span class="comment">//据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> getMiles() &#123; <span class="keyword">return</span> rep.miles;&#125;</span><br><span class="line">	<span class="keyword">char</span> getType() &#123; <span class="keyword">return</span> rep.type; &#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="built_in">set</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> m, <span class="keyword">char</span> t)</span><br><span class="line">	&#123;</span><br><span class="line">		rep.miles = m;</span><br><span class="line">		rep.type = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> *opertor <span class="keyword">new</span>(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="comment">//注意这里static，编译器默认也是static，原因在于，要在对象创建时调用，</span></span><br><span class="line"><span class="comment">//如果不是static，对象创建时，可能这个东西还在创建的过程中</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BLOCK_SIZE;	<span class="keyword">static</span> Airplane *headOfFreeList;</span><br><span class="line">&#125;;</span><br><span class="line">Airplane *Airplane::headOfFreeList;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Airplane::BLOCK_SIZE=<span class="number">512</span>;</span><br><span class="line"><span class="keyword">void</span> *Airplane::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当继承发生时</span></span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line">	Airplane *p = headOfFreeList;</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">		headOfFreeList = p-&gt;next;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Airplane *newBlock = <span class="keyword">static_cast</span>&lt;Airplane*&gt;</span><br><span class="line">		(::<span class="keyword">operator</span> <span class="keyword">new</span>(BLOCK_SIZE * <span class="keyword">sizeof</span>(Airplane));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;BLOCK_SIZE - <span class="number">1</span>;++i)</span><br><span class="line">			newBlock[i].next = &amp;newBlock[i+<span class="number">1</span>];</span><br><span class="line">		newBlock[BLOCK_SIZE<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">		p = newBlock;</span><br><span class="line">		headOfFreeList = &amp;newBlock[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Airplane::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(deadObject == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="keyword">operator</span> <span class="keyword">delete</span>(deadObject);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Airplane *carcass = <span class="keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);</span><br><span class="line">	carcass-&gt;next = headOfFreeList;</span><br><span class="line">	headOfFreeList = carcass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static-allocator"><a href="#static-allocator" class="headerlink" title="static allocator"></a>static allocator</h1><p>不同的class重写一遍几乎相同member operator new和member operator delete时，应该有方法将他们统一在一起，是他可以重用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">obj</span>* <span class="title">next</span>;</span><span class="comment">//与linux里的链表做法一样</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	obj* freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> CHUNK = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> *allocator::allocate(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	obj *p;</span><br><span class="line">	<span class="keyword">if</span>(!freeStore)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> chunk = CHUNK *size;</span><br><span class="line">		freeStore = p = (obj*)<span class="built_in">malloc</span>(chunk);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; (CHUNK<span class="number">-1</span>); +i)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = (obj*)((<span class="keyword">char</span>*)p+size);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = freeStore;</span><br><span class="line">	freeStore = freeStore-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	((obj*)p)-&gt;next = freeStore;</span><br><span class="line">	freeStore = (obj*)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Foo可以这样写了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pHead, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    &#123; <span class="keyword">return</span> myAlloc.deallocate(pHead, size); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做就方便了很多</p>
<h1 id="Macro-for-static-allocator"><a href="#Macro-for-static-allocator" class="headerlink" title="Macro for static allocator"></a>Macro for static allocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\表示续行符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_POOL_ALLOC()\</span></span><br><span class="line"><span class="keyword">public</span>:\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125;\</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123; myAlloc.deallocate(p, <span class="number">0</span>); &#125;\</span><br><span class="line"><span class="keyword">protected</span>:\</span><br><span class="line">	<span class="keyword">static</span> allocator myAlloc;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name)\</span></span><br><span class="line">allocator class_name::myAlloc;</span><br></pre></td></tr></table></figure>
<p>原来的变成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DECLARE_POOL_ALLOC()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">long</span> L;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(<span class="keyword">long</span> l) : L(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">IMPLEMENT_POOL_ALLOC(Foo)</span><br></pre></td></tr></table></figure>
<h1 id="New-handler"><a href="#New-handler" class="headerlink" title="New handler"></a>New handler</h1><p>当operator new 没有能力分配申请的memory，会抛出异常std::bad_alloc execption以仍然可以让编译器new(nothrow) Foo;<br>抛出异常之前会调用一个可由client指定的handler，以下是new handler的形式和设定方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>设计良好的new handler只有俩个选择：<br>让更多的memory可用 调用abort()和exit()</p>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h1><p>It is not only for ctor and assignments,but also apllies to operator new/new[],operator delete/delete[] and their overloads</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo() = <span class="keyword">default</span>;<span class="comment">//表示使用默认版本，如果没有的话使用编译器合成版</span></span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示不使用这个函数 </span></span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">	~Foo()=defalut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-08-cast"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/08/2017-04-08-cast/">static_cast,dynamic_cast,reinterpret_cast和const_cast</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/08/2017-04-08-cast/" class="article-date">
	  <time datetime="2017-04-07T16:00:00.000Z" itemprop="datePublished">四月 8, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。<br>同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。</p>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p>用法：static_cast \&lt;typeid> (expression)<br>说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。<br>用途：  </p>
<ol>
<li>用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。</li>
<li>用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。</li>
<li>可以把空指针转换成目标类型的空指针(null pointer)。</li>
<li>把任何类型的表达式转换成void类型。<br>注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。</li>
</ol>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>用法：dynamic_cast\&lt;typeid> (expression)<br>说明：该运算符把expression转换成typeid类型的对象。typeid必须是类的指针、类的引用或者void*。如果typeid是类的指针类型，那么expression也必须是指针，如果typeid是一个引用，那么expression也必须是一个引用。一般情况下，dynamic_cast用于具有多态性的类(即有虚函数的类)的类型转换。  </p>
<p>dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。先看RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换,例如从派生类指针转换成基类指针。而这种转换其实并不需要dynamic_cast参与。也就是说,dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的。</p>
<p>用途：主要用于类层次之间的up-casting和down-casting，还可以用于类之间的交叉转换。在进行down-casting时，dynamic_cast具有类型检查的功能，比static_cast更安全。检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转 换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。<br>注意：dynamic_cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>用法：reinterpret_cast \&lt;typeid>(expression)<br>说明：转换一个指针为其他类型的指针，也允许将一个指针转换为整数类型，反之亦然。这个操作符能够在非相关的类型之间进行转换。操作结果只是简单的从一个指针到<br>别的指针的值的二进制拷贝，在类型之间指向的内容不做任何类型的检查和转换。这是一个强制转换。使用时有很大的风险，慎用之。<br>注意：reinterpret _cast不能转换掉expression的const、volitale或者__unaligned属性。</p>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>用法：const_cast\&lt;typeid>(expression)<br>说明：这个类型操纵传递对象的const属性，或者是设置或者是移除。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class C&#123;…&#125;</span><br><span class="line"><span class="keyword">const</span> C* a = <span class="keyword">new</span> C;</span><br><span class="line">C* b = <span class="keyword">const_cast</span>&lt;C*&gt;(a);</span><br></pre></td></tr></table></figure>
<p>如果将上面的const_cast转换成其他任何其他的转换，编译都不能通过，出错的信心大致如下：</p>
<p>“…cannot convert from ‘const class C <em>‘ to ‘class C </em>‘”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _base;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> _derived;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; _derived &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Base b1;</span><br><span class="line">     Derived d1;</span><br><span class="line">     <span class="keyword">int</span> aInt = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">long</span> aLong = <span class="number">11</span>;</span><br><span class="line">     <span class="keyword">float</span> aFloat = <span class="number">11.11f</span>;</span><br><span class="line">     <span class="keyword">double</span> aDouble = <span class="number">12.12</span>;</span><br><span class="line">     Derived* pd = <span class="keyword">static_cast</span>&lt;Derived*&gt;(&amp;b1);     <span class="comment">// down-casting  不安全</span></span><br><span class="line">     Base* pb = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;d1);       <span class="comment">// up-casting   安全</span></span><br><span class="line">     Derived&amp; d = <span class="keyword">static_cast</span>&lt;Derived&amp;&gt;(b1);  <span class="comment">// down-casting   不安全</span></span><br><span class="line">     Base&amp; b = <span class="keyword">static_cast</span>&lt;Base&amp;&gt;(d1);   <span class="comment">// up-casting    安全</span></span><br><span class="line"></span><br><span class="line">     aInt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(aFloat);        <span class="comment">// 基本数据类型转换</span></span><br><span class="line">     <span class="keyword">void</span>* sth = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;aDouble);    <span class="comment">// 将double指针类型转换成void指针类型</span></span><br><span class="line">     <span class="keyword">double</span>* bDouble = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(sth);<span class="comment">// 将void指针类型转换成double指针类型</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; *bDouble &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     Base* pb1 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(&amp;d1);</span><br><span class="line">     <span class="comment">//Derived* pd1 = dynamic_cast&lt;Derived*&gt;(&amp;b1); // 编译时有warning，运行时出错</span></span><br><span class="line">     <span class="keyword">int</span> bInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(pb1);     <span class="comment">// 将地址或指针转换成整数</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; bInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base*&gt;(bInt);   <span class="comment">// 将整数转换成地址或指针</span></span><br><span class="line">     <span class="keyword">int</span>* cInt = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;aFloat);<span class="comment">// 这个转换的结果会出乎意料</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)*cInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">const</span> Base* bBase = <span class="keyword">new</span> Base();</span><br><span class="line">     Base* cBase = <span class="keyword">const_cast</span>&lt;Base*&gt;(bBase);</span><br><span class="line">     <span class="comment">//Base* dBase = dynamic_cast&lt;Base*&gt;(bBase);  // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* eBase = static_cast&lt;Base*&gt;(bBase);      // 不能通过编译</span></span><br><span class="line">     <span class="comment">//Base* fBase = reinterpret_cast&lt;Base*&gt;(bBase);    // 不能通过编译</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-06-分配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/06/2017-04-06-分配器/">分配器 allocators</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/06/2017-04-06-分配器/" class="article-date">
	  <time datetime="2017-04-05T16:00:00.000Z" itemprop="datePublished">四月 6, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span>:<span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>:<span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">deque</span>:<span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		typenaem _Alloc = <span class="built_in">std</span>::allocator&lt;_Key&gt;&gt;</span><br><span class="line">class <span class="built_in">set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare = <span class="built_in">std</span>::less&lt;_Key&gt;, </span><br><span class="line">		<span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">map</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Value&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_set</span></span><br><span class="line"><span class="keyword">template</span>&lt;class _Value, class _Hash = bash&lt;_Value&gt;,</span><br><span class="line">		class _Pred = <span class="built_in">std</span>::equal_to&lt;_Key&gt;,</span><br><span class="line">		class _Alloc = <span class="built_in">std</span>::allocator&lt;_Value&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_map</span></span><br></pre></td></tr></table></figure>
<p>一般写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc1;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>);</span><br><span class="line">alloc1.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>特殊写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__pool_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::__mt_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">__gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br></pre></td></tr></table></figure>
<p>不建议用分配器，应该用容器，new malloc</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分配器/">分配器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-04-适配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/04/2017-04-04-适配器/">适配器 adapters</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/04/2017-04-04-适配器/" class="article-date">
	  <time datetime="2017-04-03T16:00:00.000Z" itemprop="datePublished">四月 4, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="容器的适配器：stack，queue"><a href="#容器的适配器：stack，queue" class="headerlink" title="容器的适配器：stack，queue"></a>容器的适配器：stack，queue</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;<span class="comment">//底层容器deque</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数适配器binder2nd"><a href="#函数适配器binder2nd" class="headerlink" title="函数适配器binder2nd"></a>函数适配器binder2nd</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">binder2nd</span>&lt;Operation&gt; <span class="title">bind2nd</span> (<span class="title">const</span> <span class="title">Operation</span>&amp; <span class="title">op</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//辅助函数，让user更方便的使用binder2nd</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line"><span class="comment">//typename 原因在于不知道后面的类型，所以要告诉编译器他是一个typename</span></span><br><span class="line">	<span class="keyword">return</span> binder2nd&lt;Operation&gt;(op, arg2_type(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">bind2nd</span> :</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">									<span class="keyword">typename</span> Operation::result_type&gt;</span><br><span class="line"><span class="comment">//注意这里的继承，如果这个functor还可以被别人使用的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Operation op;<span class="comment">//内部成员</span></span><br><span class="line">	<span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	binder2nd(<span class="keyword">const</span> Operation&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type)</span><br><span class="line">	: op(x), value(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Operation::result_type</span><br><span class="line">	<span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> op(x, value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数适配器not1"><a href="#函数适配器not1" class="headerlink" title="函数适配器not1"></a>函数适配器not1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">unary_negate</span>&lt;Predicate&gt;<span class="title">not1</span>(<span class="title">const</span> <span class="title">Predicate</span>&amp; <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unary_negate</span></span></span><br><span class="line"><span class="class">:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Predicate pred;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//explicit关键字的作用就是防止类构造函数的隐式自动转换</span></span><br><span class="line">	explicit unary_negate(const Predicate&amp; x) : pred(x) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> !pred(x); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="新型适配器bind"><a href="#新型适配器bind" class="headerlink" title="新型适配器bind"></a>新型适配器bind</h2><p>Since c++11  </p>
<p><functional>bind —–&gt;<functional>binder1st  </functional></functional></p>
<p><functional>bind —–&gt;<functional>binder2nd  </functional></functional></p>
<p><functional>bind —–&gt;<functional>bind1st  </functional></functional></p>
<p><functional>bind —–&gt;<functional>bind2nd</functional></functional></p>
<p>可以绑定</p>
<ol>
<li>functions </li>
<li>functions objects </li>
<li>member functions ，_1必须是某个object的地址</li>
<li>data members，_1必须是某个object的地址</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::bind</span></span></span><br><span class="line"><span class="comment">// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> a,b;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...占位符</span></span><br><span class="line">  <span class="comment">// binding functions:</span></span><br><span class="line">  <span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,_1,<span class="number">2</span>);               <span class="comment">// returns x/2</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind (my_divide,_2,_1);            <span class="comment">// returns y/x</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt; (my_divide,_1,_2);     <span class="comment">// returns int(x/y)</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// binding members:</span></span><br><span class="line">  <span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind (&amp;MyPair::multiply,_1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/适配器/">适配器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-03-仿函数"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/03/2017-04-03-仿函数/">仿函数 functors</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/03/2017-04-03-仿函数/" class="article-date">
	  <time datetime="2017-04-02T16:00:00.000Z" itemprop="datePublished">四月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="仿函数functors"><a href="#仿函数functors" class="headerlink" title="仿函数functors"></a>仿函数functors</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算数类arithmetic</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span>:</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span>:</span> <span class="keyword">public</span> binary_function&lt; T, T,T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//逻辑运算类logical</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function &lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//相对关系类relational</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T , T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Stl的仿函数都是继承一个类<br>自己写的话也要这样做，才可以融入stl</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//一个操作数，如对一个东西取非</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Stl规定每个adaptable function都应该挑选适当的继承。这种继承没有任何的坏处，他的空间没有变大。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/仿函数/">仿函数</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-02-迭代器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/02/2017-04-02-迭代器/">迭代器 iterators</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/02/2017-04-02-迭代器/" class="article-date">
	  <time datetime="2017-04-01T16:00:00.000Z" itemprop="datePublished">四月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="迭代器的种类"><a href="#迭代器的种类" class="headerlink" title="迭代器的种类"></a>迭代器的种类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forword_iterator_tag</span> :</span><span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" class="img-fluid"><br></a></p>
<h1 id="迭代器对算法的影响"><a href="#迭代器对算法的影响" class="headerlink" title="迭代器对算法的影响"></a>迭代器对算法的影响</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIteartor&gt;:</span>:difference_type</span><br><span class="line">__distance(InputIterator first, InputIterator last,</span><br><span class="line">			input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(fisrt != last)</span><br><span class="line">	&#123;</span><br><span class="line">		++first; ++n; <span class="comment">///数据量一大的话,这样效率会很低.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;RandomAccessIterator&gt;:</span>:difference_type</span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">			random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">distance(InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> </span><br><span class="line"><span class="comment">//取出迭代器的分类</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;;:iterator_category category;</span><br><span class="line">	<span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里虽然只写了两种，但是由于前面图例的继承关系,所以是可以的</p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" class="img-fluid"><br></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">temlplate&lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">destory</span>(<span class="title">FI</span> <span class="title">first</span>, <span class="title">FI</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__destory(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">destory</span>(<span class="title">T</span>* <span class="title">pointer</span>)</span></span><br><span class="line"><span class="class">&#123;</span> pointer-&gt;~T(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Itr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Itr&gt;:</span>:value_type*</span><br><span class="line">value_type(<span class="keyword">const</span> Itr&amp;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span></span><br><span class="line">	&lt;<span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::valur_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">char</span> *)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(wchar *,wchar *)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class">__<span class="title">destory_aux</span>(<span class="title">FI</span>, <span class="title">FI</span>,__<span class="title">true_type</span>)&#123;</span>&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> </span></span><br><span class="line"><span class="class">__<span class="title">destory__aux</span>(<span class="title">FI</span> <span class="title">first</span>,<span class="title">FI</span> <span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span>(; first &lt;last; ++first)</span><br><span class="line">		destory(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FI</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destory</span>(<span class="title">FI</span> <span class="title">first</span>, <span class="title">FI</span> <span class="title">last</span>, <span class="title">T</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> </span><br><span class="line">	__type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">	__destory_aux(first,last, trivial_destructor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法源码中对于迭代器的分类的暗示，没有强制要求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">distance (InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">	<span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">				<span class="title">RandomAccessIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(first != last)</span><br><span class="line">	&#123;</span><br><span class="line">		__introsort_loop(first, last, value_type(first), __lg(last-first) * <span class="number">2</span>);</span><br><span class="line">		__final_insertion_sort(first, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于reverse-iterator，rbegin-，rend"><a href="#关于reverse-iterator，rbegin-，rend" class="headerlink" title="关于reverse iterator，rbegin()，rend"></a>关于reverse iterator，rbegin()，rend</h1><p><a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" class="img-fluid"><br></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse_iterator</span><br><span class="line">rbegin()</span><br><span class="line">&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//用了iterator adapter</span></span><br><span class="line">reverse_iterator</span><br><span class="line">rend()</span><br><span class="line">&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/17/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/03/01/2018-03-01-关于时间复杂度的几个典型证明/">关于时间复杂度的几个典型证明</a></h6>
              <span>三月 1, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/21/2018-02-21-Python-Pickle任意代码执行漏洞/">Python Pickle任意代码执行漏洞</a></h6>
              <span>二月 21, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/10/2018-02-10-python实现2048/">Python实现2048</a></h6>
              <span>二月 10, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/09/2018-02-09-图片转字符画/">图片转化为字符画</a></h6>
              <span>二月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/">c++中空字符串解释为True的困惑</a></h6>
              <span>二月 5, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/26/2018-01-26-python字符串令牌解析/">python字符串令牌解析</a></h6>
              <span>一月 26, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/Pickle/" style="font-size: 10px;">Pickle</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.71px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/时间复杂度/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.57px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://www.wangningcheng.com'>梦影无痕</a></li>
        
          <li class='link'><a href='https://blanboom.org'>Blanboom</a></li>
        
      </ul>
  </div>



  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
