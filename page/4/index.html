<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/4/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2018-08-11-Leetcode-104二叉树的最大深度（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/11/2018-08-11-Leetcode-104二叉树的最大深度（最详细的解法！！！）/">Leetcode 104：二叉树的最大深度（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/11/2018-08-11-Leetcode-104二叉树的最大深度（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-08-10T16:00:00.000Z" itemprop="datePublished">八月 11, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<p><strong>解题思路</strong></p>
<p>整个问题一个很简单的思路就是使用递归。怎么做呢？我们只要通过<code>maxDepth</code>分别计算出左子树和右子树的深度，比较这两个深度，取最大值<code>k</code>。那么当前这棵树深度的最大值就变成了<code>k + 1</code>。So easy！！O(∩_∩)O</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当然我们可以写得更加简洁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">else</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>但是还没有结束，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决。那这个问题怎么通过迭代解决呢？那么我们就会用到<code>stack</code>，通过<code>stack</code>模拟上面的递归过程。一个较为简单的思路就是二叉树的层序遍历，参看这篇<a href="http://blog.csdn.net/qq_17550379/article/details/80824320" target="_blank" rel="noopener">Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）</a>  ，我们在此基础上稍加修改就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        q = [(root, <span class="number">1</span>)]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, depth = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result = max(result, depth)</span><br><span class="line">                q.extend([(node.left, depth + <span class="number">1</span>), (node.right, depth + <span class="number">1</span>)])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-08-11-Leetcode-100相同的树（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/11/2018-08-11-Leetcode-100相同的树（最详细的解法！！！）/">Leetcode 100：相同的树（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/11/2018-08-11-Leetcode-100相同的树（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-08-10T16:00:00.000Z" itemprop="datePublished">八月 11, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>这个问题同样使用递归很轻松就可以解决，关键就是要理清楚递归函数的意义。我们判断<code>p</code>和<code>q</code>的<code>root、left、right</code>的值是不是相同即可。这里我们要考虑好终止条件（<code>p、q</code>是不是空）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>同样的，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决。那这个问题怎么通过迭代解决呢？那么我们就会用到<code>stack</code>，通过<code>stack</code>模拟上面的递归过程。一个较为简单的思路就是二叉树的层序遍历，参看这篇<a href="http://blog.csdn.net/qq_17550379/article/details/80824320" target="_blank" rel="noopener">Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）</a>  ，我们在此基础上稍加修改就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        q = [(p, q)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node1, node2 = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node1 <span class="keyword">and</span> node2 <span class="keyword">and</span> node1.val == node2.val:</span><br><span class="line">                q.append((node1.left, node2.left))</span><br><span class="line">                q.append((node1.right, node2.right))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node1 != node2: <span class="comment"># node1 == None and node2 != None  node1 != None and node2 == None</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-08-11-Leetcode-111二叉树的最小深度（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/11/2018-08-11-Leetcode-111二叉树的最小深度（最详细的解法！！！）/">Leetcode 111：二叉树的最小深度（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/11/2018-08-11-Leetcode-111二叉树的最小深度（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-08-10T16:00:00.000Z" itemprop="datePublished">八月 11, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<p><strong>解题思路</strong></p>
<p>这个问题和<a href="https://blog.csdn.net/qq_17550379/article/details/81586617" target="_blank" rel="noopener">Leetcode 104：二叉树的最大深度（最详细的解法！！！）</a>很像，我们是不是只要将<code>max</code>换成<code>min</code>就可以了呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">else</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当我们碰到这样一个问题的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>我们只是简单的替换为<code>min</code>就会出错，返回的结果是<code>1</code>。为什么？我们在之前问题中的<code>递归终止条件</code>不适合这个问题，我们错误地将<code>左孩子为空 || 右孩子为空</code>这种情况放到了<code>叶子节点</code>中考虑（也就是错误地将<code>1</code>看成了叶子节点），正确的写法应该是这样的</p>
<ul>
<li>根节点为空</li>
<li>左孩子为空</li>
<li>右孩子为空</li>
<li>非叶子节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>其实如果你思考的足够深入的话，这里可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.right), self.minDepth(root.left)) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同样的，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决，而且对于这个问题迭代解决应该更好理解。那这个问题怎么通过迭代解决呢？那么我们就会用到<code>stack</code>，通过<code>stack</code>模拟上面的递归过程。一个较为简单的思路就是二叉树的层序遍历，参看这篇<a href="http://blog.csdn.net/qq_17550379/article/details/80824320" target="_blank" rel="noopener">Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）</a>  ，我们在此基础上稍加修改就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        q = [(root, <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, depth = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:<span class="comment"># 叶子节点</span></span><br><span class="line">                result = min(result, depth)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-08-11-Leetcode-226翻转二叉树（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/11/2018-08-11-Leetcode-226翻转二叉树（最详细的解法！！！）/">Leetcode 226：翻转二叉树（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/11/2018-08-11-Leetcode-226翻转二叉树（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-08-10T16:00:00.000Z" itemprop="datePublished">八月 11, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>这是一道非常有名的题目，有名的地方不是因为这个问题的难度或者背后的数学知识，而是因为这是<code>Homebrew</code>(一个软件包管理器)的作者面试谷歌时候被提到的问题，并且他没有答出来，但是这个问题非常简单，当然这背后可能有什么原因，我们不去管他，我们来看看这个问题该怎么解就好了。</p>
<p>这个问题使用递归很好解决，我们只要先<code>invertTree(root.left and root.right)</code>，然后再交换<code>root.left</code>和<code>root.right</code>。我们只要明确好函数的意义，那么这个问题就很简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>同样的，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决。那这个问题怎么通过迭代解决呢？那么我们就会用到<code>stack</code>，通过<code>stack</code>模拟上面的递归过程。一个较为简单的思路就是二叉树的层序遍历，参看这篇<a href="http://blog.csdn.net/qq_17550379/article/details/80824320" target="_blank" rel="noopener">Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）</a>  ，我们在此基础上稍加修改就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line"></span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-22-Leetcode-23合并K个排序链表（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/22/2018-07-22-Leetcode-23合并K个排序链表（最详细的解法！！！）/">Leetcode 23:合并K个排序链表（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/22/2018-07-22-Leetcode-23合并K个排序链表（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-07-21T16:00:00.000Z" itemprop="datePublished">七月 22, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>对于多路归并排列，我们可以使用优先队列解决。我们首先想到的解法是，依次将<code>list</code>中的<code>ListNode</code>弹出，然后一次添加到一个优先队列中，最后将优先队列中<code>ListNode</code>依次弹出，并且添加到result中即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        result = ListNode(<span class="number">-1</span>)</span><br><span class="line">        cur = result</span><br><span class="line">        p = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> i:</span><br><span class="line">                heapq.heappush(p, (i.val, i))</span><br><span class="line">                i = i.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cur.next = heapq.heappop(p)[<span class="number">1</span>]</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure>
<p>要注意的是上述写法只可以在<code>python2</code>下使用，在<code>python3</code>中会出现错误</p>
<blockquote>
<p>TypeError: unorderable types: ListNode() &lt; ListNode()</p>
</blockquote>
<p>为什么呢？</p>
<blockquote>
<p>当对一个tuple排序时，python会从0开始对两个tuple的成员依次比较，如果两个成员相同就再比较下一个成员。问题中的tuple很有趣，前两个链表的第一项比较结果都相同（1），于是python开始比较第二个成员，第二个成员是一个<code>ListNode</code>，没有比较方法，在处理这个问题上py2和py3有了差异，py2随机瞎排，py3则是抛出异常。</p>
</blockquote>
<p>一种解决办法是我们重写一个<code>ListNode</code>，给他添加<code>__lt__</code>方法。我这里使用了另外的一种解决思路，就是在<code>tuple</code>中再添加一个元素。(￣▽￣)”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        result = ListNode(<span class="number">-1</span>)</span><br><span class="line">        cur = result</span><br><span class="line">        p = list()</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> i:</span><br><span class="line">                heapq.heappush(p, (i.val, x, i))</span><br><span class="line">                i = i.next</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cur.next = heapq.heappop(p)[<span class="number">1</span>]</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure>
<p>另外我们也可以这样做。</p>
<p>首先将<code>list</code>中的每个<code>链表</code>比较首元素，然后依次加入优先队列（或者一个堆，我这里使用堆）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q : 1  1  2</span><br><span class="line">    |  |  |</span><br><span class="line">    4  3  6</span><br><span class="line">    |  |</span><br><span class="line">    5  4</span><br></pre></td></tr></table></figure>
<p>然后判断这个<code>优先队列</code>是否为空，不为空，我们弹出队首元素（<code>1</code>），接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入队列。同时将结果加入到<code>result</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q : 1  2  4</span><br><span class="line">    |  |  |</span><br><span class="line">    3  6  5</span><br><span class="line">    |</span><br><span class="line">    4</span><br><span class="line">    </span><br><span class="line">result: 1</span><br></pre></td></tr></table></figure>
<p>接着我们通过这个思路写出如下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        result = ListNode(<span class="number">-1</span>)</span><br><span class="line">        cur = result</span><br><span class="line">        p = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> i:</span><br><span class="line">                heapq.heappush(p, (i.val, i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(p) &gt; <span class="number">0</span>:</span><br><span class="line">            cur.next = heapq.heappop(p)[<span class="number">1</span>]</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.next:</span><br><span class="line">                heapq.heappush(p, (cur.next.val, cur.next))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure>
<p>这里的代码同样会出现第一种情况下的问题，所以也可以按照之前的解决方法解决这个问题。</p>
<p>当然你可以先将所有元素加入到一个普通的队列中，然后通过<code>sorted(list, key=lambda x : x.val)</code>排序，对这个排好序的<code>list</code>，我们还要将它串成一个链表。</p>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-14-Leetcode-145二叉树的后序遍历（最详细的解法！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/14/2018-07-14-Leetcode-145二叉树的后序遍历（最详细的解法！！！）/">Leetcode 145:二叉树的后序遍历（最详细的解法！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/14/2018-07-14-Leetcode-145二叉树的后序遍历（最详细的解法！！！）/" class="article-date">
	  <time datetime="2018-07-13T16:00:00.000Z" itemprop="datePublished">七月 14, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>解题思路</strong></p>
<p>这是一个基础问题，我们参考之前的两个问题</p>
<p><a href="https://mp.csdn.net/postedit/80731041" target="_blank" rel="noopener">Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）</a> </p>
<p><a href="https://blog.csdn.net/qq_17550379/article/details/80809930" target="_blank" rel="noopener">Leetcode 94:二叉树的中序遍历（最优雅的解法！！！）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ret = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            self.inorderTraversal(root.left)</span><br><span class="line">            self.ret.append(root.val)</span><br><span class="line">            self.inorderTraversal(root.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br></pre></td></tr></table></figure>
<p>如果我们使用非递归的方法要怎么做呢？我们实际上可以模拟栈的操作。对于这个问题，实际上在计算机中是这样处理的。我们首先将<code>打印node1.val</code>、<code>访问node1的right</code>和<code>访问node1的left</code>压入栈中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack : cout1   go-1-R   go-1-L</span><br></pre></td></tr></table></figure>
<p>然后弹出<code>访问node1的left</code>，我们发现它是空，所以什么都不操作。接着我们<code>访问node1的right</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack : cout1   cout2   go-2-R   go-2-L</span><br></pre></td></tr></table></figure>
<p>然后弹出<code>go-2-L</code>，我们接着将<code>打印node3.val</code>、<code>访问node3的right</code>和<code>访问node3的left</code>压入栈中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack : cout1   cout2   go-2-R   cout3   go-3-R   go-3-L</span><br></pre></td></tr></table></figure>
<p>接着就是弹出这些指令就可以了。</p>
<p>以下伪代码写法是符合<code>栈</code>的本意的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">    top = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> top == cout操作:</span><br><span class="line">        result.append(top.val)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> top.right != <span class="keyword">None</span>:</span><br><span class="line">        stack.append(top.right)</span><br><span class="line">    <span class="keyword">if</span> top.left != <span class="keyword">None</span>:</span><br><span class="line">        stack.append(top.left)</span><br><span class="line">    stack.append(cout操作)</span><br></pre></td></tr></table></figure>
<p>但是我们想要表述这种<code>cout操作</code>，我们就不得不使用一些较复杂的数据结构，这是我们不希望看到的。我们有没有更好的做法呢？这个问题的困难的地方在于，我们要保证左右孩子都被访问过了，才访问该节点，这要怎么操作？</p>
<blockquote>
<p> 对于一个节点<code>p</code>，如果<code>p</code>没有左右孩子，我们直接<code>cout p.val</code>，如果<code>p</code>有左右孩子，我们分别加入<code>栈</code>中即可。</p>
</blockquote>
<p>我们根据上述思路，可以很容易地写出下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        stack = list()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> top.left != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line">            <span class="keyword">if</span> top.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line"></span><br><span class="line">            result.append(top.val)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>但是这样写是错的，你如果还记得<code>前序遍历</code>的话，你会发现这和之前的写法很相似<a href="https://mp.csdn.net/postedit/80731041" target="_blank" rel="noopener">Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）</a> 不同地方在于<code>先push right还是push left</code>。这种错误发生的原因在于没有正确理解<code>cout操作</code>是什么时候添加的。当然这里我们的答案很接近了，我们只要<code>reverse</code>一下结果，就是正确答案。所以我们可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        stack = list()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> top.left != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(top.left)</span><br><span class="line">            <span class="keyword">if</span> top.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line"></span><br><span class="line">            result.insert(<span class="number">0</span>, top.val)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>当然我们也可以参考<code>中序遍历</code>的思路，想出这样的解法</p>
<ul>
<li>如果<code>root</code>不为空，我们将<code>cout操作</code>压栈，同时我们一同压入<code>root</code>，并且更新<code>root=root.right</code>，这样<code>right</code>会和<code>cout操作</code>一直做压栈操作。</li>
<li>当我们发现<code>right</code>为空的时候，我们接着访问栈顶<code>node的left</code>，接着回到第一步。</li>
<li>直到<code>len(stack)==0</code>，我们就结束了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        stack = list()</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                result.insert(<span class="number">0</span>, root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.left</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-08-c++中map-unordered_map按照value排序几种优雅的写法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/08/2018-07-08-c++中map-unordered_map按照value排序几种优雅的写法/">c++中map unordered_map按照value排序几种优雅的写法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/08/2018-07-08-c++中map-unordered_map按照value排序几种优雅的写法/" class="article-date">
	  <time datetime="2018-07-07T16:00:00.000Z" itemprop="datePublished">七月 8, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们首先假设我们要操作的<code>map</code>、<code>unordered_map</code>对象是<code>m</code>。</p>
<p>第一种做法是先建立一个<code>vector&lt;pair&lt;type, type&gt;&gt;</code>的容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : m)</span><br><span class="line">    tmp.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(tmp.begin(), tmp.end(), </span><br><span class="line">          [=](<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b) &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br></pre></td></tr></table></figure>
<p>第二种写法更加符合现代<code>c++</code>。首先建立一个临时<code>map</code>，然后通过<code>transform</code>函数将<code>m</code>中的元素<code>inserter</code>进<code>tmp</code>中。通过将<code>map</code>中元素的<code>first</code>和<code>second</code>交换达到，对<code>value</code>排序的目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="built_in">std</span>::transform(m.begin(), m.end(), <span class="built_in">std</span>::inserter(tmp, tmp.begin()), </span><br><span class="line">               [](<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(a.second, a.first); &#125;);</span><br></pre></td></tr></table></figure>
<p>不过第二种写法要加头文件<code>#include &lt;algorithm&gt;</code>和<code>#include &lt;iterator&gt;</code>。<code>c++</code>中的<code>transform</code>有点类似于<code>python</code>中的<code>map</code>。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-08-Leetcode-347前K个高频元素（最详细解决方案！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/08/2018-07-08-Leetcode-347前K个高频元素（最详细解决方案！！！）/">Leetcode 347:前K个高频元素（最详细解决方案！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/08/2018-07-08-Leetcode-347前K个高频元素（最详细解决方案！！！）/" class="article-date">
	  <time datetime="2018-07-07T16:00:00.000Z" itemprop="datePublished">七月 8, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。</p>
<p>例如，</p>
<p>给定数组 <code>[1,1,1,2,2,3]</code> , 和 k = 2，返回 <code>[1,2]</code>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你可以假设给定的 <em>k</em> 总是合理的，1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>这个问题的思路很简单，首先建立一个<code>木桶数组</code>，遍历目标数组，将数据放到<code>木桶数组中</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 : 1 1 1</span><br><span class="line">2 : 2 2</span><br><span class="line">3 : 3</span><br></pre></td></tr></table></figure>
<p>我这里的<code>木桶数组</code>是通过<code>dict</code>实现的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_list = dict()</span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count_list[i] = count_list.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        t = sorted(count_list.items(), key=<span class="keyword">lambda</span> l : l[<span class="number">1</span>] ,reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            result.append(t[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>但是这种做法的时间复杂度是<code>O(nlog(n))</code>，并没有达到题目的要求。那么我们还有什么办法，我们可以使用一个<code>priority_queue</code>来存储这<code>k</code>个元素，通过遍历数组，比较数组中元素出现的频率，然后实现入队，出队操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line">        count_list = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count_list[i] = count_list.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count_list.items():</span><br><span class="line">            <span class="keyword">if</span> p.qsize() == k:<span class="comment"># 判断优先队列长度是否满足k</span></span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">1</span>] &gt; p[<span class="number">0</span>]:<span class="comment"># bug</span></span><br><span class="line">                    p.get()</span><br><span class="line">                    p.put((i[<span class="number">1</span>], i[<span class="number">0</span>]))<span class="comment"># 通过 (频率,元素) 形式存储</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.put((i[<span class="number">1</span>], i[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> p.empty():</span><br><span class="line">            _, v = p.get()</span><br><span class="line">            result.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>如你所见，上述代码是有问题的，我们无法通过<code>index</code>访问<code>PriorityQueue</code>的元素。所以我们只能换个方法，可以使用<code>heapq</code>代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        count_list = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count_list[i] = count_list.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count_list.items():</span><br><span class="line">            <span class="keyword">if</span> len(p) == k:</span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">1</span>] &gt; p[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappop(p)</span><br><span class="line">                    heapq.heappush(p, (i[<span class="number">1</span>], i[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(p, (i[<span class="number">1</span>], i[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> p]</span><br></pre></td></tr></table></figure>
<p>我们现在这个算法的时间复杂度变成了<code>O(nlog(k))</code>。但是既然我们使用了<code>heapq</code>，那么我们还有一种更加简洁的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        count_list = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count_list[i] = count_list.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count_list.items():</span><br><span class="line">            heapq.heappush(p, (i[<span class="number">1</span>], i[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> heapq.nlargest(k, p)]</span><br></pre></td></tr></table></figure>
<p>但是这种写法的时间复杂度比上面那种要高，因为我们在维护堆的时候，不再是维护<code>k</code>大小的堆，而是维护<code>n</code>大小的堆。</p>
<p>这个算法还有缺陷，当我们的<code>n == k</code>的时候，算法的时间复杂度就和第一种做法是一样的了，还有没有更好地解法？</p>
<p>我们可以把这个问题分开考虑，对与<code>n &gt; k</code>，我们依旧使用上述的算法，而对于<code>n &lt; k</code>，我们就要想有什么好的解法了。其实也很简单，我们要清楚我们的<code>PriorityQueue</code>中装的是什么，我们通过维护一个<code>n - k</code>大小的<code>PriorityQueue</code>就可以实现。</p>
<p>我们想到的做法就是，维护一个<code>n - k</code>大小的最大堆，当进来一个元素，我们就将最大的那个元素弹出到<code>result</code>中即可。但是在<code>python</code>里面我们的<code>heapq</code>没法像<code>c++</code>中那样可以修改比较函数，我们可以怎么做呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        count_list = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count_list[i] = count_list.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        p = list()</span><br><span class="line">        result = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count_list.items():</span><br><span class="line">            heapq.heappush(p, (-i[<span class="number">1</span>], -i[<span class="number">0</span>]))<span class="comment"># tricks</span></span><br><span class="line">            <span class="keyword">if</span> len(p) &gt; len(count_list) - k:</span><br><span class="line">                _, val = heapq.heappop(p)</span><br><span class="line">                result.append(-val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>一个更<code>pythonic</code>的解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="keyword">return</span> [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-01-Leetcode-127单词接龙（最详细解决方案！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/01/2018-07-01-Leetcode-127单词接龙（最详细解决方案！！！）/">Leetcode 127:单词接龙（最详细解决方案！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/01/2018-07-01-Leetcode-127单词接龙（最详细解决方案！！！）/" class="article-date">
	  <time datetime="2018-06-30T16:00:00.000Z" itemprop="datePublished">七月 1, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2018-07-01-Leetcode-279完全平方数（最详细解决方案！！！）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/07/01/2018-07-01-Leetcode-279完全平方数（最详细解决方案！！！）/">Leetcode 279:完全平方数（最详细解决方案！！！）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/01/2018-07-01-Leetcode-279完全平方数（最详细解决方案！！！）/" class="article-date">
	  <time datetime="2018-06-30T16:00:00.000Z" itemprop="datePublished">七月 1, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>很多人第一眼看到这个问题，想到的第一种做法就是使用贪心算法，但是对于这个问题是不适用的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 = 9 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>
<p>我们根据题目中<strong>完全平方数的个数最少</strong>，我们在什么算法中用到过<strong>最少</strong>这个关键字？啊哈！<strong>最短路径问题</strong>。那么和这个问题有什么联系呢？</p>
<center class="half"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1fsrq774zfhj20oz0hfmyi.jpg"><br></center>

<p>现在我们就可以用最短路径算法来解决这个问题。最短路径算法其实就是图的广度优先遍历。例如对于上图中的<code>5</code>，我们要前往<code>0</code>，我们的第一步有两种走法，先走<code>4</code>和先走<code>1</code>。所以我们需要建立一个队列或者栈，然后将第一步的走法压入队列或者栈中。如下（使用队列， 我们同时记录走的步数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q : (4, 1) (1, 1)</span><br></pre></td></tr></table></figure>
<p>我们将<code>4</code>出队，然后看<code>4</code>的下一步怎么走，发现只能走<code>3</code>，所以我们将<code>(3, 2)</code>入队</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q : (1, 1) (3, 2)</span><br></pre></td></tr></table></figure>
<p>接着我们将<code>(1, 1)</code>弹出，我们看<code>1</code>的下一步怎么走，发现只能走<code>0</code>，这个时候我们发现已经到达了<code>0</code>，那么我们更新<code>step+1</code>，然后出循环即可。以下是代码的全部过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        q = list()</span><br><span class="line">        q.append([n, <span class="number">0</span>])</span><br><span class="line">        visited = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        visited[n] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> any(q):</span><br><span class="line">            num, step = q.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            tNum = num - i**<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> tNum &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> tNum == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[tNum]:</span><br><span class="line">                    q.append((tNum, step + <span class="number">1</span>))</span><br><span class="line">                    visited[tNum] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                tNum = num - i**<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>但是这个解法不是最优的解法，但是我认为是一个不错的思维方式。那么更加快速的解法是什么样的呢？我们就要用到数学知识了，这里使用的是<strong>四平方和定理</strong>。</p>
<blockquote>
<p>Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 </p>
</blockquote>
<p>那么我们这个问题的解法就变得很简单了，我们的结果只有<code>1,2,3,4</code>，四种可能。</p>
<p>另外还有一个非常重要的推论</p>
<blockquote>
<p>if and only if n is not of the form $n = 4^a(8b + 7)$ for integers a and b. </p>
<p>满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 $n = 4^a(8b + 7)$ </p>
</blockquote>
<p>根据这个重要的推论，我们可以非常迅速的写出这样的代码。</p>
<p>我们首先将输入的<code>n</code>迅速缩小。然后我们再判断，这个缩小后的数是否可以通过<code>两个平方数的和或一个平方数</code>组成，不能的话我们返回<code>3</code>，能的话我们返回<code>平方数的个数</code>。</p>
<p>现在我们的问题已经缩减到了，怎么判断一个数是由一个还是由两个平方数的和构成？对于这个问题，我们当然可以暴力破解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> n % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            n /= <span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">8</span> == <span class="number">7</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a**<span class="number">2</span> &lt;= n:</span><br><span class="line">            b = int((n - a**<span class="number">2</span>)**<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == n:</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">not</span> <span class="keyword">not</span> a) + (<span class="keyword">not</span> <span class="keyword">not</span> b)</span><br><span class="line"></span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>另外这个问题还有一种经典的解法，就是使用动态规划。动态规划的问题关键在于状态转移方程，这里的思路还是和前面使用图的广度优先遍历一样。例如</p>
<p>我们要知道<code>12</code>最少有多少个数构成，实际上如果我们走了一步的话，我们需要知道<code>11、8、3</code>对应的步数，如果我们不走，我们就需要知道<code>12</code>的步数，我们只要通过比较是走<code>0</code>步小，还是走<code>1步</code>哪个更小即可。通过一个式子表示就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num[n] = min(num[n], num[n-i**2] + 1)</span><br></pre></td></tr></table></figure>
<p>所以我们可以先定义一个<code>n</code>大小的数组（static类型），这里我们要使数组初始化为无穷大，在<code>python</code>中我们可以使用<code>float(&#39;inf&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    _dp = list()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = self._dp</span><br><span class="line">        dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i + j**<span class="number">2</span> &lt;= n:</span><br><span class="line">                dp[i + j**<span class="number">2</span>] = min(dp[i + j**<span class="number">2</span>], dp[i] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p>但是这里写法我们在实际测试的时候超时了。</p>
<p>以下写法参考了<a href="https://leetcode.com/problems/perfect-squares/discuss/71512/Static-DP-C++-12-ms-Python-172-ms-Ruby-384-ms?page=3" target="_blank" rel="noopener">StefanPochmann</a> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    _dp = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = self._dp</span><br><span class="line">        <span class="keyword">while</span> len(dp) &lt;= n:</span><br><span class="line">            dp += list((min(dp[-i*i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp)**<span class="number">0.5</span>+<span class="number">1</span>))) + <span class="number">1</span>,))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p>思路还是和上面一样，但是这里<code>,</code>不是乱加的。为什么要加？这是因为<code>int</code>无法初始化<code>list</code>，我们只有通过加上一个<code>,</code>，将<code>int</code>变成<code>tuple</code>才可以初始化。</p>
<p><strong>我将该问题的其他语言版本添加到了我的<a href="https://github.com/luliyucoordinate/Leetcode" target="_blank" rel="noopener">GitHub Leetcode</a></strong></p>
<p><strong>如有问题，希望大家指出！！！</strong></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/13/2018-09-13-Leetcode-130-被围绕的区域（最详细的解法！！！）/">Leetcode 130：被围绕的区域（最详细的解法！！！）</a></h6>
              <span>九月 13, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/13/2018-09-13-Leetcode-200-岛屿的个数（最详细的解法！！！）/">Leetcode 200：岛屿的个数（最详细的解法！！！）</a></h6>
              <span>九月 13, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/12/2018-09-12-Leetcode-401-二进制手表（最详细的解法！！！）/">Leetcode 401：二进制手表（最详细的解法！！！）</a></h6>
              <span>九月 12, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/12/2018-09-12-Leetcode-79-单词搜索（最详细的解法！！！）/">Leetcode 79：单词搜索（最详细的解法！！！）</a></h6>
              <span>九月 12, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/11/2018-09-11-Leetcode-90-子集 II（最详细的解法！！！）/">Leetcode 90：子集 II（最详细的解法！！！）</a></h6>
              <span>九月 11, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/10/2018-09-10-Leetcode-40-组合总和 II（最详细的解法！！！）/">Leetcode 40：组合总和 II（最详细的解法！！！）</a></h6>
              <span>九月 10, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">78</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">112</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.67px;">1080ti</a> <a href="/tags/ADL/" style="font-size: 10px;">ADL</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.33px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.33px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/JSON/" style="font-size: 10.67px;">JSON</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means++</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/Li-Fei-Fei/" style="font-size: 10px;">Li Fei Fei</a> <a href="/tags/MNIST/" style="font-size: 10.67px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.67px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/Pickle/" style="font-size: 10px;">Pickle</a> <a href="/tags/QT/" style="font-size: 11.33px;">QT</a> <a href="/tags/SNIP/" style="font-size: 10px;">SNIP</a> <a href="/tags/Ubuntu/" style="font-size: 11.33px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 14.67px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.67px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/big-file/" style="font-size: 10px;">big file</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 19.33px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 18.67px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 18px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 16.67px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.33px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 11.33px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.67px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 14.67px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/descriptor/" style="font-size: 10px;">descriptor</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.33px;">error</a> <a href="/tags/estimator/" style="font-size: 11.33px;">estimator</a> <a href="/tags/fire/" style="font-size: 10px;">fire</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/mAP/" style="font-size: 10px;">mAP</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/merge/" style="font-size: 10px;">merge</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.67px;">namehiding</a> <a href="/tags/network/" style="font-size: 12px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 17.33px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.67px;">numpy</a> <a href="/tags/office/" style="font-size: 10.67px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.67px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.67px;">overload</a> <a href="/tags/override/" style="font-size: 10.67px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.67px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/pytorch/" style="font-size: 11.33px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.33px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.33px;">re</a> <a href="/tags/requests/" style="font-size: 10.67px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10.67px;">shell</a> <a href="/tags/signal/" style="font-size: 10.67px;">signal</a> <a href="/tags/sql/" style="font-size: 10.67px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16px;">stl</a> <a href="/tags/super/" style="font-size: 10.67px;">super</a> <a href="/tags/tensorflow/" style="font-size: 14.67px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.67px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.67px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.67px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 16.67px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/时间复杂度/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.67px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.33px;">笔试</a> <a href="/tags/算法/" style="font-size: 14px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.67px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.33px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://www.wangningcheng.com'>梦影无痕</a></li>
        
          <li class='link'><a href='https://blanboom.org'>Blanboom</a></li>
        
      </ul>
  </div>



  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
