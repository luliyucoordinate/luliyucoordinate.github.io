<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 9 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/9/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg,css/images/pose02.jpg,css/images/pose03.jpg".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="coordinate" rel="home"> coordinate </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-07-13-default的作用"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/13/2017-07-13-default的作用/">=default的作用</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/13/2017-07-13-default的作用/" class="article-date">
	  <time datetime="2017-07-12T16:00:00.000Z" itemprop="datePublished">七月 13, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>“=default” instructs the compiler to generate the default implementation for the function. Defaulted functions have two advantages: They are more efficient than manual implementations, and they rid the programmer from the chore of defining those functions manually.<br>By default, C++ will provide a default constructor, copy constructor, copy assignment operator (operator=) and a destructor. If you provide alternate versions of any of these functions for your class, C++ will not provide a default version. However, in C++11, you can now specify that you would like the compiler to provide a default one anyway. This is done by prototyping the function and using the default specifier.<br>The default specifier can only be used with functions that have a default.<br>=default: it means that you want to use the compiler-generated version of that function, so you don’t need to specify a body.<br>=delete: it means that you don’t want the compiler to generate that function automatically.  </p>
<p>在C+11中，对于defaulted函数，编译器会为其自动生成默认的函数定义体，从而获得更高的代码执行效率，也可免除程序员手动定义该函数的工作量。<br>C++的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。并且手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。<br>C++11标准引入了一个新特性：defaulted函数。程序员只需在函数声明后加上”=default;”，就可将该函数声明为defaulted函数，编译器将为显式声明的defaulted函数自动生成函数体。<br>defaulted函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。<br>defaulted函数既可以在类体里(inline)定义，也可以在类体外(out-of-line)定义。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/default/">default</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-08-理解引用折叠"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/08/2017-07-08-理解引用折叠/">理解引用折叠</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/08/2017-07-08-理解引用折叠/" class="article-date">
	  <time datetime="2017-07-07T16:00:00.000Z" itemprop="datePublished">七月 8, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52433305" target="_blank" rel="noopener"> Effective Modern C++ 条款28 理解引用折叠</a></p>
<p>条款23提起过把一个实参传递给模板函数时，无论实参是左值还是右值，推断出来的模板参数都会含有编码信息。那条款没有提起，只有模板形参是通用引用时，这件事才会发生，不过对于这疏忽，理由很充分：条款24才介绍通用引用。把这些关于通用引用和左值/右值编码信息综合，意味着这个模板，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>无论param是个左值还是右值，需要推断的模板参数T都会被编码。</p>
<p>编码技术是很简单的，当传递的实参是个左值时，T就被推断为一个左值引用，当传递的实参是个右值时，T就被推断为一个非引用类型。（注意这是不对称的：左值会编码为左值引用，但右值编码为非引用。）因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;      <span class="comment">// 返回右值的函数</span></span><br><span class="line">Widget w;       <span class="comment">// 一个变量，左值</span></span><br><span class="line">func(w);      <span class="comment">// 用左值调用函数，T被推断为Widget&amp;</span></span><br><span class="line">func(widgetFactory());     <span class="comment">// 用右值调用函数，T被推断为Widget</span></span><br></pre></td></tr></table></figure>
<p>两个func调用都是用Widget参数，不过一个Widget是左值，另一个是右值，从而导致了模板参数T被推断出不同的类型。这，正如我们将很快看到，是什么决定通用引用变成左值引用或右值引用的，而这也是std::forward完成工作所使用的内部技术。</p>
<p>在我们紧密关注std::forward和通用引用之前，我们必须注意到，在C++中对引用进行引用是不合法的。你可以尝试声明一个，你的编译器会严厉谴责加抗议：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span>&amp; &amp; rx = x;    <span class="comment">// 报错！不可以声明对引用的引用</span></span><br></pre></td></tr></table></figure>
<p>但想一想当一个左值被传递给接受通用引用的模板函数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;      <span class="comment">// 如前</span></span><br><span class="line">func(w);     <span class="comment">// 用左值调用func，T被推断为Widget&amp;</span></span><br></pre></td></tr></table></figure>
<p>如果使用推断出来的T类型（即Widget&amp;）实例化模板，我们得到这个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个对引用的引用！然而你的编译器内有深刻谴责加抗议。我们从条款24知道，通用引用param用一个左值进行初始化，param的类型应该出一个左值引用，但编译器是如何推断T的类型的，还有是怎样把它替代成下面这个样子，哪一个才是最终的签名呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>答案是引用折叠。是的，你是禁止声明对引用的引用，但编译器在特殊的上下文中可以产生它们，模板实例化就是其中之一。当编译器生成对引用的引用时，引用折叠指令就会随后执行。</p>
<p>有两种类型的引用（左值和右值），所以有4种可能的对引用引用的组合（左值对左值，左值对右值，右值对左值，右值对右值）。如果对引用的引用出现在被允许的上下文（例如，在模板实例化时），这个引用（即引用的引用，两个引用）会折叠成一个引用，根据的是下面的规则：</p>
<p>如果两个引用中有一个是左值引用，那么折叠的结果是一个左值引用。否则（即两个都是右值引用），折叠的结果是一个右值引用。<br>在我们上面的例子中，在函数func中把推断出来的类型Widget&amp;替代T后，产生了一个对右值的左值引用，然后引用折叠规则告诉我们结果是个左值引用。</p>
<p>引用折叠是使std::forward工作的关键部分。就如条款25解释那样，对通用引用使用std::forward，是一种常见的情况，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...        <span class="comment">// do some works</span></span><br><span class="line"></span><br><span class="line">    someFunc(<span class="built_in">std</span>::forward&lt;T&gt;(fParam));   <span class="comment">// 把fParam转发到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为fParam是一个通用引用，我们知道无论传递给函数f的实参（即用来初始化fParam的表达式）是左值还是右值，参数类型T都会被编码。std::forward的工作是，当且仅当传递给函数f的实参是个右值时，把fParam（左值）转换成一个右值。</p>
<p>这里是如何实现std::forward来完成工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">// 在命名空间std中</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这没有完全顺应标准库（我省略了一些接口细节），不过不同的部分是与理解std::forward如何工作无关。</p>
<p>假如传递给函数f的是个左值的Widget，T会被推断为Widget&amp;，然后调用std::forward会让它实例化为std::forward\&lt;Widget&amp;>。把Widget&amp;加到std::forward的实现中，变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove_reference\&lt;Widget&amp;>::type产生的是Widget，所以std::forward边冲这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);    &#125;</span><br></pre></td></tr></table></figure>
<p>在返回类型和cast中都会发生引用折叠，导致被调用的最终版本的std::forward：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&gt;(param);    &#125;</span><br></pre></td></tr></table></figure>
<p>就如你所见，当一个左值被传递给模板函数f时，std::forward被实例化为接受一个左值引用和返回一个左值引用。std::forward内部的显式转换没有做任何东西，因为param的类型已经是Widget&amp;了，所以这次转换没造成任何影响。一个左值实参被传递给std::forward，将会返回一个左值引用。根据定义，左值引用是左值，所以传递一个左值给std::forward，会导致std::forward返回一个左值，就跟它应该做的那样。</p>
<p>现在假设传递给函数f的是个右值的Widget。在这种情况下，函数f的类型参数T会被推断为Widget。因此f里面的std::forward会变成std::forward\&lt;Widget>。在std::forward的实现中用Widget代替T，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;Widget&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对非引用Widget使用std::remove_reference会产生原来的类型（Widget），所以std::forward变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);    &#125;</span><br></pre></td></tr></table></figure>
<p>这里没有对引用的引用，所以没有进行引用折叠，这也就这次std::forward调用的最终实例化版本。</p>
<p>由函数返回的右值引用被定义为右值，所以在这种情况下，std::forward会把f的参数fParam（一个左值）转换成一个右值。最终结果是传递给函数f的右值实参作为右值被转发到someFunc函数，这是顺理成章的事情。</p>
<p>在C++14中，std::remove_reference_t的存在可以让std::forward的实现变得更简洁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;      <span class="comment">// C++14，在命名空间std中</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用折叠出现在四种上下文。第一种是最常见的，就是模板实例化。第二种是auto变量的类型生成。它的细节本质上和模板实例化相同，因为auto变量的类型推断和模板类型推断本质上相同（看条款2）。再次看回之前的一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;      <span class="comment">// 返回右值的函数</span></span><br><span class="line"></span><br><span class="line">Widget w;       <span class="comment">// 一个变量，左值</span></span><br><span class="line"></span><br><span class="line">func(w);      <span class="comment">// 用左值调用函数，T被推断为Widget&amp;</span></span><br><span class="line"></span><br><span class="line">func(widgetFactory());     <span class="comment">// 用右值调用函数，T被推断为Widget</span></span><br></pre></td></tr></table></figure>
<p>这可以用auto形式模仿。这声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure>
<p>用个左值初始化w1，因此auto被推断为Widget&amp;。在声明中用Widget&amp;代替auto声明w1，产生这个对引用进行引用的代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; &amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure>
<p>这在引用折叠之后，变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; w1 = w;</span><br></pre></td></tr></table></figure>
<p>结果是，w1是个左值引用。</p>
<p>另一方面，这个声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = widgetFactory();</span><br></pre></td></tr></table></figure>
<p>用个右值初始化w2，导致auto被推断为无引用类型Widget，然后用Widget替代auto变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;&amp; w2 = widgetFactory();</span><br></pre></td></tr></table></figure>
<p>这里没有对引用的引用，所以我们已经完成了，w2是个右值引用。</p>
<p>我们现在处于真正能理解条款24介绍通用引用的位置了。通用引用不是一种新的引用类型，实际上它是右值引用——在满足了下面两个条件的上下文中：</p>
<ol>
<li>根据左值和右值来进行类型推断。T类型的左值使T被推断为T&amp;，T类型的右值使T被推断为T。</li>
<li>发生引用折叠</li>
</ol>
<p>通用引用的概念是很有用的，因为它让你免受：识别出存在引用折叠的上下文，弱智地根据左值和右值推断上下文，然后弱智地把推断出的类型代进上下文，最后使用引用折叠规则。</p>
<p>我说过有4中这样的上下文，不过我们只讨论了两种：模板实例化和auto类型生成。第三种上下文就是使用typedef和类型别名声明（看条款9）。如果，在typedef创建或者评估期间，出现了对引用的引用，引用折叠会出面消除它们。例如，假如我们有个类模板Widget，内部嵌有一个右值引用类型的typedef，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后假如我们用一个左值引用来实例化Widget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&gt; w;</span><br></pre></td></tr></table></figure>
<p>在Widget中用int&amp;代替T，typedef变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp; &amp;&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure>
<p>引用折叠把代码弄出这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="keyword">int</span>&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure>
<p>这很明显的告诉我们，我们typedef选择的名字跟我们期望得到的不一样：当用左值引用实例化Widget时，RvalueRefToT是个左值引用的typedef。</p>
<p>最后的一种会发生引用折叠的上下文是使用decltype中。如果，在分析一个使用decltype的类型期间，出现了对引用的引用，引用折叠会出面消除它。（关于decltype的详细信息，请看条款3。）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要记住的3点：</p>
<ol>
<li>引用折叠会出现在4中上下文：模板实例化，auto类型生成，typedef和类型别名声明的创建和使用，decltype。</li>
<li>当编译器在一个引用折叠上下文中生成了对引用的引用时，结果会变成一个引用。如果原来的引用中有一个是左值引用，结果就是个左值引用。否则，结果是个右值引用。</li>
<li>通用引用是——出现在类型推断区分左值和右值和出现引用折叠的上下文中的——右值引用。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/引用折叠/">引用折叠</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-07-auto,auto&amp;和auto&amp;&amp;"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/07/2017-07-07-auto,auto&和auto&&/">auto,auto&amp; 和 auto&amp;&amp;</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/07/2017-07-07-auto,auto&和auto&&/" class="article-date">
	  <time datetime="2017-07-06T16:00:00.000Z" itemprop="datePublished">七月 7, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>auto and auto&amp;&amp; cover most of the cases:  </p>
<ol>
<li>Use auto when you need a local copy. This will never produce a reference. The copy (or move) constructor must exist, but it might not get called, due to the copy elision optimization.</li>
<li>Use auto&amp;&amp; when you don’t care if the object is local or not. Technically, this will always produce a reference, but if the initializer is a temporary (e.g., the function returns by value), it will behave essentially like your own local object.</li>
</ol>
<p>Also, auto&amp;&amp; doesn’t guarantee that the object will be modifiable, either. Given a const object or reference, it will deduce const. However, modifiability is often assumed, given the specific context.  </p>
<p>auto&amp; and auto const &amp; are a little more specific:  </p>
<ol>
<li>auto&amp; guarantees that you are sharing the variable with something else. It is always a reference and never to a temporary.</li>
<li>auto const &amp; is like auto&amp;&amp;, but provides read-only access.</li>
</ol>
<p>What about for primitive/non-primitive types?<br>There is no difference.  </p>
<p>Does this also apply to range based for loops?<br>Yes. Applying the above principles,  </p>
<ol>
<li>Use auto&amp;&amp; for the ability to modify and discard values of the sequence within the loop. (That is, unless the container provides a read-only view, such as std::initializer_list, in which case it will be effectively an auto const &amp;.)</li>
<li>Use auto&amp; to modify the values of the sequence in a meaningful way.</li>
<li>Use auto const &amp; for read-only access.</li>
<li>Use auto to work with (modifiable) copies.</li>
</ol>
<p>You also mention auto const with no reference. This works, but it’s not very commonly used because there is seldom an advantage to read-only access to something that you already own.  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/auto/">auto</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/auto/">auto&</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/auto/">auto&&</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-05-关于cin的一些问题"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/05/2017-07-05-关于cin的一些问题/">关于cin的一些问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/05/2017-07-05-关于cin的一些问题/" class="article-date">
	  <time datetime="2017-07-04T16:00:00.000Z" itemprop="datePublished">七月 5, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一次看到cin.clear()这东西，很多人以为就是清空cin里面的数据流,而实际上却与此相差很远，首先我们看看以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">cin</span>.rdstate() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.rdstate() == iOS::goodbit)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入数据的类型正确，无错误！"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.rdstate() == ios_base::failbit) </span><br><span class="line">    &#123; </span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入数据类型错误，非致命错误，可清除输入缓冲区挽回！"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    system(<span class="string">"pause"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义要输入到的变量是整型，但如果我们输入了英文字母或者汉字,那就会发生错误，cin里有个方法能检测这个错误,就是cin.rdstate();<br>当cin.rdstate()返回0(即ios::goodbit)时表示无错误，可以继续输入或者操作，若返回4则发生非致命错误即ios::failbit，则不能继续输入或操作。而cin.clear则可以控制我们此时cin里对这个问题的一个标识。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.clear(标识符);</span><br></pre></td></tr></table></figure>
<p>标识符号为：</p>
<ol>
<li>goodbit无错误</li>
<li>Eofbit已到达文件尾</li>
<li>failbit非致命的输入/输出错误，可挽回</li>
<li>badbit致命的输入/输出错误，无法挽回 </li>
</ol>
<p>若在输入输出类里。需要加ios::标识符号<br>通过cin.clear()，我们能确认它的内部标识符，如果输入错误则能重新输入。结合真正的清空数据流方法cin.sync()，请看下例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a; </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span>)            <span class="comment">//条件可改写为cin.fail() </span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有错!请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">            <span class="built_in">cin</span>.clear(); </span><br><span class="line">            <span class="built_in">cin</span>.sync();   <span class="comment">//清空流</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    system(<span class="string">"pause"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的cin默认参数为0，即无错误，正常操作。当我们输入英文字母’k’时，它的状态标识改为fail（即1），即错误，用cout对用户输出信息，再用cin.clear让错误标识改回为0，让我们可以继续输入，再清空流数据继续输入。如果我们没有了cin.clear，则会进入死循环，其过程为我们输入了英文字母，它的状态标识便为fail，当运行到条件判断时，便总是回到错误的条件表示里，并且我们再也没办法输入，因为错误的表示关闭了cin，所以会进入死循环。 </p>
<p>自己再添加一句：如果输入错误，则再也输入不进去，须用clear。而sync用于清除当前输入缓冲区中的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.clear();</span><br><span class="line">    <span class="built_in">cin</span>.sync();  <span class="comment">// 可以将cin.clear();cin.sync();  不同时注释掉试一下就知道了</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cin/">cin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-04-Trie树（模糊匹配）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/04/2017-07-04-Trie树（模糊匹配）/">Trie树（模糊匹配）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/04/2017-07-04-Trie树（模糊匹配）/" class="article-date">
	  <time datetime="2017-07-03T16:00:00.000Z" itemprop="datePublished">七月 4, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Wild-Words"><a href="#Wild-Words" class="headerlink" title="Wild Words "></a><center>Wild Words</center> </h1><p>Time Limit: 2000MS         Memory Limit: 65536K  </p>
<p><strong>Description</strong><br>A word is a string of lowercases. A word pattern is a string of lowercases, ‘?’s and ‘*‘s. In a pattern, a ‘?’ matches any single lowercase, and a ‘*‘ matches none or more lowercases.<br>There are many word patterns and some words in your hand. For each word, your task is to tell which patterns match it.<br><strong>Input</strong><br>The first line of input contains two integers N (0 &lt; N &lt;= 100000) and M (0 &lt; M &lt;=100), representing the number of word patterns and the number of words. Each of the following N lines contains a word pattern, assuming all the patterns are numbered from 0 to N-1. After those, each of the last M lines contains a word.<br>You can assume that the length of patterns will not exceed 6, and the length of words will not exceed 20.<br><strong>Output</strong><br>For each word, print a line contains the numbers of matched patterns by increasing order. Each number is followed by a single blank. If there is no pattern that can match the word, print “Not match”.    </p>
<p><strong>Sample Input</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">t*</span><br><span class="line">?h*s</span><br><span class="line">??e*</span><br><span class="line">*s</span><br><span class="line">?*e</span><br><span class="line">this</span><br><span class="line">the</span><br><span class="line">an</span><br><span class="line">is</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 3 </span><br><span class="line">0 2 4 </span><br><span class="line">Not match</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oj/">oj</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/trie树/">trie树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字典树/">字典树</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-03-回文字符串"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/03/2017-07-03-回文字符串/">回文字符串</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/03/2017-07-03-回文字符串/" class="article-date">
	  <time datetime="2017-07-02T16:00:00.000Z" itemprop="datePublished">七月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>写一个程序，他用一个stack<t>容器适配器实例将从键盘输入的一行文字反向。程序应该输出反向后的结果，并判断和原始字符串是否回文（回文字符串是一个正向和反向都相同的字符串—-如果忽略空格和标点的话，例如Are we not drawn onward to a new era?）</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="built_in">string</span> str, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span> || index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str.at(low) != str.at(high))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fun(low + <span class="number">1</span>, high - <span class="number">1</span>, str, index - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; words;</span><br><span class="line">	<span class="keyword">bool</span> flag&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">exp</span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> index&#123;&#125;;</span><br><span class="line">			getline(<span class="built_in">cin</span>, <span class="built_in">exp</span>, <span class="string">'\n'</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">exp</span>.empty()) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">while</span> (index != <span class="built_in">exp</span>.length())</span><br><span class="line">			&#123;</span><br><span class="line">				words.push(<span class="built_in">exp</span>.at(index++));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">' '</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">'?'</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">','</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">'.'</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> (!words.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; words.top();</span><br><span class="line">				words.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			index = <span class="built_in">exp</span>.length();</span><br><span class="line">			<span class="keyword">if</span> (fun(<span class="number">0</span>, index - <span class="number">1</span>, <span class="built_in">exp</span>, index))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"  OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"  NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/回文字符串/">回文字符串</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-02-Aggregate和POD类型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/02/2017-07-02-Aggregate和POD类型/">Aggregate和POD类型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/02/2017-07-02-Aggregate和POD类型/" class="article-date">
	  <time datetime="2017-07-01T16:00:00.000Z" itemprop="datePublished">七月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>A plain old data structure (POD) is a data structure that is represented only as passive collections of field values, without using encapsulation or other object-oriented features.<br>POD是这样的数据结构：用组个field的集合来表示，没有使用封装或者其他面向对象的features。<br>A POD type in C++ is defined as either a scalar type or a POD class. A POD class has no user-defined copy assignment operator, no user-defined destructor, and no non-static data members that are not themselves PODs. Moreover, a POD class must be an aggregate, meaning it has no user-declared constructors, no private nor protected non-static data, no base classes and no virtual functions. The standard includes statements about how PODs must behave in C++.<br>In certain contexts, C++ allows only POD types to be used. For example, a union in C++98 cannot contain a class that has virtual functions or nontrivial constructors or destructors. This restriction is imposed because the compiler cannot determine which constructor or destructor should be called for a union. POD types can also be used for interfacing with C, which supports only PODs.<br>在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。一般来说，POD对象应该满足如下特性。<br>对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，再将其复制回对象，那么该对象的值与原始值一样。考试就到对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。<br>简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，只要其二进制内容在，就能还原出正确无误的POD对象。对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。  </p>
<p>下面是转自<a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special" target="_blank" rel="noopener">stackoverflow的一篇文章的译文</a>，比较详细介绍了aggregate 和 POD：<br>这篇文章很长，如果Aggregates和PODs都想了解，就静下心来完整的把这篇文章读完，如果你仅仅对Aggregates感兴趣，读第一部分就可以了。如果你仅对PODs感兴趣，那你必须先读懂Aggregates的定义、含义和例子，然后再跳去读PODs，但是我依然推荐你完整的读完第一部分。Aggragates的概念是定义PODs的基础。  </p>
<h2 id="什么是Aggragates，为什么他们这么特别？"><a href="#什么是Aggragates，为什么他们这么特别？" class="headerlink" title="什么是Aggragates，为什么他们这么特别？"></a>什么是Aggragates，为什么他们这么特别？</h2><p>C++标准（C++ 03 8.5.1 §1）中的正式定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个Aggregate是一个数组或者一个没有用户声明构造函数，没有私有或保护类型的非静态数据成员，没有父类和虚函数的类型</span><br></pre></td></tr></table></figure>
<p>现在我们来分析这个定义。首先，数组是Aggregate。class也可以成为Aggregate如果满足…等等！我们还没有说struct和unions，它们可以成为Aggregate吗？是的，他们可以。在C++中，术语class是指所有的classes、structs和unios。所以，class（struct，union）只要满足上面定义中的条件就可以成为Aggregate。这些条件有什么含义呢？  </p>
<ol>
<li>这并不是说Aggregate类型就不能有构造函数，事实上，它可以拥有一个默认构造函数或者一个复制构造函数，只要他们是被编译器声明的，而不是被用户自己声明的。  </li>
<li>不能拥有私有或者保护类型的非静态数据成员。你可以定义任意多的私有或者保护类型的成员方法（不包括构造函数）和静态类型的数据成员和方法，这都不违背Aggregate类型的规则。  </li>
<li>Aggregate类型可以拥有用户声明的/用户定义的 赋值操作符或者析构函数</li>
<li>数组是Aggregate类型，即便是非Aggregate类型元素的数组。</li>
</ol>
<p>来看几个例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//remember? no virtual functions</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> x; <span class="comment">//x is private by default and non-static </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NotAggregate3(<span class="keyword">int</span>) &#123;&#125; <span class="comment">//oops, user-defined constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aggregate1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NotAggregate1 member1;   <span class="comment">//ok, public member</span></span><br><span class="line">    Aggregate1&amp; <span class="keyword">operator</span> = (Aggregate1 <span class="keyword">const</span> &amp; rhs) &#123;<span class="comment">/* */</span>&#125; <span class="comment">//ok, copy-assignment  </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">void</span> f() &#123;&#125; <span class="comment">// ok, just a private function</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你已经理解了Aggregates含义了，现在我们来看为什么它这么特别。他们和非Aggregates类型不同，可以使用“{ }”初始化。这种初始化语法，在数组上很常见，而且，我们刚刚了解到数据就是Aggregates类型，所以，我们从数组开始：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type array_name[n] = &#123;a1, a2, ..., am&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m == n)</span><br></pre></td></tr></table></figure>
<p>数组的第i个元素被初始化为ai  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m &lt; n)</span><br></pre></td></tr></table></figure>
<p>数组前边的m个元素被初始化为a1, a2, …, am，剩余的n-m个元素，如果可能，将按值初始化（下面有关于这个名词的解释）  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m &gt; n)</span><br></pre></td></tr></table></figure>
<p>会引起编译错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>（有可能为这种形式a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;）</span><br></pre></td></tr></table></figure>
<p>数组的长度将被推测为m，所以int a[] = {1,2,3}等于a[3] = {1,2,3}<br>标量类型的(bool,int,char,double,指针)对象是按值初始化（value-initialized）的，意思是指它被初始化为 0 （bool类型被初始化为false， double被初始化为0.0，等等）。有用户声明的默认构造函数的Class类型的对象按值初始化时，他的默认构造函数就会被调用。如果默认构造函数是被隐式定义的，那么所有的非静态类型成员变量将会递归地按值初始化。虽然这个定义并不精确，也不完全正确，但是可以让你有个基本的认识。最近我将会写一篇关于zero-initialization，value-initialization和default-initialization之间区别的文章。引用不能按值初始化。对于非Aggregate类型的class进行按值初始化有可能失败，比如在没有合适的默认构造函数的情形下。<br>数组初始化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	 A(<span class="keyword">int</span>)&#123;&#125; <span class="comment">//no default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">class <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	B() &#123;&#125; <span class="comment">//default constructor available</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1[<span class="number">3</span>] = &#123;A(<span class="number">2</span>), A(<span class="number">1</span>), A(<span class="number">14</span>)&#125;; <span class="comment">//OK n == m</span></span><br><span class="line">    A a2[<span class="number">3</span>] = &#123;A(<span class="number">2</span>)&#125;; <span class="comment">//ERROR A没有默认构造函数. 不能按值初始化a2[1] 和 a2[2]</span></span><br><span class="line">    B b1[<span class="number">3</span>] = &#123;B()&#125;; <span class="comment">//OK b1[1]和b1[2]使用默认构造函数按值初始化</span></span><br><span class="line">    <span class="keyword">int</span> Array1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//所有元素被初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> Array2[<span class="number">1000</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">//注意: 只有第一个元素被初始化为1，其他为0;</span></span><br><span class="line">    <span class="keyword">bool</span> Array3[<span class="number">1000</span>] = &#123;&#125;; <span class="comment">//大括号里可以为空，所有元素被初始化为false；</span></span><br><span class="line">    <span class="keyword">int</span> Array4[<span class="number">1000</span>]; <span class="comment">//没有被初始化. 这和空&#123;&#125;初始化不同；</span></span><br><span class="line">    <span class="comment">//这种情形下的元素没有按值初始化，他们的值是未知的，不确定的; </span></span><br><span class="line">    <span class="comment">//(除非Array4是全局数据)</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//ERROR, 太多初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来看Aggregates类型是如何使用{ }初始化的。和上面非常类似，按照在类内部声明的顺序（按照定义都必须是public类型）初始化非静态类型的成员变量。如果初始值比成员少，那么其他的成员将按值初始化。如果有一个成员无法进行按值初始化，我们将会得到一个编译期错误。如果初始值比成员多，我们同样得到一个编译期错误。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line"> 	<span class="keyword">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"> 	X x;</span><br><span class="line"> 	<span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">float</span> f; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Y y = &#123;<span class="string">'a'</span>, &#123;<span class="number">10</span>,<span class="number">20</span>&#125;, &#123;<span class="number">20</span>,<span class="number">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，y.c被初始化为’a’，y.x.i1被初始化为10，y.x.i2被初始化为20，y.i[0]为20，y.i[1]为30，y.f被按值初始化，也即是说，被初始化为0.0，保护类型的静态成员变量d不会被初始化，因为它是静态类型的。<br>Aggregate类型的unions有所不同，使用{ }你可能只能初始化它们的第一个成员，我想如果你使用C++高级到考虑使用unions（使用他们非常危险，必须小心谨慎），你一定可以自己在C++标准中找到unions的规则。<br>我们知道了Aggregates的特别之处，现在让我们来尝试理解一下它对类型的限制，也就是说为什么会有这些限制。我们应当理解使用{ }进行成员逐一初始化意味着这一类型只是成员的集合。如果有一个用户定义的构造函数，那意味着用户需要做一些额外的工作来初始化成员，因此使用{ }初始化是不正确的。如果出现了虚函数，那意味着这个类型（大多数实现）有一个指向vtable的指针，需要在构造函数内设置，所以使用{ }初始化是不够的。作为练习，你可以按照这种方式自己理解其他限制的含义。<br>关于Aggregates的就这么多，现在我们可以更严格定义一个子类型PODs   </p>
<h2 id="什么是PODs，为什么他们这么特别"><a href="#什么是PODs，为什么他们这么特别" class="headerlink" title="什么是PODs，为什么他们这么特别  "></a>什么是PODs，为什么他们这么特别  </h2><p>C++标准（C++ 03 9 §4）中正式的定义为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD-struct类型是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的类。类似地，POD-union是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的联合。POD类型就是POD-struct和 a POD-union中的一种。</span><br></pre></td></tr></table></figure>
<p>Wow，这个定义更难解读，不是吗？让我们吧unions剥离出去，更清晰的复述为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD类型就是没有非静态类型的non-POD类型 （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型。</span><br></pre></td></tr></table></figure>
<p>这个定义的有什么含义呢？（POD就是Plain Old Data）  </p>
<ol>
<li>所有的POD类型都是Aggregates类型，换句话说，如果不是aggregate类型，那么它一定不是POD类型。  </li>
<li>类，和结构体一样可以为POD类型，因为标准中POD-struct这个术语包含了这两种情形。  </li>
<li>和Aggregates类型一样，静态成员是什么类型则无关紧要  </li>
</ol>
<p>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//no harm if there's a function</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v; <span class="comment">//static members do not matter</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AggregateButNotPOD1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    ~AggregateButNotPOD1()&#123;&#125; <span class="comment">//user-defined destructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AggregateButNotPOD2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> 	AggregateButNotPOD1 arrOfNonPod[<span class="number">3</span>]; <span class="comment">//array of non-POD class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>POD-classes，POD-unions，标量类型和这些类型的数组合成为POD类型，POD类型在很多方面都很特别，我来举几个例子：  </li>
<li>POD类型是最接近于C语言中的结构体类型的。他们都没有改变对象的内存布局，但是，POD类型却可以有自己的成员函数和任意类型的静态成员。所以，如果你想写一个可在C甚至.net平台使用的可移植的动态库，你应该让暴露的所有的方法的返回值和参数都会POD类型。  </li>
<li>非POD类型的对象的生命周期起始于构造函数，结束于析构函数调用完成。而POD类型对象的生命周期却起始于存储对象的空间被占用，结束于空间被释放或被重复利用。  </li>
<li><p>对于POD类型的对象，C++标准保证当你使用memcpy将对象的内容拷贝到一个char类型或者unsigned char类型的数组中，在使用memcpy拷贝回来的时候，对象会保持不变。特别注意，非POD类型是无法保证这一点的。当然，你也可以安全的在对象之间拷贝POD类型。下面的这个例子假设T为POD类型  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="keyword">char</span> buf[N];</span><br><span class="line">T obj; <span class="comment">// obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N); <span class="comment">// between these two calls to memcpy,</span></span><br><span class="line"><span class="comment">// obj might be modified</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N); <span class="comment">// at this point, each subobject of obj of scalar type</span></span><br><span class="line"><span class="comment">// holds its original value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>goto 语句。你知道，使用goto从一个变量没有声明的点跳转到一个变量已经被声明的点是不合法的（编译器应该会有报错）。这个限制仅仅对非POD类型有效，下面这个例子f()是不合法的，而g()则是合法的。注意到微软的编译器对这条规则过于慷慨了，仅仅给出警告而已。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NonPOD</span> &#123;</span> NonPOD()&#123;&#125;&#125;;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    NonPOD x;</span><br><span class="line">label:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">POD</span> &#123;</span><span class="keyword">int</span> i;  <span class="keyword">char</span> c;&#125;;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    POD x;</span><br><span class="line">label:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++标准保证POD类型的对象在内存起始处没有便宜。也就是说如果一个POD类型A的第一个成员为T，你可以安全的调用reinterpret_cast  从A<em>转换为T</em>,得到第一个成员的指针，反过来也成立。  </p>
</li>
</ol>
<p>这个列表还很长很长…  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>理解POD类型非常重要，因为很多C++语言特性，就像你看到的，针对于他们都会有所不同。希望这篇文章对你有用。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Aggregate/">Aggregate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/POD/">POD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-22-理解move和forward"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/22/2017-06-22-理解move和forward/">理解std::move和std::forward</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/22/2017-06-22-理解move和forward/" class="article-date">
	  <time datetime="2017-06-21T16:00:00.000Z" itemprop="datePublished">六月 22, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52371164" target="_blank" rel="noopener">Effective Modern C++ 条款23 理解std::move和std::forward</a></p>
<p>首先我要提一下右值与左值，我觉得本书中的一句话说的非常好：</p>
<p>A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is. If you can’t, it’s usually an rvalue. A nice feature of this heuristic is that it helps you remember that the type of an expression is independent of whether the expression is an lvalue or an rvalue. That is, given a type T, you can have lvalues of type T as well as rvalues of type T. It’s especially important to remember this when dealing with a parameter of rvalue reference type, because the parameter itself is an lvalue:</p>
<p>有效了解std::move和std::forward的方法是，了解它们做不了的事情。std::move不会移动任何东西，std::forward不会转发任何东西，在运行期间，它们什么事情都不会做，不会生成一个字节的可执行代码。</p>
<p>std::move和std::forward仅仅是表现为转换类型的函数（实际上是模板函数），std::move无条件地把参数转换为右值，而std::forward在满足条件下才会执行std::move的转换。这个说明导致了一系列问题，但是从根本上，那是一个完整的故事。</p>
<p>为了让故事更具体，这里是C++11的std::move的简单实现，它没有完全覆盖标准库的细节，不过很接近了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;              <span class="comment">// 在std命名空间里`</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line">move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实函数的本质就是类型转换，就如你所见，std::move接收一个对象的引用（准确地说，是通用引用，具体看条款24），然后返回相同对象的引用。</p>
<p>返回类型中的“&amp;&amp;”暗示着std::move返回的是一个右值引用，不过，就像条款28讲述那样，如果T的类型是个左值引用，T&amp;&amp;将会变成左值引用。为了防止这种事发生，我们对T使用了remove_reference（去除引用语义），因此确保了使用“&amp;&amp;”的类型不是引用类型，那就保证了std::move返回的是右值引用，这是很重要的，因为函数返回的右值引用是右值。因此，std::move把参数转换为一个右值，那就是它做的全部事情。</p>
<p>说点题外话，std::move在c++14的实现就没那么夸张了，返回类型推断（看条款3）和标准库的别名模板std::remove_reference_t（看条款9），std::move可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;             <span class="comment">// C++14，依然在std命名空间</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是容易看多了？</p>
<p>因为std::move除了把参数转换为右值，没做其他事情，这表明类似rvalue_cast这样的名字或许更适合它。话虽如此，但我们用的名字是std::move，所以记住std::move做了什么和没做什么是重要的，它做的是转换，不是移动。</p>
<p>当然，右值会成为可移动的候选者，因此对一个对象使用std::move是告诉编译器，这个对象符合被移动的条件。那就是为什么std::move会有这个名字：很容易指出可能被移动的对象。</p>
<p>事实上，右值在通常情况下是唯一的可移动候选者。假如你要写一个代表注释的类，这个类的构造函数接受一个std::string参数（含有注释），然后把参数拷贝到成员变量，根据条款41，你声明的是值传递的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span>;        <span class="comment">// 参数会被拷贝，值传递</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过因为注释类只是需要读text的值，不需要修改它，根据尽可能使用const这个悠久的历史，你修改了声明，把text修改成const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免拷贝text到成员变量的开销，你根据条款41的建议，对text使用std::move，由此产生一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span></span><br><span class="line">    : value(std::move(text))  // 把text"移动"成右值</span><br><span class="line">    &#123; ... &#125;                   <span class="comment">// 但这代码的行为跟你看到的不一样</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码编译，链接，运行，把成员变量value设置为text的内容。唯一把这代码和你眼中的完美实现分离的事情是text不是被移动到value的，它只是被拷贝。当然，text被std::move转换为右值了，但是text是被声明为const std::string，所以在转换之前，text是一个const std::string左值，转换后，是一个const std::string右值，在整个过程中，const的性质是一支存在的。</p>
<p>当编译器选择std::string构造函数时，有两个可能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span>  <span class="comment">// std::string实际上是std::basic_string&lt;char&gt;的typedef</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);   <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);     <span class="comment">//移动构造</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Annotation构造函数的初始化列表中，std::move(text)的结果是一个类型为const std::string的右值，这个右值不能传递给std::string的移动构造函数，因为移动构造函数接受的是non-const std::string的右值引用。不过这右值，可以传递给拷贝构造函数，因为一个lvalue-reference-to-const（const的左值引用）可以绑定const右值。所以，成员初始化列表调用了std::string的拷贝构造函数，即使text被转换成右值！这种行为对于维护const的正确性是必不可少的。把一个值搬离对象通常都会改变这个对象，所以C++不允许把const对象传递给会改变它们（对象）的函数（例如移动构造）。</p>
<p>在这个例子中我们可以得到两个教训。第一，如果你想要有能力移动对象，不要把它们声明为const。向一个const对象请求移动操作会默默转换为拷贝操作。第二，std::move不仅不会移动东西，还不能保证转换出来的对象有被移动的资格。你唯一能确保的事情是：对一个对象使用std::move，那个对象就被转换为右值。</p>
<p>std::forward的故事就比std::move简单多了，不过std::move是无条件把参数转换为右值，而std::forward在特定情况下才会这样做。std::forward是个有条件的类型转换。为了理解它什么时候转换，回忆一下std::forward一般是怎样使用的。最常见用法是一个模板函数接受全局引用，然后用std::forward把参数传递给另一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> Widget&amp; lvalArg)</span></span>;    <span class="comment">// 处理左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;         <span class="comment">// 处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span>      <span class="comment">// 把参数传递给process的模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();   <span class="comment">// 获取当前时间           </span></span><br><span class="line"></span><br><span class="line">     makeLogEntry(<span class="string">"Calling 'process'"</span>, now);</span><br><span class="line">     process(<span class="built_in">std</span>::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑logAndProcess的两次调用，一次左值，一次右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">logAndProcess(w);             <span class="comment">// 左值参数调用</span></span><br><span class="line">logAndProcess(<span class="built_in">std</span>::move(w));  <span class="comment">// 右值参数调用</span></span><br></pre></td></tr></table></figure>
<p>在logAndProcess里面，参数param被传递给process函数，而process函数为了左值参数和右值参数进行重载。当我们用左值调用logAndProcess的时候，我们自然是希望把左值转发给process，而当我们用右值调用logAndProcess时，我们希望调用的是右值重载的process。</p>
<p>但是param，和所有的函数参数一样，是个左值。在logAndProcess里每次调用process都会使用左值重载的process。为了防止这样的事情，我们需要一项技术，当且仅当初始化param的参数——即传递给logAndProcess的参数——是右值时，在logAndProcess把param转换为右值。这就是std::forward干的事情了，这也是为什么说std::forward是个有条件的类型转换：仅当参数是用右值初始化时，才会把它转换为右值。</p>
<p>你可能想要知道std::forward是如何知道参数是否用右值初始化的。举个例子，上面的代码中，std::forward是怎样知道初始化param的，是左值还是右值呢？简短的答案是信息会被编码到logAndProces的模板参数T中。这个参数传递给std::forward模板，然后恢复编码的信息。具体细节看条款28。</p>
<p>倘若把std::move和std::forward把归结为类型转换，那么它们的差别是std::move总是会转换，std::forward只会在某些时刻转换，你可以会问我们是否可以摒弃std::move，只是用std::forward。从纯粹的技术角度看，答案是可以的：std::forward可以应付所有场景，std::move不是必须的。当然，没有一个函数是真的必须的，因为我们可以自己写转换，不过如果那样的话，是很恶心的。</p>
<p>std::move吸引人的地方在于它的方便，减少可能的错误，还有更简洁。试想在一个类中，我们要记录移动构造函数被调用了多少次。我们所需要的是个static计数器，它在移动构造中递增。假如类中的非static成员变量只有一个std::string，这里有个十分方便的方法（即使用std::move）实现我们的移动构造：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs)</span><br><span class="line">    : s(<span class="built_in">std</span>::move(rhs.s))</span><br><span class="line">    &#123; ++moveCtorCalls; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> moveCtorCalls;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用std::forward实现相同的效果，代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Widget(Widget&amp;&amp; rhs)</span><br><span class="line">     :s(<span class="built_in">std</span>::forward&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(rhs.s))</span><br><span class="line">    &#123; ++moveCtorCalls; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先要注意到的是std::move只需要一个函数参数（rhs.s），而std::forward既需要一个函数参数（rhs.s）又需要一个模板类型参数（std::string）。然后需要注意的是我们一般传递给std::forward的参数类型是不带引用的，那是因为这会很方便把参数编码成右值（看条款28）。结合起来，意味着std::move比起std::forward需要更少的类型，不用传递类型参数可以减少编码的麻烦。它还可以消除我们可能传递的类型错误（例如，std::string&amp;， 使用std::forward的话，会导致成员变量拷贝构造，而不是移动构造）。</p>
<p>最重要的是，std::move是无条件转换，而std::forward只会将绑在右值上的参数转换为右值。这两个操作不一样，第一个操作通常会造成移动，而第二个操作只是传递——转发——一个对象给另一个函数，而保持原来的左值性质或者右值性质。因为这两个行为是不一样的，所以用两个不同的函数（和函数名）区分它们是很好的设计。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要记住的3点：</p>
<ol>
<li>std::move表现为无条件的右值转换，就其本身而已，它不会移动任何东西。</li>
<li>std::forward仅当参数被右值绑定时，才会把参数转换为右值。</li>
<li>std::move和std::forward在运行时不做任何事情。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/forward/">forward</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/move/">move</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-21-尽可能使用constexpr"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/21/2017-06-21-尽可能使用constexpr/">尽可能使用constexpr</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/21/2017-06-21-尽可能使用constexpr/" class="article-date">
	  <time datetime="2017-06-20T16:00:00.000Z" itemprop="datePublished">六月 21, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下内容转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52280393" target="_blank" rel="noopener">尽可能使用constexpr</a></p>
<p>如果要选出C++11中最让人迷惑的新关键字，那么大概是constexpr。当constexpr用于对象时，它本质上就是加强版的const，但它用于函数时，它拥有不同的意思。constexpr再迷惑，也是值得的，因为当constexpr与你想要表达的一致时，你肯定会用它。<br>在概念上，constexpr表明一个值不仅是常量，还是在编译期间可知。这概念只是拼图的一部分，因为当constexpr用于函数时，有点微妙的区别。免得我破坏了最后的惊喜，我现在只可以说，你不能假定constexpr函数的返回结果是const的，也不能理所当然的人物它们的返回值在编译期间可知。可能会很有趣，这些特性。constexpr函数不需要返回const结果和编译器可知结果，这是有益的。  </p>
<p>不过我们还是先讲constexpr对象，这些对象呢，事实上和const一样，它们的值在编译期间就知道了。<br>那些在编译期间就可知的值是享有特权的。例如，它们可能存放在只读的内存区域中，特别是为那些内嵌系统的开发者，这是一个相当重要的特性。在C++的上下文中需要一个整型常量表达式(integral constant expression)时，一个常量的和编译期间可知的整型数具有广泛适应性。这种上下文包括数组大小的表示，整型模板参数（包括std::array对象的长度），枚举的值，对齐说明，等等。如果你想要一个变量，用于刚说的东西，那么你肯定想要把那个变量声明为constexpr，因为编译器会确保它在编译期间有值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;   <span class="comment">// non-constexpr variable</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;   <span class="comment">// 错误，编译期间不知道sz的值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1;   <span class="comment">// 错误，同样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 =  <span class="number">10</span>;  <span class="comment">// 正确，10在编译期间是常量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2;  <span class="comment">// 正确，arraySize2是constexpr的</span></span><br></pre></td></tr></table></figure>
<p>请注意const并不提供与constexpr相同的保证，因为const对象在编译时不需要用已知的值初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;  <span class="comment">// 如前</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz;  <span class="comment">// 正确，arraySize是sz的**const**拷贝</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data; <span class="comment">// 错误，arraySize的值在编译期间不可知</span></span><br></pre></td></tr></table></figure>
<p>我们可以简单地认为，所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。如果你想要编译器保证变量编译期有值，即上下文请求了一个编译期间的常量，那么能用的工具是constexpr，而不是const。<br>当涉及到constexpr函数的时候，constexpr对象的使用会变得更加有趣。当编译期间的常量作为参数传递给constexpr函数时，这种函数会返回编译期间常量。如果函数的参数在运行期间才能知道，函数返回的也是运行时的值。听起来有点乱，正确的规则：  </p>
<ol>
<li>constexpr函数可以用在需求编译期间常量的上下文。在这种上下文中，如果你传递参数的值在编译期间已知，那么函数的结果会在编译期间计算。如果任何一个参数的值在编译期间未知，代码将不能通过编译。</li>
<li>如果用一个或者多个在编译期间未知的值作为参数调用constexpr函数，函数的行为和普通的函数一样，在运行期间计算结果。这意味着你不需要用两个函数来表示这个操作——一个在编译期间和一个在运行期间。constexpr函数具有两个动作。  </li>
</ol>
<p>假设我们需要一个数据结构来保存某个实验的结果，这个实验可在不同的条件下进行。例如，在实验期间，光的强度可高可低，风速和温度也可变化。如果与实验有关的环境条件有n个，每个环境变量又有3种状态，那么就有$3^n$种情况。存储实验可能出现的所有结果，就要求数据结构有足够大的空间保存$3^n$个值。假设每个结果是int值，然后n在编译期间已知（或者可计算），那么选择std::array这数据结构将会合情合理。C++标准库提供std::pow，是我们需要的数学计算函数，但这里会有两个问题。第一，std::pow作用于两个浮点型指针，而我们需要的是一个整型结果。第二，std::pow不是constexpr的，所以我们不能用它的结果来指定std::array的值。  </p>
<p>幸运的是，我们可以自己写pow函数。等下我会展示它是怎么做的，但我们先看看它是怎样声明和使用的：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span>   <span class="comment">// pow是个constexpr函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span>   <span class="comment">// 函数不会抛出引出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...     <span class="comment">// 实现看下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numCouds = <span class="number">5</span>;   <span class="comment">// 条件个数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="built_in">pow</span>(3, numCouds)&gt; results;   <span class="comment">// results有3^n个元素</span></span><br></pre></td></tr></table></figure>
<p>constexpr在pow并不是说明pow返回const值，它指的是，如果base和exp是编译期间常量，pow的结果可以被用作编译期间常量。如果base和（或）exp不是编译期间常量，pow的结果将会在程序运行时计算，这意味pow不仅可以在编译期间计算std::array的大小，还可以在运行期间的上下文调用：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> base = readFromDB(<span class="string">"base"</span>);      <span class="comment">// 在运行期间</span></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">exp</span> = readFromDB(<span class="string">"exponent"</span>);  <span class="comment">// 获取值</span></span><br><span class="line"><span class="keyword">auto</span> baseToExp = <span class="built_in">pow</span>(base, <span class="built_in">exp</span>);   <span class="comment">// 在运行期间调用pow</span></span><br></pre></td></tr></table></figure>
<p>因为用编译期间的值作为参数调用constexpr函数一定要返回编译期间的结果，所以会有限制强加于它们的实现。c++11和C++14的限制不同。  </p>
<p>在C++11，constexpr只能有一个return语句。听起来不是什么限制，因为可以用两个技巧。第一个是“？：”运算符代替if-else语句，第二个是可以用递归。所以pow可以这样实现：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span> - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以运行，但是很难想象除了大神还有谁能把它写得这么好。在C++14中，constexpr函数的限制大幅宽松，所以这种函数实现成为可能：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">por</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">exp</span>; ++i) result *= base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>constexpr函数限制持有和返回的类型为字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。在C++中，除了void之外的内置类型都是字面值类型，不过用户定义的类型也有可能是字面值类型，因为构造函数和其他成员函数可能是constexpr的：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> xVal = <span class="number">0</span>, <span class="keyword">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">   : x(xVal), y(yVal)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> xVal; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> yVal; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，Point的构造函数可以被声明为constexpr，因为如果传进来的参数在编译时就可以知道，那么由P构造的成员变量的值在编译时也可以被知道。因此Point可以用constexpr初始化 ：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;  <span class="comment">// 正确，在编译时“运行”constexpr构造</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;  <span class="comment">// 也正确</span></span><br></pre></td></tr></table></figure>
<p>同样的，获取函数（getter）xValue和yValue也可以是constexpr，因为如果它们被一个编译期间已知的Point对象调用（例如，一个constexpr的Point对象），成员变量x和y的值在编译时是已知的，这使一个constexpr函数调用Point的获取函数并用其结果来初始化一个constexpr对象成为可能：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span></span><br><span class="line"><span class="function">Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.xValue + p2.xValue)) / <span class="number">2</span>,        <span class="comment">// 调用constexpr</span></span><br><span class="line">             (p1.yValue + p2.yValue)) / <span class="number">2</span> &#125;;    <span class="comment">// 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);  <span class="comment">// 用**constexpr**函数的结果  // 初始化constexpr对象。</span></span><br></pre></td></tr></table></figure>
<p>这很有趣，这意味着对象mid的初始化涉及到构造函数、获取函数、非成员函数的调用，然后创建在只读内存区域！这意味着你可以将一个类似mid.xValue() * 10的表达式用于模板参数或者一个指定枚举值的表达式！这意味着传统意义上，编译期需完成的工作与运行期间需完成的工作之间的严格清晰的线变模糊了，而一些传统意义上运行时的工作可以迁移到编译期。参与迁移的代码越多，软件运行得越快（但是，编译的时间可能变长）。  </p>
<p>在C++11，有两个限制因素妨碍把Point的成员变量setX和setY声明为constexpr。第一，它们改变了它们操作的值，然后在C++11，constexpr成员函数是隐式声明为const的。第二，它们的返回类型是void，然后在C++11，void不是字面值类型。都是这两个限制在C++14被解除了，所以在C++14，设置函数（setter）也可以constexpr：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span>   <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function">    </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span>   <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function">    </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这使得写这奇葩的函数成为可能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回p的映像（C++14）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result;     <span class="comment">// create non-const Point</span></span><br><span class="line"></span><br><span class="line">    result.setX(-p.xValue());</span><br><span class="line">    result.setY(-p.yValue());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户的代码可能是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =      <span class="comment">// reflectedMid的值是（-19.1, -16.5）</span></span><br><span class="line">    reflection(mid);                 <span class="comment">//  而且在编译期间就知道了</span></span><br></pre></td></tr></table></figure>
<p>本条款的建议是尽可能使用constexpr，然后现在我希望你能很清楚为什么：constexpr对象和constexpr函数比起non-constexpr对象和函数具有更广泛的语境。通过尽可能地使用constexpr，你最大化了对象和函数的可能使用的情况。  </p>
<p>注意到constexpr是一个对象或函数接口的一部分是很重要的。constexpr表明“我可以用于需求常量表达式的上下文”，如果你把对象或者函数声明为constexpr，用户就有可能把它用于这种上下文。后来，如果你觉得你使用constexpr是个错误，然后你删除了它，这样就可能造成用户大量代码无法编译（为了调试添加I/O函数会导致这种问题，因为I/O语句通常不允许出现在constexpr函数）。“尽可能使用constexpr”中的“尽可能”是你愿意作出长期的承诺，强行约束着constexpr的对象和函数（这句话太难了，我不知道我的理解有没问题：Part of “whenever possible”in “Use constexpr whenever possible” is your willingness to make a long-term commitment to the constraints it imposes on the objects and functions you apply it to.）。··  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要记住4点：</p>
<ol>
<li>constexpr对象是const的，它需用编译期间已知的值初始化。</li>
<li>constexpr函数在传入编译期已知值作为参数时，会在编译期间生成结果。</li>
<li>constexpr对象和函数比起non-constexpr对象和函数具有更广泛的语境。</li>
<li>constexpr是对象和函数接口的一部分。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/constexpr/">constexpr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-20-理解模板类型推断"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/20/2017-06-20-理解模板类型推断/">理解模板类型推断</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/20/2017-06-20-理解模板类型推断/" class="article-date">
	  <time datetime="2017-06-19T16:00:00.000Z" itemprop="datePublished">六月 20, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下内容转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52140262" target="_blank" rel="noopener">Effective Modern C++ 条款1 理解模板类型推断</a></p>
<p>C++11的auto自动推断变量的方式是以模板推断为基础的，模板推断的规则也应用在auto上，所以理解掌握模板推断的规则对于我们C++程序员来说很重要。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>考虑上面的代码，当我们调用上面函数并传入参数expr时   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr);</span><br></pre></td></tr></table></figure>
<p>编译器需要根据expr的来推断两个类型，一个是T， 一个是ParamType，这两个类型通常是不一样的，因为ParamType通常会含有修饰符，例如const，例如以下代码  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">f(x);</span><br></pre></td></tr></table></figure>
<p>此时T会被推断为int，而ParamType会被推断为const int &amp; 。  </p>
<p>人们会很自然的认为编译器为T推断的类型就是我们传进的参数的类型，用上面的代码表示就是T的类型就是expr的类型，也就是说传进来的x是int的类型，然后T就是int的类型。但这有时候是不对的，类型T的推导不仅仅依赖于expr，也依赖于ParamType。  </p>
<p>具体有以下3中情况  </p>
<ol>
<li>ParamType是指针类型或者引用类型，但不是通用引用(universal references)类型</li>
<li>ParamType是通用引用(universal references)类型</li>
<li>ParamType既不是指针类型也不是引用类型</li>
</ol>
<h2 id="情况1-ParamType-是指针类型或者引用类型，但不是通用引用-universal-references-类型"><a href="#情况1-ParamType-是指针类型或者引用类型，但不是通用引用-universal-references-类型" class="headerlink" title="情况1 ParamType 是指针类型或者引用类型，但不是通用引用(universal references)类型"></a>情况1 ParamType 是指针类型或者引用类型，但不是通用引用(universal references)类型</h2><p>这是最简单的一种情况。只需记住以下两点  </p>
<ol>
<li>如果传进来的参数expr 是一个引用类型，忽视引用的部分</li>
<li>通过模式匹配expr 的类型来决定ParamType 的类型从而决定T 的类型（Then pattern-match expr’s type against ParamType to determine T. ）</li>
</ol>
<p>例子如下   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后我们定义一下变量  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用模板函数</span></span><br><span class="line">f(x);   <span class="comment">// T 的类型为int, ParamType的类型为int&amp;</span></span><br><span class="line">f(cx);   <span class="comment">// T 的类型为const int, ParamType的类型为const int&amp;</span></span><br><span class="line">f(rx);   <span class="comment">// T 的类型为const int, ParamType的类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是f(rx)，rx是引用类型，但是编译器会把引用忽略，然后用去掉引用后的参数类型来匹配T 。如果ParamType为右值引用，推断的原则也是相同。但是如果为const引用，就会与上面的结果有点不一样，参考下面的例子。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义的变量和上面的一致  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"> <span class="comment">// 一样调用模板函数</span></span><br><span class="line">f(x);   <span class="comment">// T 的类型为int, ParamType的类型为const int&amp;</span></span><br><span class="line">f(cx);   <span class="comment">// T 的类型为int, ParamTyp的类型为const int&amp;</span></span><br><span class="line">f(rx);   <span class="comment">// T 的类型为int, ParamType的类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>因为我们在定义声明模板的时候参数类型已经认定了是const引用，所以T 的类型不再需要推断出const。而rx的引用依旧被忽略。  </p>
<p>如果把引用换成指针，原则基本一致，把expr的指针类型忽略，例子如下  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;</span><br><span class="line">f(&amp;x);  <span class="comment">// T的类型为int，ParamType 的类型为int*</span></span><br><span class="line">f(px);   <span class="comment">// T的类型为const int，ParamType的类型为const int*</span></span><br></pre></td></tr></table></figure>
<h2 id="情况2-ParamType-是通用引用-universal-references-类型"><a href="#情况2-ParamType-是通用引用-universal-references-类型" class="headerlink" title="情况2 ParamType 是通用引用(universal references)类型"></a>情况2 ParamType 是通用引用(universal references)类型</h2><p>首先要知道什么是universal references，可以google或者baidu，懒得搜索的可以直接看这里。简单来说就是type&amp;&amp; + syntax + type deduction，即可以引用左值，也可以引用右值。<br>这种情况也有两个原则  </p>
<ol>
<li>如果expr是一个左值，那么T和ParamType会被推断为左值引用</li>
<li>如果expr是一个右值，那么会用正常的推断方式(情况1)</li>
</ol>
<p>可以看以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"></span><br><span class="line">f(x);  <span class="comment">// x是左值，所以T 和ParamType会被推断为int &amp;类型</span></span><br><span class="line">f(cx); <span class="comment">// cx是左值，所以T和ParamType会被推断为const int &amp;类型</span></span><br><span class="line">f(rx);  <span class="comment">// rx是左值，所以T和 ParamType会被推断为const int &amp;类型</span></span><br><span class="line">f(<span class="number">27</span>);`  <span class="comment">// 27是右值，根据情况1，T的类型会被推断为int、ParamType会被推断为int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h2 id="情况3-ParamType-既不是指针类型也不是引用类型"><a href="#情况3-ParamType-既不是指针类型也不是引用类型" class="headerlink" title="情况3 ParamType 既不是指针类型也不是引用类型"></a>情况3 ParamType 既不是指针类型也不是引用类型</h2><p>如果ParamType 既不是指针也不是引用，那么参数是通过值传递(pass-by-value)的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;    <span class="comment">// 此处会有拷贝(构造)</span></span><br></pre></td></tr></table></figure>
<p>T 的类型推断主要依赖于传进来的参数expr  </p>
<ol>
<li>如果expr的类型是引用类型，那么忽略引用</li>
<li>通过了上面的检测(无论是不是引用类型)后，如果expr 的类型是const的，把const也忽略了，还会忽略volatile。</li>
</ol>
<p>给出下面的例子  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br></pre></td></tr></table></figure>
<p>和之前的例子一样  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x);  <span class="comment">// 易知T和ParamType的类型都是int</span></span><br><span class="line">f(cx);  <span class="comment">// 忽略const，T和ParamType的类型都是int</span></span><br><span class="line">f(rx);`  <span class="comment">// 忽略了引用后再忽略const,T和ParamType的类型都是int</span></span><br></pre></td></tr></table></figure>
<p>虽说cx和rx都是const修饰的，但是param是值语义，所以param只是拷贝了cx和rx的值，并可以改变值。这就是为什么会忽略const，因为传进的参数expr 尽管不可以改变值，但并不意味着他们的拷贝不可以。  </p>
<p>如果我们定义一个指向常量的常量指针   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr = <span class="string">"Fun with pointers"</span>;</span><br></pre></td></tr></table></figure>
<p>然后调用函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(ptr);</span><br></pre></td></tr></table></figure>
<p>这个时候T 和 ParamType的类型会被推断为const char *，这是因为这种情况下传入的参数都会被函数拷贝并可以改变的，所以指针是可以指向不同的地址，个人理解在情况3是只会忽略 顶层const，然后保留 底层const。  </p>
<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><p>在情况3下，如果传入的参数是数组，会转化为指针类型，例如 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J. R. Briggs"</span>; <span class="comment">// name的类型是const char[13] </span></span><br><span class="line">f(name); <span class="comment">// T会被推断为 const char *</span></span><br></pre></td></tr></table></figure>
<p>但在情况1下 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们把数组作为参数传入函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(name); <span class="comment">// T 的类型会被推断为const char [13]</span></span><br></pre></td></tr></table></figure>
<p>这个时候T 的类型会被推断为有长度的数组，在这个例子中T 的类型会被推断为const char [13]，ParamType的类型会是 const char (&amp;) [13]<br>在这里引用一段书中的原话，这规则有毒….  </p>
<p>Yes, the syntax looks toxic, but knowing it will score you mondo points with those few souls who care.<br>是的，语法看起来很有毒，但是知道它会让你与那些关心的少数灵魂分享你的意见。  </p>
<p>利用这个特性可以写一个模板，用来返回数组的长度  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> arraySize(T (&amp;)[N]) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个模板函数是constexpr修饰的，所以他的结果可以在编译时期得到，所以可以用来初始化变量。  另外关于constexpr可以看这篇<a href="">《尽可能使用constexpr》</a></p>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>因为函数像数组一样可以转化为指针，所以函数作为参数与数组类似，例子如下  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line">f1(someFunc); <span class="comment">// 传值，ParamType 类型为void (*)(int, double)，情况3</span></span><br><span class="line"></span><br><span class="line">f2(someFunc); <span class="comment">// 引用语义，ParamType类型为void (&amp;)(int, double)，情况1</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>auto的规则与模板类型推断有很大关联，这在一开始已经说了，是理解auto的前提。  </p>
<p>要记住的4点  </p>
<ol>
<li>在模板类型推断过程中，参数的引用语义会被忽略</li>
<li>在通用引用(universal reference)类型推断时，左值引用会被特别对待</li>
<li>在传值类型的模板推断过程中，const 和 volatile的参数会以non-const 和 non-volatile 对待。</li>
<li>在模板类型推断过程中，如果参数是数组或者函数，他们被转化为对应的指针，除非模板参数类型一开始就是引用。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/auto/">auto</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/20/2017-12-20-YOLOv2代码分析（四）/">YOLOv2代码分析（四）</a></h6>
              <span>十二月 20, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/19/2017-12-19-YOLOv2代码分析（三）/">YOLOv2代码分析（三）</a></h6>
              <span>十二月 19, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/17/2017-12-17-YOLOv2代码分析（二）/">YOLOv2代码分析（二）</a></h6>
              <span>十二月 17, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/16/2017-12-16-YOLOv2代码分析（一）/">YOLOv2代码分析（一）</a></h6>
              <span>十二月 16, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/15/2017-12-15-目标检测中的IOU计算问题/">目标检测中的IOU计算问题</a></h6>
              <span>十二月 15, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2017/12/13/2017-12-13-tf.identity的作用/">tf.identity的作用</a></h6>
              <span>十二月 13, 2017</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/1080ti/">1080ti</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aggregate/">Aggregate</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dell/">Dell</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eassy/">Eassy</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eval/">Eval</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Execute/">Execute</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExecuteGlobal/">ExecuteGlobal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fibonacci/">Fibonacci</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOU/">IOU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kolakoski/">Kolakoski</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MNIST/">MNIST</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PIL/">PIL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POD/">POD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YOLO/">YOLO</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/">acm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/advance/">advance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/array/">array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp/">asp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto&</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/auto/">auto&&</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binding/">binding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c#</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cin/">cin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/constexpr/">constexpr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a><span class="tag-list-count">90</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp标准库/">cpp标准库</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp第二版/">cpp第二版</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cuda/">cuda</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cudnn/">cudnn</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/darknet/">darknet</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dd/">dd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/">default</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/downcasting/">downcasting</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/error/">error</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/estimator/">estimator</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/forward/">forward</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/">game</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glvalue/">glvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hook/">hook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/identity/">identity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/">lambda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvalue/">lvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mismatch/">mismatch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/move/">move</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/namehiding/">namehiding</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/">next</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/">notes</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/office/">office</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oj/">oj</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/">opencv</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overload/">overload</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/override/">override</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/piecewise-construct/">piecewise_construct</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/">pip</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipe/">pipe</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/process/">process</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prvalue/">prvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytesseract/">pytesseract</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quit/">quit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/re/">re</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requests/">requests</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rvalue/">rvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/signal/">signal</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql注入/">sql注入</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tensorflow/">tensorflow</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threading/">threading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie树/">trie树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uninstall/">uninstall</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unordered-multimap/">unordered_multimap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upcasting/">upcasting</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vbs/">vbs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/">vector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vfptr/">vfptr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wait/">wait</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlvalue/">xlvalue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人工智能/">人工智能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/仿函数/">仿函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/决策树算法/">决策树算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分配器/">分配器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原理/">原理</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反斜杠/">反斜杠</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文字符串/">回文字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多态/">多态</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典树/">字典树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/引用折叠/">引用折叠</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排列组合/">排列组合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/木马/">木马</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式识别/">模式识别</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞/">漏洞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/病毒/">病毒</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试/">笔试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓冲区溢出/">缓冲区溢出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪吃蛇/">贪吃蛇</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心算法/">贪心算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/迭代器/">迭代器</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/适配器/">适配器</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.83px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.67px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.67px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.83px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.83px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.67px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.67px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 12.5px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.83px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.5px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.5px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.67px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.83px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.83px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 12.5px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.67px;">error</a> <a href="/tags/estimator/" style="font-size: 11.67px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.67px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.83px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.5px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 19.17px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.5px;">numpy</a> <a href="/tags/office/" style="font-size: 10.83px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.17px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.83px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.83px;">overload</a> <a href="/tags/override/" style="font-size: 10.83px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.83px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 18.33px;">python</a> <a href="/tags/qt/" style="font-size: 13.33px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.67px;">re</a> <a href="/tags/requests/" style="font-size: 10.83px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.83px;">signal</a> <a href="/tags/sql/" style="font-size: 10.83px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.67px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.83px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.83px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.5px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.83px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/笔试/" style="font-size: 11.67px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.83px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.83px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.5px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
