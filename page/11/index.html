<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 11 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/11/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-07-03-回文字符串"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/03/2017-07-03-回文字符串/">回文字符串</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/03/2017-07-03-回文字符串/" class="article-date">
	  <time datetime="2017-07-02T16:00:00.000Z" itemprop="datePublished">七月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>写一个程序，他用一个stack<t>容器适配器实例将从键盘输入的一行文字反向。程序应该输出反向后的结果，并判断和原始字符串是否回文（回文字符串是一个正向和反向都相同的字符串—-如果忽略空格和标点的话，例如Are we not drawn onward to a new era?）</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="built_in">string</span> str, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span> || index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str.at(low) != str.at(high))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fun(low + <span class="number">1</span>, high - <span class="number">1</span>, str, index - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; words;</span><br><span class="line">	<span class="keyword">bool</span> flag&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">exp</span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> index&#123;&#125;;</span><br><span class="line">			getline(<span class="built_in">cin</span>, <span class="built_in">exp</span>, <span class="string">'\n'</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">exp</span>.empty()) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">while</span> (index != <span class="built_in">exp</span>.length())</span><br><span class="line">			&#123;</span><br><span class="line">				words.push(<span class="built_in">exp</span>.at(index++));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">' '</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">'?'</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">','</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			<span class="built_in">exp</span>.erase(remove(begin(<span class="built_in">exp</span>), end(<span class="built_in">exp</span>), <span class="string">'.'</span>), end(<span class="built_in">exp</span>));</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> (!words.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; words.top();</span><br><span class="line">				words.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			index = <span class="built_in">exp</span>.length();</span><br><span class="line">			<span class="keyword">if</span> (fun(<span class="number">0</span>, index - <span class="number">1</span>, <span class="built_in">exp</span>, index))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"  OK"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"  NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/回文字符串/">回文字符串</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-07-02-Aggregate和POD类型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/07/02/2017-07-02-Aggregate和POD类型/">Aggregate和POD类型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/02/2017-07-02-Aggregate和POD类型/" class="article-date">
	  <time datetime="2017-07-01T16:00:00.000Z" itemprop="datePublished">七月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>A plain old data structure (POD) is a data structure that is represented only as passive collections of field values, without using encapsulation or other object-oriented features.<br>POD是这样的数据结构：用组个field的集合来表示，没有使用封装或者其他面向对象的features。<br>A POD type in C++ is defined as either a scalar type or a POD class. A POD class has no user-defined copy assignment operator, no user-defined destructor, and no non-static data members that are not themselves PODs. Moreover, a POD class must be an aggregate, meaning it has no user-declared constructors, no private nor protected non-static data, no base classes and no virtual functions. The standard includes statements about how PODs must behave in C++.<br>In certain contexts, C++ allows only POD types to be used. For example, a union in C++98 cannot contain a class that has virtual functions or nontrivial constructors or destructors. This restriction is imposed because the compiler cannot determine which constructor or destructor should be called for a union. POD types can also be used for interfacing with C, which supports only PODs.<br>在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。一般来说，POD对象应该满足如下特性。<br>对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，再将其复制回对象，那么该对象的值与原始值一样。考试就到对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。<br>简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，只要其二进制内容在，就能还原出正确无误的POD对象。对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。  </p>
<p>下面是转自<a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special" target="_blank" rel="noopener">stackoverflow的一篇文章的译文</a>，比较详细介绍了aggregate 和 POD：<br>这篇文章很长，如果Aggregates和PODs都想了解，就静下心来完整的把这篇文章读完，如果你仅仅对Aggregates感兴趣，读第一部分就可以了。如果你仅对PODs感兴趣，那你必须先读懂Aggregates的定义、含义和例子，然后再跳去读PODs，但是我依然推荐你完整的读完第一部分。Aggragates的概念是定义PODs的基础。  </p>
<h2 id="什么是Aggragates，为什么他们这么特别？"><a href="#什么是Aggragates，为什么他们这么特别？" class="headerlink" title="什么是Aggragates，为什么他们这么特别？"></a>什么是Aggragates，为什么他们这么特别？</h2><p>C++标准（C++ 03 8.5.1 §1）中的正式定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个Aggregate是一个数组或者一个没有用户声明构造函数，没有私有或保护类型的非静态数据成员，没有父类和虚函数的类型</span><br></pre></td></tr></table></figure>
<p>现在我们来分析这个定义。首先，数组是Aggregate。class也可以成为Aggregate如果满足…等等！我们还没有说struct和unions，它们可以成为Aggregate吗？是的，他们可以。在C++中，术语class是指所有的classes、structs和unios。所以，class（struct，union）只要满足上面定义中的条件就可以成为Aggregate。这些条件有什么含义呢？  </p>
<ol>
<li>这并不是说Aggregate类型就不能有构造函数，事实上，它可以拥有一个默认构造函数或者一个复制构造函数，只要他们是被编译器声明的，而不是被用户自己声明的。  </li>
<li>不能拥有私有或者保护类型的非静态数据成员。你可以定义任意多的私有或者保护类型的成员方法（不包括构造函数）和静态类型的数据成员和方法，这都不违背Aggregate类型的规则。  </li>
<li>Aggregate类型可以拥有用户声明的/用户定义的 赋值操作符或者析构函数</li>
<li>数组是Aggregate类型，即便是非Aggregate类型元素的数组。</li>
</ol>
<p>来看几个例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//remember? no virtual functions</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> x; <span class="comment">//x is private by default and non-static </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAggregate3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NotAggregate3(<span class="keyword">int</span>) &#123;&#125; <span class="comment">//oops, user-defined constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aggregate1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NotAggregate1 member1;   <span class="comment">//ok, public member</span></span><br><span class="line">    Aggregate1&amp; <span class="keyword">operator</span> = (Aggregate1 <span class="keyword">const</span> &amp; rhs) &#123;<span class="comment">/* */</span>&#125; <span class="comment">//ok, copy-assignment  </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">void</span> f() &#123;&#125; <span class="comment">// ok, just a private function</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你已经理解了Aggregates含义了，现在我们来看为什么它这么特别。他们和非Aggregates类型不同，可以使用“{ }”初始化。这种初始化语法，在数组上很常见，而且，我们刚刚了解到数据就是Aggregates类型，所以，我们从数组开始：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type array_name[n] = &#123;a1, a2, ..., am&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m == n)</span><br></pre></td></tr></table></figure>
<p>数组的第i个元素被初始化为ai  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m &lt; n)</span><br></pre></td></tr></table></figure>
<p>数组前边的m个元素被初始化为a1, a2, …, am，剩余的n-m个元素，如果可能，将按值初始化（下面有关于这个名词的解释）  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m &gt; n)</span><br></pre></td></tr></table></figure>
<p>会引起编译错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>（有可能为这种形式a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;）</span><br></pre></td></tr></table></figure>
<p>数组的长度将被推测为m，所以int a[] = {1,2,3}等于a[3] = {1,2,3}<br>标量类型的(bool,int,char,double,指针)对象是按值初始化（value-initialized）的，意思是指它被初始化为 0 （bool类型被初始化为false， double被初始化为0.0，等等）。有用户声明的默认构造函数的Class类型的对象按值初始化时，他的默认构造函数就会被调用。如果默认构造函数是被隐式定义的，那么所有的非静态类型成员变量将会递归地按值初始化。虽然这个定义并不精确，也不完全正确，但是可以让你有个基本的认识。最近我将会写一篇关于zero-initialization，value-initialization和default-initialization之间区别的文章。引用不能按值初始化。对于非Aggregate类型的class进行按值初始化有可能失败，比如在没有合适的默认构造函数的情形下。<br>数组初始化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	 A(<span class="keyword">int</span>)&#123;&#125; <span class="comment">//no default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">class <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	B() &#123;&#125; <span class="comment">//default constructor available</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1[<span class="number">3</span>] = &#123;A(<span class="number">2</span>), A(<span class="number">1</span>), A(<span class="number">14</span>)&#125;; <span class="comment">//OK n == m</span></span><br><span class="line">    A a2[<span class="number">3</span>] = &#123;A(<span class="number">2</span>)&#125;; <span class="comment">//ERROR A没有默认构造函数. 不能按值初始化a2[1] 和 a2[2]</span></span><br><span class="line">    B b1[<span class="number">3</span>] = &#123;B()&#125;; <span class="comment">//OK b1[1]和b1[2]使用默认构造函数按值初始化</span></span><br><span class="line">    <span class="keyword">int</span> Array1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//所有元素被初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> Array2[<span class="number">1000</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">//注意: 只有第一个元素被初始化为1，其他为0;</span></span><br><span class="line">    <span class="keyword">bool</span> Array3[<span class="number">1000</span>] = &#123;&#125;; <span class="comment">//大括号里可以为空，所有元素被初始化为false；</span></span><br><span class="line">    <span class="keyword">int</span> Array4[<span class="number">1000</span>]; <span class="comment">//没有被初始化. 这和空&#123;&#125;初始化不同；</span></span><br><span class="line">    <span class="comment">//这种情形下的元素没有按值初始化，他们的值是未知的，不确定的; </span></span><br><span class="line">    <span class="comment">//(除非Array4是全局数据)</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//ERROR, 太多初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来看Aggregates类型是如何使用{ }初始化的。和上面非常类似，按照在类内部声明的顺序（按照定义都必须是public类型）初始化非静态类型的成员变量。如果初始值比成员少，那么其他的成员将按值初始化。如果有一个成员无法进行按值初始化，我们将会得到一个编译期错误。如果初始值比成员多，我们同样得到一个编译期错误。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line"> 	<span class="keyword">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"> 	X x;</span><br><span class="line"> 	<span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">float</span> f; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Y y = &#123;<span class="string">'a'</span>, &#123;<span class="number">10</span>,<span class="number">20</span>&#125;, &#123;<span class="number">20</span>,<span class="number">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，y.c被初始化为’a’，y.x.i1被初始化为10，y.x.i2被初始化为20，y.i[0]为20，y.i[1]为30，y.f被按值初始化，也即是说，被初始化为0.0，保护类型的静态成员变量d不会被初始化，因为它是静态类型的。<br>Aggregate类型的unions有所不同，使用{ }你可能只能初始化它们的第一个成员，我想如果你使用C++高级到考虑使用unions（使用他们非常危险，必须小心谨慎），你一定可以自己在C++标准中找到unions的规则。<br>我们知道了Aggregates的特别之处，现在让我们来尝试理解一下它对类型的限制，也就是说为什么会有这些限制。我们应当理解使用{ }进行成员逐一初始化意味着这一类型只是成员的集合。如果有一个用户定义的构造函数，那意味着用户需要做一些额外的工作来初始化成员，因此使用{ }初始化是不正确的。如果出现了虚函数，那意味着这个类型（大多数实现）有一个指向vtable的指针，需要在构造函数内设置，所以使用{ }初始化是不够的。作为练习，你可以按照这种方式自己理解其他限制的含义。<br>关于Aggregates的就这么多，现在我们可以更严格定义一个子类型PODs   </p>
<h2 id="什么是PODs，为什么他们这么特别"><a href="#什么是PODs，为什么他们这么特别" class="headerlink" title="什么是PODs，为什么他们这么特别  "></a>什么是PODs，为什么他们这么特别  </h2><p>C++标准（C++ 03 9 §4）中正式的定义为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD-struct类型是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的类。类似地，POD-union是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的联合。POD类型就是POD-struct和 a POD-union中的一种。</span><br></pre></td></tr></table></figure>
<p>Wow，这个定义更难解读，不是吗？让我们吧unions剥离出去，更清晰的复述为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD类型就是没有非静态类型的non-POD类型 （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型。</span><br></pre></td></tr></table></figure>
<p>这个定义的有什么含义呢？（POD就是Plain Old Data）  </p>
<ol>
<li>所有的POD类型都是Aggregates类型，换句话说，如果不是aggregate类型，那么它一定不是POD类型。  </li>
<li>类，和结构体一样可以为POD类型，因为标准中POD-struct这个术语包含了这两种情形。  </li>
<li>和Aggregates类型一样，静态成员是什么类型则无关紧要  </li>
</ol>
<p>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//no harm if there's a function</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v; <span class="comment">//static members do not matter</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AggregateButNotPOD1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    ~AggregateButNotPOD1()&#123;&#125; <span class="comment">//user-defined destructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AggregateButNotPOD2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> 	AggregateButNotPOD1 arrOfNonPod[<span class="number">3</span>]; <span class="comment">//array of non-POD class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>POD-classes，POD-unions，标量类型和这些类型的数组合成为POD类型，POD类型在很多方面都很特别，我来举几个例子：  </li>
<li>POD类型是最接近于C语言中的结构体类型的。他们都没有改变对象的内存布局，但是，POD类型却可以有自己的成员函数和任意类型的静态成员。所以，如果你想写一个可在C甚至.net平台使用的可移植的动态库，你应该让暴露的所有的方法的返回值和参数都会POD类型。  </li>
<li>非POD类型的对象的生命周期起始于构造函数，结束于析构函数调用完成。而POD类型对象的生命周期却起始于存储对象的空间被占用，结束于空间被释放或被重复利用。  </li>
<li><p>对于POD类型的对象，C++标准保证当你使用memcpy将对象的内容拷贝到一个char类型或者unsigned char类型的数组中，在使用memcpy拷贝回来的时候，对象会保持不变。特别注意，非POD类型是无法保证这一点的。当然，你也可以安全的在对象之间拷贝POD类型。下面的这个例子假设T为POD类型  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="keyword">char</span> buf[N];</span><br><span class="line">T obj; <span class="comment">// obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N); <span class="comment">// between these two calls to memcpy,</span></span><br><span class="line"><span class="comment">// obj might be modified</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N); <span class="comment">// at this point, each subobject of obj of scalar type</span></span><br><span class="line"><span class="comment">// holds its original value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>goto 语句。你知道，使用goto从一个变量没有声明的点跳转到一个变量已经被声明的点是不合法的（编译器应该会有报错）。这个限制仅仅对非POD类型有效，下面这个例子f()是不合法的，而g()则是合法的。注意到微软的编译器对这条规则过于慷慨了，仅仅给出警告而已。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NonPOD</span> &#123;</span> NonPOD()&#123;&#125;&#125;;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    NonPOD x;</span><br><span class="line">label:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">POD</span> &#123;</span><span class="keyword">int</span> i;  <span class="keyword">char</span> c;&#125;;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    POD x;</span><br><span class="line">label:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++标准保证POD类型的对象在内存起始处没有便宜。也就是说如果一个POD类型A的第一个成员为T，你可以安全的调用reinterpret_cast  从A<em>转换为T</em>,得到第一个成员的指针，反过来也成立。  </p>
</li>
</ol>
<p>这个列表还很长很长…  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>理解POD类型非常重要，因为很多C++语言特性，就像你看到的，针对于他们都会有所不同。希望这篇文章对你有用。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Aggregate/">Aggregate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/POD/">POD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-22-理解move和forward"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/22/2017-06-22-理解move和forward/">理解std::move和std::forward</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/22/2017-06-22-理解move和forward/" class="article-date">
	  <time datetime="2017-06-21T16:00:00.000Z" itemprop="datePublished">六月 22, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52371164" target="_blank" rel="noopener">Effective Modern C++ 条款23 理解std::move和std::forward</a></p>
<p>首先我要提一下右值与左值，我觉得本书中的一句话说的非常好：</p>
<p>A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is. If you can’t, it’s usually an rvalue. A nice feature of this heuristic is that it helps you remember that the type of an expression is independent of whether the expression is an lvalue or an rvalue. That is, given a type T, you can have lvalues of type T as well as rvalues of type T. It’s especially important to remember this when dealing with a parameter of rvalue reference type, because the parameter itself is an lvalue:</p>
<p>有效了解std::move和std::forward的方法是，了解它们做不了的事情。std::move不会移动任何东西，std::forward不会转发任何东西，在运行期间，它们什么事情都不会做，不会生成一个字节的可执行代码。</p>
<p>std::move和std::forward仅仅是表现为转换类型的函数（实际上是模板函数），std::move无条件地把参数转换为右值，而std::forward在满足条件下才会执行std::move的转换。这个说明导致了一系列问题，但是从根本上，那是一个完整的故事。</p>
<p>为了让故事更具体，这里是C++11的std::move的简单实现，它没有完全覆盖标准库的细节，不过很接近了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;              <span class="comment">// 在std命名空间里`</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line">move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实函数的本质就是类型转换，就如你所见，std::move接收一个对象的引用（准确地说，是通用引用，具体看条款24），然后返回相同对象的引用。</p>
<p>返回类型中的“&amp;&amp;”暗示着std::move返回的是一个右值引用，不过，就像条款28讲述那样，如果T的类型是个左值引用，T&amp;&amp;将会变成左值引用。为了防止这种事发生，我们对T使用了remove_reference（去除引用语义），因此确保了使用“&amp;&amp;”的类型不是引用类型，那就保证了std::move返回的是右值引用，这是很重要的，因为函数返回的右值引用是右值。因此，std::move把参数转换为一个右值，那就是它做的全部事情。</p>
<p>说点题外话，std::move在c++14的实现就没那么夸张了，返回类型推断（看条款3）和标准库的别名模板std::remove_reference_t（看条款9），std::move可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;             <span class="comment">// C++14，依然在std命名空间</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是容易看多了？</p>
<p>因为std::move除了把参数转换为右值，没做其他事情，这表明类似rvalue_cast这样的名字或许更适合它。话虽如此，但我们用的名字是std::move，所以记住std::move做了什么和没做什么是重要的，它做的是转换，不是移动。</p>
<p>当然，右值会成为可移动的候选者，因此对一个对象使用std::move是告诉编译器，这个对象符合被移动的条件。那就是为什么std::move会有这个名字：很容易指出可能被移动的对象。</p>
<p>事实上，右值在通常情况下是唯一的可移动候选者。假如你要写一个代表注释的类，这个类的构造函数接受一个std::string参数（含有注释），然后把参数拷贝到成员变量，根据条款41，你声明的是值传递的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span>;        <span class="comment">// 参数会被拷贝，值传递</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过因为注释类只是需要读text的值，不需要修改它，根据尽可能使用const这个悠久的历史，你修改了声明，把text修改成const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免拷贝text到成员变量的开销，你根据条款41的建议，对text使用std::move，由此产生一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span></span><br><span class="line">    : value(std::move(text))  // 把text"移动"成右值</span><br><span class="line">    &#123; ... &#125;                   <span class="comment">// 但这代码的行为跟你看到的不一样</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码编译，链接，运行，把成员变量value设置为text的内容。唯一把这代码和你眼中的完美实现分离的事情是text不是被移动到value的，它只是被拷贝。当然，text被std::move转换为右值了，但是text是被声明为const std::string，所以在转换之前，text是一个const std::string左值，转换后，是一个const std::string右值，在整个过程中，const的性质是一支存在的。</p>
<p>当编译器选择std::string构造函数时，有两个可能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span>  <span class="comment">// std::string实际上是std::basic_string&lt;char&gt;的typedef</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);   <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);     <span class="comment">//移动构造</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Annotation构造函数的初始化列表中，std::move(text)的结果是一个类型为const std::string的右值，这个右值不能传递给std::string的移动构造函数，因为移动构造函数接受的是non-const std::string的右值引用。不过这右值，可以传递给拷贝构造函数，因为一个lvalue-reference-to-const（const的左值引用）可以绑定const右值。所以，成员初始化列表调用了std::string的拷贝构造函数，即使text被转换成右值！这种行为对于维护const的正确性是必不可少的。把一个值搬离对象通常都会改变这个对象，所以C++不允许把const对象传递给会改变它们（对象）的函数（例如移动构造）。</p>
<p>在这个例子中我们可以得到两个教训。第一，如果你想要有能力移动对象，不要把它们声明为const。向一个const对象请求移动操作会默默转换为拷贝操作。第二，std::move不仅不会移动东西，还不能保证转换出来的对象有被移动的资格。你唯一能确保的事情是：对一个对象使用std::move，那个对象就被转换为右值。</p>
<p>std::forward的故事就比std::move简单多了，不过std::move是无条件把参数转换为右值，而std::forward在特定情况下才会这样做。std::forward是个有条件的类型转换。为了理解它什么时候转换，回忆一下std::forward一般是怎样使用的。最常见用法是一个模板函数接受全局引用，然后用std::forward把参数传递给另一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> Widget&amp; lvalArg)</span></span>;    <span class="comment">// 处理左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;         <span class="comment">// 处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span>      <span class="comment">// 把参数传递给process的模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();   <span class="comment">// 获取当前时间           </span></span><br><span class="line"></span><br><span class="line">     makeLogEntry(<span class="string">"Calling 'process'"</span>, now);</span><br><span class="line">     process(<span class="built_in">std</span>::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑logAndProcess的两次调用，一次左值，一次右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">logAndProcess(w);             <span class="comment">// 左值参数调用</span></span><br><span class="line">logAndProcess(<span class="built_in">std</span>::move(w));  <span class="comment">// 右值参数调用</span></span><br></pre></td></tr></table></figure>
<p>在logAndProcess里面，参数param被传递给process函数，而process函数为了左值参数和右值参数进行重载。当我们用左值调用logAndProcess的时候，我们自然是希望把左值转发给process，而当我们用右值调用logAndProcess时，我们希望调用的是右值重载的process。</p>
<p>但是param，和所有的函数参数一样，是个左值。在logAndProcess里每次调用process都会使用左值重载的process。为了防止这样的事情，我们需要一项技术，当且仅当初始化param的参数——即传递给logAndProcess的参数——是右值时，在logAndProcess把param转换为右值。这就是std::forward干的事情了，这也是为什么说std::forward是个有条件的类型转换：仅当参数是用右值初始化时，才会把它转换为右值。</p>
<p>你可能想要知道std::forward是如何知道参数是否用右值初始化的。举个例子，上面的代码中，std::forward是怎样知道初始化param的，是左值还是右值呢？简短的答案是信息会被编码到logAndProces的模板参数T中。这个参数传递给std::forward模板，然后恢复编码的信息。具体细节看条款28。</p>
<p>倘若把std::move和std::forward把归结为类型转换，那么它们的差别是std::move总是会转换，std::forward只会在某些时刻转换，你可以会问我们是否可以摒弃std::move，只是用std::forward。从纯粹的技术角度看，答案是可以的：std::forward可以应付所有场景，std::move不是必须的。当然，没有一个函数是真的必须的，因为我们可以自己写转换，不过如果那样的话，是很恶心的。</p>
<p>std::move吸引人的地方在于它的方便，减少可能的错误，还有更简洁。试想在一个类中，我们要记录移动构造函数被调用了多少次。我们所需要的是个static计数器，它在移动构造中递增。假如类中的非static成员变量只有一个std::string，这里有个十分方便的方法（即使用std::move）实现我们的移动构造：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs)</span><br><span class="line">    : s(<span class="built_in">std</span>::move(rhs.s))</span><br><span class="line">    &#123; ++moveCtorCalls; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> moveCtorCalls;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用std::forward实现相同的效果，代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Widget(Widget&amp;&amp; rhs)</span><br><span class="line">     :s(<span class="built_in">std</span>::forward&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(rhs.s))</span><br><span class="line">    &#123; ++moveCtorCalls; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先要注意到的是std::move只需要一个函数参数（rhs.s），而std::forward既需要一个函数参数（rhs.s）又需要一个模板类型参数（std::string）。然后需要注意的是我们一般传递给std::forward的参数类型是不带引用的，那是因为这会很方便把参数编码成右值（看条款28）。结合起来，意味着std::move比起std::forward需要更少的类型，不用传递类型参数可以减少编码的麻烦。它还可以消除我们可能传递的类型错误（例如，std::string&amp;， 使用std::forward的话，会导致成员变量拷贝构造，而不是移动构造）。</p>
<p>最重要的是，std::move是无条件转换，而std::forward只会将绑在右值上的参数转换为右值。这两个操作不一样，第一个操作通常会造成移动，而第二个操作只是传递——转发——一个对象给另一个函数，而保持原来的左值性质或者右值性质。因为这两个行为是不一样的，所以用两个不同的函数（和函数名）区分它们是很好的设计。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要记住的3点：</p>
<ol>
<li>std::move表现为无条件的右值转换，就其本身而已，它不会移动任何东西。</li>
<li>std::forward仅当参数被右值绑定时，才会把参数转换为右值。</li>
<li>std::move和std::forward在运行时不做任何事情。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/forward/">forward</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/move/">move</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-21-尽可能使用constexpr"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/21/2017-06-21-尽可能使用constexpr/">尽可能使用constexpr</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/21/2017-06-21-尽可能使用constexpr/" class="article-date">
	  <time datetime="2017-06-20T16:00:00.000Z" itemprop="datePublished">六月 21, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下内容转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52280393" target="_blank" rel="noopener">尽可能使用constexpr</a></p>
<p>如果要选出C++11中最让人迷惑的新关键字，那么大概是constexpr。当constexpr用于对象时，它本质上就是加强版的const，但它用于函数时，它拥有不同的意思。constexpr再迷惑，也是值得的，因为当constexpr与你想要表达的一致时，你肯定会用它。<br>在概念上，constexpr表明一个值不仅是常量，还是在编译期间可知。这概念只是拼图的一部分，因为当constexpr用于函数时，有点微妙的区别。免得我破坏了最后的惊喜，我现在只可以说，你不能假定constexpr函数的返回结果是const的，也不能理所当然的人物它们的返回值在编译期间可知。可能会很有趣，这些特性。constexpr函数不需要返回const结果和编译器可知结果，这是有益的。  </p>
<p>不过我们还是先讲constexpr对象，这些对象呢，事实上和const一样，它们的值在编译期间就知道了。<br>那些在编译期间就可知的值是享有特权的。例如，它们可能存放在只读的内存区域中，特别是为那些内嵌系统的开发者，这是一个相当重要的特性。在C++的上下文中需要一个整型常量表达式(integral constant expression)时，一个常量的和编译期间可知的整型数具有广泛适应性。这种上下文包括数组大小的表示，整型模板参数（包括std::array对象的长度），枚举的值，对齐说明，等等。如果你想要一个变量，用于刚说的东西，那么你肯定想要把那个变量声明为constexpr，因为编译器会确保它在编译期间有值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;   <span class="comment">// non-constexpr variable</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;   <span class="comment">// 错误，编译期间不知道sz的值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1;   <span class="comment">// 错误，同样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 =  <span class="number">10</span>;  <span class="comment">// 正确，10在编译期间是常量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2;  <span class="comment">// 正确，arraySize2是constexpr的</span></span><br></pre></td></tr></table></figure>
<p>请注意const并不提供与constexpr相同的保证，因为const对象在编译时不需要用已知的值初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;  <span class="comment">// 如前</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz;  <span class="comment">// 正确，arraySize是sz的**const**拷贝</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data; <span class="comment">// 错误，arraySize的值在编译期间不可知</span></span><br></pre></td></tr></table></figure>
<p>我们可以简单地认为，所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。如果你想要编译器保证变量编译期有值，即上下文请求了一个编译期间的常量，那么能用的工具是constexpr，而不是const。<br>当涉及到constexpr函数的时候，constexpr对象的使用会变得更加有趣。当编译期间的常量作为参数传递给constexpr函数时，这种函数会返回编译期间常量。如果函数的参数在运行期间才能知道，函数返回的也是运行时的值。听起来有点乱，正确的规则：  </p>
<ol>
<li>constexpr函数可以用在需求编译期间常量的上下文。在这种上下文中，如果你传递参数的值在编译期间已知，那么函数的结果会在编译期间计算。如果任何一个参数的值在编译期间未知，代码将不能通过编译。</li>
<li>如果用一个或者多个在编译期间未知的值作为参数调用constexpr函数，函数的行为和普通的函数一样，在运行期间计算结果。这意味着你不需要用两个函数来表示这个操作——一个在编译期间和一个在运行期间。constexpr函数具有两个动作。  </li>
</ol>
<p>假设我们需要一个数据结构来保存某个实验的结果，这个实验可在不同的条件下进行。例如，在实验期间，光的强度可高可低，风速和温度也可变化。如果与实验有关的环境条件有n个，每个环境变量又有3种状态，那么就有$3^n$种情况。存储实验可能出现的所有结果，就要求数据结构有足够大的空间保存$3^n$个值。假设每个结果是int值，然后n在编译期间已知（或者可计算），那么选择std::array这数据结构将会合情合理。C++标准库提供std::pow，是我们需要的数学计算函数，但这里会有两个问题。第一，std::pow作用于两个浮点型指针，而我们需要的是一个整型结果。第二，std::pow不是constexpr的，所以我们不能用它的结果来指定std::array的值。  </p>
<p>幸运的是，我们可以自己写pow函数。等下我会展示它是怎么做的，但我们先看看它是怎样声明和使用的：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span>   <span class="comment">// pow是个constexpr函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span>   <span class="comment">// 函数不会抛出引出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...     <span class="comment">// 实现看下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numCouds = <span class="number">5</span>;   <span class="comment">// 条件个数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="built_in">pow</span>(3, numCouds)&gt; results;   <span class="comment">// results有3^n个元素</span></span><br></pre></td></tr></table></figure>
<p>constexpr在pow并不是说明pow返回const值，它指的是，如果base和exp是编译期间常量，pow的结果可以被用作编译期间常量。如果base和（或）exp不是编译期间常量，pow的结果将会在程序运行时计算，这意味pow不仅可以在编译期间计算std::array的大小，还可以在运行期间的上下文调用：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> base = readFromDB(<span class="string">"base"</span>);      <span class="comment">// 在运行期间</span></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">exp</span> = readFromDB(<span class="string">"exponent"</span>);  <span class="comment">// 获取值</span></span><br><span class="line"><span class="keyword">auto</span> baseToExp = <span class="built_in">pow</span>(base, <span class="built_in">exp</span>);   <span class="comment">// 在运行期间调用pow</span></span><br></pre></td></tr></table></figure>
<p>因为用编译期间的值作为参数调用constexpr函数一定要返回编译期间的结果，所以会有限制强加于它们的实现。c++11和C++14的限制不同。  </p>
<p>在C++11，constexpr只能有一个return语句。听起来不是什么限制，因为可以用两个技巧。第一个是“？：”运算符代替if-else语句，第二个是可以用递归。所以pow可以这样实现：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span> - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以运行，但是很难想象除了大神还有谁能把它写得这么好。在C++14中，constexpr函数的限制大幅宽松，所以这种函数实现成为可能：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">por</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">exp</span>; ++i) result *= base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>constexpr函数限制持有和返回的类型为字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。在C++中，除了void之外的内置类型都是字面值类型，不过用户定义的类型也有可能是字面值类型，因为构造函数和其他成员函数可能是constexpr的：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> xVal = <span class="number">0</span>, <span class="keyword">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">   : x(xVal), y(yVal)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> xVal; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> yVal; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，Point的构造函数可以被声明为constexpr，因为如果传进来的参数在编译时就可以知道，那么由P构造的成员变量的值在编译时也可以被知道。因此Point可以用constexpr初始化 ：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;  <span class="comment">// 正确，在编译时“运行”constexpr构造</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;  <span class="comment">// 也正确</span></span><br></pre></td></tr></table></figure>
<p>同样的，获取函数（getter）xValue和yValue也可以是constexpr，因为如果它们被一个编译期间已知的Point对象调用（例如，一个constexpr的Point对象），成员变量x和y的值在编译时是已知的，这使一个constexpr函数调用Point的获取函数并用其结果来初始化一个constexpr对象成为可能：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span></span><br><span class="line"><span class="function">Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.xValue + p2.xValue)) / <span class="number">2</span>,        <span class="comment">// 调用constexpr</span></span><br><span class="line">             (p1.yValue + p2.yValue)) / <span class="number">2</span> &#125;;    <span class="comment">// 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);  <span class="comment">// 用**constexpr**函数的结果  // 初始化constexpr对象。</span></span><br></pre></td></tr></table></figure>
<p>这很有趣，这意味着对象mid的初始化涉及到构造函数、获取函数、非成员函数的调用，然后创建在只读内存区域！这意味着你可以将一个类似mid.xValue() * 10的表达式用于模板参数或者一个指定枚举值的表达式！这意味着传统意义上，编译期需完成的工作与运行期间需完成的工作之间的严格清晰的线变模糊了，而一些传统意义上运行时的工作可以迁移到编译期。参与迁移的代码越多，软件运行得越快（但是，编译的时间可能变长）。  </p>
<p>在C++11，有两个限制因素妨碍把Point的成员变量setX和setY声明为constexpr。第一，它们改变了它们操作的值，然后在C++11，constexpr成员函数是隐式声明为const的。第二，它们的返回类型是void，然后在C++11，void不是字面值类型。都是这两个限制在C++14被解除了，所以在C++14，设置函数（setter）也可以constexpr：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span>   <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function">    </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span>   <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function">    </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这使得写这奇葩的函数成为可能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回p的映像（C++14）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result;     <span class="comment">// create non-const Point</span></span><br><span class="line"></span><br><span class="line">    result.setX(-p.xValue());</span><br><span class="line">    result.setY(-p.yValue());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户的代码可能是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =      <span class="comment">// reflectedMid的值是（-19.1, -16.5）</span></span><br><span class="line">    reflection(mid);                 <span class="comment">//  而且在编译期间就知道了</span></span><br></pre></td></tr></table></figure>
<p>本条款的建议是尽可能使用constexpr，然后现在我希望你能很清楚为什么：constexpr对象和constexpr函数比起non-constexpr对象和函数具有更广泛的语境。通过尽可能地使用constexpr，你最大化了对象和函数的可能使用的情况。  </p>
<p>注意到constexpr是一个对象或函数接口的一部分是很重要的。constexpr表明“我可以用于需求常量表达式的上下文”，如果你把对象或者函数声明为constexpr，用户就有可能把它用于这种上下文。后来，如果你觉得你使用constexpr是个错误，然后你删除了它，这样就可能造成用户大量代码无法编译（为了调试添加I/O函数会导致这种问题，因为I/O语句通常不允许出现在constexpr函数）。“尽可能使用constexpr”中的“尽可能”是你愿意作出长期的承诺，强行约束着constexpr的对象和函数（这句话太难了，我不知道我的理解有没问题：Part of “whenever possible”in “Use constexpr whenever possible” is your willingness to make a long-term commitment to the constraints it imposes on the objects and functions you apply it to.）。··  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要记住4点：</p>
<ol>
<li>constexpr对象是const的，它需用编译期间已知的值初始化。</li>
<li>constexpr函数在传入编译期已知值作为参数时，会在编译期间生成结果。</li>
<li>constexpr对象和函数比起non-constexpr对象和函数具有更广泛的语境。</li>
<li>constexpr是对象和函数接口的一部分。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/constexpr/">constexpr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-20-理解模板类型推断"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/20/2017-06-20-理解模板类型推断/">理解模板类型推断</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/20/2017-06-20-理解模板类型推断/" class="article-date">
	  <time datetime="2017-06-19T16:00:00.000Z" itemprop="datePublished">六月 20, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下内容转自<a href="http://blog.csdn.net/big_yellow_duck/article/details/52140262" target="_blank" rel="noopener">Effective Modern C++ 条款1 理解模板类型推断</a></p>
<p>C++11的auto自动推断变量的方式是以模板推断为基础的，模板推断的规则也应用在auto上，所以理解掌握模板推断的规则对于我们C++程序员来说很重要。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>考虑上面的代码，当我们调用上面函数并传入参数expr时   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr);</span><br></pre></td></tr></table></figure>
<p>编译器需要根据expr的来推断两个类型，一个是T， 一个是ParamType，这两个类型通常是不一样的，因为ParamType通常会含有修饰符，例如const，例如以下代码  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">f(x);</span><br></pre></td></tr></table></figure>
<p>此时T会被推断为int，而ParamType会被推断为const int &amp; 。  </p>
<p>人们会很自然的认为编译器为T推断的类型就是我们传进的参数的类型，用上面的代码表示就是T的类型就是expr的类型，也就是说传进来的x是int的类型，然后T就是int的类型。但这有时候是不对的，类型T的推导不仅仅依赖于expr，也依赖于ParamType。  </p>
<p>具体有以下3中情况  </p>
<ol>
<li>ParamType是指针类型或者引用类型，但不是通用引用(universal references)类型</li>
<li>ParamType是通用引用(universal references)类型</li>
<li>ParamType既不是指针类型也不是引用类型</li>
</ol>
<h2 id="情况1-ParamType-是指针类型或者引用类型，但不是通用引用-universal-references-类型"><a href="#情况1-ParamType-是指针类型或者引用类型，但不是通用引用-universal-references-类型" class="headerlink" title="情况1 ParamType 是指针类型或者引用类型，但不是通用引用(universal references)类型"></a>情况1 ParamType 是指针类型或者引用类型，但不是通用引用(universal references)类型</h2><p>这是最简单的一种情况。只需记住以下两点  </p>
<ol>
<li>如果传进来的参数expr 是一个引用类型，忽视引用的部分</li>
<li>通过模式匹配expr 的类型来决定ParamType 的类型从而决定T 的类型（Then pattern-match expr’s type against ParamType to determine T. ）</li>
</ol>
<p>例子如下   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后我们定义一下变量  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用模板函数</span></span><br><span class="line">f(x);   <span class="comment">// T 的类型为int, ParamType的类型为int&amp;</span></span><br><span class="line">f(cx);   <span class="comment">// T 的类型为const int, ParamType的类型为const int&amp;</span></span><br><span class="line">f(rx);   <span class="comment">// T 的类型为const int, ParamType的类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是f(rx)，rx是引用类型，但是编译器会把引用忽略，然后用去掉引用后的参数类型来匹配T 。如果ParamType为右值引用，推断的原则也是相同。但是如果为const引用，就会与上面的结果有点不一样，参考下面的例子。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义的变量和上面的一致  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"> <span class="comment">// 一样调用模板函数</span></span><br><span class="line">f(x);   <span class="comment">// T 的类型为int, ParamType的类型为const int&amp;</span></span><br><span class="line">f(cx);   <span class="comment">// T 的类型为int, ParamTyp的类型为const int&amp;</span></span><br><span class="line">f(rx);   <span class="comment">// T 的类型为int, ParamType的类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>因为我们在定义声明模板的时候参数类型已经认定了是const引用，所以T 的类型不再需要推断出const。而rx的引用依旧被忽略。  </p>
<p>如果把引用换成指针，原则基本一致，把expr的指针类型忽略，例子如下  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;</span><br><span class="line">f(&amp;x);  <span class="comment">// T的类型为int，ParamType 的类型为int*</span></span><br><span class="line">f(px);   <span class="comment">// T的类型为const int，ParamType的类型为const int*</span></span><br></pre></td></tr></table></figure>
<h2 id="情况2-ParamType-是通用引用-universal-references-类型"><a href="#情况2-ParamType-是通用引用-universal-references-类型" class="headerlink" title="情况2 ParamType 是通用引用(universal references)类型"></a>情况2 ParamType 是通用引用(universal references)类型</h2><p>首先要知道什么是universal references，可以google或者baidu，懒得搜索的可以直接看这里。简单来说就是type&amp;&amp; + syntax + type deduction，即可以引用左值，也可以引用右值。<br>这种情况也有两个原则  </p>
<ol>
<li>如果expr是一个左值，那么T和ParamType会被推断为左值引用</li>
<li>如果expr是一个右值，那么会用正常的推断方式(情况1)</li>
</ol>
<p>可以看以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"></span><br><span class="line">f(x);  <span class="comment">// x是左值，所以T 和ParamType会被推断为int &amp;类型</span></span><br><span class="line">f(cx); <span class="comment">// cx是左值，所以T和ParamType会被推断为const int &amp;类型</span></span><br><span class="line">f(rx);  <span class="comment">// rx是左值，所以T和 ParamType会被推断为const int &amp;类型</span></span><br><span class="line">f(<span class="number">27</span>);`  <span class="comment">// 27是右值，根据情况1，T的类型会被推断为int、ParamType会被推断为int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h2 id="情况3-ParamType-既不是指针类型也不是引用类型"><a href="#情况3-ParamType-既不是指针类型也不是引用类型" class="headerlink" title="情况3 ParamType 既不是指针类型也不是引用类型"></a>情况3 ParamType 既不是指针类型也不是引用类型</h2><p>如果ParamType 既不是指针也不是引用，那么参数是通过值传递(pass-by-value)的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;    <span class="comment">// 此处会有拷贝(构造)</span></span><br></pre></td></tr></table></figure>
<p>T 的类型推断主要依赖于传进来的参数expr  </p>
<ol>
<li>如果expr的类型是引用类型，那么忽略引用</li>
<li>通过了上面的检测(无论是不是引用类型)后，如果expr 的类型是const的，把const也忽略了，还会忽略volatile。</li>
</ol>
<p>给出下面的例子  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br></pre></td></tr></table></figure>
<p>和之前的例子一样  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x);  <span class="comment">// 易知T和ParamType的类型都是int</span></span><br><span class="line">f(cx);  <span class="comment">// 忽略const，T和ParamType的类型都是int</span></span><br><span class="line">f(rx);`  <span class="comment">// 忽略了引用后再忽略const,T和ParamType的类型都是int</span></span><br></pre></td></tr></table></figure>
<p>虽说cx和rx都是const修饰的，但是param是值语义，所以param只是拷贝了cx和rx的值，并可以改变值。这就是为什么会忽略const，因为传进的参数expr 尽管不可以改变值，但并不意味着他们的拷贝不可以。  </p>
<p>如果我们定义一个指向常量的常量指针   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr = <span class="string">"Fun with pointers"</span>;</span><br></pre></td></tr></table></figure>
<p>然后调用函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(ptr);</span><br></pre></td></tr></table></figure>
<p>这个时候T 和 ParamType的类型会被推断为const char *，这是因为这种情况下传入的参数都会被函数拷贝并可以改变的，所以指针是可以指向不同的地址，个人理解在情况3是只会忽略 顶层const，然后保留 底层const。  </p>
<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><p>在情况3下，如果传入的参数是数组，会转化为指针类型，例如 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J. R. Briggs"</span>; <span class="comment">// name的类型是const char[13] </span></span><br><span class="line">f(name); <span class="comment">// T会被推断为 const char *</span></span><br></pre></td></tr></table></figure>
<p>但在情况1下 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们把数组作为参数传入函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(name); <span class="comment">// T 的类型会被推断为const char [13]</span></span><br></pre></td></tr></table></figure>
<p>这个时候T 的类型会被推断为有长度的数组，在这个例子中T 的类型会被推断为const char [13]，ParamType的类型会是 const char (&amp;) [13]<br>在这里引用一段书中的原话，这规则有毒….  </p>
<p>Yes, the syntax looks toxic, but knowing it will score you mondo points with those few souls who care.<br>是的，语法看起来很有毒，但是知道它会让你与那些关心的少数灵魂分享你的意见。  </p>
<p>利用这个特性可以写一个模板，用来返回数组的长度  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> arraySize(T (&amp;)[N]) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个模板函数是constexpr修饰的，所以他的结果可以在编译时期得到，所以可以用来初始化变量。  另外关于constexpr可以看这篇<a href="">《尽可能使用constexpr》</a></p>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>因为函数像数组一样可以转化为指针，所以函数作为参数与数组类似，例子如下  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line">f1(someFunc); <span class="comment">// 传值，ParamType 类型为void (*)(int, double)，情况3</span></span><br><span class="line"></span><br><span class="line">f2(someFunc); <span class="comment">// 引用语义，ParamType类型为void (&amp;)(int, double)，情况1</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>auto的规则与模板类型推断有很大关联，这在一开始已经说了，是理解auto的前提。  </p>
<p>要记住的4点  </p>
<ol>
<li>在模板类型推断过程中，参数的引用语义会被忽略</li>
<li>在通用引用(universal reference)类型推断时，左值引用会被特别对待</li>
<li>在传值类型的模板推断过程中，const 和 volatile的参数会以non-const 和 non-volatile 对待。</li>
<li>在模板类型推断过程中，如果参数是数组或者函数，他们被转化为对应的指针，除非模板参数类型一开始就是引用。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/auto/">auto</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-19-为什么size_t重要？（Why-size_t-matters）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/19/2017-06-19-为什么size_t重要？（Why-size_t-matters）/">为什么size_t重要？（Why size_t matters）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/19/2017-06-19-为什么size_t重要？（Why-size_t-matters）/" class="article-date">
	  <time datetime="2017-06-18T16:00:00.000Z" itemprop="datePublished">六月 19, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/c/">c</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://jeremybai.github.io/blog/2014/09/10/size-t" target="_blank" rel="noopener">Jeremy’s Blog</a><br>之前在《内存拷贝的注意事项》一文中提到过size_t，可能许多人对这个类型不太熟悉没有用过或者根本不敢去用，最近看到一篇文章对这个类型讲的比较详细，便翻译过来让不熟悉的同学可以知道它产生的原因以及如何使用。<br>　　原文地址： <a href="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?" target="_blank" rel="noopener">Why size_t matters</a><br>　　前言：使用size_t可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。<br>　　在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说malloc(n) 函数的参数n指明了需要申请的空间大小，还有memcpy(s1, s2, n)的最后一个参数，表明需要复制的内存大小，strlen(s)函数的返回值表明了以’\0’结尾的字符串的长度（不包括’\0’），其返回值并不是该字符串的实际长度，因为要去掉’\0’。<br>　　或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为size_t。标准中记载malloc的申明应该出现在，定义为：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>memcpy和strlen的申明应该出现在中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">char</span> <span class="keyword">const</span> *s);</span><br></pre></td></tr></table></figure></p>
<p>　　size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。<br>　　据我所知，大部分的C和C++程序员害怕这些库使用size_t，因为他们不知道size_t代表什么或者为什么这些库需要使用它，归根结底，原因在于他们什么时候什么地方需要用到它。  </p>
<h2 id="可移植性问题"><a href="#可移植性问题" class="headerlink" title="可移植性问题"></a>可移植性问题</h2><p>　　早期的C语言（由Brian Kernighan 和 Dennis Ritchie 在The C Programming Language书中所写，Prentice-Hall, 1978）并没有提供size_t类型，C标准委员会为了解决移植性问题将size_t引入，举例如下：<br>　　让我们来写一个可移植的标准memcpy函数，我们将会看到一些不同的申明和它们在不同平台不同大小的地址空间上编译下的情况。<br>　　回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void*，同时，源地址不应该被改变，所以第二个参数s2类型应该为const void*，这些都不是问题。<br>　　真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *s1, void const *s2, int n);</span><br></pre></td></tr></table></figure></p>
<p>　　使用int类型在大部分情况下都是可以的，但是并不是所有情况下都可以。int是有符号的，它可以表示负数，但是，大小不可能是复数。所以我们可以使用unsigned int代替它让第三个参数表示的范围更大。<br>　　在大部分机器上，unsigned int的最大值要比int的最大值大两倍，比如说再也给16位的机器上，unsigned int的最大值为65535，int的最大值为32767。<br>　　尽管int类型的大小依赖于C编译器的实现，但是在给定的平台上int对象的大小和unsigned int对象的大小是一样的。因此，使用unsigned int修饰第三个参数的代价与int是相同的：  　　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>　　这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。（参见下面C数据模型表示法）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C数据模型表示法</span><br><span class="line">　　最近，我偶然发现几篇文章，他们使用简明的标记来表述不同目标平台下c语言数据的实现。我还没有找到这个标记的来源，正式的语法，甚至连名字都没有，但他似乎很简单，即使没有正规的定义也可以很容易使用起来。这些标记的一边形式形如：</span><br><span class="line">　　I nI L nL LL nLL P nP。   </span><br><span class="line">　　其中每个大写字母（或成对出现）代表一个C的数据类型，每一个对应的n是这个类型包含的位数。I代表int，L代表long，LL代表long long，以及P代表指针（指向数据，而不是函数）。每个字母和数字都是可选的。   </span><br><span class="line">　　例如，I16P32架构支持16位int和32位指针类型，没有指明是否支持long或者long long。如果两个连续的类型具有相同的大小，通常省略第一个数字。例如，你可以将I16L32P32写为I16LP32，这是一个支持16位int，32位long，和32位指针的架构。  </span><br><span class="line">　　标记通常把字母分类在一起，所以可以按照其对应的数字升序排列。例如，IL32LL64P32表示支持32位int，32位long，64位long long和32位指针的架构；然而，通常写作ILP32LL64。</span><br></pre></td></tr></table></figure>
<p>　　不幸的是，这种memcpy的申明在I16LP32架构上（整形是16-bit 长整形和指针类型时32-bits）显得不够用了，比如说摩托罗拉第一代处理器68000，在这种情况下，处理器可能拷贝的数据大于65535个字节，但是这个函数第三个参数n不能处理这么大的数据。<br>　　什么？你说很容易就可以改正？只需要把memcpy的第三个参数的类型修改一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">unsigned</span> <span class="keyword">long</span>  n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>　　你可以在I16LP32目标架构上使用这个函数了，它可以处理更大的数据。而且在IP16和IP32平台上效果也还行，说明它确实给出了memcpy的一种移植性较好的申明。但是，在IP16平台上相比于使用unsigned int，你使用unsigned long可能会使你的代码运行效率大打折扣（代码量变大而且运行变慢）。<br>　　在标准C中规定，长整形（无论无符号或者有符号）至少占用32位，因此在IP16平台上支持标准C的话，那么它一定是IP16L32 平台。这些平台通常使用一对16位的字来实现32位的长整形。在这种情况下，移动一个长整形需要两条机器指令，每条移动一个16位的块。事实上，这个平台上的大部分的32位操作都需要至上两条指令。<br>　　因此，以可移植性为名将memcpy的第三个参数申明为unsigned long而降低某些平台的性能是我们所不希望看到的。使用size_t可以有效避免这种情况。<br>　　size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。  </p>
<h2 id="使用size-t"><a href="#使用size-t" class="headerlink" title="使用size_t"></a>使用size_t</h2><p>　　size_t的定义在\&lt;stddef.h>, \&lt;stdio.h>, \&lt;stdlib.h>, \&lt;string.h>, \&lt;time.h>和\&lt;wchar.h>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用size_t之前。<br>　　包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。包含以上任何C++头文件（当你只能在C++中做某种操作时）表明将size_t作为std命名空间的成员。根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="keyword">sizeof</span>(thing);</span><br></pre></td></tr></table></figure>
<p>　　考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="keyword">sizeof</span>(thing));</span><br></pre></td></tr></table></figure>
<p>　　参数中带有size_t的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，size_t是个不错的选择。<br>　　适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/c/">c</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-18-使用lambda实现Fibonacci"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/18/2017-06-18-使用lambda实现Fibonacci/">使用lambda实现Fibonacci</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/18/2017-06-18-使用lambda实现Fibonacci/" class="article-date">
	  <time datetime="2017-06-17T16:00:00.000Z" itemprop="datePublished">六月 18, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Fibonacci数列是一个整数序列0、1、1、2、3、5、8、13、21……，头两个数后面的每个整数都是它前面两个整数的和。写一个程序，用lambda表达式生成50个Fibonacci数来初始化array\&lt;T,N>容器。在程序中用全局函数将容器元素每8个一行输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                              // For standard streams</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;                                 // For array&lt;T,N&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">size_t</span>, 50&gt; data;</span><br><span class="line">	<span class="keyword">size_t</span> x1&#123;&#125;;</span><br><span class="line">	<span class="keyword">size_t</span> x2&#123; <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">size_t</span> i&#123;&#125;;</span><br><span class="line">	<span class="keyword">size_t</span> fib&#123;&#125;;</span><br><span class="line">	<span class="comment">//不错的解法，但是与题意有一些不符，数列不是从0开始的</span></span><br><span class="line">	<span class="comment">//generate(begin(data), end(data),</span></span><br><span class="line">	<span class="comment">//	[a = 0, b = 1]() mutable &#123;</span></span><br><span class="line">	<span class="comment">//	a = exchange(b, a + b);</span></span><br><span class="line">	<span class="comment">//	return a;</span></span><br><span class="line">	<span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line">	generate(begin(data), end(data),</span><br><span class="line">		[i, x1, x2, fib]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == i)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">size_t</span>)<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == i)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">size_t</span>)<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			fib = x1 + x2;</span><br><span class="line">			x1 = x2;</span><br><span class="line">			x2 = fib;</span><br><span class="line">			<span class="keyword">return</span> fib;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; data.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fibonacci/">Fibonacci</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/array/">array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lambda/">lambda</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-07-基于Kinect的手势识别"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/07/2017-06-07-基于Kinect的手势识别/">基于Kinect的手势识别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/07/2017-06-07-基于Kinect的手势识别/" class="article-date">
	  <time datetime="2017-06-06T16:00:00.000Z" itemprop="datePublished">六月 7, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/toy/">toy</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/toy/">toy</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/人工智能/">人工智能</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模式识别/">模式识别</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-03-迭代器适配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/03/2017-06-03-迭代器适配器/">迭代器适配器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/03/2017-06-03-迭代器适配器/" class="article-date">
	  <time datetime="2017-06-02T16:00:00.000Z" itemprop="datePublished">六月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Reverse（反向）迭代器"><a href="#Reverse（反向）迭代器" class="headerlink" title="Reverse（反向）迭代器"></a>Reverse（反向）迭代器</h2><p>你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create list with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find position of element with value 5</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator pos;</span><br><span class="line">    pos = find (coll.cbegin(), coll.cend(),</span><br><span class="line">                <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which iterator pos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pos:  "</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert iterator to reverse iterator rpos</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">const_reverse_iterator <span class="title">rpos</span><span class="params">(pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which reverse iterator rpos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rpos: "</span> &lt;&lt; *rpos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos:  <span class="number">5</span></span><br><span class="line">rpos: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这是由于reverse迭代器在设计是做了一个小技巧，他实际倒置“半开原则”。reverse迭代器所定义的区间并不包括起点，反而包括了终点。  </p>
<h2 id="Insert（安插型）迭代器"><a href="#Insert（安插型）迭代器" class="headerlink" title="Insert（安插型）迭代器"></a>Insert（安插型）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::insert_iterator是一个输出迭代器，它被构造，在该位置到一个容器中插入元素指出，由所提供的迭代器，使用容器的insert()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::insert_iterator是一个no-op。general inserter对所有标准容器均使用（只有array和forward list除外），因为那些容器都提供insert成员函数。然而对于associative和unordered容器而言，安插位置只是个提示，因为在这两个容器转给你元素的真正位置视为value而定。<br>安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于使用下面的语句：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = container.insert(pos, value);</span><br><span class="line">++pos;</span><br></pre></td></tr></table></figure>
<p>为什么要将insert的返回值赋给pos？原因在于为了确保迭代器的位置始终有效。如果没有这个复制动作，在deque、vector和string中，该general inserter本身可能会失效。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">back_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::back_insert_iterator是OutputIterator追加到一个容器，它被构造，使用容器的push_back()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::back_insert_iterator是一个no-op。由于push_back只存在于vector、deque、list和string，所以c++标准库中只有这些容器支持back insert。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">front_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::front_insert_iterator是输出预先考虑元素的迭代器，它被修建的容器，使用时容器的push_front()成员函数的迭代器（是否解除引用或不）被分配给的。递增std::front_insert_iterator是一个no-op。由于push_front只在deque、list和forward list有实现，所以只有这些容器可以使用。  </p>
<h2 id="Stream（串流）迭代器"><a href="#Stream（串流）迭代器" class="headerlink" title="Stream（串流）迭代器"></a>Stream（串流）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::ostream_iterator is a single-pass OutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator&lt;&lt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.<br>In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.<br>When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create ostream iterator for stream cout</span></span><br><span class="line">    <span class="comment">// - values are separated by a newline character</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; intWriter(<span class="built_in">cout</span>,<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">// write elements with the usual iterator interface</span></span><br><span class="line">    *intWriter = <span class="number">42</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">77</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">-5</span>;</span><br><span class="line">    <span class="comment">// create collection with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">// write all elements without any delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// write all elements with " &lt; " as delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" &lt; "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>&lt;<span class="number">4</span>&lt;<span class="number">5</span>&lt;<span class="number">6</span>&lt;<span class="number">7</span>&lt;<span class="number">8</span>&lt;<span class="number">9</span>&lt;</span><br></pre></td></tr></table></figure>
<p>注意分隔符类型为const char*。如果你传入string对象的话，就要调用c_str函数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::input_iterator_tag,</span><br><span class="line">                                             T, Distance, <span class="keyword">const</span> T*, <span class="keyword">const</span> T&amp;&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator&gt;&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently read object.<br>The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.<br>A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.<br>T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create istream iterator that reads integers from cin</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReader(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="comment">// create end-of-stream iterator</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReaderEOF;</span><br><span class="line">    <span class="comment">// while able to read tokens with istream iterator</span></span><br><span class="line">    <span class="comment">// - write them twice</span></span><br><span class="line">    <span class="keyword">while</span> (intReader != intReaderEOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once:       "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once again: "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++intReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> f <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">once:       <span class="number">1</span></span><br><span class="line">once again: <span class="number">1</span></span><br><span class="line">once:       <span class="number">2</span></span><br><span class="line">once again: <span class="number">2</span></span><br><span class="line">once:       <span class="number">3</span></span><br><span class="line">once again: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>结果出现的问题在于，格式错误。  </p>
<h2 id="Move（搬移）迭代器"><a href="#Move（搬移）迭代器" class="headerlink" title="Move（搬移）迭代器"></a>Move（搬移）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( <span class="keyword">const</span> Iterator&amp; i );</span><br></pre></td></tr></table></figure>
<p>(since C++11)<br>(until C++14)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++14)<br>(until C++17)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument.  </p>
<h2 id="Iterator-Trait（迭代器特性）"><a href="#Iterator-Trait（迭代器特性）" class="headerlink" title="Iterator Trait（迭代器特性）"></a>Iterator Trait（迭代器特性）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five iterator categories:  </p>
<ol>
<li>input_iterator_tag corresponds to InputIterator.</li>
<li>output_iterator_tag corresponds to OutputIterator.</li>
<li>forward_iterator_tag corresponds to ForwardIterator.</li>
<li>bidirectional_iterator_tag corresponds to BidirectionalIterator.</li>
<li>random_access_iterator_tag corresponds to RandomAccessIterator.</li>
</ol>
<p>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.<br>For every iterator type, a typedef std::iterator_traits\&lt;Iterator>::iterator_category is available, which is an alias to one of these five tag types.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;;</span></span><br></pre></td></tr></table></figure>
<p>std::iterator_traits is the type trait class that provides uniform interface to the properties of Iterator types. This makes it possible to implement algorithms only in terms of iterators.<br>The class defines the following types:  </p>
<ol>
<li>difference_type - a type that can be used to identify distance between iterators</li>
<li>value_type - the type of the values that can be obtained by dereferencing the iterator. This type is void for output iterators.</li>
<li>pointer - defines a pointer to the type iterated over (value_type)</li>
<li>reference - defines a reference to the type iterated over (value_type)</li>
<li>iterator_category - the category of the iterator. Must be one of iterator category tags.</li>
</ol>
<p>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span>,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp; </span></span><br><span class="line"><span class="class">&gt; <span class="title">struct</span> <span class="title">iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(deprecated in C++17)<br>std::iterator is the base class provided to simplify definitions of the required types for iterators.<br>其中第一个template参数定义迭代器种类，第二个参数用来定义元素类型，第三个参数用来定义difference类型，第四个参数用来定义point而类型，第五个参数用来定义reference类型。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-02-Upcasting and Downcasting"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/02/2017-06-02-Upcasting and Downcasting/">Upcasting and Downcasting</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/02/2017-06-02-Upcasting and Downcasting/" class="article-date">
	  <time datetime="2017-06-01T16:00:00.000Z" itemprop="datePublished">六月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://www.bogotobogo.com/cplusplus/upcasting_downcasting.php" target="_blank" rel="noopener">bogotobogo</a></p>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a>Upcasting</h2><p>Upcasting is converting a derived-class reference or pointer to a base-class. In other words, upcasting allows us to treat a derived type as though it were its base type. It is always allowed for public inheritance, without an explicit type cast. This is a result of the is-a relationship between the base and derived classes.<br>Here is the code dealing with shapes. We created Shape class, and derived Circle, Square, and Triangle classes from the Shape class. Then, we made a member function that talks to the base class:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Shape&amp; s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   s.draw();</span><br><span class="line">   s.move();</span><br><span class="line">   s.shrink();</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function speaks to any Shape, so it is independent of the specific type of object that it’s drawing, moving, and shrinking. If in some other part of the program we use the play( ) function like below:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c;</span><br><span class="line">Triangle t;</span><br><span class="line">Square sq;</span><br><span class="line">play(c);</span><br><span class="line">play(t);</span><br><span class="line">play(sq);</span><br></pre></td></tr></table></figure>
<p>Let’s check what’s happening here. A Triangle is being passed into a function that is expecting a Shape. Since a Triangle is a Shape, it can be treated as one by play(). That is, any message that play() can send to a Shape a Triangle can accept.<br>Upcasting allows us to treat a derived type as though it were its base type. That’s how we decouple ourselves from knowing about the exact type we are dealing with.<br>Note that it doesn’t say “If you’re a Triangle, do this, if you’re a Circle, do that, and so on.” If we write that kind of code, which checks for all the possible types of a Shape, it will soon become a messy code, and we need to change it every time we add a new kind of Shape. Here, however, we just say “You’re a Shape, I know you can move(), draw(), and shrink( ) yourself, do it, and take care of the details correctly.”<br>The compiler and runtime linker handle the details. If a member function is virtual, then when we send a message to an object, the object will do the right thing, even when upcasting is involved.<br>Note that the most important aspect of inheritance is not that it provides member functions for the new class, however. It’s the relationship expressed between the new class and the base class. This relationship can be summarized by saying, “The new class is a type of the existing class.”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">gotoSchool</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  Parent parent;</span><br><span class="line">  Child child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// upcast - implicit type cast allowed</span></span><br><span class="line">  Parent *pParent = &amp;child; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// downcast - explicit type case required </span></span><br><span class="line">  Child *pChild =  (Child *) &amp;parent;</span><br><span class="line"></span><br><span class="line">  pParent -&gt; sleep();</span><br><span class="line">  pChild -&gt; gotoSchool();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A Child object is a Parent object in that it inherits all the data members and member functions of a Parent object. So, anything that we can do to a Parent object, we can do to a Child object. Therefore, a function designed to handle a Parent pointer (reference) can perform the same acts on a Child object without any problems. The same idea applies if we pass a pointer to an object as a function argument. Upcasting is transitive: if we derive a Child class from Parent, then Parent pointer (reference) can refer to a Parent or a Child object.<br>Upcasting can cause object slicing when a derived class object is passed by value as a base class object, as in foo(Base derived_obj).</p>
<h2 id="Downcasting"><a href="#Downcasting" class="headerlink" title="Downcasting"></a>Downcasting</h2><p>The opposite process, converting a base-class pointer (reference) to a derived-class pointer (reference) is called downcasting. Downcasting is not allowed without an explicit type cast. The reason for this restriction is that the is-a relationship is not, in most of the cases, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn’t apply to the base class.<br>As in the example, we derived Child class from a Parent class, adding a member function, gotoSchool(). It wouldn’t make sense to apply the gotoSchool() method to a Parent object. However, if implicit downcasting were allowed, we could accidentally assign the address of a Parent object to a pointer-to-Child</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child *pChild =  &amp;parent; <span class="comment">// actually this won't compile</span></span><br><span class="line">        <span class="comment">// error: cannot convert from 'Parent *' to 'Child *'</span></span><br></pre></td></tr></table></figure>
<p>and use the pointer to invoke the gotoSchool() method as in the following line.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pChild -&gt; gotoSchool();</span><br></pre></td></tr></table></figure>
<p>Because a Parent isn’t a Child (a Parent need not have a gotoSchool() method), the downcasting in the above line can lead to an unsafe operation.<br>C++ provides a special explicit cast called dynamic_cast that performs this conversion. Downcasting is the opposite of the basic object-oriented rule, which states objects of a derived class, can always be assigned to variables of a base class.<br>One more thing about the upcasting:<br>Because implicit upcasting makes it possible for a base-class pointer (reference) to refer to a base-class object or a derived-class object, there is the need for dynamic binding. That’s why we have virtual member functions.<br>Pointer (Reference) type: known at compile time.<br>Object type: not known until run time.  </p>
<h2 id="Dynamic-Casting"><a href="#Dynamic-Casting" class="headerlink" title="Dynamic Casting"></a>Dynamic Casting</h2><p>The dynamic_cast operator answers the question of whether we can safely assign the address of an object to a pointer of a particular type.<br>Here is a similar example to the previous one.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> classes[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">gotoSchool</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  Parent *pParent = <span class="keyword">new</span> Parent;</span><br><span class="line">  Parent *pChild = <span class="keyword">new</span> Child;</span><br><span class="line">    </span><br><span class="line">  Child *p1 = (Child *) pParent;  <span class="comment">// #1</span></span><br><span class="line">  Parent *p2 = (Child *) pChild;  <span class="comment">// #2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let look at the lines where we do type cast.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child *p1 = (Child *) pParent;  <span class="comment">// #1</span></span><br><span class="line">Parent *p2 = (Child *) pChild;  <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>
<p>Which of the type cast is safe?<br>The only one guaranteed to be safe is the ones in which the pointer is the same type as the object or else a base type for the object.<br>Type cast #1 is not safe because it assigns the address of a base-class object (Parent) to a derived class (Child) pointer. So, the code would expect the base-class object to have derived class properties such as gotoSchool() method, and that is false. Also, Child object, for example, has a member classes that a Parent object is lacking.<br>Type case #2, however, is safe because it assigns the address of a derived-class object to a base-class pointer. In other words, public derivation promises that a Child object is also a Parent object.<br>The question of whether a type conversion is safe is more useful than the question of what kind of object is pointed to. The usual reason for wanting to know the type is so that we can know if it’s safe to invoke a particular method.<br>Here is the syntax of dynamic_cast.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child *p = <span class="keyword">dynamic_cast</span>&lt;Child *&gt;(pParent);</span><br></pre></td></tr></table></figure>
<p>This code is asking whether the pointer pParent can be type cast safely to the type Child *.</p>
<p>It returns the address of the object, if it can.<br>It returns 0, otherwise.<br>How do we use the dynamic_cast?  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Parent* p)</span> </span>&#123;</span><br><span class="line">  Child *ptr = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(p);</span><br><span class="line">   <span class="keyword">if</span>(ptr) &#123; </span><br><span class="line">    <span class="comment">// we can safely use ptr</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the code, if (ptr) is of the type Child or else derived directly or indirectly from the type Child, the dynamic_cast converts the pointer p to a pointer of type Child. Otherwise, the expression evaluates to 0, the null pointer.<br>In other words, we want to check if we can use the passed in pointer p before we do some operation on a child class object even though it’s a pointer to base class.<br>“The need for dynamic_cast generally arises because we want perform derived class operation on a derived class object, but we have only a pointer-or reference-to-base.” -Scott Meyers</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/downcasting/">downcasting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/upcasting/">upcasting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/12/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/10/2018-02-10-python实现2048/">Python实现2048</a></h6>
              <span>二月 10, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/09/2018-02-09-图片转字符画/">图片转化为字符画</a></h6>
              <span>二月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/">c++中空字符串解释为True的困惑</a></h6>
              <span>二月 5, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/26/2018-01-26-python字符串令牌解析/">python字符串令牌解析</a></h6>
              <span>一月 26, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/15/2018-01-15-RefineDet论文笔记/">RefineDet论文笔记</a></h6>
              <span>一月 15, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/09/2018-01-09-has-no-attribute-items问题/">AttributeError &#39;dict&#39; object has no attribute &#39;items&#39; 问题</a></h6>
              <span>一月 9, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.71px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.57px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://www.wangningcheng.com'>梦影无痕</a></li>
        
      </ul>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
