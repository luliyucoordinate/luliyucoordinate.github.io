<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 25 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/25/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/pose.jpg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-06-07-基于Kinect的手势识别"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/07/2017-06-07-基于Kinect的手势识别/">基于Kinect的手势识别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/07/2017-06-07-基于Kinect的手势识别/" class="article-date">
	  <time datetime="2017-06-06T16:00:00.000Z" itemprop="datePublished">六月 7, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/toy/">toy</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/toy/">toy</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/人工智能/">人工智能</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模式识别/">模式识别</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-03-迭代器适配器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/03/2017-06-03-迭代器适配器/">迭代器适配器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/03/2017-06-03-迭代器适配器/" class="article-date">
	  <time datetime="2017-06-02T16:00:00.000Z" itemprop="datePublished">六月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Reverse（反向）迭代器"><a href="#Reverse（反向）迭代器" class="headerlink" title="Reverse（反向）迭代器"></a>Reverse（反向）迭代器</h2><p>你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create list with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find position of element with value 5</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator pos;</span><br><span class="line">    pos = find (coll.cbegin(), coll.cend(),</span><br><span class="line">                <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which iterator pos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pos:  "</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert iterator to reverse iterator rpos</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">const_reverse_iterator <span class="title">rpos</span><span class="params">(pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which reverse iterator rpos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rpos: "</span> &lt;&lt; *rpos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos:  <span class="number">5</span></span><br><span class="line">rpos: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这是由于reverse迭代器在设计是做了一个小技巧，他实际倒置“半开原则”。reverse迭代器所定义的区间并不包括起点，反而包括了终点。  </p>
<h2 id="Insert（安插型）迭代器"><a href="#Insert（安插型）迭代器" class="headerlink" title="Insert（安插型）迭代器"></a>Insert（安插型）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::insert_iterator是一个输出迭代器，它被构造，在该位置到一个容器中插入元素指出，由所提供的迭代器，使用容器的insert()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::insert_iterator是一个no-op。general inserter对所有标准容器均使用（只有array和forward list除外），因为那些容器都提供insert成员函数。然而对于associative和unordered容器而言，安插位置只是个提示，因为在这两个容器转给你元素的真正位置视为value而定。<br>安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于使用下面的语句：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = container.insert(pos, value);</span><br><span class="line">++pos;</span><br></pre></td></tr></table></figure>
<p>为什么要将insert的返回值赋给pos？原因在于为了确保迭代器的位置始终有效。如果没有这个复制动作，在deque、vector和string中，该general inserter本身可能会失效。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">back_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::back_insert_iterator是OutputIterator追加到一个容器，它被构造，使用容器的push_back()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::back_insert_iterator是一个no-op。由于push_back只存在于vector、deque、list和string，所以c++标准库中只有这些容器支持back insert。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">front_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::front_insert_iterator是输出预先考虑元素的迭代器，它被修建的容器，使用时容器的push_front()成员函数的迭代器（是否解除引用或不）被分配给的。递增std::front_insert_iterator是一个no-op。由于push_front只在deque、list和forward list有实现，所以只有这些容器可以使用。  </p>
<h2 id="Stream（串流）迭代器"><a href="#Stream（串流）迭代器" class="headerlink" title="Stream（串流）迭代器"></a>Stream（串流）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::ostream_iterator is a single-pass OutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator&lt;&lt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.<br>In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.<br>When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create ostream iterator for stream cout</span></span><br><span class="line">    <span class="comment">// - values are separated by a newline character</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; intWriter(<span class="built_in">cout</span>,<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">// write elements with the usual iterator interface</span></span><br><span class="line">    *intWriter = <span class="number">42</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">77</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">-5</span>;</span><br><span class="line">    <span class="comment">// create collection with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">// write all elements without any delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// write all elements with " &lt; " as delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" &lt; "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>&lt;<span class="number">4</span>&lt;<span class="number">5</span>&lt;<span class="number">6</span>&lt;<span class="number">7</span>&lt;<span class="number">8</span>&lt;<span class="number">9</span>&lt;</span><br></pre></td></tr></table></figure>
<p>注意分隔符类型为const char*。如果你传入string对象的话，就要调用c_str函数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::input_iterator_tag,</span><br><span class="line">                                             T, Distance, <span class="keyword">const</span> T*, <span class="keyword">const</span> T&amp;&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator&gt;&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently read object.<br>The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.<br>A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.<br>T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create istream iterator that reads integers from cin</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReader(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="comment">// create end-of-stream iterator</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReaderEOF;</span><br><span class="line">    <span class="comment">// while able to read tokens with istream iterator</span></span><br><span class="line">    <span class="comment">// - write them twice</span></span><br><span class="line">    <span class="keyword">while</span> (intReader != intReaderEOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once:       "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once again: "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++intReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> f <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">once:       <span class="number">1</span></span><br><span class="line">once again: <span class="number">1</span></span><br><span class="line">once:       <span class="number">2</span></span><br><span class="line">once again: <span class="number">2</span></span><br><span class="line">once:       <span class="number">3</span></span><br><span class="line">once again: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>结果出现的问题在于，格式错误。  </p>
<h2 id="Move（搬移）迭代器"><a href="#Move（搬移）迭代器" class="headerlink" title="Move（搬移）迭代器"></a>Move（搬移）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( <span class="keyword">const</span> Iterator&amp; i );</span><br></pre></td></tr></table></figure>
<p>(since C++11)<br>(until C++14)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++14)<br>(until C++17)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument.  </p>
<h2 id="Iterator-Trait（迭代器特性）"><a href="#Iterator-Trait（迭代器特性）" class="headerlink" title="Iterator Trait（迭代器特性）"></a>Iterator Trait（迭代器特性）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five iterator categories:  </p>
<ol>
<li>input_iterator_tag corresponds to InputIterator.</li>
<li>output_iterator_tag corresponds to OutputIterator.</li>
<li>forward_iterator_tag corresponds to ForwardIterator.</li>
<li>bidirectional_iterator_tag corresponds to BidirectionalIterator.</li>
<li>random_access_iterator_tag corresponds to RandomAccessIterator.</li>
</ol>
<p>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.<br>For every iterator type, a typedef std::iterator_traits\&lt;Iterator>::iterator_category is available, which is an alias to one of these five tag types.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;;</span></span><br></pre></td></tr></table></figure>
<p>std::iterator_traits is the type trait class that provides uniform interface to the properties of Iterator types. This makes it possible to implement algorithms only in terms of iterators.<br>The class defines the following types:  </p>
<ol>
<li>difference_type - a type that can be used to identify distance between iterators</li>
<li>value_type - the type of the values that can be obtained by dereferencing the iterator. This type is void for output iterators.</li>
<li>pointer - defines a pointer to the type iterated over (value_type)</li>
<li>reference - defines a reference to the type iterated over (value_type)</li>
<li>iterator_category - the category of the iterator. Must be one of iterator category tags.</li>
</ol>
<p>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span>,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp; </span></span><br><span class="line"><span class="class">&gt; <span class="title">struct</span> <span class="title">iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(deprecated in C++17)<br>std::iterator is the base class provided to simplify definitions of the required types for iterators.<br>其中第一个template参数定义迭代器种类，第二个参数用来定义元素类型，第三个参数用来定义difference类型，第四个参数用来定义point而类型，第五个参数用来定义reference类型。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-02-Upcasting and Downcasting"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/02/2017-06-02-Upcasting and Downcasting/">Upcasting and Downcasting</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/02/2017-06-02-Upcasting and Downcasting/" class="article-date">
	  <time datetime="2017-06-01T16:00:00.000Z" itemprop="datePublished">六月 2, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://www.bogotobogo.com/cplusplus/upcasting_downcasting.php" target="_blank" rel="noopener">bogotobogo</a></p>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a>Upcasting</h2><p>Upcasting is converting a derived-class reference or pointer to a base-class. In other words, upcasting allows us to treat a derived type as though it were its base type. It is always allowed for public inheritance, without an explicit type cast. This is a result of the is-a relationship between the base and derived classes.<br>Here is the code dealing with shapes. We created Shape class, and derived Circle, Square, and Triangle classes from the Shape class. Then, we made a member function that talks to the base class:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Shape&amp; s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   s.draw();</span><br><span class="line">   s.move();</span><br><span class="line">   s.shrink();</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function speaks to any Shape, so it is independent of the specific type of object that it’s drawing, moving, and shrinking. If in some other part of the program we use the play( ) function like below:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c;</span><br><span class="line">Triangle t;</span><br><span class="line">Square sq;</span><br><span class="line">play(c);</span><br><span class="line">play(t);</span><br><span class="line">play(sq);</span><br></pre></td></tr></table></figure>
<p>Let’s check what’s happening here. A Triangle is being passed into a function that is expecting a Shape. Since a Triangle is a Shape, it can be treated as one by play(). That is, any message that play() can send to a Shape a Triangle can accept.<br>Upcasting allows us to treat a derived type as though it were its base type. That’s how we decouple ourselves from knowing about the exact type we are dealing with.<br>Note that it doesn’t say “If you’re a Triangle, do this, if you’re a Circle, do that, and so on.” If we write that kind of code, which checks for all the possible types of a Shape, it will soon become a messy code, and we need to change it every time we add a new kind of Shape. Here, however, we just say “You’re a Shape, I know you can move(), draw(), and shrink( ) yourself, do it, and take care of the details correctly.”<br>The compiler and runtime linker handle the details. If a member function is virtual, then when we send a message to an object, the object will do the right thing, even when upcasting is involved.<br>Note that the most important aspect of inheritance is not that it provides member functions for the new class, however. It’s the relationship expressed between the new class and the base class. This relationship can be summarized by saying, “The new class is a type of the existing class.”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">gotoSchool</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  Parent parent;</span><br><span class="line">  Child child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// upcast - implicit type cast allowed</span></span><br><span class="line">  Parent *pParent = &amp;child; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// downcast - explicit type case required </span></span><br><span class="line">  Child *pChild =  (Child *) &amp;parent;</span><br><span class="line"></span><br><span class="line">  pParent -&gt; sleep();</span><br><span class="line">  pChild -&gt; gotoSchool();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A Child object is a Parent object in that it inherits all the data members and member functions of a Parent object. So, anything that we can do to a Parent object, we can do to a Child object. Therefore, a function designed to handle a Parent pointer (reference) can perform the same acts on a Child object without any problems. The same idea applies if we pass a pointer to an object as a function argument. Upcasting is transitive: if we derive a Child class from Parent, then Parent pointer (reference) can refer to a Parent or a Child object.<br>Upcasting can cause object slicing when a derived class object is passed by value as a base class object, as in foo(Base derived_obj).</p>
<h2 id="Downcasting"><a href="#Downcasting" class="headerlink" title="Downcasting"></a>Downcasting</h2><p>The opposite process, converting a base-class pointer (reference) to a derived-class pointer (reference) is called downcasting. Downcasting is not allowed without an explicit type cast. The reason for this restriction is that the is-a relationship is not, in most of the cases, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn’t apply to the base class.<br>As in the example, we derived Child class from a Parent class, adding a member function, gotoSchool(). It wouldn’t make sense to apply the gotoSchool() method to a Parent object. However, if implicit downcasting were allowed, we could accidentally assign the address of a Parent object to a pointer-to-Child</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child *pChild =  &amp;parent; <span class="comment">// actually this won't compile</span></span><br><span class="line">        <span class="comment">// error: cannot convert from 'Parent *' to 'Child *'</span></span><br></pre></td></tr></table></figure>
<p>and use the pointer to invoke the gotoSchool() method as in the following line.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pChild -&gt; gotoSchool();</span><br></pre></td></tr></table></figure>
<p>Because a Parent isn’t a Child (a Parent need not have a gotoSchool() method), the downcasting in the above line can lead to an unsafe operation.<br>C++ provides a special explicit cast called dynamic_cast that performs this conversion. Downcasting is the opposite of the basic object-oriented rule, which states objects of a derived class, can always be assigned to variables of a base class.<br>One more thing about the upcasting:<br>Because implicit upcasting makes it possible for a base-class pointer (reference) to refer to a base-class object or a derived-class object, there is the need for dynamic binding. That’s why we have virtual member functions.<br>Pointer (Reference) type: known at compile time.<br>Object type: not known until run time.  </p>
<h2 id="Dynamic-Casting"><a href="#Dynamic-Casting" class="headerlink" title="Dynamic Casting"></a>Dynamic Casting</h2><p>The dynamic_cast operator answers the question of whether we can safely assign the address of an object to a pointer of a particular type.<br>Here is a similar example to the previous one.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> classes[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">gotoSchool</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  Parent *pParent = <span class="keyword">new</span> Parent;</span><br><span class="line">  Parent *pChild = <span class="keyword">new</span> Child;</span><br><span class="line">    </span><br><span class="line">  Child *p1 = (Child *) pParent;  <span class="comment">// #1</span></span><br><span class="line">  Parent *p2 = (Child *) pChild;  <span class="comment">// #2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let look at the lines where we do type cast.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child *p1 = (Child *) pParent;  <span class="comment">// #1</span></span><br><span class="line">Parent *p2 = (Child *) pChild;  <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>
<p>Which of the type cast is safe?<br>The only one guaranteed to be safe is the ones in which the pointer is the same type as the object or else a base type for the object.<br>Type cast #1 is not safe because it assigns the address of a base-class object (Parent) to a derived class (Child) pointer. So, the code would expect the base-class object to have derived class properties such as gotoSchool() method, and that is false. Also, Child object, for example, has a member classes that a Parent object is lacking.<br>Type case #2, however, is safe because it assigns the address of a derived-class object to a base-class pointer. In other words, public derivation promises that a Child object is also a Parent object.<br>The question of whether a type conversion is safe is more useful than the question of what kind of object is pointed to. The usual reason for wanting to know the type is so that we can know if it’s safe to invoke a particular method.<br>Here is the syntax of dynamic_cast.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child *p = <span class="keyword">dynamic_cast</span>&lt;Child *&gt;(pParent);</span><br></pre></td></tr></table></figure>
<p>This code is asking whether the pointer pParent can be type cast safely to the type Child *.</p>
<p>It returns the address of the object, if it can.<br>It returns 0, otherwise.<br>How do we use the dynamic_cast?  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Parent* p)</span> </span>&#123;</span><br><span class="line">  Child *ptr = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(p);</span><br><span class="line">   <span class="keyword">if</span>(ptr) &#123; </span><br><span class="line">    <span class="comment">// we can safely use ptr</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the code, if (ptr) is of the type Child or else derived directly or indirectly from the type Child, the dynamic_cast converts the pointer p to a pointer of type Child. Otherwise, the expression evaluates to 0, the null pointer.<br>In other words, we want to check if we can use the passed in pointer p before we do some operation on a child class object even though it’s a pointer to base class.<br>“The need for dynamic_cast generally arises because we want perform derived class operation on a derived class object, but we have only a pointer-or reference-to-base.” -Scott Meyers</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/downcasting/">downcasting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/upcasting/">upcasting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-06-01-C++内存模型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/01/2017-06-01-C++内存模型/">C++类对象的内存模型和占用空间</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/01/2017-06-01-C++内存模型/" class="article-date">
	  <time datetime="2017-05-31T16:00:00.000Z" itemprop="datePublished">六月 1, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/chinabinlang/article/details/8614649" target="_blank" rel="noopener">chinabinlang的专栏</a></p>
<p>很多C++书籍中都介绍过，一个Class对象需要占用多大的内存空间。最权威的结论是：  </p>
<ol>
<li>非静态成员变量总合。</li>
<li>加上编译器为了CPU计算，作出的数据对齐处理。</li>
<li>加上为了支持虚函数，产生的额外负担。</li>
</ol>
<p>介绍完了理论知识后，再看看再找一个例子看看（注：一下所有结果都是在VC6.0 开发环境中得出的结论）  </p>
<h2 id="空类的Size"><a href="#空类的Size" class="headerlink" title="空类的Size"></a>空类的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:1</p>
<p>这是为何呢？我想对于这个问题，不仅是刚入行不久的开发新手，就算有过几年以上C++开发经验的开发人员也未必能说清楚这个。<br>编译器在执行Car objCar;这行代码后需要，作出一个Class Car的Object。并且这个Object的地址还是独一无二的，于是编译器就会给空类创建一个隐含的一个字节的空间。  </p>
<h2 id="只有成员变量的Size"><a href="#只有成员变量的Size" class="headerlink" title="只有成员变量的Size"></a>只有成员变量的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>这个结果很多开发人员都清楚。在32位系统中，整型变量占4个字节。这里Class Car中含有两个整型类型的成员变量，所以Class Size是8。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sHigh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>我们这次在Class Car中添加了一个静态成员变量，但是Class Size仍然是8个字节。这正好符合了，结论中的第一条：非静态成员变量总合。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> chLogo</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sHigh;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:12  </p>
<p>在类中又插入了一个字符型变量，结果Class Size变成了12。这个就是编译器额外添加3个字符变量，做数据对齐处理，为了是提高CPU的计算速度。编译器额外添加的东西我们是无法看见的。这也符合了结论中的第二条：加上编译器为了CPU计算，作出的数据对齐处理。  </p>
<p>既然，我们这样定义类成员数据编译器会额外的增加空。那么，我们何不在定义类的时候就考虑到数据对齐的问题，可以多定义出3个字符类型变量作为预留变量，既能满足数据对齐的要求，也给自己的程序添加了一些可扩展的空间。  </p>
<h2 id="只有成员函数的Size"><a href="#只有成员函数的Size" class="headerlink" title="只有成员函数的Size"></a>只有成员函数的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:1  </p>
<p>噢，这是怎么回事儿呢？再做一个实验看看。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>这次应该很清楚的了。函数是不占用类空间的。第一个例子中的Size为1个字节，正是编译器为类创建一个隐含的一个字节的空间  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:4  </p>
<p>这次，让析构函数为虚函数，看到了Class Size为4。<strong>这正是指向Virtual Table的指针vptr的Size。</strong>这正好符合了，结论中的第三条：加上为了支持虚函数，产生的额外负担。<br>到此为止，一个Class Object究竟占用多少内存空间，已经完全说清楚了。但是，这只是针对单独类，或者说是基类适用。对于子类，却不一样了。有兴趣的朋友可以做一些实验。  </p>
<h1 id="other-example"><a href="#other-example" class="headerlink" title="other example"></a>other example</h1><p>先看两段代码：<br>代码段1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of A = "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of A =<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>代码段2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print3</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of A = "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of A =<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对象的大小是它的数据成员所占存储空间之和，就和结构体一样。类中的函数是所有该类对象通用的方法，不算作对象的成员，因此也不算在对象的存储空间内。  </p>
<p>问题：类里面不管有多少个函数，这个类的对象只占1个字节的内存。这个字节的内存的内容是什么？是指针吗？指针不是占4个字节吗？<br>当类中类有定义任何变量的时候，类的对象都是1个字节的，当类中没有任何变量的时候，这个类里没有任何真正的成员变量，所以大小应该是0，但0大小不好在内存中定位一个地址，所以，就规定它大小为0的对象要占一字节空间，以便让它拥有一个合法的地址。如果是有派生类的，还有考虑到内存对齐的问题的。  </p>
<p>另外涉及到虚函数的话又不一样了。如  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果sizeof(A)的话，得出的是4。<br>原因是涉及到虚函数的实现问题。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    m_data1;</span><br><span class="line">    m_data2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Class1对象实例<br>通过vptr指针找到虚函数表  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659ly1fg73ltk1rfj204605da9u.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1fg73ltk1rfj204605da9u.jpg" class="img-fluid"><br></a></p>
<p>Vtable(虚函数表)  </p>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659ly1fg73luk3jij203u0583ya.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1fg73luk3jij203u0583ya.jpg" class="img-fluid"><br></a></p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659ly1fg73luwx31j205i05aweb.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1fg73luwx31j205i05aweb.jpg" class="img-fluid"><br></a></p>
<p>所以回到原来的问题，A中只有一个或者几个虚函数的话，没有成员变量，那么类A相当于含有一个vptr指向虚函数表的指针，所以sizeof(A)=4。  </p>
<p>还有一点，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> B2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(B) = <span class="number">1</span>;   <span class="keyword">sizeof</span>(B2) = <span class="number">1</span>;  <span class="keyword">sizeof</span>(C) = <span class="number">1</span>;  <span class="keyword">sizeof</span>(D) = <span class="number">4</span>;  <span class="keyword">sizeof</span>(E) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>空类所占空间为一(上文以解释)，单一继承的空类空间也是1，多重继承的空类空间还是1，但是虚继承涉及到虚表(虚指针)，所以sizeof(D)=4。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-31-C++多态问题小结"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/31/2017-05-31-C++多态问题小结/">C++多态性</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/31/2017-05-31-C++多态问题小结/" class="article-date">
	  <time datetime="2017-05-30T16:00:00.000Z" itemprop="datePublished">五月 31, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/hackbuteer1/article/details/7475622" target="_blank" rel="noopener">Hackbuteer1的专栏</a></p>
<p>C++编程语言是一款应用广泛，支持多种程序设计的计算机编程语言。我们今天就会为大家详细介绍其中C++多态性的一些基本知识，以方便大家在学习过程中对此能够有一个充分的掌握。<br>多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。<br>C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。<br>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。<br>那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。<br>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    B b;  </span><br><span class="line">    A *p = &amp;a;  </span><br><span class="line">    p-&gt;foo();  </span><br><span class="line">    p-&gt;fun();  </span><br><span class="line">    p = &amp;b;  </span><br><span class="line">    p-&gt;foo();  </span><br><span class="line">    p-&gt;fun();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个p-&gt;foo()和p-&gt;fun()都很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数，因此输出结果就是1、2。<br>第二个输出结果就是1、4。p-&gt;foo()和p-&gt;fun()则是基类指针指向子类对象，正式体现多态的用法，p-&gt;foo()由于指针是个基类指针，指向是一个固定偏移量的函数，因此此时指向的就只能是基类的foo()函数的代码了，因此输出的结果还是1。而p-&gt;fun()指针是基类指针，指向的fun是一个虚函数，由于每个虚函数都有一个虚函数列表，此时p调用fun()并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，因此输出的结果也会是子类的结果4。<br>笔试的题目中还有一个另类测试方法。即  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B *ptr = (B *)&amp;a;  ptr-&gt;foo();  ptr-&gt;fun();</span><br></pre></td></tr></table></figure>
<p>问这两调用的输出结果。这是一个用子类的指针去指向一个强制转换为子类地址的基类对象。结果，这两句调用的输出结果是3，2。<br>并不是很理解这种用法，从原理上来解释，由于B是子类指针，虽然被赋予了基类对象地址，但是ptr-&gt;foo()在调用的时候，由于地址偏移量固定，偏移量是子类对象的偏移量，于是即使在指向了一个基类对象的情况下，还是调用到了子类的函数，虽然可能从始到终都没有子类对象的实例化出现。<br>而ptr-&gt;fun()的调用，可能还是因为C++多态性的原因，由于指向的是一个基类对象，通过虚函数列表的引用，找到了基类中fun()函数的地址，因此调用了基类的函数。由此可见多态性的强大，可以适应各种变化，不论指针是基类的还是子类的，都能找到正确的实现方法。<br>关于向上向下造型可以看这篇<a href="Upcasting and Downcasting">Upcasting and Downcasting</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class_B Val_b;</span><br><span class="line">Class_A Val_a = (Class_A*)Val_b;</span><br></pre></td></tr></table></figure>
<p>此刻，Val_a的实函数是Class_A的类型，虚函数是Class_B的类型！！！<br>指针的数据类型是实函数的类型，指针指向的对象的数据类型，是虚函数的数据类型<br><strong>从汇编的角度看，无非是指针的偏移问题，搞清楚哪个指针偏移多少，才是问题的本质。</strong><br><strong>如果想要了解这个问题的本质，就要了解C++内存模型，也就是要知道内存中是如何存放虚函数的。</strong>可以看这篇文章<a href="http://www.coordinate.wang/cpp/2017/06/01/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" target="_blank" rel="noopener">C++类对象的内存模型和占用空间</a></p>
<h2 id="重载与覆盖"><a href="#重载与覆盖" class="headerlink" title="重载与覆盖"></a>重载与覆盖</h2><p>成员函数被重载的特征：  </p>
<ol>
<li>相同的范围（在同一个类中）；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual关键字可有可无。 </li>
</ol>
<p>覆盖是指派生类函数覆盖基类函数，特征是：  </p>
<ol>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有virtual关键字。</li>
</ol>
<h2 id="令人迷惑的隐藏规则"><a href="#令人迷惑的隐藏规则" class="headerlink" title="令人迷惑的隐藏规则"></a>令人迷惑的隐藏规则</h2><p>本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。<br>这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：  </p>
<ol>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小结：1、有virtual才可能发生多态现象  </span></span><br><span class="line"><span class="comment">// 2、不发生多态（无virtual）调用就按原类型调用  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::g(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//多态、覆盖  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::g(int)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//隐藏  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//隐藏  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Derived d;  </span><br><span class="line">    Base *pb = &amp;d;  </span><br><span class="line">    Derived *pd = &amp;d;  </span><br><span class="line">    <span class="comment">// Good : behavior depends solely on type of the object  </span></span><br><span class="line">    pb-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line">    pd-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line">    pb-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Base::g(float)  3.14  </span></span><br><span class="line">    pd-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Derived::g(int) 3   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line">    pb-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Base::h(float) 3.14  </span></span><br><span class="line">    pd-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Derived::h(float) 3.14  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序中：  </p>
<ol>
<li>函数Derived::f(float)覆盖了Base::f(float)。</li>
<li>函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</li>
<li>函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</li>
</ol>
<p>以下内容转自<a href="http://blog.csdn.net/haoel/article/details/1948051/" target="_blank" rel="noopener">陈皓专栏</a></p>
<h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。<br>这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。<br>假设我们有这样的一个类：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Invoke the first virtual function </span></span><br><span class="line"> pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line"> pFun();</span><br></pre></td></tr></table></figure>
<p>实际运行经果如下：(Windows XP+VS2003,  Linux 2.6.22 + GCC 4.1.3)<br>虚函数表地址：0012FED4<br>虚函数表 — 第一个函数地址：0044F148<br>Base::f  </p>
<p>通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int * 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>);  <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>);  <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>);  <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>
<p>这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" class="img-fluid"><br></a></p>
<p>注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。<br>下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。  </p>
<h2 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h2><p>下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：<br>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" class="img-fluid"><br></a></p>
<p>对于实例：Derive d; 的虚函数表如下：  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" class="img-fluid"><br></a></p>
<p>我们可以看到下面几点：  </p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。</li>
</ol>
<p>我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。  </p>
<h2 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h2><p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" class="img-fluid"><br></a></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" class="img-fluid"><br></a></p>
<p>我们从表中可以看到下面几点，  </p>
<ol>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。</li>
</ol>
<p>这样，我们就可以看到对于下面这样的程序，  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derive();</span><br><span class="line">b-&gt;f();</span><br></pre></td></tr></table></figure>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。  </p>
<h2 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h2><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" class="img-fluid"><br></a></p>
<p>对于子类实例中的虚函数表，是下面这个样子：  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" class="img-fluid"><br></a></p>
<p>我们可以看到：  </p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。  </p>
<h2 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h2><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" class="img-fluid"><br></a></p>
<p>下面是对于子类实例中的虚函数表的图：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" class="img-fluid"><br></a></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line">Base1 *b1 = &amp;d;</span><br><span class="line">Base2 *b2 = &amp;d;</span><br><span class="line">Base3 *b3 = &amp;d;</span><br><span class="line">b1-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b2-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b3-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line"></span><br><span class="line">b1-&gt;g(); <span class="comment">//Base1::g()</span></span><br><span class="line">b2-&gt;g(); <span class="comment">//Base2::g()</span></span><br><span class="line">b3-&gt;g(); <span class="comment">//Base3::g()</span></span><br></pre></td></tr></table></figure>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。  </p>
<ol>
<li>通过父类型的指针访问子类自己的虚函数  </li>
</ol>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1 *b1 = <span class="keyword">new</span> Derive();</span><br><span class="line">b1-&gt;f1();  <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）  </p>
<ol>
<li>访问non-public的虚函数  </li>
</ol>
<p>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。<br>如：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    Fun  pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;d)+<span class="number">0</span>);</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion</span><span class="params">()</span></span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><ol>
<li>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 </li>
<li>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 </li>
</ol>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。  </p>
<h2 id="相似概念"><a href="#相似概念" class="headerlink" title="相似概念"></a>相似概念</h2><ol>
<li>多态性<br>指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。<br>a、编译时多态性：通过重载函数实现<br>b、运行时多态性：通过虚函数实现。 </li>
<li>虚函数<br>虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）</li>
<li>抽象类<br>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多态/">多态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-30-C++类静态成员与类静态成员函数详解"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/">C++类静态成员与类静态成员函数详解</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/" class="article-date">
	  <time datetime="2017-05-29T16:00:00.000Z" itemprop="datePublished">五月 30, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.jb51.net/article/41775.htm" target="_blank" rel="noopener">脚本之家</a><br>当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关。<br>静态数据成员的用途之一是统计有多少个对象实际存在。<br>静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。<br>静态成员不可在类体内进行赋值，因为它是被所有该类的对象所共享的。你在一个对象里给它赋值，其他对象里的该成员也会发生变化。为了避免混乱，所以不可在类体内进行赋值。<br>静态成员的值对所有的对象是一样的。静态成员可以被初始化，但只能在类体外进行初始化。<br>一般形式：<br>数据类型类名：：静态数据成员名＝初值<br>注意：不能用参数初始化表对静态成员初始化。一般系统缺省初始为0。<br>静态成员是类所有的对象的共享的成员，而不是某个对象的成员。它在对象中不占用存储空间，这个属性为整个类所共有，不属于任何一个具体对象。所以静态成员不能在类的内部初始化，比如声明一个学生类，其中一个成员为学生总数，则这个变量就应当声明为静态变量，应该根据实际需求来设置成员变量。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> x;</span><br><span class="line">     <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Getnum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          x+=<span class="number">5</span>;   <span class="comment">// 这行代码是错误的，静态成员函数不能调用非静态数据成员，要通过类的对象来调用。</span></span><br><span class="line">          num+=<span class="number">15</span>;</span><br><span class="line">          <span class="keyword">return</span> num;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> test::num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     test a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::num&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//10</span></span><br><span class="line">     test::num = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::num&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//20</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::Getnum()&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//35</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.Getnum()&lt;&lt;<span class="built_in">endl</span>;       <span class="comment">//50</span></span><br><span class="line">     system(<span class="string">"pause"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上例可知：  x+=5;   // 这行代码是错误的<br><a href="http://www.jb51.net/article/41941.htm" target="_blank" rel="noopener"><strong>静态函数成员必须通过对象名来访问非静态数据成员</strong></a>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">FunctionA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     menber = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> menber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上述代码，出错。原因很简单大家都知道，静态成员函数不能访问非静态成员，这是因为静态函数属于类而不是属于整个对象，静态函数中的 member可能都没有分配内存。静态成员函数没有隐含的this自变量。所以，它就无法访问自己类的非静态成员。<br>那要想访问怎么办呢？地球人都知道只要将：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> menber;</span><br><span class="line"><span class="comment">//change the line above to:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> menber;</span><br></pre></td></tr></table></figure>
<p>但是这个方法让我们不得不将static function内用到的成员变量都变成static的了，而且static的成员还要显式初始化，有没有更好的方法？答案是肯定的。代码说话：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">FunctionA</span><span class="params">(a* _a)</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">      	_a-&gt; menber = <span class="number">1</span>;</span><br><span class="line">      	<span class="built_in">cout</span>&lt;&lt;_a-&gt; menber&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      	_a-&gt;f();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"f被调用了"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> menber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前提是这个类要分配了内存空间。其实这里我做的就是将一个对象指针作为静态成员函数的“this”指针，意在模仿传递非静态成员函数里this变量(在非静态成员函数中都有this指针(push在ECX中似乎))  </p>
<p>另外，静态成员函数在类外实现时候无须加static关键字，否则是错误的。<br>若在类的体外来实现上述的那个静态成员函数，不能加static关键字，这样写就可以了:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> test::Getnum()</span><br><span class="line">&#123;</span><br><span class="line">	.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>static成员的所有者是类本身和对象，但是多有对象拥有一样的静态成员。从而在定义对象是不能通过构造函数对其进行初始化。</li>
<li>静态成员不能在类定义里边初始化，只能在class body外初始化。</li>
<li>静态成员仍然遵循public，private，protected访问准则。</li>
<li>静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。</li>
</ol>
<p>静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态数据成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Sum;    <span class="comment">//声明静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;       <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line">Myclass::Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">        Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Myclass::GetSum()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Sum="</span> &lt;&lt;Sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">Myclass <span class="title">me</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">        me.GetSum();</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上例可知，非静态成员函数可以任意地访问静态成员函数和静态数据成员。<br>非静态成员函数Myclass(int a,int b,int c)和GetSum()都访问了静态数据成员Sum。<br>静态成员函数不能访问非静态成员函数和非静态数据成员。<br>关于静态成员函数，可以总结为以下几点：</p>
<ol>
<li>出现在类体外的函数定义不能指定关键字static；</li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li>
<li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li>
</ol>
<p>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。静态成员变量只能被静态成员函数调用。静态成员函数也是由同一类中的所有对象共用。只能调用静态成员变量和静态成员函数。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/">lvalue,rvalue,xlvalue,glvalue,prvalue</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/" class="article-date">
	  <time datetime="2017-05-28T16:00:00.000Z" itemprop="datePublished">五月 29, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Value-categories"><a href="#Value-categories" class="headerlink" title="Value categories"></a>Value categories</h1><p>Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: prvalue, xvalue, lvalue, defined as follows:</p>
<ol>
<li>a glvalue is an expression whose evaluation determines the identity of an object, bit-field, or function;</li>
<li>a prvalue is an expression whose evaluation either<ol>
<li>computes the value of the operand of an operator (such prvalue has no result object), or</li>
<li>initializes an object or a bit-field (such prvalue is said to have a result object). All class and array prvalues have a result object even if it is discarded. In certain contexts, temporary materialization occurs to create a temporary as the result object;</li>
</ol>
</li>
<li>an xvalue is a glvalue that denotes an object or bit-field whose resources can be reused;</li>
<li>an lvalue is a glvalue that is not an xvalue;</li>
<li>an rvalue is a prvalue or an xvalue.</li>
</ol>
<p>Note: this taxonomy went through significant changes with past C++ standard revisions, see History below for details.</p>
<h1 id="Primary-categories"><a href="#Primary-categories" class="headerlink" title="Primary categories"></a>Primary categories</h1><h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><p>The following expressions are lvalue expressions:</p>
<ol>
<li>the name of a variable or a function in scope, regardless of type, such as std::cin or std::endl. Even if the variable’s type is rvalue reference, the expression consisting of its name is an lvalue expression;</li>
<li>a function call or an overloaded operator expression of lvalue reference return type, such as std::getline(std::cin, str), std::cout &lt;&lt; 1, str1 = str2, or ++it;</li>
<li>a = b, a += b, a %= b, and all other built-in assignment and compound assignment expressions;</li>
<li>++a and –a, the built-in pre-increment and pre-decrement expressions;</li>
<li>*p, the built-in indirection expression;</li>
<li>a[n] and p[n], the built-in subscript expressions, except where a is an array rvalue (since C++11);</li>
<li>a.m, the member of object expression, except where m is a member enumerator or a non-static member function, or where a is an rvalue and m is a non-static data member of non-reference type;</li>
<li>p-&gt;m, the built-in member of pointer expression, except where m is a member enumerator or a non-static member function;</li>
<li>a.*mp, the pointer to member of object expression, where a is an lvalue and mp is a pointer to data member;</li>
<li>p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to data member;</li>
<li>a, b, the built-in comma expression, where b is an lvalue;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a string literal, such as “Hello, world!”;</li>
<li>a cast expression to lvalue reference type, such as static_cast&lt;int&amp;&gt;(x);</li>
<li>a function call or an overloaded operator expression of rvalue reference to function return type;</li>
<li>a cast expression to rvalue reference to function type, such as static_cast<void (&&)(int)="">(x).<br>(since C++11)</void></li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as glvalue (below).</li>
<li>Address of an lvalue may be taken: &amp;++i[1] and &amp;std::endl are valid expressions.</li>
<li>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</li>
<li>An lvalue may be used to initialize an lvalue reference; this associates a new name with the object identified by the expression.</li>
</ol>
<h2 id="prvalue"><a href="#prvalue" class="headerlink" title="prvalue"></a>prvalue</h2><p>The following expressions are prvalue expressions:</p>
<ol>
<li>a literal (except for string literal), such as 42, true or nullptr;</li>
<li>a function call or an overloaded operator expression of non-reference return type, such as str.substr(1, 2), str1 + str2, or it++;</li>
<li>a++ and a–, the built-in post-increment and post-decrement expressions;</li>
<li>a + b, a % b, a &amp; b, a &lt;&lt; b, and all other built-in arithmetic expressions;</li>
<li>a &amp;&amp; b, a || b, !a, the built-in logical expressions;</li>
<li>a &lt; b, a == b, a &gt;= b, and all other built-in comparison expressions;</li>
<li>&amp;a, the built-in address-of expression;</li>
<li>a.m, the member of object expression, where m is a member enumerator or a non-static member function[2], or where a is an rvalue and m is a non-static data member of non-reference type (until C++11);</li>
<li>p-&gt;m, the built-in member of pointer expression, where m is a member enumerator or a non-static member function[2];</li>
<li>a.*mp, the pointer to member of object expression, where mp is a pointer to member function[2], or where a is an rvalue and mp is a pointer to data member (until C++11);</li>
<li>p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to member function[2];</li>
<li>a, b, the built-in comma expression, where b is an rvalue;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a cast expression to non-reference type, such as static_cast<double>(x), std::string{}, or (int)42;</double></li>
<li>the this pointer;</li>
<li>a lambda expression, such as <a href="int x"></a>{ return x * x; }.(since C++11)</li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as rvalue (below).</li>
<li>A prvalue cannot be polymorphic: the dynamic type of the object it identifies is always the type of the expression.</li>
<li>A non-class non-array prvalue cannot be cv-qualified. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</li>
<li>A prvalue cannot have incomplete type (except for type void, see below, or when used in decltype specifier).</li>
</ol>
<h2 id="xvalue"><a href="#xvalue" class="headerlink" title="xvalue"></a>xvalue</h2><p>The following expressions are xvalue expressions:</p>
<ol>
<li>a function call or an overloaded operator expression of rvalue reference to object return type, such as std::move(x);</li>
<li>a[n], the built-in subscript expression, where one operand is an array rvalue ;</li>
<li>a.m, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference type;</li>
<li>a.*mp, the pointer to member of object expression, where a is an rvalue and mp is a pointer to data member;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a cast expression to rvalue reference to object type, such as static_cast&lt;char&amp;&amp;&gt;(x);</li>
<li>any expression that designates a temporary object, after temporary materialization.(since C++17)</li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as rvalue (below).</li>
<li>Same as glvalue (below).</li>
</ol>
<p>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be polymorphic, and non-class xvalues may be cv-qualified.</p>
<h1 id="Mixed-categories"><a href="#Mixed-categories" class="headerlink" title="Mixed categories"></a>Mixed categories</h1><h2 id="glvalue"><a href="#glvalue" class="headerlink" title="glvalue"></a>glvalue</h2><p>A glvalue expression is either lvalue or xvalue.<br>Properties:</p>
<ol>
<li>A glvalue may be implicitly converted to a prvalue with lvalue-to-rvalue, array-to-pointer, or function-to-pointer implicit conversion.</li>
<li>A glvalue may be polymorphic: the dynamic type of the object it identifies is not necessarily the static type of the expression.</li>
<li>A glvalue can have incomplete type, where permitted by the expression.</li>
</ol>
<h2 id="rvalue"><a href="#rvalue" class="headerlink" title="rvalue"></a>rvalue</h2><p>An rvalue expression is either prvalue or xvalue.<br>Properties:</p>
<ol>
<li>Address of an rvalue may not be taken: &amp;int(), &amp;i++[3], &amp;42, and &amp;std::move(x) are invalid.</li>
<li>An rvalue can’t be used as the left-hand operand of the built-in assignment or compound assignment operators.</li>
<li>An rvalue may be used to initialize a const lvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends.</li>
<li>An rvalue may be used to initialize an rvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends.</li>
<li>When used as a function argument and when two overloads of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the move constructor, and likewise with copy and move assignment operators).</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    S () = <span class="keyword">default</span> ;</span><br><span class="line">    S (<span class="keyword">const</span> S &amp;) = <span class="keyword">delete</span> ;</span><br><span class="line">    S &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> S &amp;) = <span class="keyword">delete</span> ;</span><br><span class="line">    S (S &amp;&amp;) = <span class="keyword">default</span> ;</span><br><span class="line">    S &amp;<span class="keyword">operator</span>= (S &amp;&amp;) = <span class="keyword">default</span> ;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    S p0 ;</span><br><span class="line">    S p1[<span class="number">2</span>] ;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    S p0 = A ().p0 ;</span><br><span class="line">    S p1 = A ().p1[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p1哪里是编译不通过的，A ().p1[0]不是右值<br>好像不满足xvalue的描述  </p>
<p>A().p1[0] 的意思是（实际上也是这么运作的）先计算A().p1（这是一个lvalue，而不是xvalue，因为 3）的要求是m为非引用，当然也就是非指针了。 ）， 再取它的第1个元素（根据lvalue的性质，这当然也是一个左值了）。<br>一言以蔽之，A().p1[0] 的运算顺序是(A().p1)[0]，是一个lvalue，而不是xvalue（在C++11中）。<br>PS： ‘.’的优先级和[]一样，因此，从左到右计算。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glvalue/">glvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lvalue/">lvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/prvalue/">prvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rvalue/">rvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xlvalue/">xlvalue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-27-迭代器相关的辅助函数"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/27/2017-05-27-迭代器相关的辅助函数/">迭代器相关的辅助函数</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/27/2017-05-27-迭代器相关的辅助函数/" class="article-date">
	  <time datetime="2017-05-26T16:00:00.000Z" itemprop="datePublished">五月 27, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h2><p>定义于头文件\&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">Distance</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>( <span class="title">InputIt</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span> );</span></span><br></pre></td></tr></table></figure>
<p>增加迭代器it n个元素。如果n为负，迭代器递减。在这种情况下，InputIt的BidirectionalIterator必须满足的要求，否则该行为是未定义。<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> vi = v.begin();</span><br><span class="line">    <span class="built_in">std</span>::advance(vi, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *vi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为 4  </p>
<h2 id="next和prev"><a href="#next和prev" class="headerlink" title="next和prev"></a>next和prev</h2><p>定义于头文件 \&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>( <span class="title">ForwardIt</span> <span class="title">it</span>, </span></span><br><span class="line"><span class="class">                <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>返回的nth的继任者的迭代器it。<br>定义于头文件\&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirIt</span> <span class="title">prev</span>( <span class="title">BidirIt</span> <span class="title">it</span>, </span></span><br><span class="line"><span class="class">              <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>返回的nth的前身迭代器it。<br>前面提到了next的一个有效的用处就是在forward和bidirectional迭代器。<br>里一个用处主要是before_begin  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> posBefore = <span class="built_in">list</span>.before_begin();</span><br><span class="line"><span class="keyword">for</span>(; next(posBefore) != <span class="built_in">list</span>.end(); ++posBefore)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(*next(posBefore) %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;InputIt&gt;::difference_type </span><br><span class="line">    distance( InputIt first, InputIt last );</span><br></pre></td></tr></table></figure>
<p>返回first和last之间的元素数量。如果last不能由first递增得到，则函数的行为是未定义的。<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">     <span class="keyword">auto</span> distance = <span class="built_in">std</span>::distance(v.begin(), v.end());</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为3  </p>
<p>处理两个non-random-access迭代器之间的距离时要十分小心。第一迭代器所知的元素绝对不能在第二迭代器所指元素的后方，否则会导致不明确的行为。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iter_swap</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt1</span>, <span class="title">class</span> <span class="title">ForwardIt2</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">iter_swap</span>( <span class="title">ForwardIt1</span> <span class="title">a</span>, <span class="title">ForwardIt2</span> <span class="title">b</span> );</span></span><br></pre></td></tr></table></figure>
<p>交换给定的迭代器指向的元素的值。迭代器的类型不必相同，但其所指的两个值必须可以相互赋值。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 1 to 9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">    <span class="comment">// swap first and second value</span></span><br><span class="line">    iter_swap (coll.begin(), next(coll.begin()));</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">    <span class="comment">// swap first and last value</span></span><br><span class="line">    iter_swap (coll.begin(), prev(coll.end()));</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意，next和prev始自c++11，因此若以operator++和—取而代之，可以参看前面讲的内容。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-26-迭代器种类"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/26/2017-05-26-迭代器种类/">迭代器种类</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/26/2017-05-26-迭代器种类/" class="article-date">
	  <time datetime="2017-05-25T16:00:00.000Z" itemprop="datePublished">五月 26, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Output迭代器"><a href="#Output迭代器" class="headerlink" title="Output迭代器"></a>Output迭代器</h2><p>输出迭代器（OutputIterator）是能写入所指元素的迭代器（Iterator）。<br>实现输出迭代器（OutputIterator）的类型的例子是 std::ostream_iterator。<br>当向前迭代器（ForwardIterator）、双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）在自身的要求之上满足的输出迭代器（OutputIterator）要求时，它被描述为可变的。  </p>
<h2 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h2><p>输入迭代器（InputIterator）是能从所指向元素读取的迭代器（Iterator）。输入迭代器（InputIterator）仅保证单趟算法的合法性：一旦 InputIterator i 被自增，则所有其先前值的副本都可能变得非法。<br>Input迭代器只能读取元素一次。如果你复制input迭代器，并令源input迭代器和新产生的拷贝都向前读取，可能会遍历到不同的值。  </p>
<h2 id="Forward（前向）迭代器"><a href="#Forward（前向）迭代器" class="headerlink" title="Forward（前向）迭代器"></a>Forward（前向）迭代器</h2><p>向前迭代器（ForwardIterator）是一种能从所指向元素读取数据的迭代器（Iterator）。<br>不同于输入迭代器（InputIterator）和输出迭代器（OutputIterator），它能被用于多趟算法。<br>和input迭代器不同的是，两个forward迭代器如果指向同一个元素，operator==会获得true，如果两者都递增，会再次指向同一元素。<br>有以下对象和类型提供：  </p>
<ol>
<li>class forward_list&lt;&gt;</li>
<li>unordered容器</li>
</ol>
<h2 id="Bidirectional（双向迭代器）"><a href="#Bidirectional（双向迭代器）" class="headerlink" title="Bidirectional（双向迭代器）"></a>Bidirectional（双向迭代器）</h2><p>双向迭代器（BidirectionalIterator）是能双向移动（即自增与自减）的向前迭代器（ForwardIterator）。<br>有以下对象和类型提供：  </p>
<ol>
<li>class list&lt;&gt;</li>
<li>associative容器</li>
</ol>
<h2 id="RandomAccess（随机访问）迭代器"><a href="#RandomAccess（随机访问）迭代器" class="headerlink" title="RandomAccess（随机访问）迭代器"></a>RandomAccess（随机访问）迭代器</h2><p>随机访问迭代器（RandomAccessIterator）是能在常数时间内移动到指向任何元素的双向迭代器（BidirectionalIterator）。<br>指向数组元素的指针满足所有随机访问迭代器（RandomAccessIterator）的要求。<br>有以下对象和类型提供：  </p>
<ol>
<li>可随机访问的容器（array、vector、deque）</li>
<li>string（string、wstring）</li>
<li>寻常的c-style（pointer）</li>
</ol>
<h2 id="Vector迭代器的increment和decrement"><a href="#Vector迭代器的increment和decrement" class="headerlink" title="Vector迭代器的increment和decrement"></a>Vector迭代器的increment和decrement</h2><p>一般而言你可以递增或递减临时性迭代器，但对于array、vector和string就不行。例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(++coll.begin(), coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译++coll.begin可能会失败，但是如果使用的是deque就不会。原因是，vector、array和string的迭代器通常被实现为寻常pointer，而C++并不允许你修改任何基础类型的临时类型（包括pointer）的临时对象，但对于struct和class就允许。<br>因此，上面的代码对于vector、array和string以外的容器都没问题，因为那些容器的迭代器都不可能是寻常pointer。但对于vector、array和string，上面的代码是否可行就取决于具体实现。<br>在c++11之前的做法是使用一个辅助对象::  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>:<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = coll.begin();</span><br><span class="line">	<span class="built_in">std</span>::sort(++beg, coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11之后可以使用next   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(<span class="built_in">std</span>::next(coll.begin()), coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-25-STL容器8无序容器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/25/2017-05-25-STL容器8无序容器/">STL容器（8）无序容器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/25/2017-05-25-STL容器8无序容器/" class="article-date">
	  <time datetime="2017-05-24T16:00:00.000Z" itemprop="datePublished">五月 25, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义于头文件\&lt;unordered_set>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_set</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序集合是一个关联容器，包含一些类型为Key的唯一对象。搜索，插入和删除具有平摊的常数时间复杂度。<br>定义于头文件\&lt;unordered_set>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_multiset</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序多重集合是一个关联容器，含有一些类型为Key的，可能不是唯一的对象。搜索，插入和删除具有平摊的常数时间复杂度。<br>定义于头文件 \&lt;unordered_map>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序映射是一个关联容器，包含带有唯一键的键值对。搜索，插入和去除具有平摊的常数时间复杂度。<br>定义于头文件 \&lt;unordered_map>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_multimap</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序多重映射是一个无序关联容器，支持多个相等的键（unordered_multimap中，每个键对应的值可能不唯一）以及相关联的另一种类型的值。unordered_multimap类支持前向迭代器。搜索，插入和去除具有平摊的常数时间复杂度。  </p>
<h2 id="Unordered容器能力"><a href="#Unordered容器能力" class="headerlink" title="Unordered容器能力"></a>Unordered容器能力</h2><p>Unordered容器比起寻常的associative容器，要的优点是：在安插、删除、查找元素时获得amortized常量时间，因为偶尔发生的rehashing可能是个大型操作。主要缺点是：Unordered容器不提供operator&lt;、&gt;、&lt;=和&gt;=这些容器的多重实例。不提供lower_bound和upper_bound。由于iterator只保证至少是个forward iterator，所以别的迭代器的算法都是用不了。<br>由于元素的(key)value关系到元素的位置，所以不可以直接修改(key)value，通过iterator访问时，元素的(key)value是常量。<br>Erase函数不会造成指向元素的iterator、reference和pointer失效。在调用insert、reserve和clear、rehash时会rehashing。  </p>
<h2 id="创建和控制Unordered容器"><a href="#创建和控制Unordered容器" class="headerlink" title="创建和控制Unordered容器"></a>创建和控制Unordered容器</h2><p>欲定义最大负载系数，你必须在构建后立刻调用一个成员函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; coll;</span><br><span class="line">coll.max_load_factor(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure>
<p>通常0.7~0.8是速度和内存消耗量之间一个不错的折中。默认的最大负载系数时1.0，意思是通常碰撞会发生在rehash之前。<br>reverse与rehash的区别在于：如果在大负载系数时0.7而你打算准备100个元素，你必须将100初一0.7。也就是你必须传入143给rehash以避免在最高达到100个元素的情况下出现进一步rehash。如果使用reverse，这一计算是内部进行的额，所以你可以仅仅传递hashtable应该筹备的元素个数：<br>rehash：Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count &lt; size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor().<br>reverse：Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor())).  </p>
<h2 id="Unordered容器的其他操作"><a href="#Unordered容器的其他操作" class="headerlink" title="Unordered容器的其他操作"></a>Unordered容器的其他操作</h2><p>Unordered左右两端容器必须有相同类型，更明确地说是其hash function的类型以及equivalence criterion(等价标准)必须相同，即使hash函数本身可能不同。<br>与map/multimap对应的是unordered map/multimap的元素类型是pair<const key,="" t="">，意味着你需要first和second才能范文一个元素的key和value。  </const></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem&amp; : coll)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"key："</span> &lt;&lt; elem.first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改变key的值会导致错误，改变元素的value就没问题，只要elem是个non-const reference且value的类型不是const：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem.second = <span class="number">13.5</span>;</span><br></pre></td></tr></table></figure>
<p>如果你是用算法和lambda来操作map内的元素，你必须明确元素类型，可以查看<a href="http://www.coordinate.wang/cpp/2017/04/29/STL%E5%AE%B9%E5%99%A87Map%E5%92%8CMutimap.html" target="_blank" rel="noopener">map的例子</a><br>一般而言，erasing函数并不会令“指向至其他元素”的iterator和reference失效。然而成员函数insert和emplace有可能令所有iterator失效，当rehashing发生，尽管指向元素的reference将总是保持有效。rehashing之所以发生，是由于一次安插动作造成最终元素的个数大于等于bucket数量乘以最大负载系数。insert和emplace成员函数不会影响指向容器元素的reference的有效性。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/24/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/26/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/13/2018-09-13-Leetcode-130-被围绕的区域（最详细的解法！！！）/">Leetcode 130：被围绕的区域（最详细的解法！！！）</a></h6>
              <span>九月 13, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/13/2018-09-13-Leetcode-200-岛屿的个数（最详细的解法！！！）/">Leetcode 200：岛屿的个数（最详细的解法！！！）</a></h6>
              <span>九月 13, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/12/2018-09-12-Leetcode-401-二进制手表（最详细的解法！！！）/">Leetcode 401：二进制手表（最详细的解法！！！）</a></h6>
              <span>九月 12, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/12/2018-09-12-Leetcode-79-单词搜索（最详细的解法！！！）/">Leetcode 79：单词搜索（最详细的解法！！！）</a></h6>
              <span>九月 12, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/11/2018-09-11-Leetcode-90-子集 II（最详细的解法！！！）/">Leetcode 90：子集 II（最详细的解法！！！）</a></h6>
              <span>九月 11, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/09/10/2018-09-10-Leetcode-40-组合总和 II（最详细的解法！！！）/">Leetcode 40：组合总和 II（最详细的解法！！！）</a></h6>
              <span>九月 10, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">78</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">112</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.67px;">1080ti</a> <a href="/tags/ADL/" style="font-size: 10px;">ADL</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.33px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.33px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/JSON/" style="font-size: 10.67px;">JSON</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means</a> <a href="/tags/K-means/" style="font-size: 10px;">K-means++</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/Li-Fei-Fei/" style="font-size: 10px;">Li Fei Fei</a> <a href="/tags/MNIST/" style="font-size: 10.67px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.67px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/Pickle/" style="font-size: 10px;">Pickle</a> <a href="/tags/QT/" style="font-size: 11.33px;">QT</a> <a href="/tags/SNIP/" style="font-size: 10px;">SNIP</a> <a href="/tags/Ubuntu/" style="font-size: 11.33px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 14.67px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.67px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/big-file/" style="font-size: 10px;">big file</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 19.33px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 18.67px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 18px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 16.67px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.33px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 11.33px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.67px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 14.67px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/descriptor/" style="font-size: 10px;">descriptor</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.33px;">error</a> <a href="/tags/estimator/" style="font-size: 11.33px;">estimator</a> <a href="/tags/fire/" style="font-size: 10px;">fire</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/mAP/" style="font-size: 10px;">mAP</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/merge/" style="font-size: 10px;">merge</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.67px;">namehiding</a> <a href="/tags/network/" style="font-size: 12px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 17.33px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.67px;">numpy</a> <a href="/tags/office/" style="font-size: 10.67px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.67px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.67px;">overload</a> <a href="/tags/override/" style="font-size: 10.67px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.67px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/pytorch/" style="font-size: 11.33px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.33px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.33px;">re</a> <a href="/tags/requests/" style="font-size: 10.67px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10.67px;">shell</a> <a href="/tags/signal/" style="font-size: 10.67px;">signal</a> <a href="/tags/sql/" style="font-size: 10.67px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16px;">stl</a> <a href="/tags/super/" style="font-size: 10.67px;">super</a> <a href="/tags/tensorflow/" style="font-size: 14.67px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.67px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.67px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.67px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 16.67px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/时间复杂度/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.67px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.33px;">笔试</a> <a href="/tags/算法/" style="font-size: 14px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.67px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.33px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://www.wangningcheng.com'>梦影无痕</a></li>
        
          <li class='link'><a href='https://blanboom.org'>Blanboom</a></li>
        
      </ul>
  </div>



  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
