<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 12 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/12/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-06-01-C++内存模型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/06/01/2017-06-01-C++内存模型/">C++类对象的内存模型和占用空间</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/01/2017-06-01-C++内存模型/" class="article-date">
	  <time datetime="2017-05-31T16:00:00.000Z" itemprop="datePublished">六月 1, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/chinabinlang/article/details/8614649" target="_blank" rel="noopener">chinabinlang的专栏</a></p>
<p>很多C++书籍中都介绍过，一个Class对象需要占用多大的内存空间。最权威的结论是：  </p>
<ol>
<li>非静态成员变量总合。</li>
<li>加上编译器为了CPU计算，作出的数据对齐处理。</li>
<li>加上为了支持虚函数，产生的额外负担。</li>
</ol>
<p>介绍完了理论知识后，再看看再找一个例子看看（注：一下所有结果都是在VC6.0 开发环境中得出的结论）  </p>
<h2 id="空类的Size"><a href="#空类的Size" class="headerlink" title="空类的Size"></a>空类的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:1</p>
<p>这是为何呢？我想对于这个问题，不仅是刚入行不久的开发新手，就算有过几年以上C++开发经验的开发人员也未必能说清楚这个。<br>编译器在执行Car objCar;这行代码后需要，作出一个Class Car的Object。并且这个Object的地址还是独一无二的，于是编译器就会给空类创建一个隐含的一个字节的空间。  </p>
<h2 id="只有成员变量的Size"><a href="#只有成员变量的Size" class="headerlink" title="只有成员变量的Size"></a>只有成员变量的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>这个结果很多开发人员都清楚。在32位系统中，整型变量占4个字节。这里Class Car中含有两个整型类型的成员变量，所以Class Size是8。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sHigh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>我们这次在Class Car中添加了一个静态成员变量，但是Class Size仍然是8个字节。这正好符合了，结论中的第一条：非静态成员变量总合。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> chLogo</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sHigh;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:12  </p>
<p>在类中又插入了一个字符型变量，结果Class Size变成了12。这个就是编译器额外添加3个字符变量，做数据对齐处理，为了是提高CPU的计算速度。编译器额外添加的东西我们是无法看见的。这也符合了结论中的第二条：加上编译器为了CPU计算，作出的数据对齐处理。  </p>
<p>既然，我们这样定义类成员数据编译器会额外的增加空。那么，我们何不在定义类的时候就考虑到数据对齐的问题，可以多定义出3个字符类型变量作为预留变量，既能满足数据对齐的要求，也给自己的程序添加了一些可扩展的空间。  </p>
<h2 id="只有成员函数的Size"><a href="#只有成员函数的Size" class="headerlink" title="只有成员函数的Size"></a>只有成员函数的Size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:1  </p>
<p>噢，这是怎么回事儿呢？再做一个实验看看。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nLength;</span><br><span class="line">    <span class="keyword">int</span> nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:8  </p>
<p>这次应该很清楚的了。函数是不占用类空间的。第一个例子中的Size为1个字节，正是编译器为类创建一个隐含的一个字节的空间  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Car()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Car objCar;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(objCar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d /r"</span>, <span class="string">"Class Car Size:"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Class Car Size:4  </p>
<p>这次，让析构函数为虚函数，看到了Class Size为4。<strong>这正是指向Virtual Table的指针vptr的Size。</strong>这正好符合了，结论中的第三条：加上为了支持虚函数，产生的额外负担。<br>到此为止，一个Class Object究竟占用多少内存空间，已经完全说清楚了。但是，这只是针对单独类，或者说是基类适用。对于子类，却不一样了。有兴趣的朋友可以做一些实验。  </p>
<h1 id="other-example"><a href="#other-example" class="headerlink" title="other example"></a>other example</h1><p>先看两段代码：<br>代码段1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of A = "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of A =<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>代码段2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print3</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of A = "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of A =<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对象的大小是它的数据成员所占存储空间之和，就和结构体一样。类中的函数是所有该类对象通用的方法，不算作对象的成员，因此也不算在对象的存储空间内。  </p>
<p>问题：类里面不管有多少个函数，这个类的对象只占1个字节的内存。这个字节的内存的内容是什么？是指针吗？指针不是占4个字节吗？<br>当类中类有定义任何变量的时候，类的对象都是1个字节的，当类中没有任何变量的时候，这个类里没有任何真正的成员变量，所以大小应该是0，但0大小不好在内存中定位一个地址，所以，就规定它大小为0的对象要占一字节空间，以便让它拥有一个合法的地址。如果是有派生类的，还有考虑到内存对齐的问题的。  </p>
<p>另外涉及到虚函数的话又不一样了。如  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果sizeof(A)的话，得出的是4。<br>原因是涉及到虚函数的实现问题。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    m_data1;</span><br><span class="line">    m_data2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Class1对象实例<br>通过vptr指针找到虚函数表  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659ly1fg73ltk1rfj204605da9u.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1fg73ltk1rfj204605da9u.jpg" class="img-fluid"><br></a></p>
<p>Vtable(虚函数表)  </p>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659ly1fg73luk3jij203u0583ya.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1fg73luk3jij203u0583ya.jpg" class="img-fluid"><br></a></p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659ly1fg73luwx31j205i05aweb.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1fg73luwx31j205i05aweb.jpg" class="img-fluid"><br></a></p>
<p>所以回到原来的问题，A中只有一个或者几个虚函数的话，没有成员变量，那么类A相当于含有一个vptr指向虚函数表的指针，所以sizeof(A)=4。  </p>
<p>还有一点，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> B2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(B) = <span class="number">1</span>;   <span class="keyword">sizeof</span>(B2) = <span class="number">1</span>;  <span class="keyword">sizeof</span>(C) = <span class="number">1</span>;  <span class="keyword">sizeof</span>(D) = <span class="number">4</span>;  <span class="keyword">sizeof</span>(E) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>空类所占空间为一(上文以解释)，单一继承的空类空间也是1，多重继承的空类空间还是1，但是虚继承涉及到虚表(虚指针)，所以sizeof(D)=4。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-31-C++多态问题小结"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/31/2017-05-31-C++多态问题小结/">C++多态性</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/31/2017-05-31-C++多态问题小结/" class="article-date">
	  <time datetime="2017-05-30T16:00:00.000Z" itemprop="datePublished">五月 31, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://blog.csdn.net/hackbuteer1/article/details/7475622" target="_blank" rel="noopener">Hackbuteer1的专栏</a></p>
<p>C++编程语言是一款应用广泛，支持多种程序设计的计算机编程语言。我们今天就会为大家详细介绍其中C++多态性的一些基本知识，以方便大家在学习过程中对此能够有一个充分的掌握。<br>多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。<br>C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。<br>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。<br>那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。<br>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    B b;  </span><br><span class="line">    A *p = &amp;a;  </span><br><span class="line">    p-&gt;foo();  </span><br><span class="line">    p-&gt;fun();  </span><br><span class="line">    p = &amp;b;  </span><br><span class="line">    p-&gt;foo();  </span><br><span class="line">    p-&gt;fun();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个p-&gt;foo()和p-&gt;fun()都很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数，因此输出结果就是1、2。<br>第二个输出结果就是1、4。p-&gt;foo()和p-&gt;fun()则是基类指针指向子类对象，正式体现多态的用法，p-&gt;foo()由于指针是个基类指针，指向是一个固定偏移量的函数，因此此时指向的就只能是基类的foo()函数的代码了，因此输出的结果还是1。而p-&gt;fun()指针是基类指针，指向的fun是一个虚函数，由于每个虚函数都有一个虚函数列表，此时p调用fun()并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，因此输出的结果也会是子类的结果4。<br>笔试的题目中还有一个另类测试方法。即  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B *ptr = (B *)&amp;a;  ptr-&gt;foo();  ptr-&gt;fun();</span><br></pre></td></tr></table></figure>
<p>问这两调用的输出结果。这是一个用子类的指针去指向一个强制转换为子类地址的基类对象。结果，这两句调用的输出结果是3，2。<br>并不是很理解这种用法，从原理上来解释，由于B是子类指针，虽然被赋予了基类对象地址，但是ptr-&gt;foo()在调用的时候，由于地址偏移量固定，偏移量是子类对象的偏移量，于是即使在指向了一个基类对象的情况下，还是调用到了子类的函数，虽然可能从始到终都没有子类对象的实例化出现。<br>而ptr-&gt;fun()的调用，可能还是因为C++多态性的原因，由于指向的是一个基类对象，通过虚函数列表的引用，找到了基类中fun()函数的地址，因此调用了基类的函数。由此可见多态性的强大，可以适应各种变化，不论指针是基类的还是子类的，都能找到正确的实现方法。<br>关于向上向下造型可以看这篇<a href="Upcasting and Downcasting">Upcasting and Downcasting</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class_B Val_b;</span><br><span class="line">Class_A Val_a = (Class_A*)Val_b;</span><br></pre></td></tr></table></figure>
<p>此刻，Val_a的实函数是Class_A的类型，虚函数是Class_B的类型！！！<br>指针的数据类型是实函数的类型，指针指向的对象的数据类型，是虚函数的数据类型<br><strong>从汇编的角度看，无非是指针的偏移问题，搞清楚哪个指针偏移多少，才是问题的本质。</strong><br><strong>如果想要了解这个问题的本质，就要了解C++内存模型，也就是要知道内存中是如何存放虚函数的。</strong>可以看这篇文章<a href="http://www.coordinate.wang/cpp/2017/06/01/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" target="_blank" rel="noopener">C++类对象的内存模型和占用空间</a></p>
<h2 id="重载与覆盖"><a href="#重载与覆盖" class="headerlink" title="重载与覆盖"></a>重载与覆盖</h2><p>成员函数被重载的特征：  </p>
<ol>
<li>相同的范围（在同一个类中）；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual关键字可有可无。 </li>
</ol>
<p>覆盖是指派生类函数覆盖基类函数，特征是：  </p>
<ol>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有virtual关键字。</li>
</ol>
<h2 id="令人迷惑的隐藏规则"><a href="#令人迷惑的隐藏规则" class="headerlink" title="令人迷惑的隐藏规则"></a>令人迷惑的隐藏规则</h2><p>本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。<br>这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：  </p>
<ol>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小结：1、有virtual才可能发生多态现象  </span></span><br><span class="line"><span class="comment">// 2、不发生多态（无virtual）调用就按原类型调用  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::g(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//多态、覆盖  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::g(int)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//隐藏  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//隐藏  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Derived d;  </span><br><span class="line">    Base *pb = &amp;d;  </span><br><span class="line">    Derived *pd = &amp;d;  </span><br><span class="line">    <span class="comment">// Good : behavior depends solely on type of the object  </span></span><br><span class="line">    pb-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line">    pd-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line">    pb-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Base::g(float)  3.14  </span></span><br><span class="line">    pd-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Derived::g(int) 3   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line">    pb-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Base::h(float) 3.14  </span></span><br><span class="line">    pd-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Derived::h(float) 3.14  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序中：  </p>
<ol>
<li>函数Derived::f(float)覆盖了Base::f(float)。</li>
<li>函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</li>
<li>函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</li>
</ol>
<p>以下内容转自<a href="http://blog.csdn.net/haoel/article/details/1948051/" target="_blank" rel="noopener">陈皓专栏</a></p>
<h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。<br>这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。<br>假设我们有这样的一个类：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Invoke the first virtual function </span></span><br><span class="line"> pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line"> pFun();</span><br></pre></td></tr></table></figure>
<p>实际运行经果如下：(Windows XP+VS2003,  Linux 2.6.22 + GCC 4.1.3)<br>虚函数表地址：0012FED4<br>虚函数表 — 第一个函数地址：0044F148<br>Base::f  </p>
<p>通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int * 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>);  <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>);  <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>);  <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>
<p>这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" class="img-fluid"><br></a></p>
<p>注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。<br>下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。  </p>
<h2 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h2><p>下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：<br>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" class="img-fluid"><br></a></p>
<p>对于实例：Derive d; 的虚函数表如下：  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" class="img-fluid"><br></a></p>
<p>我们可以看到下面几点：  </p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。</li>
</ol>
<p>我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。  </p>
<h2 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h2><p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" class="img-fluid"><br></a></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" class="img-fluid"><br></a></p>
<p>我们从表中可以看到下面几点，  </p>
<ol>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。</li>
</ol>
<p>这样，我们就可以看到对于下面这样的程序，  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derive();</span><br><span class="line">b-&gt;f();</span><br></pre></td></tr></table></figure>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。  </p>
<h2 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h2><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" class="img-fluid"><br></a></p>
<p>对于子类实例中的虚函数表，是下面这个样子：  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" class="img-fluid"><br></a></p>
<p>我们可以看到：  </p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。  </p>
<h2 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h2><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。  </p>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" class="img-fluid"><br></a></p>
<p>下面是对于子类实例中的虚函数表的图：  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" class="img-fluid"><br></a></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line">Base1 *b1 = &amp;d;</span><br><span class="line">Base2 *b2 = &amp;d;</span><br><span class="line">Base3 *b3 = &amp;d;</span><br><span class="line">b1-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b2-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b3-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line"></span><br><span class="line">b1-&gt;g(); <span class="comment">//Base1::g()</span></span><br><span class="line">b2-&gt;g(); <span class="comment">//Base2::g()</span></span><br><span class="line">b3-&gt;g(); <span class="comment">//Base3::g()</span></span><br></pre></td></tr></table></figure>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。  </p>
<ol>
<li>通过父类型的指针访问子类自己的虚函数  </li>
</ol>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1 *b1 = <span class="keyword">new</span> Derive();</span><br><span class="line">b1-&gt;f1();  <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）  </p>
<ol>
<li>访问non-public的虚函数  </li>
</ol>
<p>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。<br>如：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    Fun  pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;d)+<span class="number">0</span>);</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion</span><span class="params">()</span></span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><ol>
<li>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 </li>
<li>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 </li>
</ol>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。  </p>
<h2 id="相似概念"><a href="#相似概念" class="headerlink" title="相似概念"></a>相似概念</h2><ol>
<li>多态性<br>指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。<br>a、编译时多态性：通过重载函数实现<br>b、运行时多态性：通过虚函数实现。 </li>
<li>虚函数<br>虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）</li>
<li>抽象类<br>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多态/">多态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-30-C++类静态成员与类静态成员函数详解"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/">C++类静态成员与类静态成员函数详解</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/" class="article-date">
	  <time datetime="2017-05-29T16:00:00.000Z" itemprop="datePublished">五月 30, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.jb51.net/article/41775.htm" target="_blank" rel="noopener">脚本之家</a><br>当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关。<br>静态数据成员的用途之一是统计有多少个对象实际存在。<br>静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。<br>静态成员不可在类体内进行赋值，因为它是被所有该类的对象所共享的。你在一个对象里给它赋值，其他对象里的该成员也会发生变化。为了避免混乱，所以不可在类体内进行赋值。<br>静态成员的值对所有的对象是一样的。静态成员可以被初始化，但只能在类体外进行初始化。<br>一般形式：<br>数据类型类名：：静态数据成员名＝初值<br>注意：不能用参数初始化表对静态成员初始化。一般系统缺省初始为0。<br>静态成员是类所有的对象的共享的成员，而不是某个对象的成员。它在对象中不占用存储空间，这个属性为整个类所共有，不属于任何一个具体对象。所以静态成员不能在类的内部初始化，比如声明一个学生类，其中一个成员为学生总数，则这个变量就应当声明为静态变量，应该根据实际需求来设置成员变量。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> x;</span><br><span class="line">     <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Getnum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          x+=<span class="number">5</span>;   <span class="comment">// 这行代码是错误的，静态成员函数不能调用非静态数据成员，要通过类的对象来调用。</span></span><br><span class="line">          num+=<span class="number">15</span>;</span><br><span class="line">          <span class="keyword">return</span> num;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> test::num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     test a;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::num&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//10</span></span><br><span class="line">     test::num = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::num&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">//20</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;test::Getnum()&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//35</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.Getnum()&lt;&lt;<span class="built_in">endl</span>;       <span class="comment">//50</span></span><br><span class="line">     system(<span class="string">"pause"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上例可知：  x+=5;   // 这行代码是错误的<br><a href="http://www.jb51.net/article/41941.htm" target="_blank" rel="noopener"><strong>静态函数成员必须通过对象名来访问非静态数据成员</strong></a>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">FunctionA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     menber = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> menber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上述代码，出错。原因很简单大家都知道，静态成员函数不能访问非静态成员，这是因为静态函数属于类而不是属于整个对象，静态函数中的 member可能都没有分配内存。静态成员函数没有隐含的this自变量。所以，它就无法访问自己类的非静态成员。<br>那要想访问怎么办呢？地球人都知道只要将：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> menber;</span><br><span class="line"><span class="comment">//change the line above to:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> menber;</span><br></pre></td></tr></table></figure>
<p>但是这个方法让我们不得不将static function内用到的成员变量都变成static的了，而且static的成员还要显式初始化，有没有更好的方法？答案是肯定的。代码说话：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">FunctionA</span><span class="params">(a* _a)</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">      	_a-&gt; menber = <span class="number">1</span>;</span><br><span class="line">      	<span class="built_in">cout</span>&lt;&lt;_a-&gt; menber&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      	_a-&gt;f();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"f被调用了"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> menber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前提是这个类要分配了内存空间。其实这里我做的就是将一个对象指针作为静态成员函数的“this”指针，意在模仿传递非静态成员函数里this变量(在非静态成员函数中都有this指针(push在ECX中似乎))  </p>
<p>另外，静态成员函数在类外实现时候无须加static关键字，否则是错误的。<br>若在类的体外来实现上述的那个静态成员函数，不能加static关键字，这样写就可以了:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> test::Getnum()</span><br><span class="line">&#123;</span><br><span class="line">	.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>static成员的所有者是类本身和对象，但是多有对象拥有一样的静态成员。从而在定义对象是不能通过构造函数对其进行初始化。</li>
<li>静态成员不能在类定义里边初始化，只能在class body外初始化。</li>
<li>静态成员仍然遵循public，private，protected访问准则。</li>
<li>静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。</li>
</ol>
<p>静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态数据成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Sum;    <span class="comment">//声明静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;       <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line">Myclass::Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">        Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Myclass::GetSum()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Sum="</span> &lt;&lt;Sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">Myclass <span class="title">me</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">        me.GetSum();</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上例可知，非静态成员函数可以任意地访问静态成员函数和静态数据成员。<br>非静态成员函数Myclass(int a,int b,int c)和GetSum()都访问了静态数据成员Sum。<br>静态成员函数不能访问非静态成员函数和非静态数据成员。<br>关于静态成员函数，可以总结为以下几点：</p>
<ol>
<li>出现在类体外的函数定义不能指定关键字static；</li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li>
<li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li>
</ol>
<p>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。静态成员变量只能被静态成员函数调用。静态成员函数也是由同一类中的所有对象共用。只能调用静态成员变量和静态成员函数。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/">lvalue,rvalue,xlvalue,glvalue,prvalue</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/" class="article-date">
	  <time datetime="2017-05-28T16:00:00.000Z" itemprop="datePublished">五月 29, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Value-categories"><a href="#Value-categories" class="headerlink" title="Value categories"></a>Value categories</h1><p>Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: prvalue, xvalue, lvalue, defined as follows:</p>
<ol>
<li>a glvalue is an expression whose evaluation determines the identity of an object, bit-field, or function;</li>
<li>a prvalue is an expression whose evaluation either<ol>
<li>computes the value of the operand of an operator (such prvalue has no result object), or</li>
<li>initializes an object or a bit-field (such prvalue is said to have a result object). All class and array prvalues have a result object even if it is discarded. In certain contexts, temporary materialization occurs to create a temporary as the result object;</li>
</ol>
</li>
<li>an xvalue is a glvalue that denotes an object or bit-field whose resources can be reused;</li>
<li>an lvalue is a glvalue that is not an xvalue;</li>
<li>an rvalue is a prvalue or an xvalue.</li>
</ol>
<p>Note: this taxonomy went through significant changes with past C++ standard revisions, see History below for details.</p>
<h1 id="Primary-categories"><a href="#Primary-categories" class="headerlink" title="Primary categories"></a>Primary categories</h1><h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><p>The following expressions are lvalue expressions:</p>
<ol>
<li>the name of a variable or a function in scope, regardless of type, such as std::cin or std::endl. Even if the variable’s type is rvalue reference, the expression consisting of its name is an lvalue expression;</li>
<li>a function call or an overloaded operator expression of lvalue reference return type, such as std::getline(std::cin, str), std::cout &lt;&lt; 1, str1 = str2, or ++it;</li>
<li>a = b, a += b, a %= b, and all other built-in assignment and compound assignment expressions;</li>
<li>++a and –a, the built-in pre-increment and pre-decrement expressions;</li>
<li>*p, the built-in indirection expression;</li>
<li>a[n] and p[n], the built-in subscript expressions, except where a is an array rvalue (since C++11);</li>
<li>a.m, the member of object expression, except where m is a member enumerator or a non-static member function, or where a is an rvalue and m is a non-static data member of non-reference type;</li>
<li>p-&gt;m, the built-in member of pointer expression, except where m is a member enumerator or a non-static member function;</li>
<li>a.*mp, the pointer to member of object expression, where a is an lvalue and mp is a pointer to data member;</li>
<li>p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to data member;</li>
<li>a, b, the built-in comma expression, where b is an lvalue;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a string literal, such as “Hello, world!”;</li>
<li>a cast expression to lvalue reference type, such as static_cast&lt;int&amp;&gt;(x);</li>
<li>a function call or an overloaded operator expression of rvalue reference to function return type;</li>
<li>a cast expression to rvalue reference to function type, such as static_cast<void (&&)(int)="">(x).<br>(since C++11)</void></li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as glvalue (below).</li>
<li>Address of an lvalue may be taken: &amp;++i[1] and &amp;std::endl are valid expressions.</li>
<li>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</li>
<li>An lvalue may be used to initialize an lvalue reference; this associates a new name with the object identified by the expression.</li>
</ol>
<h2 id="prvalue"><a href="#prvalue" class="headerlink" title="prvalue"></a>prvalue</h2><p>The following expressions are prvalue expressions:</p>
<ol>
<li>a literal (except for string literal), such as 42, true or nullptr;</li>
<li>a function call or an overloaded operator expression of non-reference return type, such as str.substr(1, 2), str1 + str2, or it++;</li>
<li>a++ and a–, the built-in post-increment and post-decrement expressions;</li>
<li>a + b, a % b, a &amp; b, a &lt;&lt; b, and all other built-in arithmetic expressions;</li>
<li>a &amp;&amp; b, a || b, !a, the built-in logical expressions;</li>
<li>a &lt; b, a == b, a &gt;= b, and all other built-in comparison expressions;</li>
<li>&amp;a, the built-in address-of expression;</li>
<li>a.m, the member of object expression, where m is a member enumerator or a non-static member function[2], or where a is an rvalue and m is a non-static data member of non-reference type (until C++11);</li>
<li>p-&gt;m, the built-in member of pointer expression, where m is a member enumerator or a non-static member function[2];</li>
<li>a.*mp, the pointer to member of object expression, where mp is a pointer to member function[2], or where a is an rvalue and mp is a pointer to data member (until C++11);</li>
<li>p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to member function[2];</li>
<li>a, b, the built-in comma expression, where b is an rvalue;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a cast expression to non-reference type, such as static_cast<double>(x), std::string{}, or (int)42;</double></li>
<li>the this pointer;</li>
<li>a lambda expression, such as <a href="int x"></a>{ return x * x; }.(since C++11)</li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as rvalue (below).</li>
<li>A prvalue cannot be polymorphic: the dynamic type of the object it identifies is always the type of the expression.</li>
<li>A non-class non-array prvalue cannot be cv-qualified. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</li>
<li>A prvalue cannot have incomplete type (except for type void, see below, or when used in decltype specifier).</li>
</ol>
<h2 id="xvalue"><a href="#xvalue" class="headerlink" title="xvalue"></a>xvalue</h2><p>The following expressions are xvalue expressions:</p>
<ol>
<li>a function call or an overloaded operator expression of rvalue reference to object return type, such as std::move(x);</li>
<li>a[n], the built-in subscript expression, where one operand is an array rvalue ;</li>
<li>a.m, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference type;</li>
<li>a.*mp, the pointer to member of object expression, where a is an rvalue and mp is a pointer to data member;</li>
<li>a ? b : c, the ternary conditional expression for some a, b, and c;</li>
<li>a cast expression to rvalue reference to object type, such as static_cast&lt;char&amp;&amp;&gt;(x);</li>
<li>any expression that designates a temporary object, after temporary materialization.(since C++17)</li>
</ol>
<p>Properties:</p>
<ol>
<li>Same as rvalue (below).</li>
<li>Same as glvalue (below).</li>
</ol>
<p>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be polymorphic, and non-class xvalues may be cv-qualified.</p>
<h1 id="Mixed-categories"><a href="#Mixed-categories" class="headerlink" title="Mixed categories"></a>Mixed categories</h1><h2 id="glvalue"><a href="#glvalue" class="headerlink" title="glvalue"></a>glvalue</h2><p>A glvalue expression is either lvalue or xvalue.<br>Properties:</p>
<ol>
<li>A glvalue may be implicitly converted to a prvalue with lvalue-to-rvalue, array-to-pointer, or function-to-pointer implicit conversion.</li>
<li>A glvalue may be polymorphic: the dynamic type of the object it identifies is not necessarily the static type of the expression.</li>
<li>A glvalue can have incomplete type, where permitted by the expression.</li>
</ol>
<h2 id="rvalue"><a href="#rvalue" class="headerlink" title="rvalue"></a>rvalue</h2><p>An rvalue expression is either prvalue or xvalue.<br>Properties:</p>
<ol>
<li>Address of an rvalue may not be taken: &amp;int(), &amp;i++[3], &amp;42, and &amp;std::move(x) are invalid.</li>
<li>An rvalue can’t be used as the left-hand operand of the built-in assignment or compound assignment operators.</li>
<li>An rvalue may be used to initialize a const lvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends.</li>
<li>An rvalue may be used to initialize an rvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends.</li>
<li>When used as a function argument and when two overloads of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the move constructor, and likewise with copy and move assignment operators).</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    S () = <span class="keyword">default</span> ;</span><br><span class="line">    S (<span class="keyword">const</span> S &amp;) = <span class="keyword">delete</span> ;</span><br><span class="line">    S &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> S &amp;) = <span class="keyword">delete</span> ;</span><br><span class="line">    S (S &amp;&amp;) = <span class="keyword">default</span> ;</span><br><span class="line">    S &amp;<span class="keyword">operator</span>= (S &amp;&amp;) = <span class="keyword">default</span> ;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    S p0 ;</span><br><span class="line">    S p1[<span class="number">2</span>] ;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    S p0 = A ().p0 ;</span><br><span class="line">    S p1 = A ().p1[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p1哪里是编译不通过的，A ().p1[0]不是右值<br>好像不满足xvalue的描述  </p>
<p>A().p1[0] 的意思是（实际上也是这么运作的）先计算A().p1（这是一个lvalue，而不是xvalue，因为 3）的要求是m为非引用，当然也就是非指针了。 ）， 再取它的第1个元素（根据lvalue的性质，这当然也是一个左值了）。<br>一言以蔽之，A().p1[0] 的运算顺序是(A().p1)[0]，是一个lvalue，而不是xvalue（在C++11中）。<br>PS： ‘.’的优先级和[]一样，因此，从左到右计算。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glvalue/">glvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lvalue/">lvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/prvalue/">prvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rvalue/">rvalue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xlvalue/">xlvalue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-27-迭代器相关的辅助函数"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/27/2017-05-27-迭代器相关的辅助函数/">迭代器相关的辅助函数</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/27/2017-05-27-迭代器相关的辅助函数/" class="article-date">
	  <time datetime="2017-05-26T16:00:00.000Z" itemprop="datePublished">五月 27, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h2><p>定义于头文件\&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">Distance</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>( <span class="title">InputIt</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span> );</span></span><br></pre></td></tr></table></figure>
<p>增加迭代器it n个元素。如果n为负，迭代器递减。在这种情况下，InputIt的BidirectionalIterator必须满足的要求，否则该行为是未定义。<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> vi = v.begin();</span><br><span class="line">    <span class="built_in">std</span>::advance(vi, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *vi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为 4  </p>
<h2 id="next和prev"><a href="#next和prev" class="headerlink" title="next和prev"></a>next和prev</h2><p>定义于头文件 \&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">next</span>( <span class="title">ForwardIt</span> <span class="title">it</span>, </span></span><br><span class="line"><span class="class">                <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>返回的nth的继任者的迭代器it。<br>定义于头文件\&lt;iterator>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirIt</span> <span class="title">prev</span>( <span class="title">BidirIt</span> <span class="title">it</span>, </span></span><br><span class="line"><span class="class">              <span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>返回的nth的前身迭代器it。<br>前面提到了next的一个有效的用处就是在forward和bidirectional迭代器。<br>里一个用处主要是before_begin  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> posBefore = <span class="built_in">list</span>.before_begin();</span><br><span class="line"><span class="keyword">for</span>(; next(posBefore) != <span class="built_in">list</span>.end(); ++posBefore)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(*next(posBefore) %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:iterator_traits&lt;InputIt&gt;::difference_type </span><br><span class="line">    distance( InputIt first, InputIt last );</span><br></pre></td></tr></table></figure>
<p>返回first和last之间的元素数量。如果last不能由first递增得到，则函数的行为是未定义的。<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">     <span class="keyword">auto</span> distance = <span class="built_in">std</span>::distance(v.begin(), v.end());</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为3  </p>
<p>处理两个non-random-access迭代器之间的距离时要十分小心。第一迭代器所知的元素绝对不能在第二迭代器所指元素的后方，否则会导致不明确的行为。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iter_swap</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt1</span>, <span class="title">class</span> <span class="title">ForwardIt2</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">iter_swap</span>( <span class="title">ForwardIt1</span> <span class="title">a</span>, <span class="title">ForwardIt2</span> <span class="title">b</span> );</span></span><br></pre></td></tr></table></figure>
<p>交换给定的迭代器指向的元素的值。迭代器的类型不必相同，但其所指的两个值必须可以相互赋值。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 1 to 9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">    <span class="comment">// swap first and second value</span></span><br><span class="line">    iter_swap (coll.begin(), next(coll.begin()));</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">    <span class="comment">// swap first and last value</span></span><br><span class="line">    iter_swap (coll.begin(), prev(coll.end()));</span><br><span class="line">    PRINT_ELEMENTS(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意，next和prev始自c++11，因此若以operator++和—取而代之，可以参看前面讲的内容。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-26-迭代器种类"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/26/2017-05-26-迭代器种类/">迭代器种类</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/26/2017-05-26-迭代器种类/" class="article-date">
	  <time datetime="2017-05-25T16:00:00.000Z" itemprop="datePublished">五月 26, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Output迭代器"><a href="#Output迭代器" class="headerlink" title="Output迭代器"></a>Output迭代器</h2><p>输出迭代器（OutputIterator）是能写入所指元素的迭代器（Iterator）。<br>实现输出迭代器（OutputIterator）的类型的例子是 std::ostream_iterator。<br>当向前迭代器（ForwardIterator）、双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）在自身的要求之上满足的输出迭代器（OutputIterator）要求时，它被描述为可变的。  </p>
<h2 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h2><p>输入迭代器（InputIterator）是能从所指向元素读取的迭代器（Iterator）。输入迭代器（InputIterator）仅保证单趟算法的合法性：一旦 InputIterator i 被自增，则所有其先前值的副本都可能变得非法。<br>Input迭代器只能读取元素一次。如果你复制input迭代器，并令源input迭代器和新产生的拷贝都向前读取，可能会遍历到不同的值。  </p>
<h2 id="Forward（前向）迭代器"><a href="#Forward（前向）迭代器" class="headerlink" title="Forward（前向）迭代器"></a>Forward（前向）迭代器</h2><p>向前迭代器（ForwardIterator）是一种能从所指向元素读取数据的迭代器（Iterator）。<br>不同于输入迭代器（InputIterator）和输出迭代器（OutputIterator），它能被用于多趟算法。<br>和input迭代器不同的是，两个forward迭代器如果指向同一个元素，operator==会获得true，如果两者都递增，会再次指向同一元素。<br>有以下对象和类型提供：  </p>
<ol>
<li>class forward_list&lt;&gt;</li>
<li>unordered容器</li>
</ol>
<h2 id="Bidirectional（双向迭代器）"><a href="#Bidirectional（双向迭代器）" class="headerlink" title="Bidirectional（双向迭代器）"></a>Bidirectional（双向迭代器）</h2><p>双向迭代器（BidirectionalIterator）是能双向移动（即自增与自减）的向前迭代器（ForwardIterator）。<br>有以下对象和类型提供：  </p>
<ol>
<li>class list&lt;&gt;</li>
<li>associative容器</li>
</ol>
<h2 id="RandomAccess（随机访问）迭代器"><a href="#RandomAccess（随机访问）迭代器" class="headerlink" title="RandomAccess（随机访问）迭代器"></a>RandomAccess（随机访问）迭代器</h2><p>随机访问迭代器（RandomAccessIterator）是能在常数时间内移动到指向任何元素的双向迭代器（BidirectionalIterator）。<br>指向数组元素的指针满足所有随机访问迭代器（RandomAccessIterator）的要求。<br>有以下对象和类型提供：  </p>
<ol>
<li>可随机访问的容器（array、vector、deque）</li>
<li>string（string、wstring）</li>
<li>寻常的c-style（pointer）</li>
</ol>
<h2 id="Vector迭代器的increment和decrement"><a href="#Vector迭代器的increment和decrement" class="headerlink" title="Vector迭代器的increment和decrement"></a>Vector迭代器的increment和decrement</h2><p>一般而言你可以递增或递减临时性迭代器，但对于array、vector和string就不行。例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(++coll.begin(), coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译++coll.begin可能会失败，但是如果使用的是deque就不会。原因是，vector、array和string的迭代器通常被实现为寻常pointer，而C++并不允许你修改任何基础类型的临时类型（包括pointer）的临时对象，但对于struct和class就允许。<br>因此，上面的代码对于vector、array和string以外的容器都没问题，因为那些容器的迭代器都不可能是寻常pointer。但对于vector、array和string，上面的代码是否可行就取决于具体实现。<br>在c++11之前的做法是使用一个辅助对象::  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>:<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = coll.begin();</span><br><span class="line">	<span class="built_in">std</span>::sort(++beg, coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11之后可以使用next   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"><span class="keyword">if</span>(coll.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(<span class="built_in">std</span>::next(coll.begin()), coll.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-25-STL容器8无序容器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/25/2017-05-25-STL容器8无序容器/">STL容器（8）无序容器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/25/2017-05-25-STL容器8无序容器/" class="article-date">
	  <time datetime="2017-05-24T16:00:00.000Z" itemprop="datePublished">五月 25, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义于头文件\&lt;unordered_set>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_set</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序集合是一个关联容器，包含一些类型为Key的唯一对象。搜索，插入和删除具有平摊的常数时间复杂度。<br>定义于头文件\&lt;unordered_set>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_multiset</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序多重集合是一个关联容器，含有一些类型为Key的，可能不是唯一的对象。搜索，插入和删除具有平摊的常数时间复杂度。<br>定义于头文件 \&lt;unordered_map>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序映射是一个关联容器，包含带有唯一键的键值对。搜索，插入和去除具有平摊的常数时间复杂度。<br>定义于头文件 \&lt;unordered_map>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_multimap</span>;</span></span><br></pre></td></tr></table></figure>
<p>(C++11 起)<br>无序多重映射是一个无序关联容器，支持多个相等的键（unordered_multimap中，每个键对应的值可能不唯一）以及相关联的另一种类型的值。unordered_multimap类支持前向迭代器。搜索，插入和去除具有平摊的常数时间复杂度。  </p>
<h2 id="Unordered容器能力"><a href="#Unordered容器能力" class="headerlink" title="Unordered容器能力"></a>Unordered容器能力</h2><p>Unordered容器比起寻常的associative容器，要的优点是：在安插、删除、查找元素时获得amortized常量时间，因为偶尔发生的rehashing可能是个大型操作。主要缺点是：Unordered容器不提供operator&lt;、&gt;、&lt;=和&gt;=这些容器的多重实例。不提供lower_bound和upper_bound。由于iterator只保证至少是个forward iterator，所以别的迭代器的算法都是用不了。<br>由于元素的(key)value关系到元素的位置，所以不可以直接修改(key)value，通过iterator访问时，元素的(key)value是常量。<br>Erase函数不会造成指向元素的iterator、reference和pointer失效。在调用insert、reserve和clear、rehash时会rehashing。  </p>
<h2 id="创建和控制Unordered容器"><a href="#创建和控制Unordered容器" class="headerlink" title="创建和控制Unordered容器"></a>创建和控制Unordered容器</h2><p>欲定义最大负载系数，你必须在构建后立刻调用一个成员函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; coll;</span><br><span class="line">coll.max_load_factor(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure>
<p>通常0.7~0.8是速度和内存消耗量之间一个不错的折中。默认的最大负载系数时1.0，意思是通常碰撞会发生在rehash之前。<br>reverse与rehash的区别在于：如果在大负载系数时0.7而你打算准备100个元素，你必须将100初一0.7。也就是你必须传入143给rehash以避免在最高达到100个元素的情况下出现进一步rehash。如果使用reverse，这一计算是内部进行的额，所以你可以仅仅传递hashtable应该筹备的元素个数：<br>rehash：Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count &lt; size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor().<br>reverse：Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor())).  </p>
<h2 id="Unordered容器的其他操作"><a href="#Unordered容器的其他操作" class="headerlink" title="Unordered容器的其他操作"></a>Unordered容器的其他操作</h2><p>Unordered左右两端容器必须有相同类型，更明确地说是其hash function的类型以及equivalence criterion(等价标准)必须相同，即使hash函数本身可能不同。<br>与map/multimap对应的是unordered map/multimap的元素类型是pair<const key,="" t="">，意味着你需要first和second才能范文一个元素的key和value。  </const></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem&amp; : coll)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"key："</span> &lt;&lt; elem.first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改变key的值会导致错误，改变元素的value就没问题，只要elem是个non-const reference且value的类型不是const：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem.second = <span class="number">13.5</span>;</span><br></pre></td></tr></table></figure>
<p>如果你是用算法和lambda来操作map内的元素，你必须明确元素类型，可以查看<a href="http://www.coordinate.wang/cpp/2017/04/29/STL%E5%AE%B9%E5%99%A87Map%E5%92%8CMutimap.html" target="_blank" rel="noopener">map的例子</a><br>一般而言，erasing函数并不会令“指向至其他元素”的iterator和reference失效。然而成员函数insert和emplace有可能令所有iterator失效，当rehashing发生，尽管指向元素的reference将总是保持有效。rehashing之所以发生，是由于一次安插动作造成最终元素的个数大于等于bucket数量乘以最大负载系数。insert和emplace成员函数不会影响指向容器元素的reference的有效性。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-24-多种语言实现贪吃蛇（c）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/24/2017-05-24-多种语言实现贪吃蛇（c）/">多种语言实现贪吃蛇（c）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/24/2017-05-24-多种语言实现贪吃蛇（c）/" class="article-date">
	  <time datetime="2017-05-23T16:00:00.000Z" itemprop="datePublished">五月 24, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/c/">c</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************************************************************</span></span><br><span class="line"><span class="comment">**文件:snake.c</span></span><br><span class="line"><span class="comment">**编写者:coordinate</span></span><br><span class="line"><span class="comment">**编写日期:2017_6_2</span></span><br><span class="line"><span class="comment">**简要描述:贪吃蛇游戏</span></span><br><span class="line"><span class="comment">**运行环境:vs2015</span></span><br><span class="line"><span class="comment">**************************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> length 30 <span class="comment">// map length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> width 30  <span class="comment">// map width</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[length][width] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gameover flag</span></span><br><span class="line"><span class="keyword">int</span> gameover = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//time status</span></span><br><span class="line"><span class="keyword">char</span> status;</span><br><span class="line"><span class="keyword">int</span> sleepTime = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//food coordiante</span></span><br><span class="line"><span class="keyword">int</span> food[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//snake struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNAKE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNAKE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;snake;</span><br><span class="line"></span><br><span class="line">snake *head;	<span class="comment">//snake head</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSnake</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endGame</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitself</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crosswall</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameControl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"■"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"  "</span>);</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || i== length<span class="number">-1</span> || j == width - <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">map</span>[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create Snake</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSnake</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	snake *tail;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	tail = (snake*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line">	tail-&gt;x = length / <span class="number">2</span>;</span><br><span class="line">	tail-&gt;y = width / <span class="number">2</span>;</span><br><span class="line">	tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		head = (snake*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		head-&gt;x = length / <span class="number">2</span> +  i;</span><br><span class="line">		head-&gt;y = width / <span class="number">2</span>;</span><br><span class="line">		tail = head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (tail != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">map</span>[tail-&gt;x][tail-&gt;y] = <span class="number">1</span>;</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//makefood</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	food[<span class="number">0</span>] = rand() % (length - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">	food[<span class="number">1</span>] = rand() % (width - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">map</span>[food[<span class="number">0</span>]][food[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bitself</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitself</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	snake *self;</span><br><span class="line">	self = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (self != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (self-&gt;x == head-&gt;x &amp;&amp; self-&gt;y == head-&gt;y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		self = self-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cross wall</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crossWall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head-&gt;x == <span class="number">0</span> || head-&gt;x == length - <span class="number">1</span> || </span><br><span class="line">		head-&gt;y == <span class="number">0</span> || head-&gt;y == width - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		endGame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(snake * nextthead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nextthead-&gt;x == food[<span class="number">0</span>] &amp;&amp; nextthead-&gt;y == food[<span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		nextthead-&gt;next = head;</span><br><span class="line">		head = nextthead;</span><br><span class="line">		snake *q = head;</span><br><span class="line">		<span class="keyword">while</span> (q -&gt;next!= <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">map</span>[q-&gt;x][q-&gt;y] = <span class="number">1</span>;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">map</span>[q-&gt;x][q-&gt;y] = <span class="number">0</span>;</span><br><span class="line">		makeFood();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		nextthead-&gt;next = head;</span><br><span class="line">		head = nextthead;</span><br><span class="line">		snake *q = head;</span><br><span class="line">		<span class="keyword">while</span> (q-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">map</span>[q-&gt;x][q-&gt;y] = <span class="number">1</span>;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">map</span>[q-&gt;next-&gt;x][q-&gt;next-&gt;y] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">free</span>(q-&gt;next);</span><br><span class="line">		q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">map</span>[q-&gt;x][q-&gt;y] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bitself())</span><br><span class="line">	&#123;</span><br><span class="line">		endGame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//snake move</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">snakeMove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	snake *nextthead;</span><br><span class="line">	crosswall();</span><br><span class="line"></span><br><span class="line">	nextthead = (snake *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(snake));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (status)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">		nextthead-&gt;x = head-&gt;x - <span class="number">1</span>;</span><br><span class="line">		nextthead-&gt;y = head-&gt;y;</span><br><span class="line">		move(nextthead);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">		nextthead-&gt;x = head-&gt;x;</span><br><span class="line">		nextthead-&gt;y = head-&gt;y - <span class="number">1</span>;</span><br><span class="line">		move(nextthead);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">		nextthead-&gt;x = head-&gt;x + <span class="number">1</span>;</span><br><span class="line">		nextthead-&gt;y = head-&gt;y;</span><br><span class="line">		move(nextthead);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">		nextthead-&gt;x = head-&gt;x;</span><br><span class="line">		nextthead-&gt;y = head-&gt;y + <span class="number">1</span>;</span><br><span class="line">		move(nextthead);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		nextthead-&gt;x = head-&gt;x + <span class="number">1</span>;</span><br><span class="line">		nextthead-&gt;y = head-&gt;y;</span><br><span class="line">		move(nextthead);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cntrol game</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameControl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> key = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (_kbhit())</span><br><span class="line">	&#123;</span><br><span class="line">		key = _getch();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (key)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'w'</span>:	<span class="comment">//up</span></span><br><span class="line">		status = <span class="string">'w'</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'a'</span>:	<span class="comment">//left</span></span><br><span class="line">		status = <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'s'</span>:	<span class="comment">//down</span></span><br><span class="line">		status = <span class="string">'s'</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'d'</span>:	<span class="comment">//right</span></span><br><span class="line">		status = <span class="string">'d'</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//end game</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Game Over"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	createMap();</span><br><span class="line">	createSnake();</span><br><span class="line">	makeFood();</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gameControl();</span><br><span class="line">		snakeMove();</span><br><span class="line">		Sleep(<span class="number">200</span>);</span><br><span class="line">		system(<span class="string">"cls"</span>);</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/c/">c</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/game/">game</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/贪吃蛇/">贪吃蛇</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-23-缓冲区溢出攻击"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/23/2017-05-23-缓冲区溢出攻击/">缓冲区溢出攻击</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/23/2017-05-23-缓冲区溢出攻击/" class="article-date">
	  <time datetime="2017-05-22T16:00:00.000Z" itemprop="datePublished">五月 23, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/信息安全/">信息安全</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">Florian</a><br>缓冲区溢出（Buffer Overflow）是计算机安全领域内既经典而又古老的话题。随着计算机系统安全性的加强，传统的缓冲区溢出攻击方式可能变得不再奏效，相应的介绍缓冲区溢出原理的资料也变得“大众化”起来。其中看雪的《0day安全：软件漏洞分析技术》一书将缓冲区溢出攻击的原理阐述得简洁明了。本文参考该书对缓冲区溢出原理的讲解，并结合实际的代码实例进行验证。不过即便如此，完成一个简单的溢出代码也需要解决很多书中无法涉及的问题，尤其是面对较新的具有安全特性的编译器——比如MS的Visual Studio2010。接下来，我们结合具体代码，按照对缓冲区溢出原理的循序渐进地理解方式去挖掘缓冲区溢出背后的底层机制。  </p>
<h1 id="一、代码-lt-gt-数据"><a href="#一、代码-lt-gt-数据" class="headerlink" title="一、代码 &lt;=&gt; 数据"></a>一、代码 &lt;=&gt; 数据</h1><p>顾名思义，缓冲区溢出的含义是为缓冲区提供了多于其存储容量的数据，就像往杯子里倒入了过量的水一样。通常情况下，缓冲区溢出的数据只会破坏程序数据，造成意外终止。但是如果有人精心构造溢出数据的内容，那么就有可能获得系统的控制权！如果说用户（也可能是黑客）提供了水——缓冲区溢出攻击的数据，那么系统提供了溢出的容器——缓冲区。<br>缓冲区在系统中的表现形式是多样的，高级语言定义的变量、数组、结构体等在运行时可以说都是保存在缓冲区内的，因此所谓缓冲区可以更抽象地理解为一段可读写的内存区域，缓冲区攻击的最终目的就是希望系统能执行这块可读写内存中已经被蓄意设定好的恶意代码。按照冯·诺依曼存储程序原理，程序代码是作为二进制数据存储在内存的，同样程序的数据也在内存中，因此直接从内存的二进制形式上是无法区分哪些是数据哪些是代码的，这也为缓冲区溢出攻击提供了可能。  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659ly1ffwau3ghkrj20ei0ir402.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1ffwau3ghkrj20ei0ir402.jpg" class="img-fluid"><br></a></p>
<p><center>图1 进程地址空间分布</center><br>图1是进程地址空间分布的简单表示。代码存储了用户程序的所有可执行代码，在程序正常执行的情况下，程序计数器（PC指针）只会在代码段和操作系统地址空间（内核态）内寻址。数据段内存储了用户程序的全局变量，文字池等。栈空间存储了用户程序的函数栈帧（包括参数、局部数据等），实现函数调用机制，它的数据增长方向是低地址方向。堆空间存储了程序运行时动态申请的内存数据等，数据增长方向是高地址方向。除了代码段和受操作系统保护的数据区域，其他的内存区域都可能作为缓冲区，因此缓冲区溢出的位置可能在数据段，也可能在堆、栈段。如果程序的代码有软件漏洞，恶意程序会“教唆”程序计数器从上述缓冲区内取指，执行恶意程序提供的数据代码！本文分析并实现栈溢出攻击方式。  </p>
<h1 id="二、函数栈帧"><a href="#二、函数栈帧" class="headerlink" title="二、函数栈帧"></a>二、函数栈帧</h1><p>栈的主要功能是实现函数的调用。因此在介绍栈溢出原理之前，需要弄清函数调用时栈空间发生了怎样的变化。每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为函数调用的栈帧，而且是每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。  </p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659ly1ffwau3oikoj20y90g3dj1.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1ffwau3oikoj20y90g3dj1.jpg" class="img-fluid"><br></a></p>
<p><center>图2 函数栈帧</center><br>如图所示，我们定义了一个简单的函数function，它接受一个整形参数，做一次乘法操作并返回。当调用function(0)时，arg参数记录了值0入栈，并将call function指令下一条指令的地址0x00bd16f0保存到栈内，然后跳转到function函数内部执行。每个函数定义都会有函数头和函数尾代码，如图绿框表示。因为函数内需要用ebp保存函数栈帧基址，因此先保存ebp原来的值到栈内，然后将栈指针esp内容保存到ebp。函数返回前需要做相反的操作——将esp指针恢复，并弹出ebp。这样，函数内正常情况下无论怎样使用栈，都不会使栈失去平衡。<br>sub esp,44h指令为局部变量开辟了栈空间，比如ret变量的位置。理论上，function只需要再开辟4字节空间保存ret即可，但是编译器开辟了更多的空间（这个问题很诡异，你觉得呢？）。函数调用结束返回后，函数栈帧恢复到保存参数0时的状态，为了保持栈帧平衡，需要恢复esp的内容，使用add esp,4将压入的参数弹出 。<br>之所以会有缓冲区溢出的可能，主要是因为栈空间内保存了函数的返回地址。该地址保存了函数调用结束后后续执行的指令的位置，对于计算机安全来说，该信息是很敏感的。如果有人恶意修改了这个返回地址，并使该返回地址指向了一个新的代码位置，程序便能从其它位置继续执行。  </p>
<h1 id="三、栈溢出基本原理"><a href="#三、栈溢出基本原理" class="headerlink" title="三、栈溢出基本原理"></a>三、栈溢出基本原理</h1><p>上边给出的代码是无法进行溢出操作的，因为用户没有“插足”的机会。但是实际上很多程序都会接受用户的外界输入，尤其是当函数内的一个数组缓冲区接受用户输入的时候，一旦程序代码未对输入的长度进行合法性检查的话，缓冲区溢出便有可能触发！比如下边的一个简单的函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[BUF_LEN];</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)buffer,(<span class="keyword">char</span>*)data);<span class="comment">//溢出点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数没有做什么有“意义”的事情（这里主要是为了简化问题），但是它是一个典型的栈溢出代码。在使用不安全的strcpy库函数时，系统会盲目地将data的全部数据拷贝到buffer指向的内存区域。buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，便会产生缓冲区溢出。  </p>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau3ulkpj20o00gp0vi.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau3ulkpj20o00gp0vi.jpg" class="img-fluid"><br></a></p>
<p><center>图3 缓冲区溢出</center><br>由于栈是低地址方向增长的，因此局部数组buffer的指针在缓冲区的下方。当把data的数据拷贝到buffer内时，超过缓冲区区域的高地址部分数据会“淹没”原本的其他栈帧数据，根据淹没数据的内容不同，可能会有产生以下情况：  </p>
<ol>
<li>淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。</li>
<li>淹没了ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。</li>
<li>淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！</li>
<li>淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。</li>
<li>淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改（这可能很麻烦！）。  </li>
</ol>
<p>如果在data本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的其实位置，那么就完成了基本的溢出攻击行为。  </p>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau42a46j20da0h70u1.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau42a46j20da0h70u1.jpg" class="img-fluid"><br></a></p>
<p><center>图4 基本栈溢出攻击</center><br>通过计算返回地址内存区域相对于buffer的偏移，并在对应位置构造新的地址指向buffer内部二进制代码的其实位置，便能执行用户的自定义代码！这段既是代码又是数据的二进制数据被称为shellcode，因为攻击者希望通过这段代码打开系统的shell，以执行任意的操作系统命令——比如下载病毒，安装木马，开放端口，格式化磁盘等恶意操作。</p>
<h1 id="四、栈溢出攻击"><a href="#四、栈溢出攻击" class="headerlink" title="四、栈溢出攻击"></a>四、栈溢出攻击</h1><p>上述过程虽然理论上能完成栈溢出攻击行为，但是实际上很难实现。操作系统每次加载可执行文件到进程空间的位置都是无法预测的，因此栈的位置实际是不固定的，通过硬编码覆盖新返回地址的方式并不可靠。为了能准确定位shellcode的地址，需要借助一些额外的操作，其中最经典的是借助跳板的栈溢出方式。<br>根据前边所述，函数执行后，栈指针esp会恢复到压入参数时的状态，在图4中即data参数的地址。如果我们在函数的返回地址填入一个地址，该地址指向的内存保存了一条特殊的指令jmp esp——跳板。那么函数返回后，会执行该指令并跳转到esp所在的位置——即data的位置。我们可以将缓冲区再多溢出一部分，淹没data这样的函数参数，并在这里放上我们想要执行的代码！这样，不管程序被加载到哪个位置，最终都会回来执行栈内的代码。  </p>
<p><a href="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau47z1gj20hs0h2mym.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1ffwau47z1gj20hs0h2mym.jpg" class="img-fluid"><br></a></p>
<p><center>图5 借助跳板的栈溢出攻击</center><br>借助于跳板的确可以很好的解决栈帧移位（栈加载地址不固定）的问题，但是跳板指令从哪找呢？“幸运”的是，在Windows操作系统加载的大量dll中，包含了许多这样的指令，比如kernel32.dll，ntdll.dll，这两个动态链接库是Windows程序默认加载的。如果是图形化界面的Windows程序还会加载user32.dll，它也包含了大量的跳板指令！而且更“神奇”的是Windows操作系统加载dll时候一般都是固定地址，因此这些dll内的跳板指令的地址一般都是固定的。我们可以离线搜索出跳板执行在dll内的偏移，并加上dll的加载地址，便得到一个适用的跳板指令地址！  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询dll内第一个jmp esp指令的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findJmp</span><span class="params">(<span class="keyword">char</span>*dll_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* handle=(<span class="keyword">char</span>*)LoadLibraryA(dll_name);<span class="comment">//获取dll加载地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">0</span>;;pos++)<span class="comment">//遍历dll代码空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(handle[pos]==(<span class="keyword">char</span>)<span class="number">0xff</span>&amp;&amp;handle[pos+<span class="number">1</span>]==(<span class="keyword">char</span>)<span class="number">0xe4</span>)<span class="comment">//寻找0xffe4 = jmp  esp</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(handle+pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简化了搜索算法，输出第一个跳板指令的地址，读者可以选取其他更合适位置。LoadLibraryA库函数返回值就是dll的加载地址，然后加上搜索到的跳板指令偏移pos便是最终地址。jmp esp指令的二进制表示为0xffe4，因此搜索算法就是搜索dll内这样的字节数据即可。<br>虽然如此，上述的攻击方式还不够好。因为在esp后继续追加shellcode代码会将上级函数的栈帧淹没，这样做并没有什么好处，甚至可能会带来运行时问题。既然被溢出的函数栈帧内提供了缓冲区，我们还是把核心的shellcode放在缓冲区内，而在esp之后放上跳转指令转移到原本的缓冲区位置。由于这样做使代码的位置在esp指针之前，如果shellcode中使用了push指令便会让esp指令与shellcode代码越来越近，甚至淹没自身的代码。这显然不是我们想要的结果，因此我们可以强制抬高esp指针，使它在shellcode之前（低地址位置），这样就能在shellcode内正常使用push指令了。  </p>
<p><a href="http://wx3.sinaimg.cn/mw690/af2d2659ly1ffwau4d5fgj20j30h3jsm.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1ffwau4d5fgj20j30h3jsm.jpg" class="img-fluid"><br></a></p>
<p><center>图6 调整shellcode与栈指针</center><br>调整代码的内容很简单：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp,-X</span><br><span class="line">jmp esp</span><br></pre></td></tr></table></figure>
<p>第一条指令抬高了栈指针到shellcode之前。X代表shellcode起始地址与esp的偏移。如果shellcode从缓冲区起始位置开始，那么就是buffer的地址偏移。这里不使用sub esp,X指令主要是避免X的高位字节为0的问题，很多情况下缓冲区溢出是针对字符串缓冲区的，如果出现字节0会导致缓冲区截断，从而导致溢出失败。<br>第二条指令就是跳转到shellcode的起始位置继续执行。（又是jmp esp！）<br>通过上述方式便能获得一个较为稳定的栈溢出攻击。</p>
<h1 id="五、shellcode构造"><a href="#五、shellcode构造" class="headerlink" title="五、shellcode构造"></a>五、shellcode构造</h1><p>shellcode实质是指溢出后执行的能开启系统shell的代码。但是在缓冲区溢出攻击时，也可以将整个触发缓冲区溢出攻击过程的代码统称为shellcode，按照这种定义可以把shellcode分为四部分：  </p>
<ol>
<li>核心shellcode代码，包含了攻击者要执行的所有代码。</li>
<li>溢出地址，是触发shellcode的关键所在。</li>
<li>填充物，填充未使用的缓冲区，用于控制溢出地址的位置，一般使用nop指令填充——0x90表示。</li>
<li>结束符号0，对于符号串shellcode需要用0结尾，避免溢出时字符串异常。</li>
</ol>
<p>前边一直在围绕溢出地址讨论，并解决了shellcode组织的问题，而最核心的代码如何构造并未提及——即攻击成功后做的事情。其实一旦缓冲区溢出攻击成功后，如果被攻击的程序有系统的root权限——比如系统服务程序，那么攻击者基本上可以为所欲为了！但是我们需要清楚的是，核心shellcode必须是二进制代码形式。而且shellcode执行时是在远程的计算机上，因此shellcode是否能通用是一个很复杂的问题。我们可以用一段简单的代码实例来说明这个问题 。<br>缓冲区溢出成功后，一般大家都会希望开启一个远程的shell控制被攻击的计算机。开启shell最直接的方式便是调用C语言的库函数system，该函数可以执行操作系统的命令，就像我们在命令行下执行命令那样。假如我们执行cmd命令——在远程计算机上启动一个命令提示终端（我们可能还不能和它交互，但是可以在这之前建立一个远程管道等），这里仅作为实例测试。<br>为了使system函数调用成功，我们需要将“cmd”字符串内容压入栈空间，并将其地址压入作为system函数的参数，然后使用call指令调用system函数的地址，完成函数的执行。但是这样做还不够，如果被溢出的程序没有加载C语言库的话，我们还需要调用Windows的API Loadlibrary加载C语言的库msvcrt.dll，类似的我们也需要为字符串“msvcrt.dll”开辟栈空间。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xor ebx,ebx ;//ebx=0</span><br><span class="line"></span><br><span class="line">push 0x3f3f6c6c ;//ll??</span><br><span class="line">push 0x642e7472 ;//rt.d</span><br><span class="line">push 0x6376736d ;//msvc</span><br><span class="line">mov [esp+10],ebx ;//&apos;?&apos;-&gt;&apos;0&apos;</span><br><span class="line">mov [esp+11],ebx ;//&apos;?&apos;-&gt;&apos;0&apos;</span><br><span class="line">mov eax,esp ;//&quot;msvcrt.dll&quot;地址</span><br><span class="line">push eax ;//&quot;msvcrt.dll&quot;</span><br><span class="line">mov eax,0x77b62864 ;//kernel32.dll:LoadLibraryA</span><br><span class="line">call eax ;//LoadLibraryA(&quot;msvcrt.dll&quot;)</span><br><span class="line">add esp,16</span><br><span class="line"></span><br><span class="line">push 0x3f646d63 ;//&quot;cmd?&quot;</span><br><span class="line">mov [esp+3],ebx ;//&apos;?&apos;-&gt;&apos;\0&apos;</span><br><span class="line">mov eax,esp;//&quot;cmd&quot;地址</span><br><span class="line">push eax ;//&quot;cmd&quot;</span><br><span class="line">mov eax,0x774ab16f ;//msvcrt.dll:system</span><br><span class="line">call eax ;//system(&quot;cmd&quot;)</span><br><span class="line">add esp,8</span><br></pre></td></tr></table></figure>
<p>上述汇编代码实质上是如下两个函数调用语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loadlibrary(“msvcrt.dll”);</span><br><span class="line">system(“cmd”);</span><br></pre></td></tr></table></figure>
<p>不过在构造这段汇编代码时需要注意不能出现字节0，为了填充字符串的结束字符，我们使用已经初始化为0的ebx寄存器代替。另外，在对库函数调用的时候需要提前计算出函数的地址，如Loadlibrary函数的0x77b62864。计算方式如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFunc</span><span class="params">(<span class="keyword">char</span>*dll_name,<span class="keyword">char</span>*func_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE handle=LoadLibraryA(dll_name);<span class="comment">//获取dll加载地址</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)GetProcAddress(handle,func_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数地址是在本地计算的，如果被攻击计算机的操作系统版本差别较大的话，这个地址可能是错误的。不过在《0day安全：软件漏洞分析技术》中，作者提供了一个更好的方式，感兴趣的读者可以参考该书提供的代码。因此构造一个通用的shellcode并非十分容易，如果想让攻击变得有效的话。  </p>
<h1 id="六、汇编语言自动转换"><a href="#六、汇编语言自动转换" class="headerlink" title="六、汇编语言自动转换"></a>六、汇编语言自动转换</h1><p>写出shellcode后（无论是简单的还是通用的），我们还需要将这段汇编代码转换为机器代码。如果读者对x86汇编十分熟悉的话，选择手工敲出二进制代码的话也未尝不可。不过我们都希望能让计算机帮助做完这些事，既然开发环境提供了编译器，用它们帮忙何乐而不为呢？既不用OllyDbg工具，也不适用其他的第三方工具，我们写一个简单的函数来完成这个工作。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将内嵌汇编的二进制指令dump到文件,style指定输出数组格式还是二进制形式，返回代码长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dumpCode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> END ;<span class="comment">//略过汇编代码</span></span><br><span class="line">BEGIN:</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里定义任意的合法汇编代码</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">END:</span><br><span class="line">    <span class="comment">//确定代码范围</span></span><br><span class="line">    UINT begin,end;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax,BEGIN ;</span><br><span class="line">        mov begin,eax ;</span><br><span class="line">        mov eax,END ;</span><br><span class="line">        mov end,eax ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">int</span> len=end-begin;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer,(<span class="keyword">void</span>*)begin,len);</span><br><span class="line">        <span class="comment">//四字节对齐</span></span><br><span class="line">    <span class="keyword">int</span> fill=(len-len%<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(fill--)buffer[len+fill]=<span class="number">0x90</span>;</span><br><span class="line">    <span class="comment">//返回长度</span></span><br><span class="line">    <span class="keyword">return</span> len+fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为C++是支持嵌入式汇编代码的，因此在函数内的汇编代码都会被整成编译为二进制代码。实现二进制转换的基本思想是读取编译器最终生成的二进制代码段数据，将数据导出到指定的缓冲区内。为了锁定嵌入式汇编代码的位置和长度，我们定义了两个标签BEGIN和END。这两个标签在汇编语言级别会被解析为实际的线性地址，但是在高级语言级是无法直接使用这两个标签值的，只能使用goto语句跳转使用它们。但是我们可以顺水推舟，使用两个局部变量在汇编级记录这两个标签的值！  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定代码范围</span></span><br><span class="line">UINT begin,end;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">    mov eax,BEGIN ;</span><br><span class="line">    mov begin,eax ;</span><br><span class="line">    mov eax,END ;</span><br><span class="line">    mov end,eax ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以得到嵌入式汇编的代码范围了，使用memcpy操作将代码数据拷贝到目标缓冲区即可（后边还用nop指令将代码按照四字节对齐）。不过我们还需要注意一个问题，嵌入式汇编在函数执行时也会执行，这显然不可以，我们只是把它当作数据而已（是数据？还是代码？），因此在函数开始的地方我们使用goto语句直接跳转到嵌入式会变语句的结尾——END标签！  </p>
<h1 id="七、攻击测试"><a href="#七、攻击测试" class="headerlink" title="七、攻击测试"></a>七、攻击测试</h1><p>按照上述内容，相信不难构造出一个简单的shellcode并攻击之前提供的漏洞函数。但是如果使用VS2010测试的话可能会碰到很多问题。经过大量的调试和资料查询，我们需要设置三处VS的项目属性。  </p>
<ol>
<li>配置-&gt;配置属性-&gt;C/C++-&gt;基本运行时检查=默认值，避免被检测栈帧失衡。</li>
<li>配置-&gt;配置属性-&gt;C/C++-&gt;缓冲区安全检查=否，避免识别缓冲区溢出漏洞。</li>
<li>配置-&gt;配置属性-&gt;链接器-&gt;高级-&gt;数据执行保护(DEP)=否，避免堆栈段不可执行。</li>
</ol>
<p>从这三处设置看来，目前的编译器已经针对缓冲区溢出攻击做了大量的保护工作（显然这会降低程序的执行性能，因此允许用户配置），使得传统的缓冲区溢出攻击变得没那么“猖狂”了，但是在计算机安全领域，“道高一尺，魔高一丈”，总有人会找到更隐蔽的攻击方式让编译器开发者措手不及。本文除了分析缓冲区溢出攻击的原理之外，更希望读者能从中感受到代码安全的重要性，并结合编译器提供的安全功能让自己的代码更加安全高效。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/信息安全/">信息安全</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/漏洞/">漏洞</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓冲区溢出/">缓冲区溢出</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-05-22-复杂数据类型的机器级表示2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/05/22/2017-05-22-复杂数据类型的机器级表示2/">复杂数据类型的机器级表示（2）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/22/2017-05-22-复杂数据类型的机器级表示2/" class="article-date">
	  <time datetime="2017-05-21T16:00:00.000Z" itemprop="datePublished">五月 22, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据的对齐方式"><a href="#数据的对齐方式" class="headerlink" title="数据的对齐方式"></a>数据的对齐方式</h1><h2 id="数据的对齐"><a href="#数据的对齐" class="headerlink" title="数据的对齐"></a>数据的对齐</h2><p>Alignment:<strong>要求数据的地址是相应的边界地址</strong><br>各种不同长度的数据存放时，有两种处理方式：<br>按边界存放（若一个字为32位）、不按边界存放（可能会增加访问次数）<br>虽简单的策略是：按其数据长度进行对齐。例如，Windows采用策略，int型地址是4的倍数，short型地址是2的倍数，double和long long 型的是8的倍数，float型的是4的倍数，char不对齐；linux采用更宽松的策略，short型是2的倍数，其他类型如int、float、double和指针都是4的倍数。<br>要注意的是不要讲数据类型的大小与对齐的倍数混淆，数据类型的大小linux和windows基本是一样的，只是对齐方式不一样。在linux中 long long 是8个字节但是他是按照4字节对齐的。<br>例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">short</span> si;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125;sa[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>注意结构数组变量的最末可能需要插空，以使每个数组元素都按4字节边界对齐，但是如果不是数组的话，那就可以节省3个字节的空间  </p>
<h2 id="对齐（Alignment）"><a href="#对齐（Alignment）" class="headerlink" title="对齐（Alignment）"></a>对齐（Alignment）</h2><p>如：int I,short k,double x,char c,short j<br>如果是边界对齐的情况<br>&amp;i=0;&amp;k=4;&amp;x=8;&amp;c=16;&amp;j=18;<br>x：2个周期<br>j：1个周期<br>如果边界不对齐的情况<br>&amp;i=0;&amp;k=4;&amp;x=6;&amp;c=14;&amp;j=15;<br>x：3个周期<br>j：2个周期  </p>
<h2 id="对齐方式的设定"><a href="#对齐方式的设定" class="headerlink" title="对齐方式的设定"></a>对齐方式的设定</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br></pre></td></tr></table></figure>
<p>为编译器指定结构体和类内部的成员变量的对齐方式<br>当自然边界（如int型按4字节、short型按2字节、float按4字节）比n大时，按照n字节对齐。<br>缺省或#pragma pack()，按自然边界对齐。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(m)))</span><br></pre></td></tr></table></figure>
<p>为编译器指定一个结构体或类或联合体或一个单独的变量的对齐方式 。<br>按m字节对齐，且其占用空间大小也是m的整数倍，以保证在申请连续存储空间时各元素也按m字节对齐。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((packed))</span><br></pre></td></tr></table></figure>
<p>不对齐  </p>
<p>例如  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f1;</span><br><span class="line">	<span class="keyword">uint8_t</span> f2;</span><br><span class="line">	<span class="keyword">uint8_t</span> f3;</span><br><span class="line">	<span class="keyword">uint32_t</span> f4;</span><br><span class="line">	<span class="keyword">uint64_t</span> f5;</span><br><span class="line">&#125;__attribute__((aligned(<span class="number">1024</span>)))ts;</span><br><span class="line"><span class="keyword">sizeof</span>(ts)==<span class="number">1024</span></span><br><span class="line">f1 on address:<span class="number">0x0</span></span><br><span class="line">f2 on address:<span class="number">0x4</span></span><br><span class="line">f3 on address:<span class="number">0x5</span></span><br><span class="line">f4 on address:<span class="number">0x8</span></span><br><span class="line">f5 on address:<span class="number">0xc</span></span><br></pre></td></tr></table></figure>
<h1 id="越界访问和缓冲区溢出"><a href="#越界访问和缓冲区溢出" class="headerlink" title="越界访问和缓冲区溢出"></a>越界访问和缓冲区溢出</h1><p>C语言程序中对数组的访问可能会有意或无意地超越数组存储区范围而无法发现。数组存储区可以看成是一个缓冲区，超越数组存储区范围的写入操作称为缓冲区溢出。<br>例子：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputs</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer , str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s \n"</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hacker</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"being hacked\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	outputs(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UNIX/Linux系统中，可通过调用execve函数来加载并执行程序  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">char</span> * <span class="keyword">const</span> argv[ ],<span class="keyword">char</span> * <span class="keyword">const</span> envp[ ])</span></span>;</span><br></pre></td></tr></table></figure>
<p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。<br>在历史上，大多数UNIX系统对main函数提供了三个参数，原型如下：   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中第三个参数是环境表地址。<br>ANSI C规定main函数只有两个参数，而且第三个参数与全局变量environ相比也没有带来更多益处，所以POSIX.1也规定应使用environ而不使 用第三个参数。通常用getenv和putenv函数来存取特定的环境变量，而不是用environ变量。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设hacker首地址0x08048411</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"./ceshi"</span></span><br><span class="line"><span class="string">"0123456789ABCDEFXXXX"</span></span><br><span class="line"><span class="string">"\x11\x84\x04\x08"</span></span><br><span class="line"><span class="string">"\x00"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *argv;</span><br><span class="line">	argv = shellcode;</span><br><span class="line">	execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/13/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/10/2018-02-10-python实现2048/">Python实现2048</a></h6>
              <span>二月 10, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/09/2018-02-09-图片转字符画/">图片转化为字符画</a></h6>
              <span>二月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/">c++中空字符串解释为True的困惑</a></h6>
              <span>二月 5, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/26/2018-01-26-python字符串令牌解析/">python字符串令牌解析</a></h6>
              <span>一月 26, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/15/2018-01-15-RefineDet论文笔记/">RefineDet论文笔记</a></h6>
              <span>一月 15, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/09/2018-01-09-has-no-attribute-items问题/">AttributeError &#39;dict&#39; object has no attribute &#39;items&#39; 问题</a></h6>
              <span>一月 9, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.71px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.57px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
