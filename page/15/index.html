<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 15 页 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="google-site-verification" content="true" />
  
  
    <meta name="baidu-site-verification" content="true" />
  
  
    <meta name="360-site-verification" content="true" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="coordinate">
<meta property="og:url" content="http://coordinate.wang/page/15/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coordinate">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-2017-04-20-标准模板库2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/20/2017-04-20-标准模板库2/">标准模板库(2)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/20/2017-04-20-标准模板库2/" class="article-date">
	  <time datetime="2017-04-19T16:00:00.000Z" itemprop="datePublished">四月 20, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="更易型算法-Manipulating-Algorithm"><a href="#更易型算法-Manipulating-Algorithm" class="headerlink" title="更易型算法(Manipulating Algorithm)"></a>更易型算法(Manipulating Algorithm)</h1><p>现实中存在某些限制和某些需要避开的事物，其中许多和元素/容器的改动相伴相生。有些算法会改变目标的区间。</p>
<h2 id="移除-Removing-元素"><a href="#移除-Removing-元素" class="headerlink" title="移除(Removing)元素"></a>移除(Removing)元素</h2><p>分析这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 6 to 1 and 1 to 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        coll.push_front(i);</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pre:  "</span>;</span><br><span class="line">    copy (coll.cbegin(), coll.cend(),         <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));   <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// remove all elements with value 3</span></span><br><span class="line">    remove (coll.begin(), coll.end(),         <span class="comment">// range</span></span><br><span class="line">            <span class="number">3</span>);                               <span class="comment">// value</span></span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"post: "</span>;</span><br><span class="line">    copy (coll.cbegin(), coll.cend(),         <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));   <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个程序的结果和我们预想的不一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre:  <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">post: <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>remove并没有改变集合中的元素数量。cend返回的是当初那个终点，size()返回的还是当初那个大小。<br>事实上，这个算法返回一个新终点。你可以利用这个新终点获得新区间。改进版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 6 to 1 and 1 to 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i) &#123;</span><br><span class="line">        coll.push_front(i);</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements of the collection</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements with value 3</span></span><br><span class="line">    <span class="comment">// - retain new end</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator end = remove (coll.begin(), coll.end(),</span><br><span class="line">                                      <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print resulting elements of the collection</span></span><br><span class="line">    copy (coll.begin(), end,</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print number of removed elements</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"number of removed elements: "</span></span><br><span class="line">         &lt;&lt; distance(end,coll.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove "removed" elements</span></span><br><span class="line">    coll.erase (end, coll.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements of the modified collection</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果真想把那些删除的元素斩草除根，erase正适用于此目的。<br>为什么算法不自己调用erase呢？这正是STL为了获取弹性付出的代价。通过“以迭代器为接口”，STL将数据结构和算法分离出来。任何“以迭代器访问容器”的算法，都不得通过迭代器调用容器类所提供的任何成员函数。<br>算法的操作对象不一定是“容器内的全部元素”所形成的区间，而可以使那些元素的子集。<br>注意，通常并无必要删除那些“已被删除”的元素。以逻辑终点取代容器的实际终点，通常就足以应对现实情况。</p>
<h2 id="更易Associative-关联式-和Unordered-无序-容器"><a href="#更易Associative-关联式-和Unordered-无序-容器" class="headerlink" title="更易Associative(关联式)和Unordered(无序)容器"></a>更易Associative(关联式)和Unordered(无序)容器</h2><p>更易型算法(指那些会移除，重排，修改元素的算法)若用于关联式容器或无序容器，会出问题。如果更易型算法用于关联式和无序容器身上，会改变某位置上的值，进而破会容器本身对次序的维护。<br>关联式容器和无序容器的所有迭代器均被申明为指向常量的value或key，如果你更动关联式容器或无序容器的元素会导致编译出错。</p>
<h2 id="算法VS成员函数"><a href="#算法VS成员函数" class="headerlink" title="算法VS成员函数"></a>算法VS成员函数</h2><p>如果高效能是你的首要目标，你应该总是优先选用成员函数。</p>
<h1 id="以函数作为算法的实参"><a href="#以函数作为算法的实参" class="headerlink" title="以函数作为算法的实参"></a>以函数作为算法的实参</h1><p>有些算法可以接受用户自定义的辅助函数，提高弹性和能力。</p>
<h2 id="判断式-Predicate"><a href="#判断式-Predicate" class="headerlink" title="判断式(Predicate)"></a>判断式(Predicate)</h2><p>Predicate是一种特殊的辅助函数。所谓的predicate，它会返回布尔值。<br>单参数判断式(Unary Predicate)会检查唯一实参的某项特性。<br>双参判断式(Binary Predicate)<br>Binary Predicate的典型用途是，比较两个实参的特定属性。</p>
<h1 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h1><p>可以定义对象，用于描述函数行为，并将这些对象以“inline实参”形式给算法作为predicate。</p>
<h1 id="函数对象-Function-Object"><a href="#函数对象-Function-Object" class="headerlink" title="函数对象(Function Object)"></a>函数对象(Function Object)</h1><h2 id="定义一个函数对象"><a href="#定义一个函数对象" class="headerlink" title="定义一个函数对象"></a>定义一个函数对象</h2><p>函数对象是一种带状态的函数。事实上，在同一时间点，相同类型的两个不同的函数对象所表述的相同机能，可具备不同状态。这是寻常函数中不可能的。另一个好处是，你可以在运行期初始化他们—当然必须在他们被调用之前。<br>每个函数对象有其自己的类型。寻常函数，唯有在其signature不同时，才算类型不同。而函数对象即使signature相同，也可以有不同的类型。<br>函数对象通常比寻常函数速度快。由于更多细节在编译器就已确定，所以通常可能进行更好的优化。</p>
<h2 id="预定义的函数对象"><a href="#预定义的函数对象" class="headerlink" title="预定义的函数对象"></a>预定义的函数对象</h2><p>C++标准库内含若干预定义的函数对象，含盖了许多基础运算。一个典型的例子是作为基础排序的函数对象。operator &lt; 默认排序准则是调用less&lt;&gt;，所以，如果你声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<p>会被扩展为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser&lt;<span class="keyword">int</span>,less&lt;<span class="keyword">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>
<h2 id="binder"><a href="#binder" class="headerlink" title="binder"></a>binder</h2><p>你可以使用特殊的函数适配器，所谓的binder，将于定义的函数对象和其他数值结合为一体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: due to the sorting criterion greater&lt;&gt;() elements have reverse order:</span></span><br><span class="line">    PRINT_ELEMENTS(coll1,<span class="string">"initialized: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transform all elements into coll2 by multiplying them with 10</span></span><br><span class="line">    transform (coll1.cbegin(),coll1.cend(),      <span class="comment">// source</span></span><br><span class="line">               back_inserter(coll2),             <span class="comment">// destination</span></span><br><span class="line">               bind(multiplies&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));   <span class="comment">// operation</span></span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"transformed: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace value equal to 70 with 42</span></span><br><span class="line">    replace_if (coll2.begin(),coll2.end(),       <span class="comment">// range</span></span><br><span class="line">                bind(equal_to&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">70</span>),     <span class="comment">// replace criterion</span></span><br><span class="line">                <span class="number">42</span>);                             <span class="comment">// new value</span></span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"replaced:    "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements with values between 50 and 80</span></span><br><span class="line">    coll2.erase(remove_if(coll2.begin(),coll2.end(),</span><br><span class="line">                          bind(logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">                               bind(greater_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">50</span>),</span><br><span class="line">                               bind(less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">80</span>))),</span><br><span class="line">                coll2.end());</span><br><span class="line">    PRINT_ELEMENTS(coll2,<span class="string">"removed:     "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(multiplies&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>变定义一个函数对象，将传入的第一个实参乘以10。<br>最后一例用的是binder的组合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">     bind(greater_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">50</span>),</span><br><span class="line">     bind(less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<p>表现出的是个unary predicate，拥有参数x，操作意义是x&gt;=50&amp;&amp;x&lt;=80。</p>
<h1 id="STL内部的错误和异常"><a href="#STL内部的错误和异常" class="headerlink" title="STL内部的错误和异常"></a>STL内部的错误和异常</h1><h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h2><p>C++标准库指出，对于STL的任何运用，如果违反规则，将导致不明确的行为。通常会导致不明确的内存访问，这肯能导致难缠的副作用。具体地说，使用STL，必须满足以下条件：<br>迭代器必须合法有效。例如你必须在使用他们之前先将他们初始化。<br>迭代器如果指向past-the-end位置，它并不指向任何对象。因此不能对他调用operator*和operator-&gt;。<br>区间(range)必须合法：<br>用以“指出某个区间”的前后迭代器必须指向同一个容器。<br>从第一个迭代器出发必须可以到达第二个迭代器位置。<br>如果涉及的区间不止一个，第二区间及后继各区间必须拥有“至少和第一区间一样多的”元素。<br>腹泻操作中的“标的区间”必须拥有足够多的元素，否则必须采用insert iterator<br>以下例子展示若干可能发生的错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll1;    <span class="comment">// empty collection</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;    <span class="comment">// empty collection</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - beginning is behind the end of the range</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = coll1.begin();</span><br><span class="line">    reverse (++pos, coll1.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 1 to 9 into coll1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll1.push_back (i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - overwriting nonexisting elements</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),  <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - collections mistaken</span></span><br><span class="line">    <span class="comment">// - cbegin() and cend() refer to different collections</span></span><br><span class="line">    copy (coll1.cbegin(), coll2.cend(),  <span class="comment">// source</span></span><br><span class="line">          coll1.end());                  <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-19-标准模板库1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/19/2017-04-19-标准模板库1/">标准模板库(1)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/19/2017-04-19-标准模板库1/" class="article-date">
	  <time datetime="2017-04-18T16:00:00.000Z" itemprop="datePublished">四月 19, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h1><p>序列式容器(Sequence container):array,vector,deque,list and forward_list<br>关联式容器(Associative container):set,multiset,map and multimap<br>无序容器:(Unordered(associative)container):unordered_set,unordered_multiset,unordered_map,unordered_multimap</p>
<h2 id="序列式容器-Sequence-container"><a href="#序列式容器-Sequence-container" class="headerlink" title="序列式容器(Sequence container)"></a>序列式容器(Sequence container)</h2><p>自c++11开始，c++标准库提供另一个list容器：forward list。forward list是一个单向链表。<br>因此，forward list原则上就是一个受限的list，你无法查找某个元素然后删除它，或是在他的前面安插另一个元素。因此，为了删除某个元素，你必须位于其前一个元素的位置上，因为正是那个元素，才决定一个新的后继元素。也因此，forward list对此提供了一个特殊的成员函数erase_after()<br>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create forward-list container for some prime numbers</span></span><br><span class="line">    forward_list&lt;<span class="keyword">long</span>&gt; coll = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span> &#125;;</span><br><span class="line">    <span class="comment">// resize two times</span></span><br><span class="line">    <span class="comment">// - note: poor performance</span></span><br><span class="line">    coll.resize(<span class="number">9</span>);</span><br><span class="line">    coll.resize(<span class="number">10</span>,<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// print all elements:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : coll) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联式数组-Associative-Array"><a href="#关联式数组-Associative-Array" class="headerlink" title="关联式数组(Associative Array)"></a>关联式数组(Associative Array)</h2><p>不论map或unordered map，都是key/value pair形成的集合，每个元素都带着独一无二的key。这样的集合也可以被视为一个关联式数组，也就是“索引并非整数”的array。也因此，刚才说的两个容器，都可以使用[]操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// type of the container:</span></span><br><span class="line">    <span class="comment">// - unordered_map: elements are key/value pairs</span></span><br><span class="line">    <span class="comment">// - string: keys have type string</span></span><br><span class="line">    <span class="comment">// - float: values have type float</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert some elements into the collection</span></span><br><span class="line">    <span class="comment">// - using the syntax of an associative array</span></span><br><span class="line">    coll[<span class="string">"VAT1"</span>] = <span class="number">0.16</span>;</span><br><span class="line">    coll[<span class="string">"VAT2"</span>] = <span class="number">0.07</span>;</span><br><span class="line">    coll[<span class="string">"Pi"</span>] = <span class="number">3.1415</span>;</span><br><span class="line">    coll[<span class="string">"an arbitrary number"</span>] = <span class="number">4983.223</span>;</span><br><span class="line">    coll[<span class="string">"Null"</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change value</span></span><br><span class="line">    coll[<span class="string">"VAT1"</span>] += <span class="number">0.03</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print difference of VAT values</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"VAT difference: "</span> &lt;&lt; coll[<span class="string">"VAT1"</span>] - coll[<span class="string">"VAT2"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自C++11开始，你也可以使用at()访问元素的value，只要传给他key就行。这种情况下如果容器内找不到给定的key，会导致out_of_range异常:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.at(<span class="string">"VAT1"</span>) = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure>
<p>使用map与使用unordered_map的差异在于，元素在unordered_map的次序有各种可能，但元素在map内一定是排序过的。但由于unordered_map的操作属于“amortized constant”复杂度，map提供的是“对数复杂度”，所以通常宁可使用unordered_map而放弃map，除非你需要排序。<br>容器适配器(Container Adapter)<br>Stack 名字足以说明。Stack容器对元素采取的是LIFO(后进先出)管理策略。<br>Queue 对元素采取FIFO(先进先出)管理策略。也就是说，他就是一个寻常的缓冲区(buffer)。<br>Priority queue 其内的元素拥有各种优先权。所谓的优先权是基于程序员提供的排序准则(默认为操作符&lt;)而定义。<br>迭代器(Iterator)<br>任何容器都定义两种迭代器类型：  </p>
<ol>
<li>container::iterator以“读/写”模式遍历元素。</li>
<li>container::const_iterator以“只读”模式遍历元素。</li>
</ol>
<p>我们可以使用关键字auto代替迭代器的精确类型。因此我们直接以begin初始化迭代器，就可以使用auto声明其类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin(); pos != coll.end(); ++pos)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>采用这种写法，万一容器类型发生变化，程序整体仍能保持较佳的健壮性。然而其缺点是，迭代器丧失常量性，可能引发“计划外的赋值”风险。因为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = coll.begin();</span><br></pre></td></tr></table></figure>
<p>会使pos是一个非常量迭代器，因为begin()返回的是个类型为cont::iterator的对象。为确保仍可使用常量迭代器，自C++11起容器提供cbegin和cend，他们放回一个cont::const_iterator的对象。</p>
<h1 id="算法-Algorithm"><a href="#算法-Algorithm" class="headerlink" title="算法(Algorithm)"></a>算法(Algorithm)</h1><h2 id="区间-Range"><a href="#区间-Range" class="headerlink" title="区间(Range)"></a>区间(Range)</h2><p>所有算法处理的都是半开区间(half-open range)—包括其实元素的位置但并不包括末尾元素的位置。<br>半开区间的有点主要是单纯，可免除对空集做特殊处理。当然，金无足赤，世上没有完美的设计。<br>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">    <span class="comment">// insert elements from 20 to 40</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>; i&lt;=<span class="number">40</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find position of element with value 3</span></span><br><span class="line">    <span class="comment">// - there is none, so pos3 gets coll.end()</span></span><br><span class="line">    <span class="keyword">auto</span> pos3 = find (coll.begin(), coll.end(),    <span class="comment">// range</span></span><br><span class="line">                      <span class="number">3</span>);                          <span class="comment">// value</span></span><br><span class="line">       <span class="comment">// reverse the order of elements between found element and the end</span></span><br><span class="line">    <span class="comment">// - because pos3 is coll.end() it reverses an empty range</span></span><br><span class="line">    reverse (pos3, coll.end());</span><br><span class="line">    <span class="comment">// find positions of values 25 and 35</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator pos25, pos35;</span><br><span class="line">    pos25 = find (coll.begin(), coll.end(),  <span class="comment">// range</span></span><br><span class="line">                  <span class="number">25</span>);                       <span class="comment">// value</span></span><br><span class="line">    pos35 = find (coll.begin(), coll.end(),  <span class="comment">// range</span></span><br><span class="line">                  <span class="number">35</span>);                       <span class="comment">// value</span></span><br><span class="line">    <span class="comment">// print the maximum of the corresponding range</span></span><br><span class="line">    <span class="comment">// - note: including pos25 but excluding pos35</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max: "</span> &lt;&lt; *max_element (pos25, pos35) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// process the elements including the last position</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max: "</span> &lt;&lt; *max_element (pos25, ++pos35) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找元素3的任务失败后，find()返回区间的结束位置并赋值给pos3。所以reverse()的结果就是相当于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(coll.end(), coll.end());</span><br></pre></td></tr></table></figure>
<h2 id="处理多重区间-Multiple-Ranges"><a href="#处理多重区间-Multiple-Ranges" class="headerlink" title="处理多重区间(Multiple Ranges)"></a>处理多重区间(Multiple Ranges)</h2><p>有数个算法可以同时处理多重区间。通常你必须设定第一区间的起点和终点，至于其他区间，只需设定起点即可，终点通常可由第一区间的元素数量推导出来。例如，equal从头开始比较coll1和coll2的所有元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( equal(coll1.begin(), coll1,end(),</span><br><span class="line">			coll.begin())&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，coll2之中参与比较的元素数量，间接取决于coll1内的数量。<br>这使得我们获得一个重要的心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二区间所拥有的元素个数至少和第一区间内的元素个数相同。<br>注意下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;   coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RUNTIME ERROR:</span></span><br><span class="line">    <span class="comment">// - overwrites nonexisting elements in the destination</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                 <span class="comment">// destination</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要避免上面的错误，你可以确定目标区间内有足够的元素空间，或是采用insert iterator。<br>为了是目标区间足够大，你可以一开始给他一个正确的大小，也可以显示的变更他的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;   coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize destination to have enough room for the overwriting algorithm</span></span><br><span class="line">    coll2.resize (coll1.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements from first into second collection</span></span><br><span class="line">    <span class="comment">// - overwrites existing elements in destination</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll2.begin());                 <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create third collection with enough room</span></span><br><span class="line">    <span class="comment">// - initial size is passed as parameter</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll3(coll1.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements from first into third collection</span></span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),   <span class="comment">// source</span></span><br><span class="line">          coll3.begin());                 <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这两种做法都会产生新元素并赋初值。这些元素由default构造函数初始化，没有任何实参。你可以传递额外的实参给构造函数和resize()，这样就可以按你的意思将新元素初始化。</p>
<h1 id="迭代器之适配器-Iterator-Adapter"><a href="#迭代器之适配器-Iterator-Adapter" class="headerlink" title="迭代器之适配器(Iterator Adapter)"></a>迭代器之适配器(Iterator Adapter)</h1><p>C++11标准库提供了数个预定义的特殊迭代器，亦即所谓迭代器适配器(iterator adapter)。</p>
<h2 id="Insert-Iterator-安插型迭代器"><a href="#Insert-Iterator-安插型迭代器" class="headerlink" title="Insert Iterator(安插型迭代器)"></a>Insert Iterator(安插型迭代器)</h2><p>它可以使算法以安插方式而非覆写方式运作。使用它可以解决算法的“目标空间不足”问题。她会促使目标区间的大小按需求成长。<br>Insert iterator内部将接口做了新的定义：<br>如果你将某个元素赋值，会引发“对其所属集合的按插动作”。至于插入位置是在容器的最前或最后，或某特定位置上，要视三种不同的insert iterator而定。<br>单步前行不会构成任何动静。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; coll1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the elements of coll1 into coll2 by appending them</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          back_inserter(coll2));           <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the elements of coll1 into coll3 by inserting them at the front</span></span><br><span class="line">    <span class="comment">// - reverses the order of the elements</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; coll3;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          front_inserter(coll3));          <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy elements of coll1 into coll4</span></span><br><span class="line">    <span class="comment">// - only inserter that works for associative collections</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; coll4;</span><br><span class="line">    copy (coll1.cbegin(), coll1.cend(),    <span class="comment">// source</span></span><br><span class="line">          inserter(coll4,coll4.begin()));  <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子运用了三个预定义的insert iterator<br>Back inserter其内部调用push_back()，在容器末尾插入元素。<br>Front inserter其内部调用push_front()，将元素安插于容器最前端。<br>General inserter这种一般性的inserter，简称inserter，它的作用是在“初始化时接受第二实参”所指位置的前方插入元素。其内部调用成员函数insert()，因此这是唯一可用于关联式容器身上的一种预定义inserter。</p>
<h2 id="Stream-Iterator-串流迭代器"><a href="#Stream-Iterator-串流迭代器" class="headerlink" title="Stream Iterator(串流迭代器)"></a>Stream Iterator(串流迭代器)</h2><p>Stream Iterator被用来读写stream。他们提供了必要的抽象性，使得来自键盘的输入像是个集合，你能够从中读取内容。同样道理，你也可以把一个算法输出结果重新导向到某个文件或屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read all words from the standard input</span></span><br><span class="line">    <span class="comment">// - source: all strings until end-of-file (or error)</span></span><br><span class="line">    <span class="comment">// - destination: coll (inserting)</span></span><br><span class="line">    copy (istream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cin</span>),    <span class="comment">// start of source</span></span><br><span class="line">          istream_iterator&lt;<span class="built_in">string</span>&gt;(),       <span class="comment">// end of source</span></span><br><span class="line">          back_inserter(coll));             <span class="comment">// destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort elements</span></span><br><span class="line">    sort (coll.begin(), coll.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all elements without duplicates</span></span><br><span class="line">    <span class="comment">// - source: coll</span></span><br><span class="line">    <span class="comment">// - destination: standard output (with newline between elements)</span></span><br><span class="line">    unique_copy (coll.cbegin(), coll.cend(),           <span class="comment">// source</span></span><br><span class="line">                 ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">"\n"</span>)); <span class="comment">// destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>istream_iterator<string>(cin)会产生一个可从“标准输入串流cin”读取数据的stream iterator。其中的template实参string表示这个stream iterator专门读取这个类型的元素。这些元素通过一般的operator &gt;&gt; 被读取出来。</string></p>
<h2 id="Reverse-Iterator-反向迭代器"><a href="#Reverse-Iterator-反向迭代器" class="headerlink" title="Reverse Iterator(反向迭代器)"></a>Reverse Iterator(反向迭代器)</h2><p>Reverse iterator会造成算法逆向操作。所有提供双向迭代器或随机访问迭代器的容器都可以通过他们的成员函数rbegin和rend产生一个反向迭代器。自C++11开始还提供一组对应成员函数crbegin和crend，它们会返回只读反向迭代器。<br>Forward_list和所有无序容器都没有提供回向迭代接口，即rbegin和rend等等。原因是那些容器内部实现只是使用singly linked list传奇所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert elements from 1 to 9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">        coll.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all element in reverse order</span></span><br><span class="line">    copy (coll.crbegin(), coll.crend(),      <span class="comment">// source</span></span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));  <span class="comment">// destination</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用reverse iterator，所有算法便可以不需特殊处理就以相反方向操作容器，这自然是美事一桩。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-18-理解C++语言的声明语法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/18/2017-04-18-理解C++语言的声明语法/">理解C/C++语言的声明语法-声明子</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/18/2017-04-18-理解C++语言的声明语法/" class="article-date">
	  <time datetime="2017-04-17T16:00:00.000Z" itemprop="datePublished">四月 18, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.cnblogs.com/dreamliner/archive/2009/06/10/1500827.html" target="_blank" rel="noopener">dreamliner</a>的blog</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>一些声明可能难以理解，特别是如果声明几个不同类型的名字或者那些指向函数指针的函数。例如在§10.1.1/171中，我们看到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p, q;</span><br></pre></td></tr></table></figure>
<p>定义p为一个“整型指针”类型的对象，q为一个整型对象。在§10.1.2/173中，我们看到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>声明get_analysis_ptr为一个函数，不带任何参数，它返回一个指针，它指向一个函数，它带有一个const vector&lt;Student_info&gt;&amp;参数，返回double。你可以通过重写以清楚的表达这些声明的含义，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> q;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义analysis_fp为一个函数，它带一个const vector&lt;Student_info&gt;&amp;参// 数，返回一个double类型。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*analysis_fp)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;)</span></span>;</span><br><span class="line"><span class="function">analysis_fp <span class="title">get_analysis_ptr</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>不幸的是，这种策略不会帮助你阅读其它程序员代码中令人迷惑的声明。<br>一般，一个声明大致如下<br>声明语句：声明说明符[声明子[初始化器]] [,声明子[初始化器]]…;<br>它为每一个声明子声明一个名字。这些名字始于声明开始的地方终于声明作用域结束的地方。一些声明同时也是定义。名字可以声明多次，但是仅能定义一次。如果一个声明分配了存储空间或者定义了类或函数体，那么它也是一个定义。<br>C++继承了C的声明语法。理解声明的关键是认识到每个声明包含两个部分：一系列声明说明符，它们一起说明一个类型和其它正在声明的特性，紧跟着是零个或多个声明子（每个声明子都可选的有一个关联的初始化器）。根据说明符和声明子的形式，每个声明子都为名字赋予一个类型。<br>理解声明的第一步是定位说明符和声明子的边界。这很容易：所有的说明符都是关键字或者类型名，因此说明符终止于第一个不是以上类型之一的符号。<br>例如，在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> * <span class="keyword">const</span> * cp;</span><br></pre></td></tr></table></figure>
<p>很容易找到边界：double是一个类型，左括号后面既不是关键字也不是类型名。因此，声明—说明符只是double，声明子为声明的其它部分，不包含分号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>另一个例子，考虑§10.1.2/173中的声明：<br>第一个既不是关键字也不是类型名的符号是<em>，因此说明符是const char，唯一的声明子</em> const <em> const </em> cp。</p>
<h2 id="说明符（Specifiers）"><a href="#说明符（Specifiers）" class="headerlink" title="说明符（Specifiers）"></a>说明符（Specifiers）</h2><p>我们可以将声明—说明符分成三个部分：类型说明符，存储类说明符，和其它说明符：<br>声明说明符：{类型说明符|存储类说明符|其它声明说明符}<br>然而，这种划分仅仅有助于理解，因为声明本身不存在对应的划分：声明—说明符可以以任何次序出现。<br>类型说明符决定了声明的类型。我们在§A.2/299中讨论内置类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type-specifier: char | wchar_t | bool | short | int | long | signed</span><br><span class="line">unsigned | float | double | void | type-name | const | volatile</span><br><span class="line">type-name: class-name | enum-name | typedef-name</span><br></pre></td></tr></table></figure>
<p>const说明符指出这种类型的对象不可以修改，volatile通知编译器变量可能以非语言定义的形式改变，应该避免优化。<br>注意const既可以出现在说明符部分，这样修改类型，也可以出现在声明子部分，说明一个const指针。这没有任何歧义，因为声明子部分的const总是跟着一个*。<br>存储类说明符决定变量的位置和生命周期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storage-class-specifiers: register | static | extern | mutable</span><br></pre></td></tr></table></figure>
<p>register说明符建议编译器通过将此对象放到寄存器中以优化性能。<br>一般，局部变量在退出声明它们的块（block）时即被销毁；静态变量的值在作用域的入口和出口间会被保存起来。<br>extern说明符表明当前的声明不是一个定义，隐含着在其它地方存在相应的定义。<br>mutable存储类仅用于类的数据成员，并且允许修改这些数据成员即使它们是常量对象的成员。<br>其它声明说明符定义了与类型无关的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other-decl-specifier: friend | inline | virtual | typedef</span><br></pre></td></tr></table></figure>
<p>friend说明符(§12.3.2/216 and §13.4.2/246)改写保护。<br>内联说明符用于函数定义，提示编译器如果可能内联下面的代码。当展开调用时，函数定义必须出现在那个作用域，因此将内联函数体放到声明函数的头文件中通常是一个好主意。<br>virtual说明符(§13.2.1/234)仅用于成员函数，表示这个函数是动态绑定的。<br>typedef说明符(§3.2.2/43)定义类型的同义词。</p>
<h2 id="声明子（Declarators）"><a href="#声明子（Declarators）" class="headerlink" title="声明子（Declarators）"></a>声明子（Declarators）</h2><p>一个声明为每个声明子都声明一个实体（entity）,同时为那个实体给出一个名字，并且隐含的给出存储类，类型，和由说明符给出的其它特性。说明符和声明子一起决定了名字是否是一个对象，数组，指针，引用或函数。例如，声明x为一个整型指针，f为一个函数返回一个整型。正是声明子*x和f()使类型x和f产生区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int *x, f();</span><br><span class="line">declarator: [ * [ const ] | &amp; ]... direct-declarator</span><br><span class="line">direct-declarator: declarator-id | ( declarator ) |</span><br><span class="line">direct-declarator ( parameter-declaration-list ) |</span><br><span class="line">direct-declarator [ constant-expression ]</span><br><span class="line">A declarator-id is an identifier, possibly qualified:</span><br><span class="line">declarator-id: [ nested-name-specifier ] identifier</span><br><span class="line">nested-name-specifier: &#123; class-or-namespace-name ::&#125;...</span><br></pre></td></tr></table></figure>
<p>如果声明子是一个仅包含一个declarator-id的直接-声明子，那么这说明这个标识符具有decl-specifiers隐含的属性，而没有进一步的修饰。例如，在下面的声明中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure>
<p>声明子是n，这是一个只包含direct-declarator的declarator-id，因此根据含义，n的类型为整型。<br>如果声明子为其它形式，那么你可以按照下面的方法确定标识符的类型：首先，假设T为decl-specifiers隐含的类型，忽略friend或static等非类型属性，同时假设D为声明子。然后重复下面的步骤直到推导出D为一个declarator-id，此时T正是你所寻找的类型：  </p>
<ol>
<li>如果D形如(D1)，那么用D1替换D。</li>
<li>如果D形如<em> D1 或 </em> const D1，那么根据是否有const，用“指针，它指向T”或者“常量指针，它指向T”替换T，然后用D1替换D。</li>
<li>如果D形如D1(参数-声明-列表)，那么用参数由参数-声明-列表定义的、“返回T的函数”替换T，然后用D1替换D。</li>
<li>如果D形如D1[常量-表达式]，那么用元素个数由常量-表达式给出的“T数组”替换T，然后然后用D1替换D。</li>
<li>最后，如果声明子形如&amp;D，那么用“T引用”替换T，然后用D1替换D。<br>作为一个示例，考虑下面的声明</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先，T和D分别为int和<em>f()，因此D形如</em>D1，其中D1为f()。<br>你可能认为D可以形如D1() 或者 <em>D1。然而，如果D形如D1()，那么D1将不得不为</em>f，D1将是一个direct-declarator（因为本节开始处的语法注1规定只有direct-declarator前面是()）。但是如果我们看看direct-declarator的定义注2，很明显它不能包含<em>。因此，D只能是</em>f()，它形如*D1，其中D为f()。<br>既然我们已经确定D1为f()，那么我们知道必须用“指针，它指向T”替换T，即“指针，指向整型”，同时用f()替换D。<br>至此我们还没有解析D为declarator-id，因此我们必须重复该过程。此时，D1只能是f，因此我们用“返回T的函数”替换T，它是一个“返回整型指针不带参数的函数”，然后用f替换D。<br>此时，D为declarator-id，因此推导结束。我们已经确定声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明f的类型为“不带参数返回整型指针的函数”。另一个例子，声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p, q;</span><br></pre></td></tr></table></figure>
<p>具有两个声明子，<em>p和q。对于每个声明子，T都是int。对于第一个声明子，D是</em>p，因此T变成“指针，它指向整型，”而D为p。声明p类型为“指针，它指向整型”。<br>我们单独分析第二个声明子，T还是int，D是q。很明显声明q为整型。<br>最后，让我们分析§10.1.2/173中那个奇怪的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr())(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>分析过程可以分为下面五个步骤  </p>
<ol>
<li>T: double    D: (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;)</li>
<li>T: 返回double带有 const vector&lt;Student_info&gt;&amp; 参数的函数    D: (*get_analysis_ptr())</li>
<li>T: function returning double… (如前所示)    D: *get_analysis_ptr()</li>
<li>T: 指针，它指向一个返回double…的函数    D: get_analysis_ptr()</li>
<li>T: 一个函数，返回一个函数指针，它指向一个返回double…的函数   D: get_analysis_ptr<br>get_analysis_ptr是一个函数，它返回一个函数指针，它指向一个返回double，带有const vector&lt;Student_info&gt;&amp;参数的函数。我们将如何展开const vector&lt;Student_info&gt;&amp;作为一个练习。幸运的是，很少有函数声明如此令人迷惑；它们中的大多数看起来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declarator: declarator-id ( parameter-declaration-list )</span><br></pre></td></tr></table></figure>
<p>到目前为止，常见情况中最难的是返回函数指针的函数。<br>注1：这里将allows翻译为规定而不是允许。因为如果翻译为允许，言外之意是()后面还可以是其它东西，但是在五条语法中找不到这种东西。语法指的是direct-declarator ( parameter-declaration-list )<br>注2：“declarator: [ * [ const ] | &amp; ]… direct-declarator”</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-17-cpp通用工具2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/17/2017-04-17-cpp通用工具2/">cpp通用工具(2)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/17/2017-04-17-cpp通用工具2/" class="article-date">
	  <time datetime="2017-04-16T16:00:00.000Z" itemprop="datePublished">四月 17, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Class-unique-ptr"><a href="#Class-unique-ptr" class="headerlink" title="Class unique_ptr"></a>Class unique_ptr</h1><p>可确保一个对象和其相应资源同一时间之辈一个pointer占有。<br>unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::unqiue_ptr&lt;ClassA&gt; ptr(<span class="keyword">new</span> ClassA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。</p>
<h2 id="使用unique-ptr"><a href="#使用unique-ptr" class="headerlink" title="使用unique_ptr"></a>使用unique_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create and initialize string</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"nico"</span>);</span><br><span class="line">(*up)[<span class="number">0</span>] = <span class="string">'N'</span>;<span class="comment">//replace first character</span></span><br><span class="line">up-&gt;append(<span class="string">"fjdk"</span>);<span class="comment">//append some characters</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"nico"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* sp = up.release();</span><br></pre></td></tr></table></figure>
<h2 id="转移unique-ptr的拥有权"><a href="#转移unique-ptr的拥有权" class="headerlink" title="转移unique_ptr的拥有权"></a>转移unique_ptr的拥有权</h2><p>不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。<br>举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2(up1);<span class="comment">//ERROR</span></span><br><span class="line"><span class="comment">//transfer ownership  of the unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up3(<span class="built_in">std</span>::move(up1));<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>assignment操作符的行为和上面所说的类似:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2;</span><br><span class="line">up2 = up1;<span class="comment">//ERROR </span></span><br><span class="line">up2 = <span class="built_in">std</span>::move(up1);<span class="comment">//assign the unique_ptr</span></span><br></pre></td></tr></table></figure>
<p>如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2(<span class="keyword">new</span> ClassA);</span><br><span class="line">up2 = <span class="built_in">std</span>::move(up1);<span class="comment">//assign the unique_ptr</span></span><br><span class="line"><span class="comment">//delete object owned by up2</span></span><br></pre></td></tr></table></figure>
<h2 id="对于array"><a href="#对于array" class="headerlink" title="对于array"></a>对于array</h2><p>对于array应该是用delete[]而不是delete，所以下面的做法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。<br>你只要这样申明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>[]&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>然而要注意的是，他不提供操作符*和-&gt;，提供[]，用于访问其所执行的array中的某个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>[]&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//ERROR</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; up[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<h2 id="其他相应资源的deleter"><a href="#其他相应资源的deleter" class="headerlink" title="其他相应资源的deleter"></a>其他相应资源的deleter</h2><p>当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassADeleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ClassA* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA,ClassADeleter&gt; up(<span class="keyword">new</span> ClassA());</span><br></pre></td></tr></table></figure>
<p>如果你给的是个函数或lambda，你必须声明deleter的类型位void(<em>)(T</em>)或std::function&lt;void(T*)&gt;，要不就是使用decltype</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="keyword">void</span>(*)(<span class="keyword">int</span>*)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">					[](<span class="keyword">int</span>* p)</span><br><span class="line">					&#123;</span><br><span class="line">						...</span><br><span class="line">						<span class="keyword">delete</span> [] p;</span><br><span class="line">					&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>*)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">						[](<span class="keyword">int</span>* p)</span><br><span class="line">						&#123;</span><br><span class="line">							...</span><br><span class="line">							<span class="keyword">delete</span> [] p;</span><br><span class="line">						&#125;);</span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> *p)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">delete</span> [] p;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="keyword">decltype</span>(l)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],l);</span><br></pre></td></tr></table></figure>
<h1 id="Type-Trait-和Type-Utility"><a href="#Type-Trait-和Type-Utility" class="headerlink" title="Type Trait 和Type Utility"></a>Type Trait 和Type Utility</h1><h2 id="Type-trait-的目的"><a href="#Type-trait-的目的" class="headerlink" title="Type trait 的目的"></a>Type trait 的目的</h2><p>所谓的type trait，提供一种用来处理type属性的办法。他是个template，可以在编译期根据一个或多个template实参产生一个type或value。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">std</span>::ispointer&lt;T&gt;::value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo() called for a pointer "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo() called for a value "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对整数类型的重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_impl</span><span class="params">(T val,true_type)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_impl</span><span class="params">(T val, false_type)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	foo_impl(val, <span class="built_in">std</span>::is_integral&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="细究Type-Trait"><a href="#细究Type-Trait" class="headerlink" title="细究Type Trait"></a>细究Type Trait</h1><p>Type trait定义于&lt;type_traits&gt;</p>
<h2 id="unary-Type-Predicate"><a href="#unary-Type-Predicate" class="headerlink" title="(unary) Type Predicate"></a>(unary) Type Predicate</h2><p>Trait中的大部分都是unary，也就是说他们使用一个template实参。例如is_const&lt;&gt;，它用来检查传入的类型是否为const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is_const&lt;<span class="keyword">int</span>&gt;::value <span class="comment">//false</span></span><br><span class="line">is_const&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">int</span>&gt; ::value <span class="comment">//true</span></span><br><span class="line">is_const&lt;<span class="keyword">int</span>* <span class="keyword">const</span>&gt;::value <span class="comment">//true</span></span><br><span class="line">is_const&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;;:value <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>用于检验type relation的trait</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_assignable&lt;T,T2&gt; <span class="comment">//可以将类型T2复制给类型T</span></span><br></pre></td></tr></table></figure>
<p>is_assignable&lt;&gt;的第一个类型若是nonclass，永远获得false_type。但是对于class，ordinary type作为第一类型是可以的<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is_assignable&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::value <span class="comment">//false</span></span><br><span class="line">is_assignable&lt;<span class="keyword">int</span>&amp;，<span class="keyword">void</span>*&gt;::value <span class="comment">//false</span></span><br><span class="line">is_assignable&lt;<span class="keyword">void</span>*,<span class="keyword">int</span>&amp;&gt;::value <span class="comment">//false</span></span><br><span class="line">is_assignable&lt;<span class="keyword">int</span>&amp;,<span class="keyword">int</span>&gt;::value <span class="comment">//true</span></span><br><span class="line">is_constructible&lt;T,Args...&gt; <span class="comment">//可以运用类型Args初始化T</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_constructiable&lt;<span class="keyword">int</span>&gt;::value <span class="comment">//true</span></span><br><span class="line">is_constructiable&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="Type-Modifier"><a href="#Type-Modifier" class="headerlink" title="Type Modifier"></a>Type Modifier</h2><p>所有这一类trait为类型添加一个属性，前提是该属性尚未存在，或移除一个属性，前提是这个属性已经存在。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line">add_const&lt;T&gt;::type <span class="comment">//const int</span></span><br><span class="line">remove_const&lt;T&gt;::type <span class="comment">//int</span></span><br></pre></td></tr></table></figure>
<p>而类型const int&amp;可被降级或扩展</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp; T;</span><br><span class="line">add_rvalue_reference&lt;T&gt;::type <span class="comment">//const int&amp;</span></span><br><span class="line">remoce_const&lt;T&gt;::type <span class="comment">//const int&amp;</span></span><br><span class="line">remoce_reference&lt;T&gt;::type <span class="comment">//const int</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，一个“指向某常量类型”的reference本身并不是常量。add_lvalue_reference&lt;&gt;把一个rvalue reference转换为一个lvalue reference,然而add_rvalue_reference并不会把lvalue reference转化为rvalue reference。必须使用下面的做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rvalue_reference&lt;remove_reference&lt;T&gt;::type&gt;::type</span><br></pre></td></tr></table></figure>
<h2 id="Function-Type-Wrapper"><a href="#Function-Type-Wrapper" class="headerlink" title="Function Type Wrapper"></a>Function Type Wrapper</h2><p>使用member function时，“借以调用他们”的那个对象必须被当作第一参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">memfunc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">const</span> C&amp;,<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; mf;</span><br><span class="line">mf = &amp;C::memfunc;</span><br><span class="line">mf(C(), <span class="number">42</span>,<span class="number">77</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-16-cpp通用工具1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/16/2017-04-16-cpp通用工具1/">cpp通用工具(1)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/16/2017-04-16-cpp通用工具1/" class="article-date">
	  <time datetime="2017-04-15T16:00:00.000Z" itemprop="datePublished">四月 16, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Pair"><a href="#Pair" class="headerlink" title="Pair "></a>Pair </h1><h2 id="构造函数与赋值"><a href="#构造函数与赋值" class="headerlink" title="构造函数与赋值"></a>构造函数与赋值</h2><p>自C++11开始，如果pair&lt;&gt;用到了某个类型而该类型只有一个nonconstant copy构造函数，将会编译失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	A(A&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;A,<span class="keyword">int</span>&gt; p;<span class="comment">//ERROR since C++11</span></span><br></pre></td></tr></table></figure>
<h2 id="piecewise-construction"><a href="#piecewise-construction" class="headerlink" title="piecewise construction"></a>piecewise construction</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;)&#123;&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>.. Args&gt;</span><br><span class="line">	Foo(Args... args)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; t(<span class="number">1</span>,<span class="number">2.22</span>);</span><br><span class="line">	pair&lt;<span class="keyword">int</span>,Foo) p1(<span class="number">42</span>,t);</span><br><span class="line">	pair&lt;<span class="keyword">int</span>,Foo&gt; p2(piecewise_construct, make_tuple(<span class="number">42</span>),t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当std::poecewise_construct被当作第一参数，class Foo才会被迫使用那个“接受tuple的元素而非tuple整体”的构造函数。这就意味着，在这个例子中被调用的是那个“实参数目不定的构造函数”。</p>
<h2 id="make-pair"><a href="#make-pair" class="headerlink" title="make_pair"></a>make_pair</h2><p>自C++11开始，可以使用<tuple>内的tie()接口，抽取出pair的value：</tuple></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; p = <span class="built_in">std</span>::make_pair(<span class="string">'x'</span>,<span class="string">'y'</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">std</span>::tie(sstd::ignore,c) = p;<span class="comment">//extra seconf value into c</span></span><br></pre></td></tr></table></figure>
<p>c++standard明确指出，如果可能的话make_pair()使用move语义，否则就使用copy语义</p>
<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><h2 id="Tuple的操作"><a href="#Tuple的操作" class="headerlink" title="Tuple的操作"></a>Tuple的操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create four-element tuple elements are initialized with default value</span></span><br><span class="line">tuple &lt;<span class="built_in">string</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt; t;</span><br><span class="line"><span class="comment">//create and initialize a tuple explicitly</span></span><br><span class="line">tuple &lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="built_in">string</span>&gt; t1(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">"nico"</span>);</span><br><span class="line"><span class="comment">//create tuple with make_tuple</span></span><br><span class="line"><span class="keyword">auto</span> t2 = make_tuple(<span class="number">22</span>,<span class="number">33</span>,<span class="string">"nico"</span>);</span><br><span class="line"><span class="comment">//assignment</span></span><br><span class="line">get&lt;<span class="number">1</span>&gt;(t1) = get&lt;<span class="number">1</span>&gt;(t2);</span><br><span class="line"><span class="comment">//cpmparsion</span></span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2)</span><br><span class="line">&#123;</span><br><span class="line">	t1 = t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行期传入一个索引是不允许的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">get&lt;i&gt;(t1);<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<h2 id="tie"><a href="#tie" class="headerlink" title="tie"></a>tie</h2><p>如果想最方便的在tuple中使用reference，可以使用tie，他可以建立一个内含reference的tuple：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span> <span class="keyword">float</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; t(<span class="number">77</span>,<span class="number">1.1</span>,<span class="string">"move lisght"</span>);</span><br><span class="line"><span class="keyword">int</span> i;<span class="keyword">float</span> f;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::tie(i,f,s) = t;<span class="comment">//assigns values of t to I,fand s</span></span><br></pre></td></tr></table></figure>
<p>这里std::tie会将i、f和s的reference建立起一个tuple。等同于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::make_tuple(<span class="built_in">std</span>::ref(i),<span class="built_in">std</span>::ref(f),<span class="built_in">std</span>::ref(s)) = t;</span><br></pre></td></tr></table></figure>
<p>使用tie的时候，std::ignore允许我们忽略tuple的某些元素，也就是我们可以用它来局部提取tuple的元素值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span> <span class="keyword">float</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; t(<span class="number">77</span>,<span class="number">1.1</span>,<span class="string">"move lisght"</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::tie(i,<span class="built_in">std</span>::ignore,s) = t;<span class="comment">//assign first and third value of t to I and s</span></span><br></pre></td></tr></table></figure>
<h2 id="Initializer-List"><a href="#Initializer-List" class="headerlink" title="Initializer List"></a>Initializer List</h2><p>不可以将初值列传至“期望获得一个tuple”的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;&gt; v&#123;<span class="number">1</span>,<span class="number">1.0</span>&#125;;ERROR</span><br><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; foo()&#123;<span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;&#125;<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>注意的是，上面的做法对于pair和array是可以的<br>但是对于tuple，你必须明确的将初值转为一个tuple</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;&gt; v&#123;<span class="built_in">std</span>::make_tuple(<span class="number">1</span>,<span class="number">1.0</span>),</span><br><span class="line">					<span class="built_in">std</span>::make_tuple(<span class="number">2</span>,<span class="number">2.0</span>)&#125;;<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; foo()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他的tuple特性"><a href="#其他的tuple特性" class="headerlink" title="其他的tuple特性"></a>其他的tuple特性</h2><p>tuple_size<tupletype>::value可获得元素个数<br>tuple_element&lt;idx,tupletype&gt;::type可获得idx个元素的类型<br>tuple_cat()可将多个tuple创成一个tuple<br>tuple的输入输出<br>tuple class 出公开于boost程序库，在那里tuple可以将元素写至ouput stream，但是C++标准库不支持。你可以使用一下头文件做支持：</tupletype></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printtuple.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> IDX,<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; strm,<span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		strm &lt;&lt; <span class="built_in">std</span>::get&lt;IDX&gt;(t) &lt;&lt; (IDX + <span class="number">1</span>==MAX?<span class="string">""</span>:<span class="string">","</span>);</span><br><span class="line">		PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(strm, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; strm, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	strm &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">	PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;::print(strm,t);</span><br><span class="line">	<span class="keyword">return</span> strm &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;MAX, MAX, Args...&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这文件在<a href="http://www.coordinate.wang/cpp/2017/04/14/cpp2.0%E6%96%B0%E7%89%B9%E6%80%A72.html#处理first和last元素" target="_blank" rel="noopener">cpp2.0新特性第二讲</a>中有提及</p>
<h1 id="Class-shared-ptr"><a href="#Class-shared-ptr" class="headerlink" title="Class shared_ptr"></a>Class shared_ptr</h1><p>多个shared_ptr可以共享同一个对象。对象的最后一个拥有着有责任销毁对象，并清除与该对象相关的所有资源。</p>
<h2 id="使用shared-ptr"><a href="#使用shared-ptr" class="headerlink" title="使用shared_ptr"></a>使用shared_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pNic(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"nic"</span>));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pJut(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"jut"</span>));</span><br></pre></td></tr></table></figure>
<p>由于“接受单一pointer作为唯一实参”的构造函数是explicit，所以这里不可以使用assign，那要被视为需要一个隐式转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pNic = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"nic"</span>);<span class="comment">//ERROR</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pNic;</span><br><span class="line">pNic.reset(<span class="keyword">new</span> <span class="built_in">string</span>(“nico”));<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pJut &#123;<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"jut"</span>)&#125;;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>也可以使用make_shared</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pNic = make_shared&lt;<span class="built_in">string</span>&gt;(“nic”);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pJut = make_shared&lt;<span class="built_in">string</span>&gt;(“jut”);</span><br></pre></td></tr></table></figure>
<p>这样做会比较安全</p>
<h2 id="对于array"><a href="#对于array" class="headerlink" title="对于array"></a>对于array</h2><p>可以使用unique_ptr的辅助函数作为deleter，其内部调用delete[]:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">						<span class="built_in">std</span>::default_delete&lt;<span class="keyword">int</span>[]&gt;());</span><br></pre></td></tr></table></figure>
<p>然而要注意的是，shared_ptr和unique_ptr以不同的方式处理deleter。例如unique_ptr允许你只传递对应元素类型作为template实参，对于shared_ptr就不可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>[]&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>此外对于unique_ptr，必须明确给第二个template实参，指出自己的deleter：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="keyword">void</span>(*)(<span class="keyword">int</span>*)&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">									[](<span class="keyword">int</span> *p)&#123; <span class="keyword">delete</span> []p;&#125;);</span><br></pre></td></tr></table></figure>
<p>还要注意的是shared_ptr不提供operator[]，但是unique_ptr可以。</p>
<h1 id="Class-weak-ptr"><a href="#Class-weak-ptr" class="headerlink" title="Class weak_ptr"></a>Class weak_ptr</h1><p>允许使用“共享但不拥有”的对象，这个class 会建立起一个shared_ptr。一旦最末尾一个拥有该对象的shared_ptr失去拥有全，任何weak_ptr都会自动成空。</p>
<h2 id="使用-weak-ptr"><a href="#使用-weak-ptr" class="headerlink" title="使用 weak_ptr"></a>使用 weak_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; mother;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Person&gt;&gt; kids;</span><br><span class="line"></span><br><span class="line">    Person (<span class="keyword">const</span> <span class="built_in">string</span>&amp; n,</span><br><span class="line">            <span class="built_in">shared_ptr</span>&lt;Person&gt; m = <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">shared_ptr</span>&lt;Person&gt; f = <span class="literal">nullptr</span>)</span><br><span class="line">     : name(n), mother(m), father(f) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"delete "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Person&gt; initFamily (<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; mom(<span class="keyword">new</span> Person(name+<span class="string">"'s mom"</span>)); </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; dad(<span class="keyword">new</span> Person(name+<span class="string">"'s dad"</span>)); </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; kid(<span class="keyword">new</span> Person(name,mom,dad)); </span><br><span class="line">    mom-&gt;kids.push_back(kid);</span><br><span class="line">    dad-&gt;kids.push_back(kid);</span><br><span class="line">    <span class="keyword">return</span> kid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; p = initFamily(<span class="string">"nico"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nico's family exists"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"- nico is shared "</span> &lt;&lt; p.use_count() &lt;&lt; <span class="string">" times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"- name of 1st kid of nico's mom: "</span> </span><br><span class="line">         &lt;&lt; p-&gt;mother-&gt;kids[<span class="number">0</span>]-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    p = initFamily(<span class="string">"jim"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"jim's family exists"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个person的析构函数都未被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; mother;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Person&gt; father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;weak_ptr&lt;Person&gt;&gt; kids;  <span class="comment">// weak pointer !!!</span></span><br><span class="line"></span><br><span class="line">    Person (<span class="keyword">const</span> <span class="built_in">string</span>&amp; n,</span><br><span class="line">            <span class="built_in">shared_ptr</span>&lt;Person&gt; m = <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">shared_ptr</span>&lt;Person&gt; f = <span class="literal">nullptr</span>)</span><br><span class="line">     : name(n), mother(m), father(f) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"delete "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做后。我们可以打破shared pointer形成的cycle，使得从kid到parent用的时shared pointer，而parent到kids使用的weak pointer。<br>注意使用weak pointer时，我们必须用一下方式访问对象。不应该这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;mother-&gt;kids[<span class="number">0</span>]-&gt;name</span><br></pre></td></tr></table></figure>
<p>必须是这样在式子内加上lock：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;mother-&gt;kids[<span class="number">0</span>].lock()-&gt;name</span><br></pre></td></tr></table></figure>
<h2 id="错误的使用shared-pointer"><a href="#错误的使用shared-pointer" class="headerlink" title="错误的使用shared pointer"></a>错误的使用shared pointer</h2><p>shared_ptr多次引用同一数据，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(pInt);</span><br><span class="line"><span class="comment">// 一些其它代码之后…</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2(pInt);</span><br></pre></td></tr></table></figure>
<p>这种情况在实际中是很容易发生的，结果也是非常致命的，它会导致两次释放同一块内存，而破坏堆。<br>使用shared_ptr包装this指针带来的问题，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tester</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tester()</span><br><span class="line">    ~tester()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用!\n"</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;tester&gt; sget()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;tester&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tester t;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;tester&gt; sp =  t.sget();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也将导致两次释放t对象破坏堆栈，一次是出栈时析构，一次就是shared_ptr析构。若有这种需要，可以使用下面代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tester</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;tester&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tester()</span><br><span class="line">    ~tester()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用!\n"</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;tester&gt; sget()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;tester&gt; sp(<span class="keyword">new</span> tester);</span><br><span class="line">    <span class="comment">// 正确使用sp 指针。</span></span><br><span class="line">    sp-&gt;sget();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Class-unique-ptr"><a href="#Class-unique-ptr" class="headerlink" title="Class unique_ptr"></a>Class unique_ptr</h1><p>可确保一个对象和其相应资源同一时间之辈一个pointer占有。<br>unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::unqiue&lt;ClassA&gt; ptr(<span class="keyword">new</span> ClassA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。</p>
<h2 id="使用unique-ptr"><a href="#使用unique-ptr" class="headerlink" title="使用unique_ptr"></a>使用unique_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create and initialize string</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"nico"</span>);</span><br><span class="line">(*up)[<span class="number">0</span>] = <span class="string">'N'</span>;<span class="comment">//replace first character</span></span><br><span class="line">up-&gt;append(<span class="string">"fjdk"</span>);<span class="comment">//append some characters</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"nico"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* sp = up.release();</span><br></pre></td></tr></table></figure>
<h2 id="转移unique-ptr的拥有权"><a href="#转移unique-ptr的拥有权" class="headerlink" title="转移unique_ptr的拥有权"></a>转移unique_ptr的拥有权</h2><p>不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。<br>举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2(up1);<span class="comment">//ERROR</span></span><br><span class="line"><span class="comment">//transfer ownership  of the unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up3(<span class="built_in">std</span>::move(up1));<span class="comment">//OK</span></span><br><span class="line">assignment操作符的行为和上面所说的类似:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2;</span><br><span class="line">up2 = up1;<span class="comment">//ERROR </span></span><br><span class="line">up2 = <span class="built_in">std</span>::move(up1);<span class="comment">//assign the unique_ptr</span></span><br></pre></td></tr></table></figure>
<p>如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up1(<span class="keyword">new</span> ClassA);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA&gt; up2(<span class="keyword">new</span> ClassA);</span><br><span class="line">up2 = <span class="built_in">std</span>::move(up1);<span class="comment">//assign the unique_ptr</span></span><br><span class="line"><span class="comment">//delete object owned by up2</span></span><br></pre></td></tr></table></figure>
<h2 id="对于array-1"><a href="#对于array-1" class="headerlink" title="对于array"></a>对于array</h2><p>对于array应该是用delete[]而不是delete，所以下面的做法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。<br>你只要这样申明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>[]&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>然而要注意的是，他不提供操作符*和-&gt;，提供[]，用于访问其所执行的array中的某个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>[]&gt; up(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//ERROR</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; up[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<h2 id="其他相应资源的deleter"><a href="#其他相应资源的deleter" class="headerlink" title="其他相应资源的deleter"></a>其他相应资源的deleter</h2><p>当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassADeleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ClassA* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassA,ClassADeleter&gt; up(<span class="keyword">new</span> ClassA());</span><br></pre></td></tr></table></figure>
<p>如果你给的是个函数或lambda，你必须声明deleter的类型位void(<em>)(T</em>)或std::function&lt;void(T*)&gt;，要不就是使用decltype</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="keyword">void</span>(*)(<span class="keyword">int</span>*)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">					[](<span class="keyword">int</span>* p)</span><br><span class="line">					&#123;</span><br><span class="line">						...</span><br><span class="line">						<span class="keyword">delete</span> [] p;</span><br><span class="line">					&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>*)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">						[](<span class="keyword">int</span>* p)</span><br><span class="line">						&#123;</span><br><span class="line">							...</span><br><span class="line">							<span class="keyword">delete</span> [] p;</span><br><span class="line">						&#125;);</span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> *p)</span><br><span class="line">			&#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">delete</span> [] p;</span><br><span class="line">			&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>,<span class="keyword">decltype</span>(l)&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],l);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-15-cpp2.0新特性3"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/15/2017-04-15-cpp2.0新特性3/">cpp2.0新特性(3)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/15/2017-04-15-cpp2.0新特性3/" class="article-date">
	  <time datetime="2017-04-14T16:00:00.000Z" itemprop="datePublished">四月 15, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h1><p>Rvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary copying and enable perfect forwarding.When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a separate allocation ,thus enabling move semantics<br>Lvalue:可以出现operator=左侧<br>Rvalue:只能出现operator=右侧<br>做以下测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello "</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">s1 + s2 = s2; <span class="comment">//竟然通过了编译</span></span><br><span class="line"><span class="built_in">string</span>() = <span class="string">"world"</span>;<span class="comment">//竟然可以对temp object赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 + s2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>这个是标准库设计上的不合理，temp object是一个Rvalue<br>C++ with its user-defined types has introduced some subtleties regarding modifiability and assignability that cause this definition to be incorrect</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x = foo();</span><br><span class="line"><span class="keyword">int</span> *p = &amp;foo(); <span class="comment">//ERROR 表达式必须为左值</span></span><br><span class="line">foo() = <span class="number">7</span>; <span class="comment">//ERROR 表达式必须是可修改的左值</span></span><br></pre></td></tr></table></figure>
<p>函数的返回值是一个Rvalue，对Rvalue取reference是不可以的</p>
<h2 id="Unperfect-Forwarding"><a href="#Unperfect-Forwarding" class="headerlink" title="Unperfect Forwarding"></a>Unperfect Forwarding</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"process"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"process(int&amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"forward(int &amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	process(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">process(a);<span class="comment">//process(int&amp;):0</span></span><br><span class="line">process(<span class="number">1</span>);<span class="comment">//process(int&amp;&amp;):1</span></span><br><span class="line">process(move(a));<span class="comment">//process(int&amp;&amp;):0</span></span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//forward(int&amp;&amp;):2,process(int&amp;):2</span></span><br><span class="line"><span class="comment">//rvalue经过forward()传给另一个函数却变为lvalue</span></span><br><span class="line"><span class="comment">//原因在于传递的过程中它变成了一个named object</span></span><br><span class="line">forward(move(a));<span class="comment">//forward(int&amp;&amp;):0,process(int&amp;):0</span></span><br><span class="line"><span class="comment">//rvalue经过forward()传给另一个函数却变为rvalue</span></span><br></pre></td></tr></table></figure>
<h2 id="Perfect-Forwarding"><a href="#Perfect-Forwarding" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h2><p>Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function.The nature of the argument(modifiable,const ,lvalue or rvalue) is preserved in this forwarding process.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionB(<span class="built_in">std</span>::forward&lt;T1&gt;(t1),</span><br><span class="line">				<span class="built_in">std</span>::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="String-Literal"><a href="#String-Literal" class="headerlink" title="String Literal"></a>String Literal</h1><h2 id="Raw-String-Literal"><a href="#Raw-String-Literal" class="headerlink" title="Raw String Literal"></a>Raw String Literal</h2><p>例如一个用来表示两个反斜杠和一个n的寻常字面常量可定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“\\\\n”</span><br></pre></td></tr></table></figure>
<p>也可以定义为raw string literal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R”(\\n)”</span><br></pre></td></tr></table></figure>
<p>如果要在raw string内写出)”，可以使用定义符。因此，一个raw string的完整语法是R”delim()delim”,其中delim是字符序列，最多16个基本字符，不包含反斜线、空格和小括号。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R”nc(a\</span><br><span class="line">    b\nc()”</span><br><span class="line">)nc”</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“a\\\n    b\\nc()\”\n    ”</span><br></pre></td></tr></table></figure>
<h2 id="Encoded-String-Literal"><a href="#Encoded-String-Literal" class="headerlink" title="Encoded String Literal"></a>Encoded String Literal</h2><p>u8定义一个UTF-8编码。<br>u定义一个string lteral，带着char16_t的字符<br>U定义一个string lteral，带着char32_t的字符<br>L定义一个wide string lteral，带着wchar_t的字符</p>
<h1 id="New-Fundamental-Data-Type"><a href="#New-Fundamental-Data-Type" class="headerlink" title="New Fundamental Data Type"></a>New Fundamental Data Type</h1><p>char16_t 和 char32_t<br>long long 和unsigned long long<br>std::nullptr_t</p>
<h1 id="Scoped-Enumerration"><a href="#Scoped-Enumerration" class="headerlink" title="Scoped Enumerration"></a>Scoped Enumerration</h1><p>一般情况下，在花括号中声明一个name（包括变量名，函数名），这个name的可见性会被限制在花括号的作用域内。对于在C++98风格的enum中声明的enum成员却不是这样。这些enum成员的name属于的作用域是enum所在作用域，这意味着在这个作用域中，不能拥有相同的name:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;;   <span class="comment">//black，white，red</span></span><br><span class="line">                                    <span class="comment">//和Color在同一个作用域</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误！white在这个</span></span><br><span class="line">                                    <span class="comment">//作用域已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>所以事实上，这些enum成员name泄露到enum所在的作用域中去了，这导致官方对于这种enum给出了一个官方术语：unscoped。新的C++11中有一个与此相对应的版本：scoped enum，不会像这样让name泄露：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">//black，white red</span></span><br><span class="line">                                        <span class="comment">//在Color作用域中</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                     <span class="comment">//好的，没其他white</span></span><br><span class="line">Color c = white;                        <span class="comment">//错误！在这个作用域中没有</span></span><br><span class="line">                                        <span class="comment">//一个叫“white”的enum成员</span></span><br><span class="line">Color c = Color::white;                 <span class="comment">//对的</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                  <span class="comment">//也是对的（而且和Item 5的建议一样）</span></span><br></pre></td></tr></table></figure>
<p>再举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Salutation</span> :</span> <span class="keyword">char</span> &#123; mr, ms co&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以明显定义底层类型（本例是char）并因此获得一个保证大小（如果你这里省略了char，则默认是int）。</p>
<h1 id="Member-Template"><a href="#Member-Template" class="headerlink" title="Member Template "></a>Member Template </h1><p>Member template的一个特殊形式时template构造函数。这个函数通常被提供用于“对象被复制时给予隐式类型转换”的能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//copy constructor with inmplicit type conversion</span></span><br><span class="line"><span class="comment">//-ddoes not supperss implicit copy constructor</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">	MyClass ( <span class="keyword">const</span> MyClass&lt;U&gt;&amp; x);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;<span class="keyword">double</span>&gt; xd;</span><br><span class="line">	MyClass&lt;<span class="keyword">double</span>&gt; xd2(xd);</span><br><span class="line">	MyClass&lt;<span class="keyword">int</span>&gt; xi(xd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里xd2与xd类型完全相同，因此其初始化是通过被隐式生成的copy构造函数完成。xi的类型与xd不同，因此其初始化是通过template构造函数完成的。</p>
<h1 id="Explicit-Initialization-for-Fundamental-Type"><a href="#Explicit-Initialization-for-Fundamental-Type" class="headerlink" title="Explicit Initialization for Fundamental Type"></a>Explicit Initialization for Fundamental Type</h1><p>如果你使用一个明确的构造函数，但不给实参这样的语法，基础类型会被设定初值为0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1;<span class="comment">//undefined value</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="keyword">int</span>();<span class="comment">//initialized with zero</span></span><br><span class="line"><span class="keyword">int</span> i3&#123;&#125;;<span class="comment">//initialized with zero</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; p;<span class="comment">//initialize p.first and p.second with zero</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-14-cpp2.0新特性2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/14/2017-04-14-cpp2.0新特性2/">cpp2.0新特性(2)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/14/2017-04-14-cpp2.0新特性2/" class="article-date">
	  <time datetime="2017-04-13T16:00:00.000Z" itemprop="datePublished">四月 14, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>Declval converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.<br>Decltype allows the compiler to infer the return type of a function based on an arbitrary expression and makes perfect forwarding more generic.In past versions,for two arbitrary T1 and T2,there was no way to deduce the type of an expression used these two types.The decltype feature allows you to state, for example, an expression that has template arguments,such as sum&lt;T1,T2&gt;() has the type T1+T2.<br>By using the new decltype keyword,you can let the complier find out the type of an expression.This is the realization of the often requested typeof feature.However,the existing typeof implementations were inconsistent and incomplete,so C++11 introduced a new keyword.For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br></pre></td></tr></table></figure>
<p>One application of decltype is to <strong>declare return types</strong>.Another is to use it <strong>in metaprogramming</strong> or to <strong>pass the type of a lambda</strong>.</p>
<h2 id="Used-to-declare-return-types"><a href="#Used-to-declare-return-types" class="headerlink" title="Used to declare return types"></a>Used to declare return types</h2><p>Sometimes,the return type of a function depends on an expression processed with the arguments.However,something like</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y)add(T1 x,T2 y);</span><br></pre></td></tr></table></figure>
<p>was not possible before C++11,because the return expression uses objects not introduced or in scope yet.But with C++11,you can alternatively declare the return type of a function behind the parameter list: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x,T2 y)-&gt;decltype(x+y);</span><br></pre></td></tr></table></figure>
<p>This uses the same syntax as for lambdas to declare return types.</p>
<h2 id="In-metaprogramming"><a href="#In-metaprogramming" class="headerlink" title="In metaprogramming"></a>In metaprogramming</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_decltype</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt;::value_type elem;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt; coll;</span><br><span class="line">	<span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line"></span><br><span class="line">	typedef typename decltype(obj)::iterator iType;</span><br><span class="line">	<span class="comment">//typedef typename T::iterator iType;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">decltype</span>(obj) anotherObj(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pass-the-type-of-a-lambda"><a href="#Pass-the-type-of-a-lambda" class="headerlink" title="Pass the type of a lambda"></a>Pass the type of a lambda</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp =[](<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.lastname()&lt;p2.lastname()||</span><br><span class="line">			(p1.lastname() == p2.lastname()&amp;&amp;</span><br><span class="line">			p1.lastname() &lt; p2.lastname());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>
<p>对于lambda，我们手上往往只有object，没有type。这是可以使用decltype<br>Because you need the type of the lambda for the declaration of the set,decltype must be used ,which yields the type of a lambda object,such as cmp.Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion passed ,and by rule lambdas have no default constructor and no assignment operator.So,for a sorting criterion,a class defining the function objects might still be more intuitive.</p>
<h1 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h1><p>C++11 introduced lambdas,allowing the definition of inline functionality,which can used as a parameter or a local object.Lambdas change the way the C++ standard library is used.<br>A lambda is a definition of functionality that can be defined inside statements and expressions.Thus,you can use a lambdas as an inline function.The minimal lambda function has no parameters and simply does something;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>You can call it directly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>or pass it to objects to get called:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Auto l = []&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">l();</span><br></pre></td></tr></table></figure>
<p>you can specify a capture to access data of outer scope that is not passed as an argument:<br>[=]means that the outer scope is passed to the lambda by value.<br>[&amp;]means that the outer scope is passed to the lambda by reference.<br>Ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">41</span>;</span><br><span class="line"><span class="keyword">auto</span> q = [x,&amp;y] &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>[=,&amp;y]to pass y by reference and all other objects by value.<br>Objects are passed by value,but inside the function object defined by the lambda,you have write access to the passed value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;<span class="comment">//如果没有写mutable，这个还有效吗?</span></span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>the type of a lambda is an anonymous function object(or functor)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		++id;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br></pre></td></tr></table></figure>
<h2 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass by value"></a>pass by value</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:<span class="number">0</span></span><br><span class="line">id:<span class="number">1</span></span><br><span class="line">id:<span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h2 id="pass-by-reference"><a href="#pass-by-reference" class="headerlink" title="pass by reference"></a>pass by reference</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;id]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:<span class="number">42</span></span><br><span class="line">id:<span class="number">43</span></span><br><span class="line">id:<span class="number">44</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<h2 id="No-mutable"><a href="#No-mutable" class="headerlink" title="No mutable"></a>No mutable</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    ++id;<span class="comment">//ERROR</span></span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">f();f();f();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">if</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果是：<br>ERROR increment of read-only variable ‘id’</p>
<h2 id="可以申明变量，可以返回变量"><a href="#可以申明变量，可以返回变量" class="headerlink" title="可以申明变量，可以返回变量"></a>可以申明变量，可以返回变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="再看Variadic-Template"><a href="#再看Variadic-Template" class="headerlink" title="再看Variadic Template"></a>再看Variadic Template</h1><h2 id="重写printf"><a href="#重写printf" class="headerlink" title="重写printf()"></a>重写printf()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,T value,Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">'%'</span> &amp;&amp; *(++s) != <span class="string">'%'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">			<span class="built_in">printf</span>(++s, args...);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"extra arguments provided to printf"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*s == <span class="string">'%'</span>&amp;&amp;*(++s) != <span class="string">'%'</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invaild format string: missing arguments"</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现max接受任意个数"><a href="#实现max接受任意个数" class="headerlink" title="实现max接受任意个数"></a>实现max接受任意个数</h2><p>若参数type都一样，就无需调用variadic templates,使用initializer_list<t>就足够了。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator,</span><br><span class="line">		<span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__max_element(_ForwardIterator __first,</span><br><span class="line">				_ForwardIterator __last,</span><br><span class="line">				_Compare _comp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(__first == __last) <span class="keyword">return</span> __first;</span><br><span class="line">	_ForwardIterator __result = __first;</span><br><span class="line">	<span class="keyword">while</span>(++__first != __last)</span><br><span class="line">		<span class="keyword">if</span>(__comp(__result, __first))</span><br><span class="line">			__result = __first;</span><br><span class="line">	<span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">max_element(_ForwardIterator __first,</span><br><span class="line">			_ForwardIterator __last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __max_element(__first,__last,</span><br><span class="line">						__iter_less_iter());</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _Tp</span><br><span class="line">max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *max_element(_l.begin(),__l.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> _Iter_less_iter </span><br><span class="line">__iter_less_iter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _Iter_less_iter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Iter_less_iter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1,<span class="keyword">typename</span> _Iterator2&gt;</span><br><span class="line">	<span class="keyword">bool</span> </span><br><span class="line">	<span class="keyword">operator</span>()(_Iterator1 __it1,_Iterator2 __it2) <span class="keyword">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *__it1 &lt; *__it2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="若参数type不同的话，使用variadic-templates"><a href="#若参数type不同的话，使用variadic-templates" class="headerlink" title="若参数type不同的话，使用variadic templates"></a>若参数type不同的话，使用variadic templates</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(n, mymax(args...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理first和last元素"><a href="#处理first和last元素" class="headerlink" title="处理first和last元素"></a>处理first和last元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">	PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;::print(os,t);</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> IDX,<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os,<span class="keyword">const</span> tuple &lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + <span class="number">1</span>==MAX?<span class="string">""</span>:<span class="string">","</span>);</span><br><span class="line">		PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;MAX, MAX, Args...&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; make_tuple(<span class="number">7.5</span>, <span class="built_in">string</span>(<span class="string">"hello"</span>),<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7.5</span>,hello,<span class="number">0000000101111001</span>,<span class="number">42</span>]</span><br></pre></td></tr></table></figure>
<h2 id="递归继承recursive-inheritance"><a href="#递归继承recursive-inheritance" class="headerlink" title="递归继承recursive inheritance"></a>递归继承recursive inheritance</h2><p>参看<a href="http://www.coordinate.wang/cpp/2017/04/13/cpp2.0%E6%96%B0%E7%89%B9%E6%80%A71.html#variadic-templates" target="_blank" rel="noopener">第一讲</a><br>但是里面有一行在这里就要变为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head;&#125; </span><br><span class="line"><span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;<span class="comment">//至此这就完美了</span></span><br></pre></td></tr></table></figure>
<h2 id="递归复合recursive-composition"><a href="#递归复合recursive-composition" class="headerlink" title="递归复合recursive composition"></a>递归复合recursive composition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;<span class="comment">//结束边界</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span> &lt;Head, Tail...&gt;</span></span><br><span class="line"><span class="class">	:</span><span class="keyword">private</span> tuple &lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> tuple &lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail)</span><br><span class="line">		:m_head(v), m_tail(vtail...) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tail; &#125;</span><br><span class="line"><span class="keyword">protected</span>:]</span><br><span class="line">    inherited m_tail;</span><br><span class="line">	Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-13-cpp2.0新特性1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/13/2017-04-13-cpp2.0新特性1/">cpp2.0新特性(1)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/13/2017-04-13-cpp2.0新特性1/" class="article-date">
	  <time datetime="2017-04-12T16:00:00.000Z" itemprop="datePublished">四月 13, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="新增加的头文件"><a href="#新增加的头文件" class="headerlink" title="新增加的头文件"></a>新增加的头文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理最后情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; first, <span class="keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//递归调用recursive</span></span><br><span class="line">	print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…就是所谓的pack<br>用于template parameters ，就是template parameters pack<br>用于function parameter types，就是function parameters types pack<br>用于function parameters ，就是function parameters pack<br>sizeof…(args) yields the number of arguments</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;<span class="comment">//结束边界</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span> &lt;Head, Tail...&gt;</span></span><br><span class="line"><span class="class">	:</span><span class="keyword">private</span> tuple &lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> tuple &lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail)</span><br><span class="line">		:m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line">	<span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" class="img-fluid"><br></a></p>
<h1 id="Spaces-in-template-expressions"><a href="#Spaces-in-template-expressions" class="headerlink" title="Spaces in template expressions"></a>Spaces in template expressions</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt;;<span class="comment">//ok in each c++ version</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">//ok in c++ 11</span></span><br></pre></td></tr></table></figure>
<h1 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a>nullptr and std::nullptr_t</h1><p>C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value.This new feature especially helps to avoid mistakes that occurred when a null ointer was interpreted as an integral value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="literal">NULL</span>)</span></span>;<span class="comment">//valls f(int) if NULL is 0,ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">//call f(void*)</span></span><br><span class="line"><span class="literal">nullptr</span> is a <span class="keyword">new</span> keywords</span><br></pre></td></tr></table></figure>
<h1 id="Automatic-type-deduction-with-auto"><a href="#Automatic-type-deduction-with-auto" class="headerlink" title="Automatic type deduction with auto "></a>Automatic type deduction with auto </h1><p>With c++11,you can declare a variable or an object without specifying its specific type by using auto.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = f();</span><br></pre></td></tr></table></figure>
<p>using auto is especially useful where the type is a pretty long and/or complicated expression.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin(); <span class="comment">//pos has type vector&lt;string&gt;::iterator</span></span><br></pre></td></tr></table></figure>
<h1 id="Uniform-initialization"><a href="#Uniform-initialization" class="headerlink" title="Uniform initialization"></a>Uniform initialization</h1><p>Before c++11,programmers,especially novices,could easily become confused by the question of how to initialize a variable or an object.Initialization could happen parentheses, braces,and/or assignment opretators.<br>For this reason ,c++11  introduces the concept of uniform initialization ,which means that for any initialization ,you can use one common syntax.This syntax uses braces, so the following is possible now;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> values[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123; <span class="number">4.0</span>,<span class="number">3.0</span> &#125;;<span class="comment">//背后有个array&lt;double,2&gt;</span></span><br></pre></td></tr></table></figure>
<p>编译器看到{1,2…}便做出一个initializer_list<t>，它关联至一个array&lt;T,n&gt;。调用函数时该array内的元素可被编译器逐一分解传给函数。但若函数参数是个initializer_list<t>，调用者却不能给予数个T参数然后以为他们会被自动转为一个initializer_list<t>传入。</t></t></t></p>
<h1 id="Initializer-lists"><a href="#Initializer-lists" class="headerlink" title="Initializer lists"></a>Initializer lists</h1><p>An initializer list forces so-called value initialization ,which means that even local variables of fundamental data types,which usually have an undefined initial value,are initialized by zero</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">//i has undefined value</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j is initialized by 0</span></span><br><span class="line"><span class="keyword">int</span> *p;<span class="comment">//i has undefined value</span></span><br><span class="line"><span class="keyword">int</span> *q&#123;&#125;;<span class="comment">//q is initialized by nullptr</span></span><br></pre></td></tr></table></figure>
<p>Note,however,that narrowing initializations –those that reduce precision or where the supplied value gets modified – are not possible with braces.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;<span class="comment">//x1 to 5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2 to 5</span></span><br><span class="line"><span class="keyword">int</span> x3&#123;<span class="number">5.3</span>&#125;;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> x4 = &#123;<span class="number">5.3</span>&#125;;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>To support  the concept of initializer lists for user-defined types,c++11 provides the class template std::initializer_list&lt;&gt; .It can be used to support initializations by a list of values or in any place where you want to process just a list of values.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p = vals.begin(); p != vals.end(); ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);<span class="comment">//与前面不同的是这里面的类型必须相同</span></span><br></pre></td></tr></table></figure>
<p>when there are constructors for both a specific number of arguments and an initializer list, the version with the initializer list is preferred.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	P(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"fjdsjf"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	P(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; initlist)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : initlist)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>, <span class="number">5</span>)</span></span>; <span class="comment">//P(int,int)</span></span><br><span class="line">P q&#123; <span class="number">77</span>,<span class="number">5</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br><span class="line">P r&#123; <span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br><span class="line">P s = &#123; <span class="number">77</span>,<span class="number">5</span> &#125;;<span class="comment">//P(initializer_list&lt;&gt;)</span></span><br></pre></td></tr></table></figure>
<p>Without the constructor for the initializer list, the constructor taking two ints would be called to initialize q and s,while the initialization of r would be invalid.<br>Initializer_list objects are automatically constructed as if an array of elements of type T was allocated ,with each of the elements in the list being copy-initialized to its corresponding element in the array,using  any necessary non-narrowing implicit conversions.<br>The initializer_list object refers to the element of this array without containing them:copying an initializer_list object produces another object referring to the same underlying elements, not to new copies of them (reference semantics).<br>The lifetime of this temporary array is the same as the initializer_list object.</p>
<h1 id="Explicit-for-ctors-taking-more-than-one-argument"><a href="#Explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="Explicit for ctors taking more than one argument"></a>Explicit for ctors taking more than one argument</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	P(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">P y = (<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//error</span></span><br><span class="line">P z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">P v = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//ok</span></span><br><span class="line">P w = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>关于上面()这样做的错误原因，我后来想了一下，（）内取得是“，”运算符的结果，将这个结果初始化y，但是没有单个参数的构造函数，所以出现了“初始化: 无法从“int”转换为“P”，此时如果将第一个构造函数改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>编译果然通过了，结果和预想的一样</p>
<p><a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" data-lightbox="roadtrip" target="_blank" rel="noopener"><br><img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" class="img-fluid"><br></a></p>
<h1 id="Range-based-for-statement"><a href="#Range-based-for-statement" class="headerlink" title="Range-based for statement"></a>Range-based for statement</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (decl : coll)</span><br><span class="line">&#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>No explicit type conversions are possible when elements are initialized as decl inside the for loop.Thus ,the following does not compile:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> C&amp; elem : vs) <span class="comment">//ERROR,no conversion from string to C defined </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default ,=delete"></a>=default ,=delete</h1><p>如果你自行定义了一个ctor，那么编译器就不会再给你一个default ctor。<br>如果你强行加上=default，就可以重新获得并使用default ctor。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Zoo(<span class="keyword">int</span> i1,<span class="keyword">int</span> i2) : d1(i1),d2(i2);</span><br><span class="line">	Zoo(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;<span class="comment">//表示我不使用这个构造函数，default ctor也不会使用</span></span><br><span class="line"><span class="comment">// Zoo(const Zoo&amp;) = default;//ERROR,’Zoo(const Zoo&amp;)’cannot be overload</span></span><br><span class="line"><span class="comment">//对于copy assignment也是类似 的</span></span><br><span class="line">	Zoo(Zoo&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//表示使用编译器给我的默认构造函数</span></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~Zoo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>=default用于big-5之外没有意义，编译会报错<br>=delete可以用在任何函数上<br>default ctor和dtor主要是给编译器放置如唤起base classed以及non-static members的ctors和dtors，这个在effective c++中有所提及。<br>对于何种类需要自己写big-3呢？<br>如果这个类内部有pointer member的话，大多数情况下是需要自己写的，如果没有pointer member的话，基本可以使用default。</p>
<h1 id="Alias-template-template-typedef"><a href="#Alias-template-template-typedef" class="headerlink" title="Alias template(template typedef)"></a>Alias template(template typedef)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>the term</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, MyAlloc&lt;<span class="keyword">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>
<p>It is not possible to partially or explicitly specialize an alias template.<br>难道只是为了少敲几个代码吗？<br>看这个例子：<br>//函数功能：可以传入不同容器进行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">		c.insert(c.end(), T());</span><br><span class="line">	output_static_data(*(c.begin()));</span><br><span class="line">	Container&lt;T&gt; c1(c);</span><br><span class="line">	Container&lt;T&gt; c2(<span class="built_in">std</span>::move(c));</span><br><span class="line">	c1.swap(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是container里面的类型也是不定的所以就用到了以下方法：<br>template template parameter</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">XCLs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	XCLs()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">			c.insert(c.end(), T());</span><br><span class="line">		output_static_data(T());</span><br><span class="line">		Container&lt;T&gt; c1(c);</span><br><span class="line">		Container&lt;T&gt; c2(<span class="built_in">std</span>::move(c));</span><br><span class="line">		c1.swap(c2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">XCLs&lt;MyString,<span class="built_in">vector</span>&gt; c1;</span><br></pre></td></tr></table></figure>
<p>但是这里报错了<br>ERROR type/value mismatch at argument 2 in template parameter list for ‘template&lt;class T,template <class>class Container&gt; class XCLs’<br>原因在于</class></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span>: <span class="keyword">protected</span> _Vector_base&lt;_Tp,_Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>虽然第二个参数有默认值但是<br>Alias template are never deduced by template argument deduction when deducing a template template parameter<br>最终的解决法，这样使用这个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">vector</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">//上面的东西是不可以写在函数内的</span></span><br><span class="line">XCLs&lt;MyString,Vec&gt; c1;</span><br></pre></td></tr></table></figure>
<h1 id="Type-alias-similar-to-typedef"><a href="#Type-alias-similar-to-typedef" class="headerlink" title="Type alias(similar to typedef)"></a>Type alias(similar to typedef)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>There is no difference between a type alias declaration and typedef declaration.This declaration many appear in block scope,class scope or namespace scope.</p>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void foo() noexcept(true);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>Declares that foo() won’t throw.If an exception is not handled locally inside foo()-thus,if foo() throws – the program is terminated ,calling std::terminate(),which by default calls std::abort().<br>由于noexcept不需要stack unwinding ，程序员从今开始可以表现“绝不抛出”而不需要额外开销。c++11开始不再鼓励使用异常明细。<br>You can even specify a condition undef which a function throws no exception.For example,for any type Type,the alobal swap() usually is defined as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void swap(Type &amp;x, Type&amp; y) noexcept(noexcept(x.wap(y)))</span><br><span class="line">&#123;</span><br><span class="line">	x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here,inside noexception(…),you can specify a Boolean condition under which no thrown :Specifying noexcept without condition is a short form of specifying  noexcept(true).<br>You need to inform C++(specifivally std::vector)that your move constructor and destructor does not throw.Then the move constructor will be called when the vector frows.If the constructor is not noexcept,std::vector can’t use it,since then it can’t ensure the exception guarantees demanded by the standard.<br>Growable containers(会发生memory reallocation) 只有两种:vector 和 deque</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyString(MyString &amp;&amp;str)<span class="keyword">noexcept</span></span><br><span class="line">		: _data(str._data), _len(str._len) &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//ERROR 'virtual void Derived::vfunc(in)' marked override,but does not override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span> override </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">final</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">//ERROR cannot derive from 'final' base 'Base' in derived type 'Derived'</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//ERROR overriding final function</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp第二版/">cpp第二版</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-12-loki&#39;s allocator"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-loki's allocator/">loki::allocator</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-loki's allocator/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pData_: <span class="keyword">unsigned</span> <span class="keyword">char</span>*</span><br><span class="line">firstAvailableBlock_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//第一个可用的编号</span></span><br><span class="line">blocksAvailable_: <span class="keyword">unsigned</span> <span class="keyword">char</span><span class="comment">//剩余可用的数目</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Init(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	pData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[blockSize * blocks];</span><br><span class="line">	Reset(blockSize, blocks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Reset(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize,<span class="keyword">unsigned</span> <span class="keyword">char</span> blocks)</span><br><span class="line">&#123;</span><br><span class="line">	firstAvailableBlock_ = <span class="number">0</span>;</span><br><span class="line">	blocksAvailable_ = blocks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* p = pData_;</span><br><span class="line">	<span class="keyword">for</span>(; i!=blocks; p+=blockSize)</span><br><span class="line">		*p =++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Release()</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">delete</span>[] pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Allocate(<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!blocksAvailable_) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* pResult = </span><br><span class="line">		pData_ + (firstAvailableBlock_ * blockSize);</span><br><span class="line">	firstAvailableBlock_ = *pResult;</span><br><span class="line">	--blocksAvailable_;</span><br><span class="line">	<span class="keyword">return</span> pResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Chunk::Deallocate(<span class="keyword">void</span>* p,<span class="built_in">std</span>::<span class="keyword">size_t</span> blockSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * toRelease = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">	*toRelease = firstAvailableBlock_;</span><br><span class="line">	firstAvailableBlock_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(</span><br><span class="line">						(toRelease - pData_)/blockSize);</span><br><span class="line">	++blocksAvailable_;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="FixedAllocator"><a href="#FixedAllocator" class="headerlink" title="FixedAllocator"></a>FixedAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunks_:<span class="built_in">vector</span>&lt;Chunk&gt;</span><br><span class="line">allocChunk_: Chunk*</span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *FixedAllocator::Allocate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(allocChunk == <span class="number">0</span> || allocChunk_-&gt;blocksAvailable_ == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunks::iterator i = chunks_.begin();</span><br><span class="line">		<span class="keyword">for</span>(;; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == chunks_.end())</span><br><span class="line">			&#123;</span><br><span class="line">				chunks_.push_back(Chunk());</span><br><span class="line">				Chunk&amp; newChunk = chunks_.back();</span><br><span class="line">				newChunk.Init(blockSize_, numBlocks_);</span><br><span class="line">				allocChunk_ = &amp;newChunk;<span class="comment">//指向上次给出去的chunk</span></span><br><span class="line">				deallocChunk_ = &amp;chunks_.front();<span class="comment">//指向上一次的回收</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i-&gt;blocksAvailable_&gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				allocChunk_ = &amp;*i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> allocChunk_-&gt;Allocate(blockSize_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::Deallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_ = VicinityFind(p);</span><br><span class="line">	DoDealllocate(p);</span><br><span class="line">&#125;</span><br><span class="line">FixedAllocator::Chunk* FixedAllocator::VicinityFind(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> chunkLength = numBlocks_ * blockSize_;</span><br><span class="line">	</span><br><span class="line">	Chunk* lo = deallocChunk_;</span><br><span class="line">	Chunk* hi = deallocChunk_ + <span class="number">1</span>;</span><br><span class="line">	Chunk* loBound = &amp;chunks_.front();</span><br><span class="line">	Chunk* hiBound = &amp;chunks_.back() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(lo)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= lo-&gt;pData_ &amp;&amp; p&lt; lo-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> lo;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(lo == loBound) lo = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> --lo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &gt;= hi-&gt;pData_&amp;&amp; p &lt;hi-&gt;pData_ + chunkLength)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> hi;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>( ++ hi == hiBound) hi = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> FixedAllocator::DoDeallocate(<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	deallocChunk_-&gt;Deallocate(p, blockSize_);</span><br><span class="line"><span class="comment">//是否等于开始的登记值</span></span><br><span class="line">	<span class="keyword">if</span>(deallocChunk_-&gt;blocksAvailable == numBlocks)</span><br><span class="line">	&#123;</span><br><span class="line">		Chunk&amp; lastChunk == chunks_.back();</span><br><span class="line"><span class="comment">//这里的做法与vc SBH defer类似</span></span><br><span class="line"><span class="comment">//__sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原</span></span><br><span class="line"><span class="comment">//本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer </span></span><br><span class="line"><span class="comment">//group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer </span></span><br><span class="line"><span class="comment">//group取出block完成分配，Defer指针会被取消(设为NULL);</span></span><br><span class="line"><span class="comment">//__sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(&amp;lastChunk == deallocChunk_)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(chunks_.size() &gt;<span class="number">1</span> &amp;&amp;</span><br><span class="line">				deallocChunk_[<span class="number">-1</span>].blocksAvailable_ == numBlocks)</span><br><span class="line">			&#123;</span><br><span class="line">				lastChunk.Release();</span><br><span class="line">				chunks_.pop_back();</span><br><span class="line">				allocChunk_ = deallocChunk_ = &amp;chunks_.front();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lastChunk.blocksAvailable == numBlocks)</span><br><span class="line">		&#123;</span><br><span class="line">			lastChunk.Release();</span><br><span class="line">			chunks_.pop_back();</span><br><span class="line">			allocChunk_ = deallocChunk_;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(*deallocChunk_, lastChunk);</span><br><span class="line">			allocChunk_ = &amp;chunks_.back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SmallObjAllocator"><a href="#SmallObjAllocator" class="headerlink" title="SmallObjAllocator"></a>SmallObjAllocator</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool_: <span class="built_in">vector</span>&lt;FixedAllocator&gt;</span><br><span class="line">pLastAlloc: FixedAllocator</span><br><span class="line">pLastDealloc: FixedAllocator</span><br><span class="line">chunkSize: <span class="keyword">size_t</span></span><br><span class="line">maxObjectSize: <span class="keyword">size_t</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2017-04-12-other issues"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-other issues/">other issues</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/2017-04-12-other issues/" class="article-date">
	  <time datetime="2017-04-11T16:00:00.000Z" itemprop="datePublished">四月 12, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>当将元素加入容器中，容器必须分配更多的内存以足够保存这些元素，于是他们向他的模板参数allocator发出申请，该模板参数往往被另一个名为 allocator_type。甚至将chars添加到string class也是如此，因为string也算是一个正规的STL容器。每个元素类型为T的容器的Allocator模板默认为allocator<t>。其接口只有大约20个public申明，包括嵌套的typedefs和成员函数。最重要的两个成员函数是：</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Void <span class="title">deallocate</span><span class="params">(T* p, size_type n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>N指的是客户申请的元素个数，不是指空间总量。这些空间是通过调用::operator new获得，但何时需要并无具体指定。  </p>
<p>最容易满足需求的做法就是每当容器需要内存就调用operator new，每当容器释放内存就调用operator delete。这种做法比起分配大块内存并缓存然后小块小块的使用当然较慢，优势则是可以在极大范围的硬件和操作系统有效运作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::new_allocator</span><br></pre></td></tr></table></figure>
<p>实现出简洁的operator new 和operator delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::malloc_allocator</span><br></pre></td></tr></table></figure>
<p>实现上例唯一不同的是，它使用c函数std::malloc和std::free  </p>
<p>另外一种做法就是使用智能型allocator，将分配所得的内存加以缓存。这种额外机制可以数种形式呈现：可以是个bitmap index，用以索引至一个以2的指数倍成长的篮子。也可以是个相较之下比较简易的fixed-size pooling cache这里所说的cache被程序内的所有容器共享，而operators new和operator delete不经常<br>被调用，这可带来速度上的优势。使用这个技巧的allocators包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::bitmap_allocator</span><br></pre></td></tr></table></figure>
<p>一个高效能的allocator，使用bit-map追踪被使用和未使用的内存块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::pool_allocator</span><br><span class="line">__gnu_cxx::__mt_alloc</span><br></pre></td></tr></table></figure>
<p>Class allocator 只拥有typedef,constructor,和rebind等成员。它继承自一个high-speed extension allocators。也因此，所有分配器和归还都取决于该base class，而这个base class也许是终端用户无法碰触和操控的。很难挑选出某个分配策略说他可以提供最大共同利益而不至于令某些行为过度优势。事实上，就算要挑选何种典型动作以测量速度，都是一种困难。<br>GNU C++提供三项综合测试用以C++allocators之间的速度比较：<br>Insertion进过多次iterations后各种STL容器将拥有某个极大量。分别测试sequence和associative容器。多线程环境中的insertion and erasure 。这个测试展示allocator归还内存，测量线程之间对内存的竞争。A threaded producer/consumer model分别测试sequence和associative容器。</p>
<p>另外两个智能allocator：<br><strong>gnu_cxx::debug_allocator<br>这个是一个外覆器(wrapper)，可包含于任何allocator之上。他把客户的申请量添加一些，然后由allocator回应，并以那个一小块额外内存放置size信息。一旦deallocate()收到一个pointer，就会检查size并以assert()保证吻合。  
</strong>gnu_cxx::array_allocator<br>允许分配一个已知固定大小的内存块，内存来自std::array objects。用上这个allocator，大小固定的容器就无需在调用::operator new 和::operator delete。这就允许我们使用STL abstractions而无需再运行期添加额外开销。甚至在program startup情况下也可使用。注意他是静态的，所以他不需要调用delete。</p>
<h2 id="Array-allocator"><a href="#Array-allocator" class="headerlink" title="Array allocator"></a>Array allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array内的第二个参数表示array的大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Array = <span class="built_in">std</span>::tr1::<span class="built_in">array</span>&lt;_Tp,<span class="number">1</span>&gt;&gt;</span><br><span class="line">class array_allocator:<span class="keyword">public</span> array_allocator_base&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Array array_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	array_type* _M_array;</span><br><span class="line">	size_type _M_used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	array_allocator(array_type* __array = <span class="literal">NULL</span>)<span class="keyword">throw</span>()</span><br><span class="line">		:_M_array(__array), _M_used(size_type())&#123;&#125;</span><br><span class="line">		...</span><br><span class="line">	pointer</span><br><span class="line">	allocate(size_type __n,<span class="keyword">const</span> <span class="keyword">void</span>* =<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_M_array == <span class="number">0</span>|| _M_used + __n&gt;_M_array &gt; size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		pointer __ret = _M_array-&gt;begin() + _M_used();</span><br><span class="line">		_M_used += __n;</span><br><span class="line">		<span class="keyword">return</span> __ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">debug_allocator</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">debug_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	size_type _M_extra;<span class="comment">//额外的空间，记录整个区块的大小</span></span><br><span class="line">	_Alloc _M_allocator;</span><br><span class="line">	</span><br><span class="line">	size_type _S_extra()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">size_t</span> __obj_size = <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">sizeof</span>(size_type) + __obj_size - <span class="number">1</span>)/__obj_size;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	debug_allocator(<span class="keyword">const</span> _Alloc&amp; __a)</span><br><span class="line">		:_M_allocator(__a), _M_extra(_S_extra())&#123;&#125;</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pointer __res = _M_allocator.allocate(__n + __m_extra);</span><br><span class="line">		size_type *__ps = <span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__res);</span><br><span class="line">		*__ps = __n;</span><br><span class="line">		<span class="keyword">return</span> __res + _M_extra;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::__throw_runtine_error;</span><br><span class="line">		<span class="keyword">if</span>(__p)</span><br><span class="line">		&#123;</span><br><span class="line">			pointer __real_p = __p + _m_extra;</span><br><span class="line">			<span class="keyword">if</span>(*<span class="keyword">reinterpret_cast</span>&lt;size_type*&gt;(__real_p) != __n)</span><br><span class="line">				__throw_runtime_error</span><br><span class="line">					(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">			_M_allocator.deallocate(__ + _M_extra);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			__throw_runtime_error</span><br><span class="line">				(<span class="string">"debug_allocator::deallocate wrong size"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bitmap-allocator"><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a>bitmap_allocator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitmap_allocator</span>:</span><span class="keyword">private</span> free_list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__n &gt; <span class="keyword">this</span>-&gt;max_size())</span><br><span class="line">			<span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,<span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_M_allocate_single_object();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> size_type __b = __n * <span class="keyword">sizeof</span>(value_type);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;pointer&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p,size_type __n)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(__builtin_expect(__p !=<span class="number">0</span>,<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(__builtin_expect(__n == <span class="number">1</span>,tue))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;_M_delaoocate_single_object(__p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				::<span class="keyword">operator</span> <span class="keyword">delete</span>(_p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vector的元素排列将以super block size为依据，新进者若大于最末者，便直接delete新进者，否则delete最末者后再insert新进者，若没有到达64则insert到适当位置。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/16/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/luliyucoordinate" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="QQ"><i class="fa fa-qq" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weixin"><i class="fa fa-weixin" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/10/2018-02-10-python实现2048/">Python实现2048</a></h6>
              <span>二月 10, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/09/2018-02-09-图片转字符画/">图片转化为字符画</a></h6>
              <span>二月 9, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/">c++中空字符串解释为True的困惑</a></h6>
              <span>二月 5, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/26/2018-01-26-python字符串令牌解析/">python字符串令牌解析</a></h6>
              <span>一月 26, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/15/2018-01-15-RefineDet论文笔记/">RefineDet论文笔记</a></h6>
              <span>一月 15, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/01/09/2018-01-09-has-no-attribute-items问题/">AttributeError &#39;dict&#39; object has no attribute &#39;items&#39; 问题</a></h6>
              <span>一月 9, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QT/">QT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/asp/">asp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/index/">index</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息安全/">信息安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统原理/">计算机系统原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/1080ti/" style="font-size: 10.71px;">1080ti</a> <a href="/tags/Aggregate/" style="font-size: 10px;">Aggregate</a> <a href="/tags/Dell/" style="font-size: 11.43px;">Dell</a> <a href="/tags/Eassy/" style="font-size: 11.43px;">Eassy</a> <a href="/tags/Eval/" style="font-size: 10px;">Eval</a> <a href="/tags/Execute/" style="font-size: 10px;">Execute</a> <a href="/tags/ExecuteGlobal/" style="font-size: 10px;">ExecuteGlobal</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Kolakoski/" style="font-size: 10px;">Kolakoski</a> <a href="/tags/MNIST/" style="font-size: 10.71px;">MNIST</a> <a href="/tags/MySQL/" style="font-size: 10.71px;">MySQL</a> <a href="/tags/PIL/" style="font-size: 10px;">PIL</a> <a href="/tags/POD/" style="font-size: 10px;">POD</a> <a href="/tags/QT/" style="font-size: 11.43px;">QT</a> <a href="/tags/Ubuntu/" style="font-size: 11.43px;">Ubuntu</a> <a href="/tags/YOLO/" style="font-size: 15px;">YOLO</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/advance/" style="font-size: 10px;">advance</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/array/" style="font-size: 10px;">array</a> <a href="/tags/asp/" style="font-size: 10px;">asp</a> <a href="/tags/auto/" style="font-size: 10.71px;">auto</a> <a href="/tags/auto/" style="font-size: 10px;">auto&</a> <a href="/tags/auto/" style="font-size: 10px;">auto&&</a> <a href="/tags/binding/" style="font-size: 10px;">binding</a> <a href="/tags/c/" style="font-size: 17.86px;">c</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/cin/" style="font-size: 10px;">cin</a> <a href="/tags/constexpr/" style="font-size: 10px;">constexpr</a> <a href="/tags/cpp/" style="font-size: 20px;">cpp</a> <a href="/tags/cpp标准库/" style="font-size: 17.14px;">cpp标准库</a> <a href="/tags/cpp第二版/" style="font-size: 11.43px;">cpp第二版</a> <a href="/tags/cuda/" style="font-size: 10.71px;">cuda</a> <a href="/tags/cudnn/" style="font-size: 10.71px;">cudnn</a> <a href="/tags/darknet/" style="font-size: 15px;">darknet</a> <a href="/tags/dd/" style="font-size: 10px;">dd</a> <a href="/tags/default/" style="font-size: 10px;">default</a> <a href="/tags/dict/" style="font-size: 10px;">dict</a> <a href="/tags/downcasting/" style="font-size: 10px;">downcasting</a> <a href="/tags/error/" style="font-size: 11.43px;">error</a> <a href="/tags/estimator/" style="font-size: 11.43px;">estimator</a> <a href="/tags/forward/" style="font-size: 10px;">forward</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/glvalue/" style="font-size: 10px;">glvalue</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/identity/" style="font-size: 10px;">identity</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 16.43px;">linux</a> <a href="/tags/lvalue/" style="font-size: 10px;">lvalue</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/mismatch/" style="font-size: 10px;">mismatch</a> <a href="/tags/move/" style="font-size: 10px;">move</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/namehiding/" style="font-size: 10.71px;">namehiding</a> <a href="/tags/network/" style="font-size: 12.14px;">network</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/notes/" style="font-size: 18.57px;">notes</a> <a href="/tags/numpy/" style="font-size: 12.86px;">numpy</a> <a href="/tags/office/" style="font-size: 10.71px;">office</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/opencv/" style="font-size: 14.29px;">opencv</a> <a href="/tags/oracle/" style="font-size: 10.71px;">oracle</a> <a href="/tags/overload/" style="font-size: 10.71px;">overload</a> <a href="/tags/override/" style="font-size: 10.71px;">override</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/piecewise-construct/" style="font-size: 10px;">piecewise_construct</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/pipe/" style="font-size: 10.71px;">pipe</a> <a href="/tags/process/" style="font-size: 10px;">process</a> <a href="/tags/prvalue/" style="font-size: 10px;">prvalue</a> <a href="/tags/pytesseract/" style="font-size: 10px;">pytesseract</a> <a href="/tags/python/" style="font-size: 19.29px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/qt/" style="font-size: 13.57px;">qt</a> <a href="/tags/quit/" style="font-size: 10px;">quit</a> <a href="/tags/re/" style="font-size: 11.43px;">re</a> <a href="/tags/requests/" style="font-size: 10.71px;">requests</a> <a href="/tags/rvalue/" style="font-size: 10px;">rvalue</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/signal/" style="font-size: 10.71px;">signal</a> <a href="/tags/sql/" style="font-size: 10.71px;">sql</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/stl/" style="font-size: 16.43px;">stl</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/thread/" style="font-size: 10.71px;">thread</a> <a href="/tags/threading/" style="font-size: 10px;">threading</a> <a href="/tags/trie树/" style="font-size: 10px;">trie树</a> <a href="/tags/uninstall/" style="font-size: 10.71px;">uninstall</a> <a href="/tags/unordered-multimap/" style="font-size: 10px;">unordered_multimap</a> <a href="/tags/upcasting/" style="font-size: 10px;">upcasting</a> <a href="/tags/vbs/" style="font-size: 10px;">vbs</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/vfptr/" style="font-size: 10px;">vfptr</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/windows/" style="font-size: 10.71px;">windows</a> <a href="/tags/xlvalue/" style="font-size: 10px;">xlvalue</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/人工智能/" style="font-size: 10px;">人工智能</a> <a href="/tags/仿函数/" style="font-size: 10px;">仿函数</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/决策树算法/" style="font-size: 10px;">决策树算法</a> <a href="/tags/分配器/" style="font-size: 10px;">分配器</a> <a href="/tags/原理/" style="font-size: 17.14px;">原理</a> <a href="/tags/反斜杠/" style="font-size: 10px;">反斜杠</a> <a href="/tags/回文字符串/" style="font-size: 10px;">回文字符串</a> <a href="/tags/多态/" style="font-size: 10px;">多态</a> <a href="/tags/字典树/" style="font-size: 10px;">字典树</a> <a href="/tags/字符串令牌/" style="font-size: 10px;">字符串令牌</a> <a href="/tags/引用折叠/" style="font-size: 10px;">引用折叠</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/木马/" style="font-size: 10px;">木马</a> <a href="/tags/机器学习/" style="font-size: 10.71px;">机器学习</a> <a href="/tags/模式识别/" style="font-size: 10px;">模式识别</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/漏洞/" style="font-size: 10px;">漏洞</a> <a href="/tags/病毒/" style="font-size: 10px;">病毒</a> <a href="/tags/空字符串/" style="font-size: 10px;">空字符串</a> <a href="/tags/笔试/" style="font-size: 11.43px;">笔试</a> <a href="/tags/算法/" style="font-size: 13.57px;">算法</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/计算机网络/" style="font-size: 10.71px;">计算机网络</a> <a href="/tags/贪吃蛇/" style="font-size: 10px;">贪吃蛇</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a> <a href="/tags/转载/" style="font-size: 15.71px;">转载</a> <a href="/tags/迭代器/" style="font-size: 12.14px;">迭代器</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
