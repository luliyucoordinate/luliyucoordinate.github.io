<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迭代器适配器 | coordinate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="cpp迭代器notescpp标准库" />
  
  
  
  
  <meta name="description" content="Reverse（反向）迭代器你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。   12345678910111213141516171819202122232425#include &amp;lt;iterator&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;">
<meta name="keywords" content="cpp,迭代器,notes,cpp标准库">
<meta property="og:type" content="article">
<meta property="og:title" content="迭代器适配器">
<meta property="og:url" content="http://coordinate.wang/2017/06/03/2017-06-03-迭代器适配器/index.html">
<meta property="og:site_name" content="coordinate">
<meta property="og:description" content="Reverse（反向）迭代器你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。   12345678910111213141516171819202122232425#include &amp;lt;iterator&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-18T03:29:06.768Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迭代器适配器">
<meta name="twitter:description" content="Reverse（反向）迭代器你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。   12345678910111213141516171819202122232425#include &amp;lt;iterator&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;">
  
    <link rel="alternate" href="/atom.xml" title="coordinate" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="coordinate" rel="home"> coordinate </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-2017-06-03-迭代器适配器" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      迭代器适配器
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/06/03/2017-06-03-迭代器适配器/" class="article-date">
	  <time datetime="2017-06-02T16:00:00.000Z" itemprop="datePublished">六月 3, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Reverse（反向）迭代器"><a href="#Reverse（反向）迭代器" class="headerlink" title="Reverse（反向）迭代器"></a>Reverse（反向）迭代器</h2><p>你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create list with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find position of element with value 5</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator pos;</span><br><span class="line">    pos = find (coll.cbegin(), coll.cend(),</span><br><span class="line">                <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which iterator pos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pos:  "</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert iterator to reverse iterator rpos</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">const_reverse_iterator <span class="title">rpos</span><span class="params">(pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print value to which reverse iterator rpos refers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rpos: "</span> &lt;&lt; *rpos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos:  <span class="number">5</span></span><br><span class="line">rpos: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这是由于reverse迭代器在设计是做了一个小技巧，他实际倒置“半开原则”。reverse迭代器所定义的区间并不包括起点，反而包括了终点。  </p>
<h2 id="Insert（安插型）迭代器"><a href="#Insert（安插型）迭代器" class="headerlink" title="Insert（安插型）迭代器"></a>Insert（安插型）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::insert_iterator是一个输出迭代器，它被构造，在该位置到一个容器中插入元素指出，由所提供的迭代器，使用容器的insert()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::insert_iterator是一个no-op。general inserter对所有标准容器均使用（只有array和forward list除外），因为那些容器都提供insert成员函数。然而对于associative和unordered容器而言，安插位置只是个提示，因为在这两个容器转给你元素的真正位置视为value而定。<br>安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于使用下面的语句：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = container.insert(pos, value);</span><br><span class="line">++pos;</span><br></pre></td></tr></table></figure>
<p>为什么要将insert的返回值赋给pos？原因在于为了确保迭代器的位置始终有效。如果没有这个复制动作，在deque、vector和string中，该general inserter本身可能会失效。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">back_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::back_insert_iterator是OutputIterator追加到一个容器，它被构造，使用容器的push_back()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::back_insert_iterator是一个no-op。由于push_back只存在于vector、deque、list和string，所以c++标准库中只有这些容器支持back insert。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">front_insert_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt; <span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                                   <span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span> &gt;</span><br></pre></td></tr></table></figure>
<p>std::front_insert_iterator是输出预先考虑元素的迭代器，它被修建的容器，使用时容器的push_front()成员函数的迭代器（是否解除引用或不）被分配给的。递增std::front_insert_iterator是一个no-op。由于push_front只在deque、list和forward list有实现，所以只有这些容器可以使用。  </p>
<h2 id="Stream（串流）迭代器"><a href="#Stream（串流）迭代器" class="headerlink" title="Stream（串流）迭代器"></a>Stream（串流）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::output_iterator_tag,</span><br><span class="line">                                              <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::ostream_iterator is a single-pass OutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator&lt;&lt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.<br>In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.<br>When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create ostream iterator for stream cout</span></span><br><span class="line">    <span class="comment">// - values are separated by a newline character</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; intWriter(<span class="built_in">cout</span>,<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">// write elements with the usual iterator interface</span></span><br><span class="line">    *intWriter = <span class="number">42</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">77</span>;</span><br><span class="line">    intWriter++;</span><br><span class="line">    *intWriter = <span class="number">-5</span>;</span><br><span class="line">    <span class="comment">// create collection with elements from 1 to 9</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">// write all elements without any delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// write all elements with " &lt; " as delimiter</span></span><br><span class="line">    copy (coll.cbegin(), coll.cend(),</span><br><span class="line">          ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" &lt; "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">2</span>&lt;<span class="number">3</span>&lt;<span class="number">4</span>&lt;<span class="number">5</span>&lt;<span class="number">6</span>&lt;<span class="number">7</span>&lt;<span class="number">8</span>&lt;<span class="number">9</span>&lt;</span><br></pre></td></tr></table></figure>
<p>注意分隔符类型为const char*。如果你传入string对象的话，就要调用c_str函数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::input_iterator_tag,</span><br><span class="line">                                             T, Distance, <span class="keyword">const</span> T*, <span class="keyword">const</span> T&amp;&gt;</span><br></pre></td></tr></table></figure>
<p>(until C++17)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">CharT</span> = <span class="title">char</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator&gt;&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently read object.<br>The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.<br>A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.<br>T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements.<br>例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create istream iterator that reads integers from cin</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReader(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="comment">// create end-of-stream iterator</span></span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; intReaderEOF;</span><br><span class="line">    <span class="comment">// while able to read tokens with istream iterator</span></span><br><span class="line">    <span class="comment">// - write them twice</span></span><br><span class="line">    <span class="keyword">while</span> (intReader != intReaderEOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once:       "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"once again: "</span> &lt;&lt; *intReader &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++intReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> f <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>结果为：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">once:       <span class="number">1</span></span><br><span class="line">once again: <span class="number">1</span></span><br><span class="line">once:       <span class="number">2</span></span><br><span class="line">once again: <span class="number">2</span></span><br><span class="line">once:       <span class="number">3</span></span><br><span class="line">once again: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>结果出现的问题在于，格式错误。  </p>
<h2 id="Move（搬移）迭代器"><a href="#Move（搬移）迭代器" class="headerlink" title="Move（搬移）迭代器"></a>Move（搬移）迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( <span class="keyword">const</span> Iterator&amp; i );</span><br></pre></td></tr></table></figure>
<p>(since C++11)<br>(until C++14)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++14)<br>(until C++17)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">std</span>:</span>:move_iterator&lt;Iterator&gt; make_move_iterator( Iterator i );</span><br></pre></td></tr></table></figure>
<p>(since C++17)<br>make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument.  </p>
<h2 id="Iterator-Trait（迭代器特性）"><a href="#Iterator-Trait（迭代器特性）" class="headerlink" title="Iterator Trait（迭代器特性）"></a>Iterator Trait（迭代器特性）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five iterator categories:  </p>
<ol>
<li>input_iterator_tag corresponds to InputIterator.</li>
<li>output_iterator_tag corresponds to OutputIterator.</li>
<li>forward_iterator_tag corresponds to ForwardIterator.</li>
<li>bidirectional_iterator_tag corresponds to BidirectionalIterator.</li>
<li>random_access_iterator_tag corresponds to RandomAccessIterator.</li>
</ol>
<p>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.<br>For every iterator type, a typedef std::iterator_traits\&lt;Iterator>::iterator_category is available, which is an alias to one of these five tag types.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;;</span></span><br></pre></td></tr></table></figure>
<p>std::iterator_traits is the type trait class that provides uniform interface to the properties of Iterator types. This makes it possible to implement algorithms only in terms of iterators.<br>The class defines the following types:  </p>
<ol>
<li>difference_type - a type that can be used to identify distance between iterators</li>
<li>value_type - the type of the values that can be obtained by dereferencing the iterator. This type is void for output iterators.</li>
<li>pointer - defines a pointer to the type iterated over (value_type)</li>
<li>reference - defines a reference to the type iterated over (value_type)</li>
<li>iterator_category - the category of the iterator. Must be one of iterator category tags.</li>
</ol>
<p>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Distance</span> = <span class="title">std</span>:</span>:<span class="keyword">ptrdiff_t</span>,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp; </span></span><br><span class="line"><span class="class">&gt; <span class="title">struct</span> <span class="title">iterator</span>;</span></span><br></pre></td></tr></table></figure>
<p>(deprecated in C++17)<br>std::iterator is the base class provided to simplify definitions of the required types for iterators.<br>其中第一个template参数定义迭代器种类，第二个参数用来定义元素类型，第三个参数用来定义difference类型，第四个参数用来定义point而类型，第五个参数用来定义reference类型。  </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/cpp/">cpp</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp标准库/">cpp标准库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/迭代器/">迭代器</a></li></ul>

      
        
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'luliyucoordinate';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/07/2017-06-07-基于Kinect的手势识别/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          基于Kinect的手势识别
        
      </div>
    </a>
  
  
    <a href="/2017/06/02/2017-06-02-Upcasting and Downcasting/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Upcasting and Downcasting</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse（反向）迭代器"><span class="nav-number">1.</span> <span class="nav-text">Reverse（反向）迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Insert（安插型）迭代器"><span class="nav-number">2.</span> <span class="nav-text">Insert（安插型）迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream（串流）迭代器"><span class="nav-number">3.</span> <span class="nav-text">Stream（串流）迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Move（搬移）迭代器"><span class="nav-number">4.</span> <span class="nav-text">Move（搬移）迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator-Trait（迭代器特性）"><span class="nav-number">5.</span> <span class="nav-text">Iterator Trait（迭代器特性）</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 coordinate All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
